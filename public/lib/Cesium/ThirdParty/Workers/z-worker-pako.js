/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.96.6
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */

(function(){"use strict";const{Array:T,Object:w,Math:v,Error:z,Uint8Array:p,Uint16Array:_e,Uint32Array:ie,Int32Array:me,DataView:ce,TextEncoder:P,crypto:A,postMessage:K}=globalThis,R=[];for(let n=0;256>n;n++){let e=n;for(let t=0;8>t;t++)1&e?e=e>>>1^3988292384:e>>>=1;R[n]=e}class W{constructor(e){this.crc=e||-1}append(e){let t=0|this.crc;for(let s=0,r=0|e.length;r>s;s++)t=t>>>8^R[255&(t^e[s])];this.crc=t}get(){return~this.crc}}const d={concat(n,e){if(n.length===0||e.length===0)return n.concat(e);const t=n[n.length-1],s=d.getPartial(t);return s===32?n.concat(e):d._shiftRight(e,s,0|t,n.slice(0,n.length-1))},bitLength(n){const e=n.length;if(e===0)return 0;const t=n[e-1];return 32*(e-1)+d.getPartial(t)},clamp(n,e){if(32*n.length<e)return n;const t=(n=n.slice(0,v.ceil(e/32))).length;return e&=31,t>0&&e&&(n[t-1]=d.partial(e,n[t-1]&2147483648>>e-1,1)),n},partial:(n,e,t)=>n===32?e:(t?0|e:e<<32-n)+1099511627776*n,getPartial:n=>v.round(n/1099511627776)||32,_shiftRight(n,e,t,s){for(s===void 0&&(s=[]);e>=32;e-=32)s.push(t),t=0;if(e===0)return s.concat(n);for(let i=0;i<n.length;i++)s.push(t|n[i]>>>e),t=n[i]<<32-e;const r=n.length?n[n.length-1]:0,a=d.getPartial(r);return s.push(d.partial(e+a&31,e+a>32?t:s.pop(),1)),s}},E={bytes:{fromBits(n){const e=d.bitLength(n)/8,t=new p(e);let s;for(let r=0;e>r;r++)(3&r)==0&&(s=n[r/4]),t[r]=s>>>24,s<<=8;return t},toBits(n){const e=[];let t,s=0;for(t=0;t<n.length;t++)s=s<<8|n[t],(3&t)==3&&(e.push(s),s=0);return 3&t&&e.push(d.partial(8*(3&t),s)),e}}},M={sha1:function(n){n?(this._h=n._h.slice(0),this._buffer=n._buffer.slice(0),this._length=n._length):this.reset()}};M.sha1.prototype={blockSize:512,reset:function(){const n=this;return n._h=this._init.slice(0),n._buffer=[],n._length=0,n},update:function(n){const e=this;typeof n=="string"&&(n=E.utf8String.toBits(n));const t=e._buffer=d.concat(e._buffer,n),s=e._length,r=e._length=s+d.bitLength(n);if(r>9007199254740991)throw new z("Cannot hash more than 2^53 - 1 bits");const a=new ie(t);let i=0;for(let o=e.blockSize+s-(e.blockSize+s&e.blockSize-1);r>=o;o+=e.blockSize)e._block(a.subarray(16*i,16*(i+1))),i+=1;return t.splice(0,16*i),e},finalize:function(){const n=this;let e=n._buffer;const t=n._h;e=d.concat(e,[d.partial(1,1)]);for(let s=e.length+2;15&s;s++)e.push(0);for(e.push(v.floor(n._length/4294967296)),e.push(0|n._length);e.length;)n._block(e.splice(0,16));return n.reset(),t},_init:[1732584193,4023233417,2562383102,271733878,3285377520],_key:[1518500249,1859775393,2400959708,3395469782],_f:(n,e,t,s)=>n>19?n>39?n>59?n>79?void 0:e^t^s:e&t|e&s|t&s:e^t^s:e&t|~e&s,_S:(n,e)=>e<<n|e>>>32-n,_block:function(n){const e=this,t=e._h,s=T(80);for(let c=0;16>c;c++)s[c]=n[c];let r=t[0],a=t[1],i=t[2],o=t[3],l=t[4];for(let c=0;79>=c;c++){16>c||(s[c]=e._S(1,s[c-3]^s[c-8]^s[c-14]^s[c-16]));const h=e._S(5,r)+e._f(c,a,i,o)+l+s[c]+e._key[v.floor(c/20)]|0;l=o,o=i,i=e._S(30,a),a=r,r=h}t[0]=t[0]+r|0,t[1]=t[1]+a|0,t[2]=t[2]+i|0,t[3]=t[3]+o|0,t[4]=t[4]+l|0}};const j="Invalid pasword",I=16,x={name:"PBKDF2"},oe=w.assign({hash:{name:"HMAC"}},x),le=w.assign({iterations:1e3,hash:{name:"SHA-1"}},x),he=["deriveBits"],H=[8,12,16],V=[16,24,32],_=10,F=[0,0,0,0],y=E.bytes,O=class{constructor(n){const e=this;e._tables=[[[],[],[],[],[]],[[],[],[],[],[]]],e._tables[0][0][0]||e._precompute();const t=e._tables[0][4],s=e._tables[1],r=n.length;let a,i,o,l=1;if(r!==4&&r!==6&&r!==8)throw new z("invalid aes key size");for(e._key=[i=n.slice(0),o=[]],a=r;4*r+28>a;a++){let c=i[a-1];(a%r==0||r===8&&a%r==4)&&(c=t[c>>>24]<<24^t[c>>16&255]<<16^t[c>>8&255]<<8^t[255&c],a%r==0&&(c=c<<8^c>>>24^l<<24,l=l<<1^283*(l>>7))),i[a]=i[a-r]^c}for(let c=0;a;c++,a--){const h=i[3&c?a:a-4];o[c]=4>=a||4>c?h:s[0][t[h>>>24]]^s[1][t[h>>16&255]]^s[2][t[h>>8&255]]^s[3][t[255&h]]}}encrypt(n){return this._crypt(n,0)}decrypt(n){return this._crypt(n,1)}_precompute(){const n=this._tables[0],e=this._tables[1],t=n[4],s=e[4],r=[],a=[];let i,o,l,c;for(let h=0;256>h;h++)a[(r[h]=h<<1^283*(h>>7))^h]=h;for(let h=i=0;!t[h];h^=o||1,i=a[i]||1){let f=i^i<<1^i<<2^i<<3^i<<4;f=f>>8^255&f^99,t[h]=f,s[f]=h,c=r[l=r[o=r[h]]];let S=16843009*c^65537*l^257*o^16843008*h,D=257*r[f]^16843008*f;for(let g=0;4>g;g++)n[g][h]=D=D<<24^D>>>8,e[g][f]=S=S<<24^S>>>8}for(let h=0;5>h;h++)n[h]=n[h].slice(0),e[h]=e[h].slice(0)}_crypt(n,e){if(n.length!==4)throw new z("invalid aes block size");const t=this._key[e],s=t.length/4-2,r=[0,0,0,0],a=this._tables[e],i=a[0],o=a[1],l=a[2],c=a[3],h=a[4];let f,S,D,g=n[0]^t[0],m=n[e?3:1]^t[1],b=n[2]^t[2],k=n[e?1:3]^t[3],B=4;for(let C=0;s>C;C++)f=i[g>>>24]^o[m>>16&255]^l[b>>8&255]^c[255&k]^t[B],S=i[m>>>24]^o[b>>16&255]^l[k>>8&255]^c[255&g]^t[B+1],D=i[b>>>24]^o[k>>16&255]^l[g>>8&255]^c[255&m]^t[B+2],k=i[k>>>24]^o[g>>16&255]^l[m>>8&255]^c[255&b]^t[B+3],B+=4,g=f,m=S,b=D;for(let C=0;4>C;C++)r[e?3&-C:C]=h[g>>>24]<<24^h[m>>16&255]<<16^h[b>>8&255]<<8^h[255&k]^t[B++],f=g,g=m,m=b,b=k,k=f;return r}},q=class{constructor(n,e){this._prf=n,this._initIv=e,this._iv=e}reset(){this._iv=this._initIv}update(n){return this.calculate(this._prf,n,this._iv)}incWord(n){if((n>>24&255)==255){let e=n>>16&255,t=n>>8&255,s=255&n;e===255?(e=0,t===255?(t=0,s===255?s=0:++s):++t):++e,n=0,n+=e<<16,n+=t<<8,n+=s}else n+=1<<24;return n}incCounter(n){(n[0]=this.incWord(n[0]))===0&&(n[1]=this.incWord(n[1]))}calculate(n,e,t){let s;if(!(s=e.length))return[];const r=d.bitLength(e);for(let a=0;s>a;a+=4){this.incCounter(t);const i=n.encrypt(t);e[a]^=i[0],e[a+1]^=i[1],e[a+2]^=i[2],e[a+3]^=i[3]}return d.clamp(e,r)}},J=class{constructor(n){const e=this,t=e._hash=M.sha1,s=[[],[]],r=t.prototype.blockSize/32;e._baseHash=[new t,new t],n.length>r&&(n=t.hash(n));for(let a=0;r>a;a++)s[0][a]=909522486^n[a],s[1][a]=1549556828^n[a];e._baseHash[0].update(s[0]),e._baseHash[1].update(s[1]),e._resultHash=new t(e._baseHash[0])}reset(){const n=this;n._resultHash=new n._hash(n._baseHash[0]),n._updated=!1}update(n){this._updated=!0,this._resultHash.update(n)}digest(){const n=this,e=n._resultHash.finalize(),t=new n._hash(n._baseHash[1]).update(e).finalize();return n.reset(),t}};class pe{constructor(e,t,s){w.assign(this,{password:e,signed:t,strength:s-1,pendingInput:new p(0)})}async append(e){const t=this;if(t.password){const s=u(e,0,H[t.strength]+2);await(async(r,a,i)=>{await Q(r,i,u(a,0,H[r.strength]));const o=u(a,H[r.strength]),l=r.keys.passwordVerification;if(l[0]!=o[0]||l[1]!=o[1])throw new z(j)})(t,s,t.password),t.password=null,t.aesCtrGladman=new q(new O(t.keys.key),T.from(F)),t.hmac=new J(t.keys.authentication),e=u(e,H[t.strength]+2)}return N(t,e,new p(e.length-_-(e.length-_)%I),0,_,!0)}flush(){const e=this,t=e.pendingInput,s=u(t,0,t.length-_),r=u(t,t.length-_);let a=new p(0);if(s.length){const o=y.toBits(s);e.hmac.update(o);const l=e.aesCtrGladman.update(o);a=y.fromBits(l)}let i=!0;if(e.signed){const o=u(y.fromBits(e.hmac.digest()),0,_);for(let l=0;_>l;l++)o[l]!=r[l]&&(i=!1)}return{valid:i,data:a}}}class de{constructor(e,t){w.assign(this,{password:e,strength:t-1,pendingInput:new p(0)})}async append(e){const t=this;let s=new p(0);t.password&&(s=await(async(a,i)=>{const o=A.getRandomValues(new p(H[a.strength]));return await Q(a,i,o),U(o,a.keys.passwordVerification)})(t,t.password),t.password=null,t.aesCtrGladman=new q(new O(t.keys.key),T.from(F)),t.hmac=new J(t.keys.authentication));const r=new p(s.length+e.length-e.length%I);return r.set(s,0),N(t,e,r,s.length,0)}flush(){const e=this;let t=new p(0);if(e.pendingInput.length){const r=e.aesCtrGladman.update(y.toBits(e.pendingInput));e.hmac.update(r),t=y.fromBits(r)}const s=u(y.fromBits(e.hmac.digest()),0,_);return{data:U(t,s),signature:s}}}function N(n,e,t,s,r,a){const i=e.length-r;let o;for(n.pendingInput.length&&(e=U(n.pendingInput,e),t=((l,c)=>{if(c&&c>l.length){const h=l;(l=new p(c)).set(h,0)}return l})(t,i-i%I)),o=0;i-I>=o;o+=I){const l=y.toBits(u(e,o,o+I));a&&n.hmac.update(l);const c=n.aesCtrGladman.update(l);a||n.hmac.update(c),t.set(y.fromBits(c),o+s)}return n.pendingInput=u(e,o),t}async function Q(n,e,t){const s=(o=>{if(P===void 0){const l=new p((o=unescape(encodeURIComponent(o))).length);for(let c=0;c<l.length;c++)l[c]=o.charCodeAt(c);return l}return new P().encode(o)})(e),r=await A.subtle.importKey("raw",s,oe,!1,he),a=await A.subtle.deriveBits(w.assign({salt:t},le),r,8*(2*V[n.strength]+2)),i=new p(a);n.keys={key:y.toBits(u(i,0,V[n.strength])),authentication:y.toBits(u(i,V[n.strength],2*V[n.strength])),passwordVerification:u(i,2*V[n.strength])}}function U(n,e){let t=n;return n.length+e.length&&(t=new p(n.length+e.length),t.set(n,0),t.set(e,n.length)),t}function u(n,e,t){return n.subarray(e,t)}class ue{constructor(e,t){w.assign(this,{password:e,passwordVerification:t}),Z(this,e)}append(e){const t=this;if(t.password){const s=X(t,e.subarray(0,12));if(t.password=null,s[11]!=t.passwordVerification)throw new z(j);e=e.subarray(12)}return X(t,e)}flush(){return{valid:!0,data:new p(0)}}}class fe{constructor(e,t){w.assign(this,{password:e,passwordVerification:t}),Z(this,e)}append(e){const t=this;let s,r;if(t.password){t.password=null;const a=A.getRandomValues(new p(12));a[11]=t.passwordVerification,s=new p(e.length+a.length),s.set(Y(t,a),0),r=12}else s=new p(e.length),r=0;return s.set(Y(t,e),r),s}flush(){return{data:new p(0)}}}function X(n,e){const t=new p(e.length);for(let s=0;s<e.length;s++)t[s]=$(n)^e[s],G(n,t[s]);return t}function Y(n,e){const t=new p(e.length);for(let s=0;s<e.length;s++)t[s]=$(n)^e[s],G(n,e[s]);return t}function Z(n,e){n.keys=[305419896,591751049,878082192],n.crcKey0=new W(n.keys[0]),n.crcKey2=new W(n.keys[2]);for(let t=0;t<e.length;t++)G(n,e.charCodeAt(t))}function G(n,e){n.crcKey0.append([e]),n.keys[0]=~n.crcKey0.get(),n.keys[1]=te(n.keys[1]+ee(n.keys[0])),n.keys[1]=te(v.imul(n.keys[1],134775813)+1),n.crcKey2.append([n.keys[1]>>>24]),n.keys[2]=~n.crcKey2.get()}function $(n){const e=2|n.keys[2];return ee(v.imul(e,1^e)>>>8)}function ee(n){return 255&n}function te(n){return 4294967295&n}const ne="deflate",se="inflate",re="Invalid signature";class ge{constructor(e,{signature:t,password:s,signed:r,compressed:a,zipCrypto:i,passwordVerification:o,encryptionStrength:l},{chunkSize:c}){const h=!!s;w.assign(this,{signature:t,encrypted:h,signed:r,compressed:a,inflate:a&&new e({chunkSize:c}),crc32:r&&new W,zipCrypto:i,decrypt:h&&i?new ue(s,o):new pe(s,r,l)})}async append(e){const t=this;return t.encrypted&&e.length&&(e=await t.decrypt.append(e)),t.compressed&&e.length&&(e=await t.inflate.append(e)),(!t.encrypted||t.zipCrypto)&&t.signed&&e.length&&t.crc32.append(e),e}async flush(){const e=this;let t,s=new p(0);if(e.encrypted){const r=e.decrypt.flush();if(!r.valid)throw new z(re);s=r.data}if((!e.encrypted||e.zipCrypto)&&e.signed){const r=new ce(new p(4).buffer);if(t=e.crc32.get(),r.setUint32(0,t),e.signature!=r.getUint32(0,!1))throw new z(re)}return e.compressed&&(s=await e.inflate.append(s)||new p(0),await e.inflate.flush()),{data:s,signature:t}}}class we{constructor(e,{encrypted:t,signed:s,compressed:r,level:a,zipCrypto:i,password:o,passwordVerification:l,encryptionStrength:c},{chunkSize:h}){w.assign(this,{encrypted:t,signed:s,compressed:r,deflate:r&&new e({level:a||5,chunkSize:h}),crc32:s&&new W,zipCrypto:i,encrypt:t&&i?new fe(o,l):new de(o,c)})}async append(e){const t=this;let s=e;return t.compressed&&e.length&&(s=await t.deflate.append(e)),t.encrypted&&s.length&&(s=await t.encrypt.append(s)),(!t.encrypted||t.zipCrypto)&&t.signed&&e.length&&t.crc32.append(e),s}async flush(){const e=this;let t,s=new p(0);if(e.compressed&&(s=await e.deflate.flush()||new p(0)),e.encrypted){s=await e.encrypt.append(s);const r=e.encrypt.flush();t=r.signature;const a=new p(s.length+r.data.length);a.set(s,0),a.set(r.data,s.length),s=a}return e.encrypted&&!e.zipCrypto||!e.signed||(t=e.crc32.get()),{data:s,signature:t}}}const ye={init(n){n.scripts&&n.scripts.length&&importScripts.apply(void 0,n.scripts);const e=n.options;let t;self.initCodec&&self.initCodec(),e.codecType.startsWith(ne)?t=self.Deflate:e.codecType.startsWith(se)&&(t=self.Inflate),L=((s,r,a)=>r.codecType.startsWith(ne)?new we(s,r,a):r.codecType.startsWith(se)?new ge(s,r,a):void 0)(t,e,n.config)},append:async n=>({data:await L.append(n.data)}),flush:()=>L.flush()};let L;function ae(n,e,t){return class{constructor(r){const a=this;a.codec=new n(w.assign({},e,r)),t(a.codec,i=>{if(a.pendingData){const o=a.pendingData;a.pendingData=new p(o.length+i.length),a.pendingData.set(o,0),a.pendingData.set(i,o.length)}else a.pendingData=new p(i)})}async append(r){return this.codec.push(r),s(this)}async flush(){return this.codec.push(new p(0),!0),s(this)}};function s(r){if(r.pendingData){const a=r.pendingData;return r.pendingData=null,a}return new p(0)}}addEventListener("message",async n=>{const e=n.data,t=e.type,s=ye[t];if(s)try{e.data&&(e.data=new p(e.data));const r=await s(e)||{};if(r.type=t,r.data)try{r.data=r.data.buffer,K(r,[r.data])}catch{K(r)}else K(r)}catch(r){K({type:t,error:{message:r.message,stack:r.stack}})}}),self.initCodec=()=>{const{Deflate:n,Inflate:e}=((t,s={},r)=>({Deflate:ae(t.Deflate,s.deflate,r),Inflate:ae(t.Inflate,s.inflate,r)}))(pako,{deflate:{raw:!0},inflate:{raw:!0}},(t,s)=>t.onData=s);self.Deflate=n,self.Inflate=e}})();
