/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.96.6
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */

define(["exports","./Transforms-66eda18c","./Matrix2-4706dd70","./ComponentDatatype-438cad2a","./CylinderGeometryLibrary-37f2ca9d","./defaultValue-028a8a27","./RuntimeError-a977b8e0","./GeometryAttribute-2cdece80","./GeometryAttributes-98e858da","./GeometryOffsetAttribute-116f8293","./IndexDatatype-dfa09980","./VertexFormat-3518f543"],function(j,J,d,R,W,c,v,D,H,G,K,_){"use strict";const E=new d.Cartesian2,Q=new d.Cartesian3,X=new d.Cartesian3,$=new d.Cartesian3,M=new d.Cartesian3;function C(t){t=c.defaultValue(t,c.defaultValue.EMPTY_OBJECT);const o=t.length,e=t.topRadius,w=t.bottomRadius,n=c.defaultValue(t.vertexFormat,_.VertexFormat.DEFAULT),r=c.defaultValue(t.slices,128);if(!c.defined(o))throw new v.DeveloperError("options.length must be defined.");if(!c.defined(e))throw new v.DeveloperError("options.topRadius must be defined.");if(!c.defined(w))throw new v.DeveloperError("options.bottomRadius must be defined.");if(r<3)throw new v.DeveloperError("options.slices must be greater than or equal to 3.");if(c.defined(t.offsetAttribute)&&t.offsetAttribute===G.GeometryOffsetAttribute.TOP)throw new v.DeveloperError("GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.");this._length=o,this._topRadius=e,this._bottomRadius=w,this._vertexFormat=_.VertexFormat.clone(n),this._slices=r,this._offsetAttribute=t.offsetAttribute,this._workerName="createCylinderGeometry"}C.packedLength=_.VertexFormat.packedLength+5,C.pack=function(t,o,e){if(!c.defined(t))throw new v.DeveloperError("value is required");if(!c.defined(o))throw new v.DeveloperError("array is required");return e=c.defaultValue(e,0),_.VertexFormat.pack(t._vertexFormat,o,e),e+=_.VertexFormat.packedLength,o[e++]=t._length,o[e++]=t._topRadius,o[e++]=t._bottomRadius,o[e++]=t._slices,o[e]=c.defaultValue(t._offsetAttribute,-1),o};const x=new _.VertexFormat,S={vertexFormat:x,length:void 0,topRadius:void 0,bottomRadius:void 0,slices:void 0,offsetAttribute:void 0};C.unpack=function(t,o,e){if(!c.defined(t))throw new v.DeveloperError("array is required");o=c.defaultValue(o,0);const w=_.VertexFormat.unpack(t,o,x);o+=_.VertexFormat.packedLength;const n=t[o++],r=t[o++],b=t[o++],P=t[o++],A=t[o];return c.defined(e)?(e._vertexFormat=_.VertexFormat.clone(w,e._vertexFormat),e._length=n,e._topRadius=r,e._bottomRadius=b,e._slices=P,e._offsetAttribute=A===-1?void 0:A,e):(S.length=n,S.topRadius=r,S.bottomRadius=b,S.slices=P,S.offsetAttribute=A===-1?void 0:A,new C(S))},C.createGeometry=function(t){let o=t._length;const e=t._topRadius,w=t._bottomRadius,n=t._vertexFormat,r=t._slices;if(o<=0||e<0||w<0||e===0&&w===0)return;const b=r+r,P=r+b,A=b+b,k=W.CylinderGeometryLibrary.computePositions(o,e,w,r,!0),z=n.st?new Float32Array(A*2):void 0,m=n.normal?new Float32Array(A*3):void 0,u=n.tangent?new Float32Array(A*3):void 0,p=n.bitangent?new Float32Array(A*3):void 0;let i;const U=n.normal||n.tangent||n.bitangent;if(U){const O=n.tangent||n.bitangent;let f=0,h=0,l=0;const B=Math.atan2(w-e,o),g=Q;g.z=Math.sin(B);const Y=Math.cos(B);let y=$,F=X;for(i=0;i<r;i++){const Z=i/r*R.CesiumMath.TWO_PI,tt=Y*Math.cos(Z),et=Y*Math.sin(Z);U&&(g.x=tt,g.y=et,O&&(y=d.Cartesian3.normalize(d.Cartesian3.cross(d.Cartesian3.UNIT_Z,g,y),y)),n.normal&&(m[f++]=g.x,m[f++]=g.y,m[f++]=g.z,m[f++]=g.x,m[f++]=g.y,m[f++]=g.z),n.tangent&&(u[h++]=y.x,u[h++]=y.y,u[h++]=y.z,u[h++]=y.x,u[h++]=y.y,u[h++]=y.z),n.bitangent&&(F=d.Cartesian3.normalize(d.Cartesian3.cross(g,y,F),F),p[l++]=F.x,p[l++]=F.y,p[l++]=F.z,p[l++]=F.x,p[l++]=F.y,p[l++]=F.z))}for(i=0;i<r;i++)n.normal&&(m[f++]=0,m[f++]=0,m[f++]=-1),n.tangent&&(u[h++]=1,u[h++]=0,u[h++]=0),n.bitangent&&(p[l++]=0,p[l++]=-1,p[l++]=0);for(i=0;i<r;i++)n.normal&&(m[f++]=0,m[f++]=0,m[f++]=1),n.tangent&&(u[h++]=1,u[h++]=0,u[h++]=0),n.bitangent&&(p[l++]=0,p[l++]=1,p[l++]=0)}const I=12*r-12,s=K.IndexDatatype.createTypedArray(A,I);let a=0,T=0;for(i=0;i<r-1;i++)s[a++]=T,s[a++]=T+2,s[a++]=T+3,s[a++]=T,s[a++]=T+3,s[a++]=T+1,T+=2;for(s[a++]=b-2,s[a++]=0,s[a++]=1,s[a++]=b-2,s[a++]=1,s[a++]=b-1,i=1;i<r-1;i++)s[a++]=b+i+1,s[a++]=b+i,s[a++]=b;for(i=1;i<r-1;i++)s[a++]=P,s[a++]=P+i,s[a++]=P+i+1;let q=0;if(n.st){const O=Math.max(e,w);for(i=0;i<A;i++){const f=d.Cartesian3.fromArray(k,i*3,M);z[q++]=(f.x+O)/(2*O),z[q++]=(f.y+O)/(2*O)}}const L=new H.GeometryAttributes;n.position&&(L.position=new D.GeometryAttribute({componentDatatype:R.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:k})),n.normal&&(L.normal=new D.GeometryAttribute({componentDatatype:R.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:m})),n.tangent&&(L.tangent=new D.GeometryAttribute({componentDatatype:R.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:u})),n.bitangent&&(L.bitangent=new D.GeometryAttribute({componentDatatype:R.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:p})),n.st&&(L.st=new D.GeometryAttribute({componentDatatype:R.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:z})),E.x=o*.5,E.y=Math.max(w,e);const V=new J.BoundingSphere(d.Cartesian3.ZERO,d.Cartesian2.magnitude(E));if(c.defined(t._offsetAttribute)){o=k.length;const O=t._offsetAttribute===G.GeometryOffsetAttribute.NONE?0:1,f=new Uint8Array(o/3).fill(O);L.applyOffset=new D.GeometryAttribute({componentDatatype:R.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:f})}return new D.Geometry({attributes:L,indices:s,primitiveType:D.PrimitiveType.TRIANGLES,boundingSphere:V,offsetAttribute:t._offsetAttribute})};let N;C.getUnitCylinder=function(){return c.defined(N)||(N=C.createGeometry(new C({topRadius:1,bottomRadius:1,length:1,vertexFormat:_.VertexFormat.POSITION_ONLY}))),N},j.CylinderGeometry=C});
