/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.96.6
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */

define(["exports","./AttributeCompression-18035d40","./Matrix2-4706dd70","./RuntimeError-a977b8e0","./defaultValue-028a8a27","./ComponentDatatype-438cad2a","./Transforms-66eda18c","./EncodedCartesian3-b59dee27","./GeometryAttribute-2cdece80","./IndexDatatype-dfa09980","./IntersectionTests-54d7f8a4","./Plane-f4cd36d8"],function(xe,ee,r,T,f,O,Q,Re,I,G,Ee,De){"use strict";const Ne=new r.Cartesian3,ze=new r.Cartesian3,qe=new r.Cartesian3;function Ve(e,n,t,s,i){T.Check.defined("point",e),T.Check.defined("p0",n),T.Check.defined("p1",t),T.Check.defined("p2",s),f.defined(i)||(i=new r.Cartesian3);let c,o,a,u,d,p,h,l;if(f.defined(n.z)){if(r.Cartesian3.equalsEpsilon(e,n,O.CesiumMath.EPSILON14))return r.Cartesian3.clone(r.Cartesian3.UNIT_X,i);if(r.Cartesian3.equalsEpsilon(e,t,O.CesiumMath.EPSILON14))return r.Cartesian3.clone(r.Cartesian3.UNIT_Y,i);if(r.Cartesian3.equalsEpsilon(e,s,O.CesiumMath.EPSILON14))return r.Cartesian3.clone(r.Cartesian3.UNIT_Z,i);c=r.Cartesian3.subtract(t,n,Ne),o=r.Cartesian3.subtract(s,n,ze),a=r.Cartesian3.subtract(e,n,qe),u=r.Cartesian3.dot(c,c),d=r.Cartesian3.dot(c,o),p=r.Cartesian3.dot(c,a),h=r.Cartesian3.dot(o,o),l=r.Cartesian3.dot(o,a)}else{if(r.Cartesian2.equalsEpsilon(e,n,O.CesiumMath.EPSILON14))return r.Cartesian3.clone(r.Cartesian3.UNIT_X,i);if(r.Cartesian2.equalsEpsilon(e,t,O.CesiumMath.EPSILON14))return r.Cartesian3.clone(r.Cartesian3.UNIT_Y,i);if(r.Cartesian2.equalsEpsilon(e,s,O.CesiumMath.EPSILON14))return r.Cartesian3.clone(r.Cartesian3.UNIT_Z,i);c=r.Cartesian2.subtract(t,n,Ne),o=r.Cartesian2.subtract(s,n,ze),a=r.Cartesian2.subtract(e,n,qe),u=r.Cartesian2.dot(c,c),d=r.Cartesian2.dot(c,o),p=r.Cartesian2.dot(c,a),h=r.Cartesian2.dot(o,o),l=r.Cartesian2.dot(o,a)}i.y=h*p-d*l,i.z=u*l-d*p;const v=u*h-d*d;if(v!==0)return i.y/=v,i.z/=v,i.x=1-i.y-i.z,i}const me={};me.calculateACMR=function(e){e=f.defaultValue(e,f.defaultValue.EMPTY_OBJECT);const n=e.indices;let t=e.maximumIndex;const s=f.defaultValue(e.cacheSize,24);if(!f.defined(n))throw new T.DeveloperError("indices is required.");const i=n.length;if(i<3||i%3!==0)throw new T.DeveloperError("indices length must be a multiple of three.");if(t<=0)throw new T.DeveloperError("maximumIndex must be greater than zero.");if(s<3)throw new T.DeveloperError("cacheSize must be greater than two.");if(!f.defined(t)){t=0;let a=0,u=n[a];for(;a<i;)u>t&&(t=u),++a,u=n[a]}const c=[];for(let a=0;a<t+1;a++)c[a]=0;let o=s+1;for(let a=0;a<i;++a)o-c[n[a]]>s&&(c[n[a]]=o,++o);return(o-s+1)/(i/3)},me.tipsify=function(e){e=f.defaultValue(e,f.defaultValue.EMPTY_OBJECT);const n=e.indices,t=e.maximumIndex,s=f.defaultValue(e.cacheSize,24);let i;function c(F,z,q,B){for(;z.length>=1;){const k=z[z.length-1];if(z.splice(z.length-1,1),F[k].numLiveTriangles>0)return k}for(;i<B;){if(F[i].numLiveTriangles>0)return++i,i-1;++i}return-1}function o(F,z,q,B,k,U,J){let X=-1,j,Oe=-1,Le=0;for(;Le<q.length;){const ae=q[Le];B[ae].numLiveTriangles&&(j=0,k-B[ae].timeStamp+2*B[ae].numLiveTriangles<=z&&(j=k-B[ae].timeStamp),(j>Oe||Oe===-1)&&(Oe=j,X=ae)),++Le}return X===-1?c(B,U,F,J):X}if(!f.defined(n))throw new T.DeveloperError("indices is required.");const a=n.length;if(a<3||a%3!==0)throw new T.DeveloperError("indices length must be a multiple of three.");if(t<=0)throw new T.DeveloperError("maximumIndex must be greater than zero.");if(s<3)throw new T.DeveloperError("cacheSize must be greater than two.");let u=0,d=0,p=n[d];const h=a;if(f.defined(t))u=t+1;else{for(;d<h;)p>u&&(u=p),++d,p=n[d];if(u===-1)return 0;++u}const l=[];let v;for(v=0;v<u;v++)l[v]={numLiveTriangles:0,timeStamp:0,vertexTriangles:[]};d=0;let b=0;for(;d<h;)l[n[d]].vertexTriangles.push(b),++l[n[d]].numLiveTriangles,l[n[d+1]].vertexTriangles.push(b),++l[n[d+1]].numLiveTriangles,l[n[d+2]].vertexTriangles.push(b),++l[n[d+2]].numLiveTriangles,++b,d+=3;let C=0,m=s+1;i=1;let g=[];const y=[];let w,S,N=0;const A=[],E=a/3,D=[];for(v=0;v<E;v++)D[v]=!1;let L,P;for(;C!==-1;){g=[],S=l[C],P=S.vertexTriangles.length;for(let F=0;F<P;++F)if(b=S.vertexTriangles[F],!D[b]){D[b]=!0,d=b+b+b;for(let z=0;z<3;++z)L=n[d],g.push(L),y.push(L),A[N]=L,++N,w=l[L],--w.numLiveTriangles,m-w.timeStamp>s&&(w.timeStamp=m,++m),++d}C=o(n,s,g,l,m,y,u)}return A};const _={};function de(e,n,t,s,i){e[n++]=t,e[n++]=s,e[n++]=s,e[n++]=i,e[n++]=i,e[n]=t}function Me(e){const n=e.length,t=n/3*6,s=G.IndexDatatype.createTypedArray(n,t);let i=0;for(let c=0;c<n;c+=3,i+=6)de(s,i,e[c],e[c+1],e[c+2]);return s}function en(e){const n=e.length;if(n>=3){const t=(n-2)*6,s=G.IndexDatatype.createTypedArray(n,t);de(s,0,e[0],e[1],e[2]);let i=6;for(let c=3;c<n;++c,i+=6)de(s,i,e[c-1],e[c],e[c-2]);return s}return new Uint16Array}function nn(e){if(e.length>0){const n=e.length-1,t=(n-1)*6,s=G.IndexDatatype.createTypedArray(n,t),i=e[0];let c=0;for(let o=1;o<n;++o,c+=6)de(s,c,i,e[o],e[o+1]);return s}return new Uint16Array}_.toWireframe=function(e){if(!f.defined(e))throw new T.DeveloperError("geometry is required.");const n=e.indices;if(f.defined(n)){switch(e.primitiveType){case I.PrimitiveType.TRIANGLES:e.indices=Me(n);break;case I.PrimitiveType.TRIANGLE_STRIP:e.indices=en(n);break;case I.PrimitiveType.TRIANGLE_FAN:e.indices=nn(n);break;default:throw new T.DeveloperError("geometry.primitiveType must be TRIANGLES, TRIANGLE_STRIP, or TRIANGLE_FAN.")}e.primitiveType=I.PrimitiveType.LINES}return e},_.createLineSegmentsForVectors=function(e,n,t){if(n=f.defaultValue(n,"normal"),!f.defined(e))throw new T.DeveloperError("geometry is required.");if(!f.defined(e.attributes.position))throw new T.DeveloperError("geometry.attributes.position is required.");if(!f.defined(e.attributes[n]))throw new T.DeveloperError(`geometry.attributes must have an attribute with the same name as the attributeName parameter, ${n}.`);t=f.defaultValue(t,1e4);const s=e.attributes.position.values,i=e.attributes[n].values,c=s.length,o=new Float64Array(2*c);let a=0;for(let p=0;p<c;p+=3)o[a++]=s[p],o[a++]=s[p+1],o[a++]=s[p+2],o[a++]=s[p]+i[p]*t,o[a++]=s[p+1]+i[p+1]*t,o[a++]=s[p+2]+i[p+2]*t;let u;const d=e.boundingSphere;return f.defined(d)&&(u=new Q.BoundingSphere(d.center,d.radius+t)),new I.Geometry({attributes:{position:new I.GeometryAttribute({componentDatatype:O.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:o})},primitiveType:I.PrimitiveType.LINES,boundingSphere:u})},_.createAttributeLocations=function(e){if(!f.defined(e))throw new T.DeveloperError("geometry is required.");const n=["position","positionHigh","positionLow","position3DHigh","position3DLow","position2DHigh","position2DLow","pickColor","normal","st","tangent","bitangent","extrudeDirection","compressedAttributes"],t=e.attributes,s={};let i=0,c;const o=n.length;for(c=0;c<o;++c){const a=n[c];f.defined(t[a])&&(s[a]=i++)}for(const a in t)t.hasOwnProperty(a)&&!f.defined(s[a])&&(s[a]=i++);return s},_.reorderForPreVertexCache=function(e){if(!f.defined(e))throw new T.DeveloperError("geometry is required.");const n=I.Geometry.computeNumberOfVertices(e),t=e.indices;if(f.defined(t)){const s=new Int32Array(n);for(let l=0;l<n;l++)s[l]=-1;const i=t,c=i.length,o=G.IndexDatatype.createTypedArray(n,c);let a=0,u=0,d=0,p;for(;a<c;)p=s[i[a]],p!==-1?o[u]=p:(p=i[a],s[p]=d,o[u]=d,++d),++a,++u;e.indices=o;const h=e.attributes;for(const l in h)if(h.hasOwnProperty(l)&&f.defined(h[l])&&f.defined(h[l].values)){const v=h[l],b=v.values;let C=0;const m=v.componentsPerAttribute,g=O.ComponentDatatype.createTypedArray(v.componentDatatype,d*m);for(;C<n;){const y=s[C];if(y!==-1)for(let w=0;w<m;w++)g[m*y+w]=b[m*C+w];++C}v.values=g}}return e},_.reorderForPostVertexCache=function(e,n){if(!f.defined(e))throw new T.DeveloperError("geometry is required.");const t=e.indices;if(e.primitiveType===I.PrimitiveType.TRIANGLES&&f.defined(t)){const s=t.length;let i=0;for(let c=0;c<s;c++)t[c]>i&&(i=t[c]);e.indices=me.tipsify({indices:t,maximumIndex:i,cacheSize:n})}return e};function Be(e){const n={};for(const t in e)if(e.hasOwnProperty(t)&&f.defined(e[t])&&f.defined(e[t].values)){const s=e[t];n[t]=new I.GeometryAttribute({componentDatatype:s.componentDatatype,componentsPerAttribute:s.componentsPerAttribute,normalize:s.normalize,values:[]})}return n}function tn(e,n,t){for(const s in n)if(n.hasOwnProperty(s)&&f.defined(n[s])&&f.defined(n[s].values)){const i=n[s];for(let c=0;c<i.componentsPerAttribute;++c)e[s].values.push(i.values[t*i.componentsPerAttribute+c])}}_.fitToUnsignedShortIndices=function(e){if(!f.defined(e))throw new T.DeveloperError("geometry is required.");if(f.defined(e.indices)&&e.primitiveType!==I.PrimitiveType.TRIANGLES&&e.primitiveType!==I.PrimitiveType.LINES&&e.primitiveType!==I.PrimitiveType.POINTS)throw new T.DeveloperError("geometry.primitiveType must equal to PrimitiveType.TRIANGLES, PrimitiveType.LINES, or PrimitiveType.POINTS.");const n=[],t=I.Geometry.computeNumberOfVertices(e);if(f.defined(e.indices)&&t>=O.CesiumMath.SIXTY_FOUR_KILOBYTES){let s=[],i=[],c=0,o=Be(e.attributes);const a=e.indices,u=a.length;let d;e.primitiveType===I.PrimitiveType.TRIANGLES?d=3:e.primitiveType===I.PrimitiveType.LINES?d=2:e.primitiveType===I.PrimitiveType.POINTS&&(d=1);for(let p=0;p<u;p+=d){for(let h=0;h<d;++h){const l=a[p+h];let v=s[l];f.defined(v)||(v=c++,s[l]=v,tn(o,e.attributes,l)),i.push(v)}c+d>=O.CesiumMath.SIXTY_FOUR_KILOBYTES&&(n.push(new I.Geometry({attributes:o,indices:i,primitiveType:e.primitiveType,boundingSphere:e.boundingSphere,boundingSphereCV:e.boundingSphereCV})),s=[],i=[],c=0,o=Be(e.attributes))}i.length!==0&&n.push(new I.Geometry({attributes:o,indices:i,primitiveType:e.primitiveType,boundingSphere:e.boundingSphere,boundingSphereCV:e.boundingSphereCV}))}else n.push(e);return n};const ke=new r.Cartesian3,sn=new r.Cartographic;_.projectTo2D=function(e,n,t,s,i){if(!f.defined(e))throw new T.DeveloperError("geometry is required.");if(!f.defined(n))throw new T.DeveloperError("attributeName is required.");if(!f.defined(t))throw new T.DeveloperError("attributeName3D is required.");if(!f.defined(s))throw new T.DeveloperError("attributeName2D is required.");if(!f.defined(e.attributes[n]))throw new T.DeveloperError(`geometry must have attribute matching the attributeName argument: ${n}.`);if(e.attributes[n].componentDatatype!==O.ComponentDatatype.DOUBLE)throw new T.DeveloperError("The attribute componentDatatype must be ComponentDatatype.DOUBLE.");const c=e.attributes[n];i=f.defined(i)?i:new Q.GeographicProjection;const o=i.ellipsoid,a=c.values,u=new Float64Array(a.length);let d=0;for(let p=0;p<a.length;p+=3){const h=r.Cartesian3.fromArray(a,p,ke),l=o.cartesianToCartographic(h,sn);if(!f.defined(l))throw new T.DeveloperError(`Could not project point (${h.x}, ${h.y}, ${h.z}) to 2D.`);const v=i.project(l,ke);u[d++]=v.x,u[d++]=v.y,u[d++]=v.z}return e.attributes[t]=c,e.attributes[s]=new I.GeometryAttribute({componentDatatype:O.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:u}),delete e.attributes[n],e};const we={high:0,low:0};_.encodeAttribute=function(e,n,t,s){if(!f.defined(e))throw new T.DeveloperError("geometry is required.");if(!f.defined(n))throw new T.DeveloperError("attributeName is required.");if(!f.defined(t))throw new T.DeveloperError("attributeHighName is required.");if(!f.defined(s))throw new T.DeveloperError("attributeLowName is required.");if(!f.defined(e.attributes[n]))throw new T.DeveloperError(`geometry must have attribute matching the attributeName argument: ${n}.`);if(e.attributes[n].componentDatatype!==O.ComponentDatatype.DOUBLE)throw new T.DeveloperError("The attribute componentDatatype must be ComponentDatatype.DOUBLE.");const i=e.attributes[n],c=i.values,o=c.length,a=new Float32Array(o),u=new Float32Array(o);for(let p=0;p<o;++p)Re.EncodedCartesian3.encode(c[p],we),a[p]=we.high,u[p]=we.low;const d=i.componentsPerAttribute;return e.attributes[t]=new I.GeometryAttribute({componentDatatype:O.ComponentDatatype.FLOAT,componentsPerAttribute:d,values:a}),e.attributes[s]=new I.GeometryAttribute({componentDatatype:O.ComponentDatatype.FLOAT,componentsPerAttribute:d,values:u}),delete e.attributes[n],e};let H=new r.Cartesian3;function Ce(e,n){if(f.defined(n)){const t=n.values,s=t.length;for(let i=0;i<s;i+=3)r.Cartesian3.unpack(t,i,H),r.Matrix4.multiplyByPoint(e,H,H),r.Cartesian3.pack(H,t,i)}}function be(e,n){if(f.defined(n)){const t=n.values,s=t.length;for(let i=0;i<s;i+=3)r.Cartesian3.unpack(t,i,H),r.Matrix3.multiplyByVector(e,H,H),H=r.Cartesian3.normalize(H,H),r.Cartesian3.pack(H,t,i)}}const fe=new r.Matrix4,le=new r.Matrix3;_.transformToWorldCoordinates=function(e){if(!f.defined(e))throw new T.DeveloperError("instance is required.");const n=e.modelMatrix;if(r.Matrix4.equals(n,r.Matrix4.IDENTITY))return e;const t=e.geometry.attributes;Ce(n,t.position),Ce(n,t.prevPosition),Ce(n,t.nextPosition),(f.defined(t.normal)||f.defined(t.tangent)||f.defined(t.bitangent))&&(r.Matrix4.inverse(n,fe),r.Matrix4.transpose(fe,fe),r.Matrix4.getMatrix3(fe,le),be(le,t.normal),be(le,t.tangent),be(le,t.bitangent));const s=e.geometry.boundingSphere;return f.defined(s)&&(e.geometry.boundingSphere=Q.BoundingSphere.transform(s,n,s)),e.modelMatrix=r.Matrix4.clone(r.Matrix4.IDENTITY),e};function rn(e,n){const t=e.length,s={},i=e[0][n].attributes;let c;for(c in i)if(i.hasOwnProperty(c)&&f.defined(i[c])&&f.defined(i[c].values)){const o=i[c];let a=o.values.length,u=!0;for(let d=1;d<t;++d){const p=e[d][n].attributes[c];if(!f.defined(p)||o.componentDatatype!==p.componentDatatype||o.componentsPerAttribute!==p.componentsPerAttribute||o.normalize!==p.normalize){u=!1;break}a+=p.values.length}u&&(s[c]=new I.GeometryAttribute({componentDatatype:o.componentDatatype,componentsPerAttribute:o.componentsPerAttribute,normalize:o.normalize,values:O.ComponentDatatype.createTypedArray(o.componentDatatype,a)}))}return s}const on=new r.Cartesian3;function ye(e,n){const t=e.length;let s,i,c,o;const a=e[0].modelMatrix,u=f.defined(e[0][n].indices),d=e[0][n].primitiveType;for(i=1;i<t;++i){if(!r.Matrix4.equals(e[i].modelMatrix,a))throw new T.DeveloperError("All instances must have the same modelMatrix.");if(f.defined(e[i][n].indices)!==u)throw new T.DeveloperError("All instance geometries must have an indices or not have one.");if(e[i][n].primitiveType!==d)throw new T.DeveloperError("All instance geometries must have the same primitiveType.")}const p=rn(e,n);let h,l,v;for(s in p)if(p.hasOwnProperty(s))for(h=p[s].values,o=0,i=0;i<t;++i)for(l=e[i][n].attributes[s].values,v=l.length,c=0;c<v;++c)h[o++]=l[c];let b;if(u){let y=0;for(i=0;i<t;++i)y+=e[i][n].indices.length;const w=I.Geometry.computeNumberOfVertices(new I.Geometry({attributes:p,primitiveType:I.PrimitiveType.POINTS})),S=G.IndexDatatype.createTypedArray(w,y);let N=0,A=0;for(i=0;i<t;++i){const E=e[i][n].indices,D=E.length;for(o=0;o<D;++o)S[N++]=A+E[o];A+=I.Geometry.computeNumberOfVertices(e[i][n])}b=S}let C=new r.Cartesian3,m=0,g;for(i=0;i<t;++i){if(g=e[i][n].boundingSphere,!f.defined(g)){C=void 0;break}r.Cartesian3.add(g.center,C,C)}if(f.defined(C))for(r.Cartesian3.divideByScalar(C,t,C),i=0;i<t;++i){g=e[i][n].boundingSphere;const y=r.Cartesian3.magnitude(r.Cartesian3.subtract(g.center,C,on))+g.radius;y>m&&(m=y)}return new I.Geometry({attributes:p,indices:b,primitiveType:d,boundingSphere:f.defined(C)?new Q.BoundingSphere(C,m):void 0})}_.combineInstances=function(e){if(!f.defined(e)||e.length<1)throw new T.DeveloperError("instances is required and must have length greater than zero.");const n=[],t=[],s=e.length;for(let c=0;c<s;++c){const o=e[c];f.defined(o.geometry)?n.push(o):f.defined(o.westHemisphereGeometry)&&f.defined(o.eastHemisphereGeometry)&&t.push(o)}const i=[];return n.length>0&&i.push(ye(n,"geometry")),t.length>0&&(i.push(ye(t,"westHemisphereGeometry")),i.push(ye(t,"eastHemisphereGeometry"))),i};const Y=new r.Cartesian3,re=new r.Cartesian3,ne=new r.Cartesian3,te=new r.Cartesian3;_.computeNormal=function(e){if(!f.defined(e))throw new T.DeveloperError("geometry is required.");if(!f.defined(e.attributes.position)||!f.defined(e.attributes.position.values))throw new T.DeveloperError("geometry.attributes.position.values is required.");if(!f.defined(e.indices))throw new T.DeveloperError("geometry.indices is required.");if(e.indices.length<2||e.indices.length%3!==0)throw new T.DeveloperError("geometry.indices length must be greater than 0 and be a multiple of 3.");if(e.primitiveType!==I.PrimitiveType.TRIANGLES)throw new T.DeveloperError("geometry.primitiveType must be PrimitiveType.TRIANGLES.");const n=e.indices,t=e.attributes,s=t.position.values,i=t.position.values.length/3,c=n.length,o=new Array(i),a=new Array(c/3),u=new Array(c);let d;for(d=0;d<i;d++)o[d]={indexOffset:0,count:0,currentCount:0};let p=0;for(d=0;d<c;d+=3){const b=n[d],C=n[d+1],m=n[d+2],g=b*3,y=C*3,w=m*3;re.x=s[g],re.y=s[g+1],re.z=s[g+2],ne.x=s[y],ne.y=s[y+1],ne.z=s[y+2],te.x=s[w],te.y=s[w+1],te.z=s[w+2],o[b].count++,o[C].count++,o[m].count++,r.Cartesian3.subtract(ne,re,ne),r.Cartesian3.subtract(te,re,te),a[p]=r.Cartesian3.cross(ne,te,new r.Cartesian3),p++}let h=0;for(d=0;d<i;d++)o[d].indexOffset+=h,h+=o[d].count;p=0;let l;for(d=0;d<c;d+=3){l=o[n[d]];let b=l.indexOffset+l.currentCount;u[b]=p,l.currentCount++,l=o[n[d+1]],b=l.indexOffset+l.currentCount,u[b]=p,l.currentCount++,l=o[n[d+2]],b=l.indexOffset+l.currentCount,u[b]=p,l.currentCount++,p++}const v=new Float32Array(i*3);for(d=0;d<i;d++){const b=d*3;if(l=o[d],r.Cartesian3.clone(r.Cartesian3.ZERO,Y),l.count>0){for(p=0;p<l.count;p++)r.Cartesian3.add(Y,a[u[l.indexOffset+p]],Y);r.Cartesian3.equalsEpsilon(r.Cartesian3.ZERO,Y,O.CesiumMath.EPSILON10)&&r.Cartesian3.clone(a[u[l.indexOffset]],Y)}r.Cartesian3.equalsEpsilon(r.Cartesian3.ZERO,Y,O.CesiumMath.EPSILON10)&&(Y.z=1),r.Cartesian3.normalize(Y,Y),v[b]=Y.x,v[b+1]=Y.y,v[b+2]=Y.z}return e.attributes.normal=new I.GeometryAttribute({componentDatatype:O.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:v}),e};const cn=new r.Cartesian3,Fe=new r.Cartesian3,an=new r.Cartesian3;_.computeTangentAndBitangent=function(e){if(!f.defined(e))throw new T.DeveloperError("geometry is required.");const n=e.attributes,t=e.indices;if(!f.defined(n.position)||!f.defined(n.position.values))throw new T.DeveloperError("geometry.attributes.position.values is required.");if(!f.defined(n.normal)||!f.defined(n.normal.values))throw new T.DeveloperError("geometry.attributes.normal.values is required.");if(!f.defined(n.st)||!f.defined(n.st.values))throw new T.DeveloperError("geometry.attributes.st.values is required.");if(!f.defined(t))throw new T.DeveloperError("geometry.indices is required.");if(t.length<2||t.length%3!==0)throw new T.DeveloperError("geometry.indices length must be greater than 0 and be a multiple of 3.");if(e.primitiveType!==I.PrimitiveType.TRIANGLES)throw new T.DeveloperError("geometry.primitiveType must be PrimitiveType.TRIANGLES.");const s=e.attributes.position.values,i=e.attributes.normal.values,c=e.attributes.st.values,o=e.attributes.position.values.length/3,a=t.length,u=new Array(o*3);let d;for(d=0;d<u.length;d++)u[d]=0;let p,h,l;for(d=0;d<a;d+=3){const C=t[d],m=t[d+1],g=t[d+2];p=C*3,h=m*3,l=g*3;const y=C*2,w=m*2,S=g*2,N=s[p],A=s[p+1],E=s[p+2],D=c[y],L=c[y+1],P=c[w+1]-L,F=c[S+1]-L,z=1/((c[w]-D)*F-(c[S]-D)*P),q=(F*(s[h]-N)-P*(s[l]-N))*z,B=(F*(s[h+1]-A)-P*(s[l+1]-A))*z,k=(F*(s[h+2]-E)-P*(s[l+2]-E))*z;u[p]+=q,u[p+1]+=B,u[p+2]+=k,u[h]+=q,u[h+1]+=B,u[h+2]+=k,u[l]+=q,u[l+1]+=B,u[l+2]+=k}const v=new Float32Array(o*3),b=new Float32Array(o*3);for(d=0;d<o;d++){p=d*3,h=p+1,l=p+2;const C=r.Cartesian3.fromArray(i,p,cn),m=r.Cartesian3.fromArray(u,p,an),g=r.Cartesian3.dot(C,m);r.Cartesian3.multiplyByScalar(C,g,Fe),r.Cartesian3.normalize(r.Cartesian3.subtract(m,Fe,m),m),v[p]=m.x,v[h]=m.y,v[l]=m.z,r.Cartesian3.normalize(r.Cartesian3.cross(C,m,m),m),b[p]=m.x,b[h]=m.y,b[l]=m.z}return e.attributes.tangent=new I.GeometryAttribute({componentDatatype:O.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:v}),e.attributes.bitangent=new I.GeometryAttribute({componentDatatype:O.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:b}),e};const oe=new r.Cartesian2,W=new r.Cartesian3,_e=new r.Cartesian3,Ue=new r.Cartesian3;let ue=new r.Cartesian2;_.compressVertices=function(e){if(!f.defined(e))throw new T.DeveloperError("geometry is required.");const n=e.attributes.extrudeDirection;let t,s;if(f.defined(n)){const A=n.values;s=A.length/3;const E=new Float32Array(s*2);let D=0;for(t=0;t<s;++t){if(r.Cartesian3.fromArray(A,t*3,W),r.Cartesian3.equals(W,r.Cartesian3.ZERO)){D+=2;continue}ue=ee.AttributeCompression.octEncodeInRange(W,65535,ue),E[D++]=ue.x,E[D++]=ue.y}return e.attributes.compressedAttributes=new I.GeometryAttribute({componentDatatype:O.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:E}),delete e.attributes.extrudeDirection,e}const i=e.attributes.normal,c=e.attributes.st,o=f.defined(i),a=f.defined(c);if(!o&&!a)return e;const u=e.attributes.tangent,d=e.attributes.bitangent,p=f.defined(u),h=f.defined(d);let l,v,b,C;o&&(l=i.values),a&&(v=c.values),p&&(b=u.values),h&&(C=d.values),s=(o?l.length:v.length)/(o?3:2);let y=s,w=a&&o?2:1;w+=p||h?1:0,y*=w;const S=new Float32Array(y);let N=0;for(t=0;t<s;++t){a&&(r.Cartesian2.fromArray(v,t*2,oe),S[N++]=ee.AttributeCompression.compressTextureCoordinates(oe));const A=t*3;o&&f.defined(b)&&f.defined(C)?(r.Cartesian3.fromArray(l,A,W),r.Cartesian3.fromArray(b,A,_e),r.Cartesian3.fromArray(C,A,Ue),ee.AttributeCompression.octPack(W,_e,Ue,oe),S[N++]=oe.x,S[N++]=oe.y):(o&&(r.Cartesian3.fromArray(l,A,W),S[N++]=ee.AttributeCompression.octEncodeFloat(W)),p&&(r.Cartesian3.fromArray(b,A,W),S[N++]=ee.AttributeCompression.octEncodeFloat(W)),h&&(r.Cartesian3.fromArray(C,A,W),S[N++]=ee.AttributeCompression.octEncodeFloat(W)))}return e.attributes.compressedAttributes=new I.GeometryAttribute({componentDatatype:O.ComponentDatatype.FLOAT,componentsPerAttribute:w,values:S}),o&&delete e.attributes.normal,a&&delete e.attributes.st,h&&delete e.attributes.bitangent,p&&delete e.attributes.tangent,e};function dn(e){if(f.defined(e.indices))return e;const n=I.Geometry.computeNumberOfVertices(e);if(n<3)throw new T.DeveloperError("The number of vertices must be at least three.");if(n%3!==0)throw new T.DeveloperError("The number of vertices must be a multiple of three.");const t=G.IndexDatatype.createTypedArray(n,n);for(let s=0;s<n;++s)t[s]=s;return e.indices=t,e}function fn(e){const n=I.Geometry.computeNumberOfVertices(e);if(n<3)throw new T.DeveloperError("The number of vertices must be at least three.");const t=G.IndexDatatype.createTypedArray(n,(n-2)*3);t[0]=1,t[1]=0,t[2]=2;let s=3;for(let i=3;i<n;++i)t[s++]=i-1,t[s++]=0,t[s++]=i;return e.indices=t,e.primitiveType=I.PrimitiveType.TRIANGLES,e}function ln(e){const n=I.Geometry.computeNumberOfVertices(e);if(n<3)throw new T.DeveloperError("The number of vertices must be at least 3.");const t=G.IndexDatatype.createTypedArray(n,(n-2)*3);t[0]=0,t[1]=1,t[2]=2,n>3&&(t[3]=0,t[4]=2,t[5]=3);let s=6;for(let i=3;i<n-1;i+=2)t[s++]=i,t[s++]=i-1,t[s++]=i+1,i+2<n&&(t[s++]=i,t[s++]=i+1,t[s++]=i+2);return e.indices=t,e.primitiveType=I.PrimitiveType.TRIANGLES,e}function un(e){if(f.defined(e.indices))return e;const n=I.Geometry.computeNumberOfVertices(e);if(n<2)throw new T.DeveloperError("The number of vertices must be at least two.");if(n%2!==0)throw new T.DeveloperError("The number of vertices must be a multiple of 2.");const t=G.IndexDatatype.createTypedArray(n,n);for(let s=0;s<n;++s)t[s]=s;return e.indices=t,e}function pn(e){const n=I.Geometry.computeNumberOfVertices(e);if(n<2)throw new T.DeveloperError("The number of vertices must be at least two.");const t=G.IndexDatatype.createTypedArray(n,(n-1)*2);t[0]=0,t[1]=1;let s=2;for(let i=2;i<n;++i)t[s++]=i-1,t[s++]=i;return e.indices=t,e.primitiveType=I.PrimitiveType.LINES,e}function hn(e){const n=I.Geometry.computeNumberOfVertices(e);if(n<2)throw new T.DeveloperError("The number of vertices must be at least two.");const t=G.IndexDatatype.createTypedArray(n,n*2);t[0]=0,t[1]=1;let s=2;for(let i=2;i<n;++i)t[s++]=i-1,t[s++]=i;return t[s++]=n-1,t[s]=0,e.indices=t,e.primitiveType=I.PrimitiveType.LINES,e}function vn(e){switch(e.primitiveType){case I.PrimitiveType.TRIANGLE_FAN:return fn(e);case I.PrimitiveType.TRIANGLE_STRIP:return ln(e);case I.PrimitiveType.TRIANGLES:return dn(e);case I.PrimitiveType.LINE_STRIP:return pn(e);case I.PrimitiveType.LINE_LOOP:return hn(e);case I.PrimitiveType.LINES:return un(e)}return e}function K(e,n){Math.abs(e.y)<O.CesiumMath.EPSILON6&&(n?e.y=-O.CesiumMath.EPSILON6:e.y=O.CesiumMath.EPSILON6)}function mn(e,n,t){if(e.y!==0&&n.y!==0&&t.y!==0){K(e,e.y<0),K(n,n.y<0),K(t,t.y<0);return}const s=Math.abs(e.y),i=Math.abs(n.y),c=Math.abs(t.y);let o;s>i?s>c?o=O.CesiumMath.sign(e.y):o=O.CesiumMath.sign(t.y):i>c?o=O.CesiumMath.sign(n.y):o=O.CesiumMath.sign(t.y);const a=o<0;K(e,a),K(n,a),K(t,a)}const je=new r.Cartesian3;function Z(e,n,t,s){r.Cartesian3.add(e,r.Cartesian3.multiplyByScalar(r.Cartesian3.subtract(n,e,je),e.y/(e.y-n.y),je),t),r.Cartesian3.clone(t,s),K(t,!0),K(s,!1)}const x=new r.Cartesian3,R=new r.Cartesian3,V=new r.Cartesian3,M=new r.Cartesian3,Te={positions:new Array(7),indices:new Array(3*3)};function wn(e,n,t){if(e.x>=0||n.x>=0||t.x>=0)return;mn(e,n,t);const s=e.y<0,i=n.y<0,c=t.y<0;let o=0;o+=s?1:0,o+=i?1:0,o+=c?1:0;const a=Te.indices;o===1?(a[1]=3,a[2]=4,a[5]=6,a[7]=6,a[8]=5,s?(Z(e,n,x,V),Z(e,t,R,M),a[0]=0,a[3]=1,a[4]=2,a[6]=1):i?(Z(n,t,x,V),Z(n,e,R,M),a[0]=1,a[3]=2,a[4]=0,a[6]=2):c&&(Z(t,e,x,V),Z(t,n,R,M),a[0]=2,a[3]=0,a[4]=1,a[6]=0)):o===2&&(a[2]=4,a[4]=4,a[5]=3,a[7]=5,a[8]=6,s?i?c||(Z(t,e,x,V),Z(t,n,R,M),a[0]=0,a[1]=1,a[3]=0,a[6]=2):(Z(n,t,x,V),Z(n,e,R,M),a[0]=2,a[1]=0,a[3]=2,a[6]=1):(Z(e,n,x,V),Z(e,t,R,M),a[0]=1,a[1]=2,a[3]=1,a[6]=0));const u=Te.positions;return u[0]=e,u[1]=n,u[2]=t,u.length=3,(o===1||o===2)&&(u[3]=x,u[4]=R,u[5]=V,u[6]=M,u.length=7),Te}function Ge(e,n){const t=e.attributes;if(t.position.values.length===0)return;for(const i in t)if(t.hasOwnProperty(i)&&f.defined(t[i])&&f.defined(t[i].values)){const c=t[i];c.values=O.ComponentDatatype.createTypedArray(c.componentDatatype,c.values)}const s=I.Geometry.computeNumberOfVertices(e);return e.indices=G.IndexDatatype.createTypedArray(s,e.indices),n&&(e.boundingSphere=Q.BoundingSphere.fromVertices(t.position.values)),e}function ie(e){const n=e.attributes,t={};for(const s in n)if(n.hasOwnProperty(s)&&f.defined(n[s])&&f.defined(n[s].values)){const i=n[s];t[s]=new I.GeometryAttribute({componentDatatype:i.componentDatatype,componentsPerAttribute:i.componentsPerAttribute,normalize:i.normalize,values:[]})}return new I.Geometry({attributes:t,indices:[],primitiveType:e.primitiveType})}function Pe(e,n,t){const s=f.defined(e.geometry.boundingSphere);n=Ge(n,s),t=Ge(t,s),f.defined(t)&&!f.defined(n)?e.geometry=t:!f.defined(t)&&f.defined(n)?e.geometry=n:(e.westHemisphereGeometry=n,e.eastHemisphereGeometry=t,e.geometry=void 0)}function Ie(e,n){const t=new e,s=new e,i=new e;return function(c,o,a,u,d,p,h,l){const v=e.fromArray(d,c*n,t),b=e.fromArray(d,o*n,s),C=e.fromArray(d,a*n,i);e.multiplyByScalar(v,u.x,v),e.multiplyByScalar(b,u.y,b),e.multiplyByScalar(C,u.z,C);const m=e.add(v,b,v);e.add(m,C,m),l&&e.normalize(m,m),e.pack(m,p,h*n)}}const Cn=Ie(r.Cartesian4,4),pe=Ie(r.Cartesian3,3),Ye=Ie(r.Cartesian2,2),bn=function(e,n,t,s,i,c,o){const a=i[e]*s.x,u=i[n]*s.y,d=i[t]*s.z;c[o]=a+u+d>O.CesiumMath.EPSILON6?1:0},ce=new r.Cartesian3,Se=new r.Cartesian3,ge=new r.Cartesian3,yn=new r.Cartesian3;function he(e,n,t,s,i,c,o,a,u,d,p,h,l,v,b,C){if(!f.defined(c)&&!f.defined(o)&&!f.defined(a)&&!f.defined(u)&&!f.defined(d)&&v===0)return;const m=r.Cartesian3.fromArray(i,e*3,ce),g=r.Cartesian3.fromArray(i,n*3,Se),y=r.Cartesian3.fromArray(i,t*3,ge),w=Ve(s,m,g,y,yn);if(!!f.defined(w)){if(f.defined(c)&&pe(e,n,t,w,c,h.normal.values,C,!0),f.defined(d)){const S=r.Cartesian3.fromArray(d,e*3,ce),N=r.Cartesian3.fromArray(d,n*3,Se),A=r.Cartesian3.fromArray(d,t*3,ge);r.Cartesian3.multiplyByScalar(S,w.x,S),r.Cartesian3.multiplyByScalar(N,w.y,N),r.Cartesian3.multiplyByScalar(A,w.z,A);let E;!r.Cartesian3.equals(S,r.Cartesian3.ZERO)||!r.Cartesian3.equals(N,r.Cartesian3.ZERO)||!r.Cartesian3.equals(A,r.Cartesian3.ZERO)?(E=r.Cartesian3.add(S,N,S),r.Cartesian3.add(E,A,E),r.Cartesian3.normalize(E,E)):(E=ce,E.x=0,E.y=0,E.z=0),r.Cartesian3.pack(E,h.extrudeDirection.values,C*3)}if(f.defined(p)&&bn(e,n,t,w,p,h.applyOffset.values,C),f.defined(o)&&pe(e,n,t,w,o,h.tangent.values,C,!0),f.defined(a)&&pe(e,n,t,w,a,h.bitangent.values,C,!0),f.defined(u)&&Ye(e,n,t,w,u,h.st.values,C),v>0)for(let S=0;S<v;S++){const N=l[S];Tn(e,n,t,w,C,b[N],h[N])}}}function Tn(e,n,t,s,i,c,o){const a=c.componentsPerAttribute,u=c.values,d=o.values;switch(a){case 4:Cn(e,n,t,s,u,d,i,!1);break;case 3:pe(e,n,t,s,u,d,i,!1);break;case 2:Ye(e,n,t,s,u,d,i,!1);break;default:d[i]=u[e]*s.x+u[n]*s.y+u[t]*s.z}}function $(e,n,t,s,i,c){const o=e.position.values.length/3;if(i!==-1){const a=s[i],u=t[a];return u===-1?(t[a]=o,e.position.values.push(c.x,c.y,c.z),n.push(o),o):(n.push(u),u)}return e.position.values.push(c.x,c.y,c.z),n.push(o),o}const Pn={position:!0,normal:!0,bitangent:!0,tangent:!0,st:!0,extrudeDirection:!0,applyOffset:!0};function Ze(e){const n=e.geometry,t=n.attributes,s=t.position.values,i=f.defined(t.normal)?t.normal.values:void 0,c=f.defined(t.bitangent)?t.bitangent.values:void 0,o=f.defined(t.tangent)?t.tangent.values:void 0,a=f.defined(t.st)?t.st.values:void 0,u=f.defined(t.extrudeDirection)?t.extrudeDirection.values:void 0,d=f.defined(t.applyOffset)?t.applyOffset.values:void 0,p=n.indices,h=[];for(const E in t)t.hasOwnProperty(E)&&!Pn[E]&&f.defined(t[E])&&h.push(E);const l=h.length,v=ie(n),b=ie(n);let C,m,g,y,w;const S=[];S.length=s.length/3;const N=[];for(N.length=s.length/3,w=0;w<S.length;++w)S[w]=-1,N[w]=-1;const A=p.length;for(w=0;w<A;w+=3){const E=p[w],D=p[w+1],L=p[w+2];let P=r.Cartesian3.fromArray(s,E*3),F=r.Cartesian3.fromArray(s,D*3),z=r.Cartesian3.fromArray(s,L*3);const q=wn(P,F,z);if(f.defined(q)&&q.positions.length>3){const B=q.positions,k=q.indices,U=k.length;for(let J=0;J<U;++J){const X=k[J],j=B[X];j.y<0?(C=b.attributes,m=b.indices,g=S):(C=v.attributes,m=v.indices,g=N),y=$(C,m,g,p,X<3?w+X:-1,j),he(E,D,L,j,s,i,o,c,a,u,d,C,h,l,t,y)}}else f.defined(q)&&(P=q.positions[0],F=q.positions[1],z=q.positions[2]),P.y<0?(C=b.attributes,m=b.indices,g=S):(C=v.attributes,m=v.indices,g=N),y=$(C,m,g,p,w,P),he(E,D,L,P,s,i,o,c,a,u,d,C,h,l,t,y),y=$(C,m,g,p,w+1,F),he(E,D,L,F,s,i,o,c,a,u,d,C,h,l,t,y),y=$(C,m,g,p,w+2,z),he(E,D,L,z,s,i,o,c,a,u,d,C,h,l,t,y)}Pe(e,b,v)}const Xe=De.Plane.fromPointNormal(r.Cartesian3.ZERO,r.Cartesian3.UNIT_Y),In=new r.Cartesian3,Sn=new r.Cartesian3;function se(e,n,t,s,i,c,o){if(!f.defined(o))return;const a=r.Cartesian3.fromArray(s,e*3,ce);r.Cartesian3.equalsEpsilon(a,t,O.CesiumMath.EPSILON10)?c.applyOffset.values[i]=o[e]:c.applyOffset.values[i]=o[n]}function He(e){const n=e.geometry,t=n.attributes,s=t.position.values,i=f.defined(t.applyOffset)?t.applyOffset.values:void 0,c=n.indices,o=ie(n),a=ie(n);let u;const d=c.length,p=[];p.length=s.length/3;const h=[];for(h.length=s.length/3,u=0;u<p.length;++u)p[u]=-1,h[u]=-1;for(u=0;u<d;u+=2){const l=c[u],v=c[u+1],b=r.Cartesian3.fromArray(s,l*3,ce),C=r.Cartesian3.fromArray(s,v*3,Se);let m;Math.abs(b.y)<O.CesiumMath.EPSILON6&&(b.y<0?b.y=-O.CesiumMath.EPSILON6:b.y=O.CesiumMath.EPSILON6),Math.abs(C.y)<O.CesiumMath.EPSILON6&&(C.y<0?C.y=-O.CesiumMath.EPSILON6:C.y=O.CesiumMath.EPSILON6);let g=o.attributes,y=o.indices,w=h,S=a.attributes,N=a.indices,A=p;const E=Ee.IntersectionTests.lineSegmentPlane(b,C,Xe,ge);if(f.defined(E)){const D=r.Cartesian3.multiplyByScalar(r.Cartesian3.UNIT_Y,5*O.CesiumMath.EPSILON9,In);b.y<0&&(r.Cartesian3.negate(D,D),g=a.attributes,y=a.indices,w=p,S=o.attributes,N=o.indices,A=h);const L=r.Cartesian3.add(E,D,Sn);m=$(g,y,w,c,u,b),se(l,v,b,s,m,g,i),m=$(g,y,w,c,-1,L),se(l,v,L,s,m,g,i),r.Cartesian3.negate(D,D),r.Cartesian3.add(E,D,L),m=$(S,N,A,c,-1,L),se(l,v,L,s,m,S,i),m=$(S,N,A,c,u+1,C),se(l,v,C,s,m,S,i)}else{let D,L,P;b.y<0?(D=a.attributes,L=a.indices,P=p):(D=o.attributes,L=o.indices,P=h),m=$(D,L,P,c,u,b),se(l,v,b,s,m,D,i),m=$(D,L,P,c,u+1,C),se(l,v,C,s,m,D,i)}}Pe(e,a,o)}const We=new r.Cartesian2,gn=new r.Cartesian2,$e=new r.Cartesian3,Je=new r.Cartesian3,Ae=new r.Cartesian3,An=new r.Cartesian3,On=new r.Cartesian3,Ln=new r.Cartesian3,Ke=new r.Cartesian4;function Qe(e){const n=e.attributes,t=n.position.values,s=n.prevPosition.values,i=n.nextPosition.values,c=t.length;for(let o=0;o<c;o+=3){const a=r.Cartesian3.unpack(t,o,$e);if(a.x>0)continue;const u=r.Cartesian3.unpack(s,o,Je);(a.y<0&&u.y>0||a.y>0&&u.y<0)&&(o-3>0?(s[o]=t[o-3],s[o+1]=t[o-2],s[o+2]=t[o-1]):r.Cartesian3.pack(a,s,o));const d=r.Cartesian3.unpack(i,o,Ae);(a.y<0&&d.y>0||a.y>0&&d.y<0)&&(o+3<c?(i[o]=t[o+3],i[o+1]=t[o+4],i[o+2]=t[o+5]):r.Cartesian3.pack(a,i,o))}}const En=5*O.CesiumMath.EPSILON9,ve=O.CesiumMath.EPSILON6;function Dn(e){const n=e.geometry,t=n.attributes,s=t.position.values,i=t.prevPosition.values,c=t.nextPosition.values,o=t.expandAndWidth.values,a=f.defined(t.st)?t.st.values:void 0,u=f.defined(t.color)?t.color.values:void 0,d=ie(n),p=ie(n);let h,l,v,b=!1;const C=s.length/3;for(h=0;h<C;h+=4){const m=h,g=h+2,y=r.Cartesian3.fromArray(s,m*3,$e),w=r.Cartesian3.fromArray(s,g*3,Je);if(Math.abs(y.y)<ve)for(y.y=ve*(w.y<0?-1:1),s[h*3+1]=y.y,s[(h+1)*3+1]=y.y,l=m*3;l<m*3+4*3;l+=3)i[l]=s[h*3],i[l+1]=s[h*3+1],i[l+2]=s[h*3+2];if(Math.abs(w.y)<ve)for(w.y=ve*(y.y<0?-1:1),s[(h+2)*3+1]=w.y,s[(h+3)*3+1]=w.y,l=m*3;l<m*3+4*3;l+=3)c[l]=s[(h+2)*3],c[l+1]=s[(h+2)*3+1],c[l+2]=s[(h+2)*3+2];let S=d.attributes,N=d.indices,A=p.attributes,E=p.indices;const D=Ee.IntersectionTests.lineSegmentPlane(y,w,Xe,An);if(f.defined(D)){b=!0;const L=r.Cartesian3.multiplyByScalar(r.Cartesian3.UNIT_Y,En,On);y.y<0&&(r.Cartesian3.negate(L,L),S=p.attributes,N=p.indices,A=d.attributes,E=d.indices);const P=r.Cartesian3.add(D,L,Ln);S.position.values.push(y.x,y.y,y.z,y.x,y.y,y.z),S.position.values.push(P.x,P.y,P.z),S.position.values.push(P.x,P.y,P.z),S.prevPosition.values.push(i[m*3],i[m*3+1],i[m*3+2]),S.prevPosition.values.push(i[m*3+3],i[m*3+4],i[m*3+5]),S.prevPosition.values.push(y.x,y.y,y.z,y.x,y.y,y.z),S.nextPosition.values.push(P.x,P.y,P.z),S.nextPosition.values.push(P.x,P.y,P.z),S.nextPosition.values.push(P.x,P.y,P.z),S.nextPosition.values.push(P.x,P.y,P.z),r.Cartesian3.negate(L,L),r.Cartesian3.add(D,L,P),A.position.values.push(P.x,P.y,P.z),A.position.values.push(P.x,P.y,P.z),A.position.values.push(w.x,w.y,w.z,w.x,w.y,w.z),A.prevPosition.values.push(P.x,P.y,P.z),A.prevPosition.values.push(P.x,P.y,P.z),A.prevPosition.values.push(P.x,P.y,P.z),A.prevPosition.values.push(P.x,P.y,P.z),A.nextPosition.values.push(w.x,w.y,w.z,w.x,w.y,w.z),A.nextPosition.values.push(c[g*3],c[g*3+1],c[g*3+2]),A.nextPosition.values.push(c[g*3+3],c[g*3+4],c[g*3+5]);const F=r.Cartesian2.fromArray(o,m*2,We),z=Math.abs(F.y);S.expandAndWidth.values.push(-1,z,1,z),S.expandAndWidth.values.push(-1,-z,1,-z),A.expandAndWidth.values.push(-1,z,1,z),A.expandAndWidth.values.push(-1,-z,1,-z);let q=r.Cartesian3.magnitudeSquared(r.Cartesian3.subtract(D,y,Ae));if(q/=r.Cartesian3.magnitudeSquared(r.Cartesian3.subtract(w,y,Ae)),f.defined(u)){const B=r.Cartesian4.fromArray(u,m*4,Ke),k=r.Cartesian4.fromArray(u,g*4,Ke),U=O.CesiumMath.lerp(B.x,k.x,q),J=O.CesiumMath.lerp(B.y,k.y,q),X=O.CesiumMath.lerp(B.z,k.z,q),j=O.CesiumMath.lerp(B.w,k.w,q);for(l=m*4;l<m*4+2*4;++l)S.color.values.push(u[l]);for(S.color.values.push(U,J,X,j),S.color.values.push(U,J,X,j),A.color.values.push(U,J,X,j),A.color.values.push(U,J,X,j),l=g*4;l<g*4+2*4;++l)A.color.values.push(u[l])}if(f.defined(a)){const B=r.Cartesian2.fromArray(a,m*2,We),k=r.Cartesian2.fromArray(a,(h+3)*2,gn),U=O.CesiumMath.lerp(B.x,k.x,q);for(l=m*2;l<m*2+2*2;++l)S.st.values.push(a[l]);for(S.st.values.push(U,B.y),S.st.values.push(U,k.y),A.st.values.push(U,B.y),A.st.values.push(U,k.y),l=g*2;l<g*2+2*2;++l)A.st.values.push(a[l])}v=S.position.values.length/3-4,N.push(v,v+2,v+1),N.push(v+1,v+2,v+3),v=A.position.values.length/3-4,E.push(v,v+2,v+1),E.push(v+1,v+2,v+3)}else{let L,P;for(y.y<0?(L=p.attributes,P=p.indices):(L=d.attributes,P=d.indices),L.position.values.push(y.x,y.y,y.z),L.position.values.push(y.x,y.y,y.z),L.position.values.push(w.x,w.y,w.z),L.position.values.push(w.x,w.y,w.z),l=h*3;l<h*3+4*3;++l)L.prevPosition.values.push(i[l]),L.nextPosition.values.push(c[l]);for(l=h*2;l<h*2+4*2;++l)L.expandAndWidth.values.push(o[l]),f.defined(a)&&L.st.values.push(a[l]);if(f.defined(u))for(l=h*4;l<h*4+4*4;++l)L.color.values.push(u[l]);v=L.position.values.length/3-4,P.push(v,v+2,v+1),P.push(v+1,v+2,v+3)}}b&&(Qe(p),Qe(d)),Pe(e,p,d)}_.splitLongitude=function(e){if(!f.defined(e))throw new T.DeveloperError("instance is required.");const n=e.geometry,t=n.boundingSphere;if(f.defined(t)&&(t.center.x-t.radius>0||Q.BoundingSphere.intersectPlane(t,De.Plane.ORIGIN_ZX_PLANE)!==Q.Intersect.INTERSECTING))return e;if(n.geometryType!==I.GeometryType.NONE)switch(n.geometryType){case I.GeometryType.POLYLINES:Dn(e);break;case I.GeometryType.TRIANGLES:Ze(e);break;case I.GeometryType.LINES:He(e);break}else vn(n),n.primitiveType===I.PrimitiveType.TRIANGLES?Ze(e):n.primitiveType===I.PrimitiveType.LINES&&He(e);return e},xe.GeometryPipeline=_});
