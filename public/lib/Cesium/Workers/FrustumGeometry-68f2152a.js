/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.96.6
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */

define(["exports","./Transforms-66eda18c","./Matrix2-4706dd70","./RuntimeError-a977b8e0","./ComponentDatatype-438cad2a","./defaultValue-028a8a27","./GeometryAttribute-2cdece80","./GeometryAttributes-98e858da","./Plane-f4cd36d8","./VertexFormat-3518f543"],function(R,z,t,p,b,c,L,u,H,T){"use strict";function k(e){this.planes=c.defaultValue(e,[])}const Y=[new t.Cartesian3,new t.Cartesian3,new t.Cartesian3];t.Cartesian3.clone(t.Cartesian3.UNIT_X,Y[0]),t.Cartesian3.clone(t.Cartesian3.UNIT_Y,Y[1]),t.Cartesian3.clone(t.Cartesian3.UNIT_Z,Y[2]);const j=new t.Cartesian3,ee=new t.Cartesian3,Z=new H.Plane(new t.Cartesian3(1,0,0),0);k.fromBoundingSphere=function(e,n){if(!c.defined(e))throw new p.DeveloperError("boundingSphere is required.");c.defined(n)||(n=new k);const i=Y.length,s=n.planes;s.length=2*i;const f=e.center,w=e.radius;let d=0;for(let g=0;g<i;++g){const o=Y[g];let r=s[d],_=s[d+1];c.defined(r)||(r=s[d]=new t.Cartesian4),c.defined(_)||(_=s[d+1]=new t.Cartesian4),t.Cartesian3.multiplyByScalar(o,-w,j),t.Cartesian3.add(f,j,j),r.x=o.x,r.y=o.y,r.z=o.z,r.w=-t.Cartesian3.dot(o,j),t.Cartesian3.multiplyByScalar(o,w,j),t.Cartesian3.add(f,j,j),_.x=-o.x,_.y=-o.y,_.z=-o.z,_.w=-t.Cartesian3.dot(t.Cartesian3.negate(o,ee),j),d+=2}return n},k.prototype.computeVisibility=function(e){if(!c.defined(e))throw new p.DeveloperError("boundingVolume is required.");const n=this.planes;let i=!1;for(let s=0,f=n.length;s<f;++s){const w=e.intersectPlane(H.Plane.fromCartesian4(n[s],Z));if(w===z.Intersect.OUTSIDE)return z.Intersect.OUTSIDE;w===z.Intersect.INTERSECTING&&(i=!0)}return i?z.Intersect.INTERSECTING:z.Intersect.INSIDE},k.prototype.computeVisibilityWithPlaneMask=function(e,n){if(!c.defined(e))throw new p.DeveloperError("boundingVolume is required.");if(!c.defined(n))throw new p.DeveloperError("parentPlaneMask is required.");if(n===k.MASK_OUTSIDE||n===k.MASK_INSIDE)return n;let i=k.MASK_INSIDE;const s=this.planes;for(let f=0,w=s.length;f<w;++f){const d=f<31?1<<f:0;if(f<31&&(n&d)===0)continue;const g=e.intersectPlane(H.Plane.fromCartesian4(s[f],Z));if(g===z.Intersect.OUTSIDE)return k.MASK_OUTSIDE;g===z.Intersect.INTERSECTING&&(i|=d)}return i},k.MASK_OUTSIDE=4294967295,k.MASK_INSIDE=0,k.MASK_INDETERMINATE=2147483647;function l(e){e=c.defaultValue(e,c.defaultValue.EMPTY_OBJECT),this.left=e.left,this._left=void 0,this.right=e.right,this._right=void 0,this.top=e.top,this._top=void 0,this.bottom=e.bottom,this._bottom=void 0,this.near=c.defaultValue(e.near,1),this._near=this.near,this.far=c.defaultValue(e.far,5e8),this._far=this.far,this._cullingVolume=new k,this._orthographicMatrix=new t.Matrix4}function m(e){if(!c.defined(e.right)||!c.defined(e.left)||!c.defined(e.top)||!c.defined(e.bottom)||!c.defined(e.near)||!c.defined(e.far))throw new p.DeveloperError("right, left, top, bottom, near, or far parameters are not set.");if(e.top!==e._top||e.bottom!==e._bottom||e.left!==e._left||e.right!==e._right||e.near!==e._near||e.far!==e._far){if(e.left>e.right)throw new p.DeveloperError("right must be greater than left.");if(e.bottom>e.top)throw new p.DeveloperError("top must be greater than bottom.");e.near<=0||e.near>e.far,e._left=e.left,e._right=e.right,e._top=e.top,e._bottom=e.bottom,e._near=e.near,e._far=e.far,e._orthographicMatrix=t.Matrix4.computeOrthographicOffCenter(e.left,e.right,e.bottom,e.top,e.near,e.far,e._orthographicMatrix)}}Object.defineProperties(l.prototype,{projectionMatrix:{get:function(){return m(this),this._orthographicMatrix}}});const ne=new t.Cartesian3,te=new t.Cartesian3,ie=new t.Cartesian3,$=new t.Cartesian3;l.prototype.computeCullingVolume=function(e,n,i){if(!c.defined(e))throw new p.DeveloperError("position is required.");if(!c.defined(n))throw new p.DeveloperError("direction is required.");if(!c.defined(i))throw new p.DeveloperError("up is required.");const s=this._cullingVolume.planes,f=this.top,w=this.bottom,d=this.right,g=this.left,o=this.near,r=this.far,_=t.Cartesian3.cross(n,i,ne);t.Cartesian3.normalize(_,_);const v=te;t.Cartesian3.multiplyByScalar(n,o,v),t.Cartesian3.add(e,v,v);const C=ie;t.Cartesian3.multiplyByScalar(_,g,C),t.Cartesian3.add(v,C,C);let a=s[0];return c.defined(a)||(a=s[0]=new t.Cartesian4),a.x=_.x,a.y=_.y,a.z=_.z,a.w=-t.Cartesian3.dot(_,C),t.Cartesian3.multiplyByScalar(_,d,C),t.Cartesian3.add(v,C,C),a=s[1],c.defined(a)||(a=s[1]=new t.Cartesian4),a.x=-_.x,a.y=-_.y,a.z=-_.z,a.w=-t.Cartesian3.dot(t.Cartesian3.negate(_,$),C),t.Cartesian3.multiplyByScalar(i,w,C),t.Cartesian3.add(v,C,C),a=s[2],c.defined(a)||(a=s[2]=new t.Cartesian4),a.x=i.x,a.y=i.y,a.z=i.z,a.w=-t.Cartesian3.dot(i,C),t.Cartesian3.multiplyByScalar(i,f,C),t.Cartesian3.add(v,C,C),a=s[3],c.defined(a)||(a=s[3]=new t.Cartesian4),a.x=-i.x,a.y=-i.y,a.z=-i.z,a.w=-t.Cartesian3.dot(t.Cartesian3.negate(i,$),C),a=s[4],c.defined(a)||(a=s[4]=new t.Cartesian4),a.x=n.x,a.y=n.y,a.z=n.z,a.w=-t.Cartesian3.dot(n,v),t.Cartesian3.multiplyByScalar(n,r,C),t.Cartesian3.add(e,C,C),a=s[5],c.defined(a)||(a=s[5]=new t.Cartesian4),a.x=-n.x,a.y=-n.y,a.z=-n.z,a.w=-t.Cartesian3.dot(t.Cartesian3.negate(n,$),C),this._cullingVolume},l.prototype.getPixelDimensions=function(e,n,i,s,f){if(m(this),!c.defined(e)||!c.defined(n))throw new p.DeveloperError("Both drawingBufferWidth and drawingBufferHeight are required.");if(e<=0)throw new p.DeveloperError("drawingBufferWidth must be greater than zero.");if(n<=0)throw new p.DeveloperError("drawingBufferHeight must be greater than zero.");if(!c.defined(i))throw new p.DeveloperError("distance is required.");if(!c.defined(s))throw new p.DeveloperError("pixelRatio is required.");if(s<=0)throw new p.DeveloperError("pixelRatio must be greater than zero.");if(!c.defined(f))throw new p.DeveloperError("A result object is required.");const w=this.right-this.left,d=this.top-this.bottom,g=s*w/e,o=s*d/n;return f.x=g,f.y=o,f},l.prototype.clone=function(e){return c.defined(e)||(e=new l),e.left=this.left,e.right=this.right,e.top=this.top,e.bottom=this.bottom,e.near=this.near,e.far=this.far,e._left=void 0,e._right=void 0,e._top=void 0,e._bottom=void 0,e._near=void 0,e._far=void 0,e},l.prototype.equals=function(e){return c.defined(e)&&e instanceof l&&this.right===e.right&&this.left===e.left&&this.top===e.top&&this.bottom===e.bottom&&this.near===e.near&&this.far===e.far},l.prototype.equalsEpsilon=function(e,n,i){return e===this||c.defined(e)&&e instanceof l&&b.CesiumMath.equalsEpsilon(this.right,e.right,n,i)&&b.CesiumMath.equalsEpsilon(this.left,e.left,n,i)&&b.CesiumMath.equalsEpsilon(this.top,e.top,n,i)&&b.CesiumMath.equalsEpsilon(this.bottom,e.bottom,n,i)&&b.CesiumMath.equalsEpsilon(this.near,e.near,n,i)&&b.CesiumMath.equalsEpsilon(this.far,e.far,n,i)};function P(e){e=c.defaultValue(e,c.defaultValue.EMPTY_OBJECT),this._offCenterFrustum=new l,this.width=e.width,this._width=void 0,this.aspectRatio=e.aspectRatio,this._aspectRatio=void 0,this.near=c.defaultValue(e.near,1),this._near=this.near,this.far=c.defaultValue(e.far,5e8),this._far=this.far}P.packedLength=4,P.pack=function(e,n,i){return p.Check.typeOf.object("value",e),p.Check.defined("array",n),i=c.defaultValue(i,0),n[i++]=e.width,n[i++]=e.aspectRatio,n[i++]=e.near,n[i]=e.far,n},P.unpack=function(e,n,i){return p.Check.defined("array",e),n=c.defaultValue(n,0),c.defined(i)||(i=new P),i.width=e[n++],i.aspectRatio=e[n++],i.near=e[n++],i.far=e[n],i};function E(e){if(!c.defined(e.width)||!c.defined(e.aspectRatio)||!c.defined(e.near)||!c.defined(e.far))throw new p.DeveloperError("width, aspectRatio, near, or far parameters are not set.");const n=e._offCenterFrustum;if(e.width!==e._width||e.aspectRatio!==e._aspectRatio||e.near!==e._near||e.far!==e._far){if(e.aspectRatio<0)throw new p.DeveloperError("aspectRatio must be positive.");if(e.near<0||e.near>e.far)throw new p.DeveloperError("near must be greater than zero and less than far.");e._aspectRatio=e.aspectRatio,e._width=e.width,e._near=e.near,e._far=e.far;const i=1/e.aspectRatio;n.right=e.width*.5,n.left=-n.right,n.top=i*n.right,n.bottom=-n.top,n.near=e.near,n.far=e.far}}Object.defineProperties(P.prototype,{projectionMatrix:{get:function(){return E(this),this._offCenterFrustum.projectionMatrix}}}),P.prototype.computeCullingVolume=function(e,n,i){return E(this),this._offCenterFrustum.computeCullingVolume(e,n,i)},P.prototype.getPixelDimensions=function(e,n,i,s,f){return E(this),this._offCenterFrustum.getPixelDimensions(e,n,i,s,f)},P.prototype.clone=function(e){return c.defined(e)||(e=new P),e.aspectRatio=this.aspectRatio,e.width=this.width,e.near=this.near,e.far=this.far,e._aspectRatio=void 0,e._width=void 0,e._near=void 0,e._far=void 0,this._offCenterFrustum.clone(e._offCenterFrustum),e},P.prototype.equals=function(e){return!c.defined(e)||!(e instanceof P)?!1:(E(this),E(e),this.width===e.width&&this.aspectRatio===e.aspectRatio&&this._offCenterFrustum.equals(e._offCenterFrustum))},P.prototype.equalsEpsilon=function(e,n,i){return!c.defined(e)||!(e instanceof P)?!1:(E(this),E(e),b.CesiumMath.equalsEpsilon(this.width,e.width,n,i)&&b.CesiumMath.equalsEpsilon(this.aspectRatio,e.aspectRatio,n,i)&&this._offCenterFrustum.equalsEpsilon(e._offCenterFrustum,n,i))};function q(e){e=c.defaultValue(e,c.defaultValue.EMPTY_OBJECT),this.left=e.left,this._left=void 0,this.right=e.right,this._right=void 0,this.top=e.top,this._top=void 0,this.bottom=e.bottom,this._bottom=void 0,this.near=c.defaultValue(e.near,1),this._near=this.near,this.far=c.defaultValue(e.far,5e8),this._far=this.far,this._cullingVolume=new k,this._perspectiveMatrix=new t.Matrix4,this._infinitePerspective=new t.Matrix4}function J(e){if(!c.defined(e.right)||!c.defined(e.left)||!c.defined(e.top)||!c.defined(e.bottom)||!c.defined(e.near)||!c.defined(e.far))throw new p.DeveloperError("right, left, top, bottom, near, or far parameters are not set.");const n=e.top,i=e.bottom,s=e.right,f=e.left,w=e.near,d=e.far;if(n!==e._top||i!==e._bottom||f!==e._left||s!==e._right||w!==e._near||d!==e._far){if(e.near<=0||e.near>e.far)throw new p.DeveloperError("near must be greater than zero and less than far.");e._left=f,e._right=s,e._top=n,e._bottom=i,e._near=w,e._far=d,e._perspectiveMatrix=t.Matrix4.computePerspectiveOffCenter(f,s,i,n,w,d,e._perspectiveMatrix),e._infinitePerspective=t.Matrix4.computeInfinitePerspectiveOffCenter(f,s,i,n,w,e._infinitePerspective)}}Object.defineProperties(q.prototype,{projectionMatrix:{get:function(){return J(this),this._perspectiveMatrix}},infiniteProjectionMatrix:{get:function(){return J(this),this._infinitePerspective}}});const oe=new t.Cartesian3,ae=new t.Cartesian3,ce=new t.Cartesian3,se=new t.Cartesian3;q.prototype.computeCullingVolume=function(e,n,i){if(!c.defined(e))throw new p.DeveloperError("position is required.");if(!c.defined(n))throw new p.DeveloperError("direction is required.");if(!c.defined(i))throw new p.DeveloperError("up is required.");const s=this._cullingVolume.planes,f=this.top,w=this.bottom,d=this.right,g=this.left,o=this.near,r=this.far,_=t.Cartesian3.cross(n,i,oe),v=ae;t.Cartesian3.multiplyByScalar(n,o,v),t.Cartesian3.add(e,v,v);const C=ce;t.Cartesian3.multiplyByScalar(n,r,C),t.Cartesian3.add(e,C,C);const a=se;t.Cartesian3.multiplyByScalar(_,g,a),t.Cartesian3.add(v,a,a),t.Cartesian3.subtract(a,e,a),t.Cartesian3.normalize(a,a),t.Cartesian3.cross(a,i,a),t.Cartesian3.normalize(a,a);let h=s[0];return c.defined(h)||(h=s[0]=new t.Cartesian4),h.x=a.x,h.y=a.y,h.z=a.z,h.w=-t.Cartesian3.dot(a,e),t.Cartesian3.multiplyByScalar(_,d,a),t.Cartesian3.add(v,a,a),t.Cartesian3.subtract(a,e,a),t.Cartesian3.cross(i,a,a),t.Cartesian3.normalize(a,a),h=s[1],c.defined(h)||(h=s[1]=new t.Cartesian4),h.x=a.x,h.y=a.y,h.z=a.z,h.w=-t.Cartesian3.dot(a,e),t.Cartesian3.multiplyByScalar(i,w,a),t.Cartesian3.add(v,a,a),t.Cartesian3.subtract(a,e,a),t.Cartesian3.cross(_,a,a),t.Cartesian3.normalize(a,a),h=s[2],c.defined(h)||(h=s[2]=new t.Cartesian4),h.x=a.x,h.y=a.y,h.z=a.z,h.w=-t.Cartesian3.dot(a,e),t.Cartesian3.multiplyByScalar(i,f,a),t.Cartesian3.add(v,a,a),t.Cartesian3.subtract(a,e,a),t.Cartesian3.cross(a,_,a),t.Cartesian3.normalize(a,a),h=s[3],c.defined(h)||(h=s[3]=new t.Cartesian4),h.x=a.x,h.y=a.y,h.z=a.z,h.w=-t.Cartesian3.dot(a,e),h=s[4],c.defined(h)||(h=s[4]=new t.Cartesian4),h.x=n.x,h.y=n.y,h.z=n.z,h.w=-t.Cartesian3.dot(n,v),t.Cartesian3.negate(n,a),h=s[5],c.defined(h)||(h=s[5]=new t.Cartesian4),h.x=a.x,h.y=a.y,h.z=a.z,h.w=-t.Cartesian3.dot(a,C),this._cullingVolume},q.prototype.getPixelDimensions=function(e,n,i,s,f){if(J(this),!c.defined(e)||!c.defined(n))throw new p.DeveloperError("Both drawingBufferWidth and drawingBufferHeight are required.");if(e<=0)throw new p.DeveloperError("drawingBufferWidth must be greater than zero.");if(n<=0)throw new p.DeveloperError("drawingBufferHeight must be greater than zero.");if(!c.defined(i))throw new p.DeveloperError("distance is required.");if(!c.defined(s))throw new p.DeveloperError("pixelRatio is required");if(s<=0)throw new p.DeveloperError("pixelRatio must be greater than zero.");if(!c.defined(f))throw new p.DeveloperError("A result object is required.");const w=1/this.near;let d=this.top*w;const g=2*s*i*d/n;d=this.right*w;const o=2*s*i*d/e;return f.x=o,f.y=g,f},q.prototype.clone=function(e){return c.defined(e)||(e=new q),e.right=this.right,e.left=this.left,e.top=this.top,e.bottom=this.bottom,e.near=this.near,e.far=this.far,e._left=void 0,e._right=void 0,e._top=void 0,e._bottom=void 0,e._near=void 0,e._far=void 0,e},q.prototype.equals=function(e){return c.defined(e)&&e instanceof q&&this.right===e.right&&this.left===e.left&&this.top===e.top&&this.bottom===e.bottom&&this.near===e.near&&this.far===e.far},q.prototype.equalsEpsilon=function(e,n,i){return e===this||c.defined(e)&&e instanceof q&&b.CesiumMath.equalsEpsilon(this.right,e.right,n,i)&&b.CesiumMath.equalsEpsilon(this.left,e.left,n,i)&&b.CesiumMath.equalsEpsilon(this.top,e.top,n,i)&&b.CesiumMath.equalsEpsilon(this.bottom,e.bottom,n,i)&&b.CesiumMath.equalsEpsilon(this.near,e.near,n,i)&&b.CesiumMath.equalsEpsilon(this.far,e.far,n,i)};function O(e){e=c.defaultValue(e,c.defaultValue.EMPTY_OBJECT),this._offCenterFrustum=new q,this.fov=e.fov,this._fov=void 0,this._fovy=void 0,this._sseDenominator=void 0,this.aspectRatio=e.aspectRatio,this._aspectRatio=void 0,this.near=c.defaultValue(e.near,1),this._near=this.near,this.far=c.defaultValue(e.far,5e8),this._far=this.far,this.xOffset=c.defaultValue(e.xOffset,0),this._xOffset=this.xOffset,this.yOffset=c.defaultValue(e.yOffset,0),this._yOffset=this.yOffset}O.packedLength=6,O.pack=function(e,n,i){return p.Check.typeOf.object("value",e),p.Check.defined("array",n),i=c.defaultValue(i,0),n[i++]=e.fov,n[i++]=e.aspectRatio,n[i++]=e.near,n[i++]=e.far,n[i++]=e.xOffset,n[i]=e.yOffset,n},O.unpack=function(e,n,i){return p.Check.defined("array",e),n=c.defaultValue(n,0),c.defined(i)||(i=new O),i.fov=e[n++],i.aspectRatio=e[n++],i.near=e[n++],i.far=e[n++],i.xOffset=e[n++],i.yOffset=e[n],i};function S(e){if(!c.defined(e.fov)||!c.defined(e.aspectRatio)||!c.defined(e.near)||!c.defined(e.far))throw new p.DeveloperError("fov, aspectRatio, near, or far parameters are not set.");const n=e._offCenterFrustum;if(e.fov!==e._fov||e.aspectRatio!==e._aspectRatio||e.near!==e._near||e.far!==e._far||e.xOffset!==e._xOffset||e.yOffset!==e._yOffset){if(e.fov<0||e.fov>=Math.PI)throw new p.DeveloperError("fov must be in the range [0, PI).");if(e.aspectRatio<0)throw new p.DeveloperError("aspectRatio must be positive.");if(e.near<0||e.near>e.far)throw new p.DeveloperError("near must be greater than zero and less than far.");e._aspectRatio=e.aspectRatio,e._fov=e.fov,e._fovy=e.aspectRatio<=1?e.fov:Math.atan(Math.tan(e.fov*.5)/e.aspectRatio)*2,e._near=e.near,e._far=e.far,e._sseDenominator=2*Math.tan(.5*e._fovy),e._xOffset=e.xOffset,e._yOffset=e.yOffset,n.top=e.near*Math.tan(.5*e._fovy),n.bottom=-n.top,n.right=e.aspectRatio*n.top,n.left=-n.right,n.near=e.near,n.far=e.far,n.right+=e.xOffset,n.left+=e.xOffset,n.top+=e.yOffset,n.bottom+=e.yOffset}}Object.defineProperties(O.prototype,{projectionMatrix:{get:function(){return S(this),this._offCenterFrustum.projectionMatrix}},infiniteProjectionMatrix:{get:function(){return S(this),this._offCenterFrustum.infiniteProjectionMatrix}},fovy:{get:function(){return S(this),this._fovy}},sseDenominator:{get:function(){return S(this),this._sseDenominator}}}),O.prototype.computeCullingVolume=function(e,n,i){return S(this),this._offCenterFrustum.computeCullingVolume(e,n,i)},O.prototype.getPixelDimensions=function(e,n,i,s,f){return S(this),this._offCenterFrustum.getPixelDimensions(e,n,i,s,f)},O.prototype.clone=function(e){return c.defined(e)||(e=new O),e.aspectRatio=this.aspectRatio,e.fov=this.fov,e.near=this.near,e.far=this.far,e._aspectRatio=void 0,e._fov=void 0,e._near=void 0,e._far=void 0,this._offCenterFrustum.clone(e._offCenterFrustum),e},O.prototype.equals=function(e){return!c.defined(e)||!(e instanceof O)?!1:(S(this),S(e),this.fov===e.fov&&this.aspectRatio===e.aspectRatio&&this._offCenterFrustum.equals(e._offCenterFrustum))},O.prototype.equalsEpsilon=function(e,n,i){return!c.defined(e)||!(e instanceof O)?!1:(S(this),S(e),b.CesiumMath.equalsEpsilon(this.fov,e.fov,n,i)&&b.CesiumMath.equalsEpsilon(this.aspectRatio,e.aspectRatio,n,i)&&this._offCenterFrustum.equalsEpsilon(e._offCenterFrustum,n,i))};const K=0,re=1;function U(e){p.Check.typeOf.object("options",e),p.Check.typeOf.object("options.frustum",e.frustum),p.Check.typeOf.object("options.origin",e.origin),p.Check.typeOf.object("options.orientation",e.orientation);const n=e.frustum,i=e.orientation,s=e.origin,f=c.defaultValue(e.vertexFormat,T.VertexFormat.DEFAULT),w=c.defaultValue(e._drawNearPlane,!0);let d,g;n instanceof O?(d=K,g=O.packedLength):n instanceof P&&(d=re,g=P.packedLength),this._frustumType=d,this._frustum=n.clone(),this._origin=t.Cartesian3.clone(s),this._orientation=z.Quaternion.clone(i),this._drawNearPlane=w,this._vertexFormat=f,this._workerName="createFrustumGeometry",this.packedLength=2+g+t.Cartesian3.packedLength+z.Quaternion.packedLength+T.VertexFormat.packedLength}U.pack=function(e,n,i){p.Check.typeOf.object("value",e),p.Check.defined("array",n),i=c.defaultValue(i,0);const s=e._frustumType,f=e._frustum;return n[i++]=s,s===K?(O.pack(f,n,i),i+=O.packedLength):(P.pack(f,n,i),i+=P.packedLength),t.Cartesian3.pack(e._origin,n,i),i+=t.Cartesian3.packedLength,z.Quaternion.pack(e._orientation,n,i),i+=z.Quaternion.packedLength,T.VertexFormat.pack(e._vertexFormat,n,i),i+=T.VertexFormat.packedLength,n[i]=e._drawNearPlane?1:0,n};const he=new O,fe=new P,pe=new z.Quaternion,de=new t.Cartesian3,Ce=new T.VertexFormat;U.unpack=function(e,n,i){p.Check.defined("array",e),n=c.defaultValue(n,0);const s=e[n++];let f;s===K?(f=O.unpack(e,n,he),n+=O.packedLength):(f=P.unpack(e,n,fe),n+=P.packedLength);const w=t.Cartesian3.unpack(e,n,de);n+=t.Cartesian3.packedLength;const d=z.Quaternion.unpack(e,n,pe);n+=z.Quaternion.packedLength;const g=T.VertexFormat.unpack(e,n,Ce);n+=T.VertexFormat.packedLength;const o=e[n]===1;if(!c.defined(i))return new U({frustum:f,origin:w,orientation:d,vertexFormat:g,_drawNearPlane:o});const r=s===i._frustumType?i._frustum:void 0;return i._frustum=f.clone(r),i._frustumType=s,i._origin=t.Cartesian3.clone(w,i._origin),i._orientation=z.Quaternion.clone(d,i._orientation),i._vertexFormat=T.VertexFormat.clone(g,i._vertexFormat),i._drawNearPlane=o,i};function Q(e,n,i,s,f,w,d,g){const o=e/3*2;for(let r=0;r<4;++r)c.defined(n)&&(n[e]=w.x,n[e+1]=w.y,n[e+2]=w.z),c.defined(i)&&(i[e]=d.x,i[e+1]=d.y,i[e+2]=d.z),c.defined(s)&&(s[e]=g.x,s[e+1]=g.y,s[e+2]=g.z),e+=3;f[o]=0,f[o+1]=0,f[o+2]=1,f[o+3]=0,f[o+4]=1,f[o+5]=1,f[o+6]=0,f[o+7]=1}const we=new t.Matrix3,_e=new t.Matrix4,W=new t.Matrix4,I=new t.Cartesian3,V=new t.Cartesian3,M=new t.Cartesian3,ge=new t.Cartesian3,ye=new t.Cartesian3,ve=new t.Cartesian3,B=new Array(3),G=new Array(4);G[0]=new t.Cartesian4(-1,-1,1,1),G[1]=new t.Cartesian4(1,-1,1,1),G[2]=new t.Cartesian4(1,1,1,1),G[3]=new t.Cartesian4(-1,1,1,1);const x=new Array(4);for(let e=0;e<4;++e)x[e]=new t.Cartesian4;U._computeNearFarPlanes=function(e,n,i,s,f,w,d,g){const o=t.Matrix3.fromQuaternion(n,we);let r=c.defaultValue(w,I),_=c.defaultValue(d,V),v=c.defaultValue(g,M);r=t.Matrix3.getColumn(o,0,r),_=t.Matrix3.getColumn(o,1,_),v=t.Matrix3.getColumn(o,2,v),t.Cartesian3.normalize(r,r),t.Cartesian3.normalize(_,_),t.Cartesian3.normalize(v,v),t.Cartesian3.negate(r,r);const C=t.Matrix4.computeView(e,v,_,r,_e);let a,h;if(i===K){const F=s.projectionMatrix,D=t.Matrix4.multiply(F,C,W);h=t.Matrix4.inverse(D,W)}else a=t.Matrix4.inverseTransformation(C,W);c.defined(h)?(B[0]=s.near,B[1]=s.far):(B[0]=0,B[1]=s.near,B[2]=s.far);for(let F=0;F<2;++F)for(let D=0;D<4;++D){let y=t.Cartesian4.clone(G[D],x[D]);if(c.defined(h)){y=t.Matrix4.multiplyByVector(h,y,y);const N=1/y.w;t.Cartesian3.multiplyByScalar(y,N,y),t.Cartesian3.subtract(y,e,y),t.Cartesian3.normalize(y,y);const A=t.Cartesian3.dot(v,y);t.Cartesian3.multiplyByScalar(y,B[F]/A,y),t.Cartesian3.add(y,e,y)}else{c.defined(s._offCenterFrustum)&&(s=s._offCenterFrustum);const N=B[F],A=B[F+1];y.x=(y.x*(s.right-s.left)+s.left+s.right)*.5,y.y=(y.y*(s.top-s.bottom)+s.bottom+s.top)*.5,y.z=(y.z*(N-A)-N-A)*.5,y.w=1,t.Matrix4.multiplyByVector(a,y,y)}f[12*F+D*3]=y.x,f[12*F+D*3+1]=y.y,f[12*F+D*3+2]=y.z}},U.createGeometry=function(e){const n=e._frustumType,i=e._frustum,s=e._origin,f=e._orientation,w=e._drawNearPlane,d=e._vertexFormat,g=w?6:5;let o=new Float64Array(3*4*6);U._computeNearFarPlanes(s,f,n,i,o);let r=3*4*2;o[r]=o[3*4],o[r+1]=o[3*4+1],o[r+2]=o[3*4+2],o[r+3]=o[0],o[r+4]=o[1],o[r+5]=o[2],o[r+6]=o[3*3],o[r+7]=o[3*3+1],o[r+8]=o[3*3+2],o[r+9]=o[3*7],o[r+10]=o[3*7+1],o[r+11]=o[3*7+2],r+=3*4,o[r]=o[3*5],o[r+1]=o[3*5+1],o[r+2]=o[3*5+2],o[r+3]=o[3],o[r+4]=o[3+1],o[r+5]=o[3+2],o[r+6]=o[0],o[r+7]=o[1],o[r+8]=o[2],o[r+9]=o[3*4],o[r+10]=o[3*4+1],o[r+11]=o[3*4+2],r+=3*4,o[r]=o[3],o[r+1]=o[3+1],o[r+2]=o[3+2],o[r+3]=o[3*5],o[r+4]=o[3*5+1],o[r+5]=o[3*5+2],o[r+6]=o[3*6],o[r+7]=o[3*6+1],o[r+8]=o[3*6+2],o[r+9]=o[3*2],o[r+10]=o[3*2+1],o[r+11]=o[3*2+2],r+=3*4,o[r]=o[3*2],o[r+1]=o[3*2+1],o[r+2]=o[3*2+2],o[r+3]=o[3*6],o[r+4]=o[3*6+1],o[r+5]=o[3*6+2],o[r+6]=o[3*7],o[r+7]=o[3*7+1],o[r+8]=o[3*7+2],o[r+9]=o[3*3],o[r+10]=o[3*3+1],o[r+11]=o[3*3+2],w||(o=o.subarray(3*4));const _=new u.GeometryAttributes({position:new L.GeometryAttribute({componentDatatype:b.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:o})});if(c.defined(d.normal)||c.defined(d.tangent)||c.defined(d.bitangent)||c.defined(d.st)){const C=c.defined(d.normal)?new Float32Array(12*g):void 0,a=c.defined(d.tangent)?new Float32Array(3*4*g):void 0,h=c.defined(d.bitangent)?new Float32Array(3*4*g):void 0,F=c.defined(d.st)?new Float32Array(2*4*g):void 0,D=I,y=V,N=M,A=t.Cartesian3.negate(D,ge),be=t.Cartesian3.negate(y,ye),X=t.Cartesian3.negate(N,ve);r=0,w&&(Q(r,C,a,h,F,X,D,y),r+=3*4),Q(r,C,a,h,F,N,A,y),r+=3*4,Q(r,C,a,h,F,A,X,y),r+=3*4,Q(r,C,a,h,F,be,X,A),r+=3*4,Q(r,C,a,h,F,D,N,y),r+=3*4,Q(r,C,a,h,F,y,N,A),c.defined(C)&&(_.normal=new L.GeometryAttribute({componentDatatype:b.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:C})),c.defined(a)&&(_.tangent=new L.GeometryAttribute({componentDatatype:b.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:a})),c.defined(h)&&(_.bitangent=new L.GeometryAttribute({componentDatatype:b.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:h})),c.defined(F)&&(_.st=new L.GeometryAttribute({componentDatatype:b.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:F}))}const v=new Uint16Array(6*g);for(let C=0;C<g;++C){const a=C*6,h=C*4;v[a]=h,v[a+1]=h+1,v[a+2]=h+2,v[a+3]=h,v[a+4]=h+2,v[a+5]=h+3}return new L.Geometry({attributes:_,indices:v,primitiveType:L.PrimitiveType.TRIANGLES,boundingSphere:z.BoundingSphere.fromVertices(o)})},R.FrustumGeometry=U,R.OrthographicFrustum=P,R.PerspectiveFrustum=O});
