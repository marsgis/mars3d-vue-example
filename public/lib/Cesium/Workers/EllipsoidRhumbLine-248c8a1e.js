/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.96.6
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */

define(["exports","./Matrix2-4706dd70","./RuntimeError-a977b8e0","./defaultValue-028a8a27","./ComponentDatatype-438cad2a"],function(w,r,P,l,e){"use strict";function E(t,s,h){if(t===0)return s*h;const i=t*t,n=i*i,a=n*i,u=a*i,d=u*i,c=d*i,o=h,M=Math.sin(2*o),g=Math.sin(4*o),f=Math.sin(6*o),_=Math.sin(8*o),S=Math.sin(10*o),T=Math.sin(12*o);return s*((1-i/4-3*n/64-5*a/256-175*u/16384-441*d/65536-4851*c/1048576)*o-(3*i/8+3*n/32+45*a/1024+105*u/4096+2205*d/131072+6237*c/524288)*M+(15*n/256+45*a/1024+525*u/16384+1575*d/65536+155925*c/8388608)*g-(35*a/3072+175*u/12288+3675*d/262144+13475*c/1048576)*f+(315*u/131072+2205*d/524288+43659*c/8388608)*_-(693*d/1310720+6237*c/5242880)*S+1001*c/8388608*T)}function v(t,s,h){const i=t/h;if(s===0)return i;const n=i*i,a=n*i,u=a*i,d=s,c=d*d,o=c*c,M=o*c,g=M*c,f=g*c,_=f*c,S=Math.sin(2*i),T=Math.cos(2*i),N=Math.sin(4*i),U=Math.cos(4*i),V=Math.sin(6*i),H=Math.cos(6*i),z=Math.sin(8*i),G=Math.cos(8*i),A=Math.sin(10*i),B=Math.cos(10*i),F=Math.sin(12*i);return i+i*c/4+7*i*o/64+15*i*M/256+579*i*g/16384+1515*i*f/65536+16837*i*_/1048576+(3*i*o/16+45*i*M/256-i*(32*n-561)*g/4096-i*(232*n-1677)*f/16384+i*(399985-90560*n+512*u)*_/5242880)*T+(21*i*M/256+483*i*g/4096-i*(224*n-1969)*f/16384-i*(33152*n-112599)*_/1048576)*U+(151*i*g/4096+4681*i*f/65536+1479*i*_/16384-453*a*_/32768)*H+(1097*i*f/65536+42783*i*_/1048576)*G+8011*i*_/1048576*B+(3*c/8+3*o/16+213*M/2048-3*n*M/64+255*g/4096-33*n*g/512+20861*f/524288-33*n*f/512+u*f/1024+28273*_/1048576-471*n*_/8192+9*u*_/4096)*S+(21*o/256+21*M/256+533*g/8192-21*n*g/512+197*f/4096-315*n*f/4096+584039*_/16777216-12517*n*_/131072+7*u*_/2048)*N+(151*M/6144+151*g/4096+5019*f/131072-453*n*f/16384+26965*_/786432-8607*n*_/131072)*V+(1097*g/131072+1097*f/65536+225797*_/10485760-1097*n*_/65536)*z+(8011*f/2621440+8011*_/1048576)*A+293393*_/251658240*F}function C(t,s){if(t===0)return Math.log(Math.tan(.5*(e.CesiumMath.PI_OVER_TWO+s)));const h=t*Math.sin(s);return Math.log(Math.tan(.5*(e.CesiumMath.PI_OVER_TWO+s)))-t/2*Math.log((1+h)/(1-h))}function W(t,s,h,i,n){const a=C(t._ellipticity,h),u=C(t._ellipticity,n);return Math.atan2(e.CesiumMath.negativePiToPi(i-s),u-a)}function k(t,s,h,i,n,a,u){const d=t._heading,c=a-i;let o=0;if(e.CesiumMath.equalsEpsilon(Math.abs(d),e.CesiumMath.PI_OVER_TWO,e.CesiumMath.EPSILON8))if(s===h)o=s*Math.cos(n)*e.CesiumMath.negativePiToPi(c);else{const M=Math.sin(n);o=s*Math.cos(n)*e.CesiumMath.negativePiToPi(c)/Math.sqrt(1-t._ellipticitySquared*M*M)}else{const M=E(t._ellipticity,s,n);o=(E(t._ellipticity,s,u)-M)/Math.cos(d)}return Math.abs(o)}const b=new r.Cartesian3,I=new r.Cartesian3;function m(t,s,h,i){const n=r.Cartesian3.normalize(i.cartographicToCartesian(s,I),b),a=r.Cartesian3.normalize(i.cartographicToCartesian(h,I),I);P.Check.typeOf.number.greaterThanOrEquals("value",Math.abs(Math.abs(r.Cartesian3.angleBetween(n,a))-Math.PI),.0125);const u=i.maximumRadius,d=i.minimumRadius,c=u*u,o=d*d;t._ellipticitySquared=(c-o)/c,t._ellipticity=Math.sqrt(t._ellipticitySquared),t._start=r.Cartographic.clone(s,t._start),t._start.height=0,t._end=r.Cartographic.clone(h,t._end),t._end.height=0,t._heading=W(t,s.longitude,s.latitude,h.longitude,h.latitude),t._distance=k(t,i.maximumRadius,i.minimumRadius,s.longitude,s.latitude,h.longitude,h.latitude)}function q(t,s,h,i,n,a){if(h===0)return r.Cartographic.clone(t,a);const u=n*n;let d,c,o;if(Math.abs(e.CesiumMath.PI_OVER_TWO-Math.abs(s))>e.CesiumMath.EPSILON8){const M=E(n,i,t.latitude),g=h*Math.cos(s),f=M+g;c=v(f,n,i);const _=C(n,t.latitude),S=C(n,c);o=Math.tan(s)*(S-_),d=e.CesiumMath.negativePiToPi(t.longitude+o)}else{c=t.latitude;let M;if(n===0)M=i*Math.cos(t.latitude);else{const g=Math.sin(t.latitude);M=i*Math.cos(t.latitude)/Math.sqrt(1-u*g*g)}o=h/M,s>0?d=e.CesiumMath.negativePiToPi(t.longitude+o):d=e.CesiumMath.negativePiToPi(t.longitude-o)}return l.defined(a)?(a.longitude=d,a.latitude=c,a.height=0,a):new r.Cartographic(d,c,0)}function O(t,s,h){const i=l.defaultValue(h,r.Ellipsoid.WGS84);this._ellipsoid=i,this._start=new r.Cartographic,this._end=new r.Cartographic,this._heading=void 0,this._distance=void 0,this._ellipticity=void 0,this._ellipticitySquared=void 0,l.defined(t)&&l.defined(s)&&m(this,t,s,i)}Object.defineProperties(O.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},surfaceDistance:{get:function(){return P.Check.defined("distance",this._distance),this._distance}},start:{get:function(){return this._start}},end:{get:function(){return this._end}},heading:{get:function(){return P.Check.defined("distance",this._distance),this._heading}}}),O.fromStartHeadingDistance=function(t,s,h,i,n){P.Check.defined("start",t),P.Check.defined("heading",s),P.Check.defined("distance",h),P.Check.typeOf.number.greaterThan("distance",h,0);const a=l.defaultValue(i,r.Ellipsoid.WGS84),u=a.maximumRadius,d=a.minimumRadius,c=u*u,o=d*d,M=Math.sqrt((c-o)/c);s=e.CesiumMath.negativePiToPi(s);const g=q(t,s,h,a.maximumRadius,M);return!l.defined(n)||l.defined(i)&&!i.equals(n.ellipsoid)?new O(t,g,a):(n.setEndPoints(t,g),n)},O.prototype.setEndPoints=function(t,s){P.Check.defined("start",t),P.Check.defined("end",s),m(this,t,s,this._ellipsoid)},O.prototype.interpolateUsingFraction=function(t,s){return this.interpolateUsingSurfaceDistance(t*this._distance,s)},O.prototype.interpolateUsingSurfaceDistance=function(t,s){if(P.Check.typeOf.number("distance",t),!l.defined(this._distance)||this._distance===0)throw new P.DeveloperError("EllipsoidRhumbLine must have distinct start and end set.");return q(this._start,this._heading,t,this._ellipsoid.maximumRadius,this._ellipticity,s)},O.prototype.findIntersectionWithLongitude=function(t,s){if(P.Check.typeOf.number("intersectionLongitude",t),!l.defined(this._distance)||this._distance===0)throw new P.DeveloperError("EllipsoidRhumbLine must have distinct start and end set.");const h=this._ellipticity,i=this._heading,n=Math.abs(i),a=this._start;if(t=e.CesiumMath.negativePiToPi(t),e.CesiumMath.equalsEpsilon(Math.abs(t),Math.PI,e.CesiumMath.EPSILON14)&&(t=e.CesiumMath.sign(a.longitude)*Math.PI),l.defined(s)||(s=new r.Cartographic),Math.abs(e.CesiumMath.PI_OVER_TWO-n)<=e.CesiumMath.EPSILON8)return s.longitude=t,s.latitude=a.latitude,s.height=0,s;if(e.CesiumMath.equalsEpsilon(Math.abs(e.CesiumMath.PI_OVER_TWO-n),e.CesiumMath.PI_OVER_TWO,e.CesiumMath.EPSILON8))return e.CesiumMath.equalsEpsilon(t,a.longitude,e.CesiumMath.EPSILON12)?void 0:(s.longitude=t,s.latitude=e.CesiumMath.PI_OVER_TWO*e.CesiumMath.sign(e.CesiumMath.PI_OVER_TWO-i),s.height=0,s);const u=a.latitude,d=h*Math.sin(u),c=Math.tan(.5*(e.CesiumMath.PI_OVER_TWO+u))*Math.exp((t-a.longitude)/Math.tan(i)),o=(1+d)/(1-d);let M=a.latitude,g;do{g=M;const f=h*Math.sin(g),_=(1+f)/(1-f);M=2*Math.atan(c*Math.pow(_/o,h/2))-e.CesiumMath.PI_OVER_TWO}while(!e.CesiumMath.equalsEpsilon(M,g,e.CesiumMath.EPSILON12));return s.longitude=t,s.latitude=M,s.height=0,s},O.prototype.findIntersectionWithLatitude=function(t,s){if(P.Check.typeOf.number("intersectionLatitude",t),!l.defined(this._distance)||this._distance===0)throw new P.DeveloperError("EllipsoidRhumbLine must have distinct start and end set.");const h=this._ellipticity,i=this._heading,n=this._start;if(e.CesiumMath.equalsEpsilon(Math.abs(i),e.CesiumMath.PI_OVER_TWO,e.CesiumMath.EPSILON8))return;const a=C(h,n.latitude),u=C(h,t),d=Math.tan(i)*(u-a),c=e.CesiumMath.negativePiToPi(n.longitude+d);return l.defined(s)?(s.longitude=c,s.latitude=t,s.height=0,s):new r.Cartographic(c,t,0)},w.EllipsoidRhumbLine=O});
