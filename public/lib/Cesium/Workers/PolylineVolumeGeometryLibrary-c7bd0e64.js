/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.96.6
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */

define(["exports","./Matrix2-4706dd70","./EllipsoidTangentPlane-100869c1","./ComponentDatatype-438cad2a","./PolylinePipeline-52ab0181","./Transforms-66eda18c","./defaultValue-028a8a27","./RuntimeError-a977b8e0"],function(X,e,ae,Y,$,Q,J,he){"use strict";var H=Object.freeze({ROUNDED:0,MITERED:1,BEVELED:2});const re={};function P(t,a){if(!J.defined(t))throw new he.DeveloperError("identifier is required.");J.defined(re[t])||(re[t]=!0,console.warn(J.defaultValue(a,t)))}P.geometryOutlines="Entity geometry outlines are unsupported on terrain. Outlines will be disabled. To enable outlines, disable geometry terrain clamping by explicitly setting height to 0.",P.geometryZIndex="Entity geometry with zIndex are unsupported when height or extrudedHeight are defined.  zIndex will be ignored",P.geometryHeightReference="Entity corridor, ellipse, polygon or rectangle with heightReference must also have a defined height.  heightReference will be ignored",P.geometryExtrudedHeightReference="Entity corridor, ellipse, polygon or rectangle with extrudedHeightReference must also have a defined extrudedHeight.  extrudedHeightReference will be ignored";const m=[new e.Cartesian3,new e.Cartesian3],de=new e.Cartesian3,fe=new e.Cartesian3,ye=new e.Cartesian3,ge=new e.Cartesian3,me=new e.Cartesian3,we=new e.Cartesian3,pe=new e.Cartesian3,Ee=new e.Cartesian3,Se=new e.Cartesian3,V=new e.Cartesian3,U=new e.Cartesian3,I={};let K=new e.Cartographic;function Te(t,a){const o=new Array(t.length);for(let r=0;r<t.length;r++){const n=t[r];K=a.cartesianToCartographic(n,K),o[r]=K.height,t[r]=a.scaleToGeodeticSurface(n,n)}return o}function x(t,a,o,r){const n=t[0],s=t[1],C=e.Cartesian3.angleBetween(n,s),c=Math.ceil(C/r),u=new Array(c);let l;if(a===o){for(l=0;l<c;l++)u[l]=a;return u.push(o),u}const f=(o-a)/c;for(l=1;l<c;l++){const p=a+l*f;u[l]=p}return u[0]=a,u.push(o),u}const k=new e.Cartesian3,Z=new e.Cartesian3;function Be(t,a,o,r){const n=new ae.EllipsoidTangentPlane(o,r),s=n.projectPointOntoPlane(e.Cartesian3.add(o,t,k),k),C=n.projectPointOntoPlane(e.Cartesian3.add(o,a,Z),Z),c=e.Cartesian2.angleBetween(s,C);return C.x*s.y-C.y*s.x>=0?-c:c}const be=new e.Cartesian3(-1,0,0);let D=new e.Matrix4;const ze=new e.Matrix4;let M=new e.Matrix3;const Ae=e.Matrix3.IDENTITY.clone(),Oe=new e.Cartesian3,ve=new e.Cartesian4,se=new e.Cartesian3;function O(t,a,o,r,n,s,C,c){let u=Oe,l=ve;D=Q.Transforms.eastNorthUpToFixedFrame(t,n,D),u=e.Matrix4.multiplyByPointAsVector(D,be,u),u=e.Cartesian3.normalize(u,u);const S=Be(u,a,t,n);M=e.Matrix3.fromRotationZ(S,M),se.z=s,D=e.Matrix4.multiplyTransformation(D,e.Matrix4.fromRotationTranslation(M,se,ze),D);const f=Ae;f[0]=C;for(let p=0;p<c;p++)for(let i=0;i<o.length;i+=3)l=e.Cartesian3.fromArray(o,i,l),l=e.Matrix3.multiplyByVector(f,l,l),l=e.Matrix4.multiplyByPoint(D,l,l),r.push(l.x,l.y,l.z);return r}const je=new e.Cartesian3;function ee(t,a,o,r,n,s,C){for(let c=0;c<t.length;c+=3){const u=e.Cartesian3.fromArray(t,c,je);r=O(u,a,o,r,n,s[c/3],C,1)}return r}function De(t,a){const o=t.length,r=new Array(o*6);let n=0;const s=a.x+a.width/2,C=a.y+a.height/2;let c=t[0];r[n++]=c.x-s,r[n++]=0,r[n++]=c.y-C;for(let u=1;u<o;u++){c=t[u];const l=c.x-s,S=c.y-C;r[n++]=l,r[n++]=0,r[n++]=S,r[n++]=l,r[n++]=0,r[n++]=S}return c=t[0],r[n++]=c.x-s,r[n++]=0,r[n++]=c.y-C,r}function oe(t,a){const o=t.length,r=new Array(o*3);let n=0;const s=a.x+a.width/2,C=a.y+a.height/2;for(let c=0;c<o;c++)r[n++]=t[c].x-s,r[n++]=0,r[n++]=t[c].y-C;return r}const ce=new Q.Quaternion,le=new e.Cartesian3,ie=new e.Matrix3;function Ce(t,a,o,r,n,s,C,c,u,l){const S=e.Cartesian3.angleBetween(e.Cartesian3.subtract(a,t,V),e.Cartesian3.subtract(o,t,U)),f=r===H.BEVELED?0:Math.ceil(S/Y.CesiumMath.toRadians(5));let p;n?p=e.Matrix3.fromQuaternion(Q.Quaternion.fromAxisAngle(e.Cartesian3.negate(t,V),S/(f+1),ce),ie):p=e.Matrix3.fromQuaternion(Q.Quaternion.fromAxisAngle(t,S/(f+1),ce),ie);let i,y;if(a=e.Cartesian3.clone(a,le),f>0){const j=l?2:1;for(let g=0;g<f;g++)a=e.Matrix3.multiplyByVector(p,a,a),i=e.Cartesian3.subtract(a,t,V),i=e.Cartesian3.normalize(i,i),n||(i=e.Cartesian3.negate(i,i)),y=s.scaleToGeodeticSurface(a,U),C=O(y,i,c,C,s,u,1,j)}else i=e.Cartesian3.subtract(a,t,V),i=e.Cartesian3.normalize(i,i),n||(i=e.Cartesian3.negate(i,i)),y=s.scaleToGeodeticSurface(a,U),C=O(y,i,c,C,s,u,1,1),o=e.Cartesian3.clone(o,le),i=e.Cartesian3.subtract(o,t,V),i=e.Cartesian3.normalize(i,i),n||(i=e.Cartesian3.negate(i,i)),y=s.scaleToGeodeticSurface(o,U),C=O(y,i,c,C,s,u,1,1);return C}I.removeDuplicatesFromShape=function(t){const a=t.length,o=[];for(let r=a-1,n=0;n<a;r=n++){const s=t[r],C=t[n];e.Cartesian2.equals(s,C)||o.push(C)}return o},I.angleIsGreaterThanPi=function(t,a,o,r){const n=new ae.EllipsoidTangentPlane(o,r),s=n.projectPointOntoPlane(e.Cartesian3.add(o,t,k),k),C=n.projectPointOntoPlane(e.Cartesian3.add(o,a,Z),Z);return C.x*s.y-C.y*s.x>=0};const He=new e.Cartesian3,Pe=new e.Cartesian3;I.computePositions=function(t,a,o,r,n){const s=r._ellipsoid,C=Te(t,s),c=r._granularity,u=r._cornerType,l=n?De(a,o):oe(a,o),S=n?oe(a,o):void 0,f=o.height/2,p=o.width/2;let i=t.length,y=[],j=n?[]:void 0,g=de,v=fe,d=ye,E=ge,B=me,b=we,z=pe,h=Ee,T=Se,w=t[0],N=t[1];E=s.geodeticSurfaceNormal(w,E),g=e.Cartesian3.subtract(N,w,g),g=e.Cartesian3.normalize(g,g),h=e.Cartesian3.cross(E,g,h),h=e.Cartesian3.normalize(h,h);let G=C[0],A=C[1];n&&(j=O(w,h,S,j,s,G+f,1,1)),T=e.Cartesian3.clone(w,T),w=N,v=e.Cartesian3.negate(g,v);let L,F;for(let _=1;_<i-1;_++){const ue=n?2:1;if(N=t[_+1],w.equals(N)){P("Positions are too close and are considered equivalent with rounding error.");continue}g=e.Cartesian3.subtract(N,w,g),g=e.Cartesian3.normalize(g,g),d=e.Cartesian3.add(g,v,d),d=e.Cartesian3.normalize(d,d),E=s.geodeticSurfaceNormal(w,E);const q=e.Cartesian3.multiplyByScalar(E,e.Cartesian3.dot(g,E),He);e.Cartesian3.subtract(g,q,q),e.Cartesian3.normalize(q,q);const R=e.Cartesian3.multiplyByScalar(E,e.Cartesian3.dot(v,E),Pe);if(e.Cartesian3.subtract(v,R,R),e.Cartesian3.normalize(R,R),!Y.CesiumMath.equalsEpsilon(Math.abs(e.Cartesian3.dot(q,R)),1,Y.CesiumMath.EPSILON7)){d=e.Cartesian3.cross(d,E,d),d=e.Cartesian3.cross(E,d,d),d=e.Cartesian3.normalize(d,d);const W=1/Math.max(.25,e.Cartesian3.magnitude(e.Cartesian3.cross(d,v,V))),te=I.angleIsGreaterThanPi(g,v,w,s);te?(B=e.Cartesian3.add(w,e.Cartesian3.multiplyByScalar(d,W*p,d),B),b=e.Cartesian3.add(B,e.Cartesian3.multiplyByScalar(h,p,b),b),m[0]=e.Cartesian3.clone(T,m[0]),m[1]=e.Cartesian3.clone(b,m[1]),L=x(m,G+f,A+f,c),F=$.PolylinePipeline.generateArc({positions:m,granularity:c,ellipsoid:s}),y=ee(F,h,l,y,s,L,1),h=e.Cartesian3.cross(E,g,h),h=e.Cartesian3.normalize(h,h),z=e.Cartesian3.add(B,e.Cartesian3.multiplyByScalar(h,p,z),z),u===H.ROUNDED||u===H.BEVELED?Ce(B,b,z,u,te,s,y,l,A+f,n):(d=e.Cartesian3.negate(d,d),y=O(w,d,l,y,s,A+f,W,ue)),T=e.Cartesian3.clone(z,T)):(B=e.Cartesian3.add(w,e.Cartesian3.multiplyByScalar(d,W*p,d),B),b=e.Cartesian3.add(B,e.Cartesian3.multiplyByScalar(h,-p,b),b),m[0]=e.Cartesian3.clone(T,m[0]),m[1]=e.Cartesian3.clone(b,m[1]),L=x(m,G+f,A+f,c),F=$.PolylinePipeline.generateArc({positions:m,granularity:c,ellipsoid:s}),y=ee(F,h,l,y,s,L,1),h=e.Cartesian3.cross(E,g,h),h=e.Cartesian3.normalize(h,h),z=e.Cartesian3.add(B,e.Cartesian3.multiplyByScalar(h,-p,z),z),u===H.ROUNDED||u===H.BEVELED?Ce(B,b,z,u,te,s,y,l,A+f,n):y=O(w,d,l,y,s,A+f,W,ue),T=e.Cartesian3.clone(z,T)),v=e.Cartesian3.negate(g,v)}else y=O(T,h,l,y,s,G+f,1,1),T=w;G=A,A=C[_+1],w=N}m[0]=e.Cartesian3.clone(T,m[0]),m[1]=e.Cartesian3.clone(w,m[1]),L=x(m,G+f,A+f,c),F=$.PolylinePipeline.generateArc({positions:m,granularity:c,ellipsoid:s}),y=ee(F,h,l,y,s,L,1),n&&(j=O(w,h,S,j,s,A+f,1,1)),i=y.length;const Ve=n?i+j.length:i,ne=new Float64Array(Ve);return ne.set(y),n&&ne.set(j,i),ne},X.CornerType=H,X.PolylineVolumeGeometryLibrary=I,X.oneTimeWarning=P});
