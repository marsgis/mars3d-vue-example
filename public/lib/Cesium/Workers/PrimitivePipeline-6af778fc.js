/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.96.6
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */

define(["exports","./Transforms-66eda18c","./ComponentDatatype-438cad2a","./defaultValue-028a8a27","./RuntimeError-a977b8e0","./Matrix2-4706dd70","./GeometryAttribute-2cdece80","./GeometryAttributes-98e858da","./GeometryPipeline-d062bcb6","./IndexDatatype-dfa09980","./WebMercatorProjection-9bd06b6c"],function(z,y,k,d,w,G,A,j,b,E,U){"use strict";function v(e,n,t){e=d.defaultValue(e,0),n=d.defaultValue(n,0),t=d.defaultValue(t,0),this.value=new Float32Array([e,n,t])}Object.defineProperties(v.prototype,{componentDatatype:{get:function(){return k.ComponentDatatype.FLOAT}},componentsPerAttribute:{get:function(){return 3}},normalize:{get:function(){return!1}}}),v.fromCartesian3=function(e){return w.Check.defined("offset",e),new v(e.x,e.y,e.z)},v.toValue=function(e,n){return w.Check.defined("offset",e),d.defined(n)||(n=new Float32Array([e.x,e.y,e.z])),n[0]=e.x,n[1]=e.y,n[2]=e.z,n};function $(e,n,t){let o=!t;const r=e.length;let s;if(!o&&r>1){const i=e[0].modelMatrix;for(s=1;s<r;++s)if(!G.Matrix4.equals(i,e[s].modelMatrix)){o=!0;break}}if(o)for(s=0;s<r;++s)d.defined(e[s].geometry)&&b.GeometryPipeline.transformToWorldCoordinates(e[s]);else G.Matrix4.multiplyTransformation(n,e[0].modelMatrix,n)}function I(e,n){const t=e.attributes,o=t.position,r=o.values.length/o.componentsPerAttribute;t.batchId=new A.GeometryAttribute({componentDatatype:k.ComponentDatatype.FLOAT,componentsPerAttribute:1,values:new Float32Array(r)});const s=t.batchId.values;for(let i=0;i<r;++i)s[i]=n}function T(e){const n=e.length;for(let t=0;t<n;++t){const o=e[t];d.defined(o.geometry)?I(o.geometry,t):d.defined(o.westHemisphereGeometry)&&d.defined(o.eastHemisphereGeometry)&&(I(o.westHemisphereGeometry,t),I(o.eastHemisphereGeometry,t))}}function W(e){const n=e.instances,t=e.projection,o=e.elementIndexUintSupported,r=e.scene3DOnly,s=e.vertexCacheOptimize,i=e.compressVertices,l=e.modelMatrix;let c,h,u,f=n.length;for(c=0;c<f;++c)if(d.defined(n[c].geometry)){u=n[c].geometry.primitiveType;break}for(c=1;c<f;++c)if(d.defined(n[c].geometry)&&n[c].geometry.primitiveType!==u)throw new w.DeveloperError("All instance geometries must have the same primitiveType.");if($(n,l,r),!r)for(c=0;c<f;++c)d.defined(n[c].geometry)&&b.GeometryPipeline.splitLongitude(n[c]);if(T(n),s)for(c=0;c<f;++c){const p=n[c];d.defined(p.geometry)?(b.GeometryPipeline.reorderForPostVertexCache(p.geometry),b.GeometryPipeline.reorderForPreVertexCache(p.geometry)):d.defined(p.westHemisphereGeometry)&&d.defined(p.eastHemisphereGeometry)&&(b.GeometryPipeline.reorderForPostVertexCache(p.westHemisphereGeometry),b.GeometryPipeline.reorderForPreVertexCache(p.westHemisphereGeometry),b.GeometryPipeline.reorderForPostVertexCache(p.eastHemisphereGeometry),b.GeometryPipeline.reorderForPreVertexCache(p.eastHemisphereGeometry))}let g=b.GeometryPipeline.combineInstances(n);for(f=g.length,c=0;c<f;++c){h=g[c];const p=h.attributes;if(r)for(const m in p)p.hasOwnProperty(m)&&p[m].componentDatatype===k.ComponentDatatype.DOUBLE&&b.GeometryPipeline.encodeAttribute(h,m,`${m}3DHigh`,`${m}3DLow`);else for(const m in p)if(p.hasOwnProperty(m)&&p[m].componentDatatype===k.ComponentDatatype.DOUBLE){const a=`${m}3D`,S=`${m}2D`;b.GeometryPipeline.projectTo2D(h,m,a,S,t),d.defined(h.boundingSphere)&&m==="position"&&(h.boundingSphereCV=y.BoundingSphere.fromVertices(h.attributes.position2D.values)),b.GeometryPipeline.encodeAttribute(h,a,`${a}High`,`${a}Low`),b.GeometryPipeline.encodeAttribute(h,S,`${S}High`,`${S}Low`)}i&&b.GeometryPipeline.compressVertices(h)}if(!o){let p=[];for(f=g.length,c=0;c<f;++c)h=g[c],p=p.concat(b.GeometryPipeline.fitToUnsignedShortIndices(h));g=p}return g}function O(e,n,t,o){let r,s,i;const l=o.length-1;if(l>=0){const h=o[l];r=h.offset+h.count,i=h.index,s=t[i].indices.length}else r=0,i=0,s=t[i].indices.length;const c=e.length;for(let h=0;h<c;++h){const f=e[h][n];if(!d.defined(f))continue;const g=f.indices.length;r+g>s&&(r=0,s=t[++i].indices.length),o.push({index:i,offset:r,count:g}),r+=g}}function R(e,n){const t=[];return O(e,"geometry",n,t),O(e,"westHemisphereGeometry",n,t),O(e,"eastHemisphereGeometry",n,t),t}const C={};C.combineGeometry=function(e){let n,t;const o=e.instances,r=o.length;let s,i,l=!1;r>0&&(n=W(e),n.length>0&&(t=b.GeometryPipeline.createAttributeLocations(n[0]),e.createPickOffsets&&(s=R(o,n))),d.defined(o[0].attributes)&&d.defined(o[0].attributes.offset)&&(i=new Array(r),l=!0));const c=new Array(r),h=new Array(r);for(let u=0;u<r;++u){const f=o[u],g=f.geometry;d.defined(g)&&(c[u]=g.boundingSphere,h[u]=g.boundingSphereCV,l&&(i[u]=f.geometry.offsetAttribute));const p=f.eastHemisphereGeometry,m=f.westHemisphereGeometry;d.defined(p)&&d.defined(m)&&(d.defined(p.boundingSphere)&&d.defined(m.boundingSphere)&&(c[u]=y.BoundingSphere.union(p.boundingSphere,m.boundingSphere)),d.defined(p.boundingSphereCV)&&d.defined(m.boundingSphereCV)&&(h[u]=y.BoundingSphere.union(p.boundingSphereCV,m.boundingSphereCV)))}return{geometries:n,modelMatrix:e.modelMatrix,attributeLocations:t,pickOffsets:s,offsetInstanceExtend:i,boundingSpheres:c,boundingSpheresCV:h}};function q(e,n){const t=e.attributes;for(const o in t)if(t.hasOwnProperty(o)){const r=t[o];d.defined(r)&&d.defined(r.values)&&n.push(r.values.buffer)}d.defined(e.indices)&&n.push(e.indices.buffer)}function J(e,n){const t=e.length;for(let o=0;o<t;++o)q(e[o],n)}function K(e){let n=1;const t=e.length;for(let o=0;o<t;o++){const r=e[o];if(++n,!d.defined(r))continue;const s=r.attributes;n+=7+2*y.BoundingSphere.packedLength+(d.defined(r.indices)?r.indices.length:0);for(const i in s)if(s.hasOwnProperty(i)&&d.defined(s[i])){const l=s[i];n+=5+l.values.length}}return n}C.packCreateGeometryResults=function(e,n){const t=new Float64Array(K(e)),o=[],r={},s=e.length;let i=0;t[i++]=s;for(let l=0;l<s;l++){const c=e[l],h=d.defined(c);if(t[i++]=h?1:0,!h)continue;t[i++]=c.primitiveType,t[i++]=c.geometryType,t[i++]=d.defaultValue(c.offsetAttribute,-1);const u=d.defined(c.boundingSphere)?1:0;t[i++]=u,u&&y.BoundingSphere.pack(c.boundingSphere,t,i),i+=y.BoundingSphere.packedLength;const f=d.defined(c.boundingSphereCV)?1:0;t[i++]=f,f&&y.BoundingSphere.pack(c.boundingSphereCV,t,i),i+=y.BoundingSphere.packedLength;const g=c.attributes,p=[];for(const a in g)g.hasOwnProperty(a)&&d.defined(g[a])&&(p.push(a),d.defined(r[a])||(r[a]=o.length,o.push(a)));t[i++]=p.length;for(let a=0;a<p.length;a++){const S=p[a],x=g[S];t[i++]=r[S],t[i++]=x.componentDatatype,t[i++]=x.componentsPerAttribute,t[i++]=x.normalize?1:0,t[i++]=x.values.length,t.set(x.values,i),i+=x.values.length}const m=d.defined(c.indices)?c.indices.length:0;t[i++]=m,m>0&&(t.set(c.indices,i),i+=m)}return n.push(t.buffer),{stringTable:o,packedData:t}},C.unpackCreateGeometryResults=function(e){const n=e.stringTable,t=e.packedData;let o;const r=new Array(t[0]);let s=0,i=1;for(;i<t.length;){if(!(t[i++]===1)){r[s++]=void 0;continue}const c=t[i++],h=t[i++];let u=t[i++];u===-1&&(u=void 0);let f,g;t[i++]===1&&(f=y.BoundingSphere.unpack(t,i)),i+=y.BoundingSphere.packedLength,t[i++]===1&&(g=y.BoundingSphere.unpack(t,i)),i+=y.BoundingSphere.packedLength;let a,S,x;const M=new j.GeometryAttributes,X=t[i++];for(o=0;o<X;o++){const B=n[t[i++]],F=t[i++];x=t[i++];const Y=t[i++]!==0;a=t[i++],S=k.ComponentDatatype.createTypedArray(F,a);for(let P=0;P<a;P++)S[P]=t[i++];M[B]=new A.GeometryAttribute({componentDatatype:F,componentsPerAttribute:x,normalize:Y,values:S})}let D;if(a=t[i++],a>0){const B=S.length/x;for(D=E.IndexDatatype.createTypedArray(B,a),o=0;o<a;o++)D[o]=t[i++]}r[s++]=new A.Geometry({primitiveType:c,geometryType:h,boundingSphere:f,boundingSphereCV:g,indices:D,attributes:M,offsetAttribute:u})}return r};function N(e,n){const t=e.length,o=new Float64Array(1+t*19);let r=0;o[r++]=t;for(let s=0;s<t;s++){const i=e[s];if(G.Matrix4.pack(i.modelMatrix,o,r),r+=G.Matrix4.packedLength,d.defined(i.attributes)&&d.defined(i.attributes.offset)){const l=i.attributes.offset.value;o[r]=l[0],o[r+1]=l[1],o[r+2]=l[2]}r+=3}return n.push(o.buffer),o}function Q(e){const n=e,t=new Array(n[0]);let o=0,r=1;for(;r<n.length;){const s=G.Matrix4.unpack(n,r);let i;r+=G.Matrix4.packedLength,d.defined(n[r])&&(i={offset:new v(n[r],n[r+1],n[r+2])}),r+=3,t[o++]={modelMatrix:s,attributes:i}}return t}C.packCombineGeometryParameters=function(e,n){const t=e.createGeometryResults,o=t.length;for(let r=0;r<o;r++)n.push(t[r].packedData.buffer);return{createGeometryResults:e.createGeometryResults,packedInstances:N(e.instances,n),ellipsoid:e.ellipsoid,isGeographic:e.projection instanceof y.GeographicProjection,elementIndexUintSupported:e.elementIndexUintSupported,scene3DOnly:e.scene3DOnly,vertexCacheOptimize:e.vertexCacheOptimize,compressVertices:e.compressVertices,modelMatrix:e.modelMatrix,createPickOffsets:e.createPickOffsets}},C.unpackCombineGeometryParameters=function(e){const n=Q(e.packedInstances),t=e.createGeometryResults,o=t.length;let r=0;for(let l=0;l<o;l++){const c=C.unpackCreateGeometryResults(t[l]),h=c.length;for(let u=0;u<h;u++){const f=c[u],g=n[r];g.geometry=f,++r}}const s=G.Ellipsoid.clone(e.ellipsoid),i=e.isGeographic?new y.GeographicProjection(s):new U.WebMercatorProjection(s);return{instances:n,ellipsoid:s,projection:i,elementIndexUintSupported:e.elementIndexUintSupported,scene3DOnly:e.scene3DOnly,vertexCacheOptimize:e.vertexCacheOptimize,compressVertices:e.compressVertices,modelMatrix:G.Matrix4.clone(e.modelMatrix),createPickOffsets:e.createPickOffsets}};function L(e){const n=e.length,t=1+(y.BoundingSphere.packedLength+1)*n,o=new Float32Array(t);let r=0;o[r++]=n;for(let s=0;s<n;++s){const i=e[s];d.defined(i)?(o[r++]=1,y.BoundingSphere.pack(e[s],o,r)):o[r++]=0,r+=y.BoundingSphere.packedLength}return o}function H(e){const n=new Array(e[0]);let t=0,o=1;for(;o<e.length;)e[o++]===1&&(n[t]=y.BoundingSphere.unpack(e,o)),++t,o+=y.BoundingSphere.packedLength;return n}C.packCombineGeometryResults=function(e,n){d.defined(e.geometries)&&J(e.geometries,n);const t=L(e.boundingSpheres),o=L(e.boundingSpheresCV);return n.push(t.buffer,o.buffer),{geometries:e.geometries,attributeLocations:e.attributeLocations,modelMatrix:e.modelMatrix,pickOffsets:e.pickOffsets,offsetInstanceExtend:e.offsetInstanceExtend,boundingSpheres:t,boundingSpheresCV:o}},C.unpackCombineGeometryResults=function(e){return{geometries:e.geometries,attributeLocations:e.attributeLocations,modelMatrix:e.modelMatrix,pickOffsets:e.pickOffsets,offsetInstanceExtend:e.offsetInstanceExtend,boundingSpheres:H(e.boundingSpheres),boundingSpheresCV:H(e.boundingSpheresCV)}},z.PrimitivePipeline=C});
