/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.96.6
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */

define(["exports","./Transforms-66eda18c","./Matrix2-4706dd70","./RuntimeError-a977b8e0","./defaultValue-028a8a27","./EllipsoidTangentPlane-100869c1","./ComponentDatatype-438cad2a","./Plane-f4cd36d8"],function($,z,e,m,d,V,v,I){"use strict";function f(a,n){this.center=e.Cartesian3.clone(d.defaultValue(a,e.Cartesian3.ZERO)),this.halfAxes=e.Matrix3.clone(d.defaultValue(n,e.Matrix3.ZERO))}f.packedLength=e.Cartesian3.packedLength+e.Matrix3.packedLength,f.pack=function(a,n,s){return m.Check.typeOf.object("value",a),m.Check.defined("array",n),s=d.defaultValue(s,0),e.Cartesian3.pack(a.center,n,s),e.Matrix3.pack(a.halfAxes,n,s+e.Cartesian3.packedLength),n},f.unpack=function(a,n,s){return m.Check.defined("array",a),n=d.defaultValue(n,0),d.defined(s)||(s=new f),e.Cartesian3.unpack(a,n,s.center),e.Matrix3.unpack(a,n+e.Cartesian3.packedLength,s.halfAxes),s};const H=new e.Cartesian3,x=new e.Cartesian3,M=new e.Cartesian3,ee=new e.Cartesian3,ne=new e.Cartesian3,ae=new e.Cartesian3,te=new e.Matrix3,se={unitary:new e.Matrix3,diagonal:new e.Matrix3};f.fromPoints=function(a,n){if(d.defined(n)||(n=new f),!d.defined(a)||a.length===0)return n.halfAxes=e.Matrix3.ZERO,n.center=e.Cartesian3.ZERO,n;let s;const i=a.length,c=e.Cartesian3.clone(a[0],H);for(s=1;s<i;s++)e.Cartesian3.add(c,a[s],c);const o=1/i;e.Cartesian3.multiplyByScalar(c,o,c);let C=0,P=0,w=0,p=0,l=0,t=0,r;for(s=0;s<i;s++)r=e.Cartesian3.subtract(a[s],c,x),C+=r.x*r.x,P+=r.x*r.y,w+=r.x*r.z,p+=r.y*r.y,l+=r.y*r.z,t+=r.z*r.z;C*=o,P*=o,w*=o,p*=o,l*=o,t*=o;const h=te;h[0]=C,h[1]=P,h[2]=w,h[3]=P,h[4]=p,h[5]=l,h[6]=w,h[7]=l,h[8]=t;const O=e.Matrix3.computeEigenDecomposition(h,se),g=e.Matrix3.clone(O.unitary,n.halfAxes);let N=e.Matrix3.getColumn(g,0,ee),y=e.Matrix3.getColumn(g,1,ne),b=e.Matrix3.getColumn(g,2,ae),A=-Number.MAX_VALUE,S=-Number.MAX_VALUE,L=-Number.MAX_VALUE,U=Number.MAX_VALUE,W=Number.MAX_VALUE,q=Number.MAX_VALUE;for(s=0;s<i;s++)r=a[s],A=Math.max(e.Cartesian3.dot(N,r),A),S=Math.max(e.Cartesian3.dot(y,r),S),L=Math.max(e.Cartesian3.dot(b,r),L),U=Math.min(e.Cartesian3.dot(N,r),U),W=Math.min(e.Cartesian3.dot(y,r),W),q=Math.min(e.Cartesian3.dot(b,r),q);N=e.Cartesian3.multiplyByScalar(N,.5*(U+A),N),y=e.Cartesian3.multiplyByScalar(y,.5*(W+S),y),b=e.Cartesian3.multiplyByScalar(b,.5*(q+L),b);const T=e.Cartesian3.add(N,y,n.center);e.Cartesian3.add(T,b,T);const E=M;return E.x=A-U,E.y=S-W,E.z=L-q,e.Cartesian3.multiplyByScalar(E,.5,E),e.Matrix3.multiplyByScale(n.halfAxes,E,n.halfAxes),n};const _=new e.Cartesian3,ce=new e.Cartesian3;function R(a,n,s,i,c,o,C,P,w,p,l){if(!d.defined(c)||!d.defined(o)||!d.defined(C)||!d.defined(P)||!d.defined(w)||!d.defined(p))throw new m.DeveloperError("all extents (minimum/maximum X/Y/Z) are required.");d.defined(l)||(l=new f);const t=l.halfAxes;e.Matrix3.setColumn(t,0,n,t),e.Matrix3.setColumn(t,1,s,t),e.Matrix3.setColumn(t,2,i,t);let r=_;r.x=(c+o)/2,r.y=(C+P)/2,r.z=(w+p)/2;const h=ce;h.x=(o-c)/2,h.y=(P-C)/2,h.z=(p-w)/2;const O=l.center;return r=e.Matrix3.multiplyByVector(t,r,r),e.Cartesian3.add(a,r,O),e.Matrix3.multiplyByScale(t,h,t),l}const k=new e.Cartographic,oe=new e.Cartesian3,re=new e.Cartographic,Ce=new e.Cartographic,ie=new e.Cartographic,he=new e.Cartographic,de=new e.Cartographic,fe=new e.Cartesian3,X=new e.Cartesian3,we=new e.Cartesian3,Z=new e.Cartesian3,pe=new e.Cartesian3,Pe=new e.Cartesian2,le=new e.Cartesian2,Ae=new e.Cartesian2,Ne=new e.Cartesian2,ye=new e.Cartesian2,me=new e.Cartesian3,Oe=new e.Cartesian3,be=new e.Cartesian3,ge=new e.Cartesian3,Se=new e.Cartesian2,Te=new e.Cartesian3,ve=new e.Cartesian3,Ee=new e.Cartesian3,We=new I.Plane(e.Cartesian3.UNIT_X,0);f.fromRectangle=function(a,n,s,i,c){if(!d.defined(a))throw new m.DeveloperError("rectangle is required");if(a.width<0||a.width>v.CesiumMath.TWO_PI)throw new m.DeveloperError("Rectangle width must be between 0 and 2*pi");if(a.height<0||a.height>v.CesiumMath.PI)throw new m.DeveloperError("Rectangle height must be between 0 and pi");if(d.defined(i)&&!v.CesiumMath.equalsEpsilon(i.radii.x,i.radii.y,v.CesiumMath.EPSILON15))throw new m.DeveloperError("Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)");n=d.defaultValue(n,0),s=d.defaultValue(s,0),i=d.defaultValue(i,e.Ellipsoid.WGS84);let o,C,P,w,p,l,t;if(a.width<=v.CesiumMath.PI){const W=e.Rectangle.center(a,k),q=i.cartographicToCartesian(W,oe),T=new V.EllipsoidTangentPlane(q,i);t=T.plane;const E=W.longitude,_e=a.south<0&&a.north>0?0:W.latitude,Re=e.Cartographic.fromRadians(E,a.north,s,re),B=e.Cartographic.fromRadians(a.west,a.north,s,Ce),ke=e.Cartographic.fromRadians(a.west,_e,s,ie),j=e.Cartographic.fromRadians(a.west,a.south,s,he),Xe=e.Cartographic.fromRadians(E,a.south,s,de),Ze=i.cartographicToCartesian(Re,fe);let u=i.cartographicToCartesian(B,X);const Ye=i.cartographicToCartesian(ke,we);let D=i.cartographicToCartesian(j,Z);const Ge=i.cartographicToCartesian(Xe,pe),Fe=T.projectPointToNearestOnPlane(Ze,Pe),K=T.projectPointToNearestOnPlane(u,le),Je=T.projectPointToNearestOnPlane(Ye,Ae),Q=T.projectPointToNearestOnPlane(D,Ne),Ke=T.projectPointToNearestOnPlane(Ge,ye);return o=Math.min(K.x,Je.x,Q.x),C=-o,w=Math.max(K.y,Fe.y),P=Math.min(Q.y,Ke.y),B.height=j.height=n,u=i.cartographicToCartesian(B,X),D=i.cartographicToCartesian(j,Z),p=Math.min(I.Plane.getPointDistance(t,u),I.Plane.getPointDistance(t,D)),l=s,R(T.origin,T.xAxis,T.yAxis,T.zAxis,o,C,P,w,p,l,c)}const r=a.south>0,h=a.north<0,O=r?a.south:h?a.north:0,g=e.Rectangle.center(a,k).longitude,N=e.Cartesian3.fromRadians(g,O,s,i,me);N.z=0;const b=Math.abs(N.x)<v.CesiumMath.EPSILON10&&Math.abs(N.y)<v.CesiumMath.EPSILON10?e.Cartesian3.UNIT_X:e.Cartesian3.normalize(N,Oe),A=e.Cartesian3.UNIT_Z,S=e.Cartesian3.cross(b,A,be);t=I.Plane.fromPointNormal(N,b,We);const L=e.Cartesian3.fromRadians(g+v.CesiumMath.PI_OVER_TWO,O,s,i,ge);C=e.Cartesian3.dot(I.Plane.projectPointOntoPlane(t,L,Se),S),o=-C,w=e.Cartesian3.fromRadians(0,a.north,h?n:s,i,Te).z,P=e.Cartesian3.fromRadians(0,a.south,r?n:s,i,ve).z;const U=e.Cartesian3.fromRadians(a.east,O,s,i,Ee);return p=I.Plane.getPointDistance(t,U),l=0,R(N,S,A,b,o,C,P,w,p,l,c)},f.fromTransformation=function(a,n){return m.Check.typeOf.object("transformation",a),d.defined(n)||(n=new f),n.center=e.Matrix4.getTranslation(a,n.center),n.halfAxes=e.Matrix4.getMatrix3(a,n.halfAxes),n.halfAxes=e.Matrix3.multiplyByScalar(n.halfAxes,.5,n.halfAxes),n},f.clone=function(a,n){if(!!d.defined(a))return d.defined(n)?(e.Cartesian3.clone(a.center,n.center),e.Matrix3.clone(a.halfAxes,n.halfAxes),n):new f(a.center,a.halfAxes)},f.intersectPlane=function(a,n){if(!d.defined(a))throw new m.DeveloperError("box is required.");if(!d.defined(n))throw new m.DeveloperError("plane is required.");const s=a.center,i=n.normal,c=a.halfAxes,o=i.x,C=i.y,P=i.z,w=Math.abs(o*c[e.Matrix3.COLUMN0ROW0]+C*c[e.Matrix3.COLUMN0ROW1]+P*c[e.Matrix3.COLUMN0ROW2])+Math.abs(o*c[e.Matrix3.COLUMN1ROW0]+C*c[e.Matrix3.COLUMN1ROW1]+P*c[e.Matrix3.COLUMN1ROW2])+Math.abs(o*c[e.Matrix3.COLUMN2ROW0]+C*c[e.Matrix3.COLUMN2ROW1]+P*c[e.Matrix3.COLUMN2ROW2]),p=e.Cartesian3.dot(i,s)+n.distance;return p<=-w?z.Intersect.OUTSIDE:p>=w?z.Intersect.INSIDE:z.Intersect.INTERSECTING};const Y=new e.Cartesian3,G=new e.Cartesian3,F=new e.Cartesian3,ze=new e.Cartesian3,J=new e.Cartesian3,Ie=new e.Cartesian3;f.distanceSquaredTo=function(a,n){if(!d.defined(a))throw new m.DeveloperError("box is required.");if(!d.defined(n))throw new m.DeveloperError("cartesian is required.");const s=e.Cartesian3.subtract(n,a.center,_),i=a.halfAxes;let c=e.Matrix3.getColumn(i,0,Y),o=e.Matrix3.getColumn(i,1,G),C=e.Matrix3.getColumn(i,2,F);const P=e.Cartesian3.magnitude(c),w=e.Cartesian3.magnitude(o),p=e.Cartesian3.magnitude(C);let l=!0,t=!0,r=!0;P>0?e.Cartesian3.divideByScalar(c,P,c):l=!1,w>0?e.Cartesian3.divideByScalar(o,w,o):t=!1,p>0?e.Cartesian3.divideByScalar(C,p,C):r=!1;const h=!l+!t+!r;let O,g,N;if(h===1){let S=c;O=o,g=C,t?r||(S=C,g=c):(S=o,O=c),N=e.Cartesian3.cross(O,g,J),S===c?c=N:S===o?o=N:S===C&&(C=N)}else if(h===2){O=c,t?O=o:r&&(O=C);let S=e.Cartesian3.UNIT_Y;S.equalsEpsilon(O,v.CesiumMath.EPSILON3)&&(S=e.Cartesian3.UNIT_X),g=e.Cartesian3.cross(O,S,ze),e.Cartesian3.normalize(g,g),N=e.Cartesian3.cross(O,g,J),e.Cartesian3.normalize(N,N),O===c?(o=g,C=N):O===o?(C=g,c=N):O===C&&(c=g,o=N)}else h===3&&(c=e.Cartesian3.UNIT_X,o=e.Cartesian3.UNIT_Y,C=e.Cartesian3.UNIT_Z);const y=Ie;y.x=e.Cartesian3.dot(s,c),y.y=e.Cartesian3.dot(s,o),y.z=e.Cartesian3.dot(s,C);let b=0,A;return y.x<-P?(A=y.x+P,b+=A*A):y.x>P&&(A=y.x-P,b+=A*A),y.y<-w?(A=y.y+w,b+=A*A):y.y>w&&(A=y.y-w,b+=A*A),y.z<-p?(A=y.z+p,b+=A*A):y.z>p&&(A=y.z-p,b+=A*A),b};const Le=new e.Cartesian3,Ue=new e.Cartesian3;f.computePlaneDistances=function(a,n,s,i){if(!d.defined(a))throw new m.DeveloperError("box is required.");if(!d.defined(n))throw new m.DeveloperError("position is required.");if(!d.defined(s))throw new m.DeveloperError("direction is required.");d.defined(i)||(i=new z.Interval);let c=Number.POSITIVE_INFINITY,o=Number.NEGATIVE_INFINITY;const C=a.center,P=a.halfAxes,w=e.Matrix3.getColumn(P,0,Y),p=e.Matrix3.getColumn(P,1,G),l=e.Matrix3.getColumn(P,2,F),t=e.Cartesian3.add(w,p,Le);e.Cartesian3.add(t,l,t),e.Cartesian3.add(t,C,t);const r=e.Cartesian3.subtract(t,n,Ue);let h=e.Cartesian3.dot(s,r);return c=Math.min(h,c),o=Math.max(h,o),e.Cartesian3.add(C,w,t),e.Cartesian3.add(t,p,t),e.Cartesian3.subtract(t,l,t),e.Cartesian3.subtract(t,n,r),h=e.Cartesian3.dot(s,r),c=Math.min(h,c),o=Math.max(h,o),e.Cartesian3.add(C,w,t),e.Cartesian3.subtract(t,p,t),e.Cartesian3.add(t,l,t),e.Cartesian3.subtract(t,n,r),h=e.Cartesian3.dot(s,r),c=Math.min(h,c),o=Math.max(h,o),e.Cartesian3.add(C,w,t),e.Cartesian3.subtract(t,p,t),e.Cartesian3.subtract(t,l,t),e.Cartesian3.subtract(t,n,r),h=e.Cartesian3.dot(s,r),c=Math.min(h,c),o=Math.max(h,o),e.Cartesian3.subtract(C,w,t),e.Cartesian3.add(t,p,t),e.Cartesian3.add(t,l,t),e.Cartesian3.subtract(t,n,r),h=e.Cartesian3.dot(s,r),c=Math.min(h,c),o=Math.max(h,o),e.Cartesian3.subtract(C,w,t),e.Cartesian3.add(t,p,t),e.Cartesian3.subtract(t,l,t),e.Cartesian3.subtract(t,n,r),h=e.Cartesian3.dot(s,r),c=Math.min(h,c),o=Math.max(h,o),e.Cartesian3.subtract(C,w,t),e.Cartesian3.subtract(t,p,t),e.Cartesian3.add(t,l,t),e.Cartesian3.subtract(t,n,r),h=e.Cartesian3.dot(s,r),c=Math.min(h,c),o=Math.max(h,o),e.Cartesian3.subtract(C,w,t),e.Cartesian3.subtract(t,p,t),e.Cartesian3.subtract(t,l,t),e.Cartesian3.subtract(t,n,r),h=e.Cartesian3.dot(s,r),c=Math.min(h,c),o=Math.max(h,o),i.start=c,i.stop=o,i};const qe=new e.Cartesian3,Be=new e.Cartesian3,je=new e.Cartesian3;f.computeCorners=function(a,n){m.Check.typeOf.object("box",a),d.defined(n)||(n=[new e.Cartesian3,new e.Cartesian3,new e.Cartesian3,new e.Cartesian3,new e.Cartesian3,new e.Cartesian3,new e.Cartesian3,new e.Cartesian3]);const s=a.center,i=a.halfAxes,c=e.Matrix3.getColumn(i,0,qe),o=e.Matrix3.getColumn(i,1,Be),C=e.Matrix3.getColumn(i,2,je);return e.Cartesian3.clone(s,n[0]),e.Cartesian3.subtract(n[0],c,n[0]),e.Cartesian3.subtract(n[0],o,n[0]),e.Cartesian3.subtract(n[0],C,n[0]),e.Cartesian3.clone(s,n[1]),e.Cartesian3.subtract(n[1],c,n[1]),e.Cartesian3.subtract(n[1],o,n[1]),e.Cartesian3.add(n[1],C,n[1]),e.Cartesian3.clone(s,n[2]),e.Cartesian3.subtract(n[2],c,n[2]),e.Cartesian3.add(n[2],o,n[2]),e.Cartesian3.subtract(n[2],C,n[2]),e.Cartesian3.clone(s,n[3]),e.Cartesian3.subtract(n[3],c,n[3]),e.Cartesian3.add(n[3],o,n[3]),e.Cartesian3.add(n[3],C,n[3]),e.Cartesian3.clone(s,n[4]),e.Cartesian3.add(n[4],c,n[4]),e.Cartesian3.subtract(n[4],o,n[4]),e.Cartesian3.subtract(n[4],C,n[4]),e.Cartesian3.clone(s,n[5]),e.Cartesian3.add(n[5],c,n[5]),e.Cartesian3.subtract(n[5],o,n[5]),e.Cartesian3.add(n[5],C,n[5]),e.Cartesian3.clone(s,n[6]),e.Cartesian3.add(n[6],c,n[6]),e.Cartesian3.add(n[6],o,n[6]),e.Cartesian3.subtract(n[6],C,n[6]),e.Cartesian3.clone(s,n[7]),e.Cartesian3.add(n[7],c,n[7]),e.Cartesian3.add(n[7],o,n[7]),e.Cartesian3.add(n[7],C,n[7]),n};const ue=new e.Matrix3;f.computeTransformation=function(a,n){m.Check.typeOf.object("box",a),d.defined(n)||(n=new e.Matrix4);const s=a.center,i=e.Matrix3.multiplyByUniformScale(a.halfAxes,2,ue);return e.Matrix4.fromRotationTranslation(i,s,n)};const De=new z.BoundingSphere;f.isOccluded=function(a,n){if(!d.defined(a))throw new m.DeveloperError("box is required.");if(!d.defined(n))throw new m.DeveloperError("occluder is required.");const s=z.BoundingSphere.fromOrientedBoundingBox(a,De);return!n.isBoundingSphereVisible(s)},f.prototype.intersectPlane=function(a){return f.intersectPlane(this,a)},f.prototype.distanceSquaredTo=function(a){return f.distanceSquaredTo(this,a)},f.prototype.computePlaneDistances=function(a,n,s){return f.computePlaneDistances(this,a,n,s)},f.prototype.computeCorners=function(a){return f.computeCorners(this,a)},f.prototype.computeTransformation=function(a){return f.computeTransformation(this,a)},f.prototype.isOccluded=function(a){return f.isOccluded(this,a)},f.equals=function(a,n){return a===n||d.defined(a)&&d.defined(n)&&e.Cartesian3.equals(a.center,n.center)&&e.Matrix3.equals(a.halfAxes,n.halfAxes)},f.prototype.clone=function(a){return f.clone(this,a)},f.prototype.equals=function(a){return f.equals(this,a)},$.OrientedBoundingBox=f});
