!function (v, A) {
  'object' == typeof exports && 'object' == typeof module ? module['exports'] = A() : 'function' == typeof define && define['amd'] ? define([], A) : 'object' == typeof exports ? exports['QE'] = A() : v['QE'] = A();
}(self, () => (() => {
  let qeFetch = function (url) {
    if (Cesium?.Resource?.ReplaceMars3DUrl) {
      url = Cesium.Resource.ReplaceMars3DUrl.bind(this)(url)
    }
    return fetch['bind'](window)(url)
  };

  var v = {
    0x399: l => {
      function K (i) {
        var b = new Error('Cannot\x20find\x20module\x20\x27' + i + '\x27');
        throw b['code'] = 'MODULE_NOT_FOUND',
        b;
      }
      K['keys'] = () => [],
        K['resolve'] = K,
        K['id'] = 0x399,
        l['exports'] = K;
    }
    ,
    0x17a: (l, K, i) => {
      l['exports'] = function b (c, H, x) {
        function p (w, Y) {
          if (!H[w]) {
            if (!c[w]) {
              if (!Y && i(0x399))
                return require(w, !0);
              if (F)
                return F(w, true);
              var T = new Error('Cannot\x20find\x20module\x20\x27' + w + '\x27');
              throw T['code'] = 'MODULE_NOT_FOUND',
              T;
            }
            var X = H[w] = {
              'exports': {}
            };
            c[w][0x0]['call'](X['exports'], function (E) {
              return p(c[w][0x1][E] || E);
            }, X, X['exports'], b, c, H, x);
          }
          return H[w]['exports'];
        }
        for (var F = undefined, y = 0x0; y < x['length']; y++)
          p(x[y]);
        return p;
      }({
        0x1: [function (c, H, x) {
          'use strict';
          var p = c('./utils')
            , F = c('./support')
            , y = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
          x['encode'] = function (w) {
            for (var Y, T, X, E, W, I, j, D = [], V = 0x0, Z = w['length'], B = Z, S = 'string' !== p['getTypeOf'](w); V < w['length'];)
              B = Z - V,
                X = S ? (Y = w[V++],
                  T = V < Z ? w[V++] : 0x0,
                  V < Z ? w[V++] : 0x0) : (Y = w['charCodeAt'](V++),
                    T = V < Z ? w['charCodeAt'](V++) : 0x0,
                    V < Z ? w['charCodeAt'](V++) : 0x0),
                E = Y >> 0x2,
                W = (0x3 & Y) << 0x4 | T >> 0x4,
                I = 0x1 < B ? (0xf & T) << 0x2 | X >> 0x6 : 0x40,
                j = 0x2 < B ? 0x3f & X : 0x40,
                D['push'](y['charAt'](E) + y['charAt'](W) + y['charAt'](I) + y['charAt'](j));
            return D['join']('');
          }
            ,
            x['decode'] = function (w) {
              var Y, T, X, E, W, I, j = 0x0, D = 0x0, V = 'data:';
              if (w['substr'](0x0, 0x5) === V)
                throw new Error('Invalid\x20base64\x20input,\x20it\x20looks\x20like\x20a\x20data\x20url.');
              var Z, B = 0x3 * (w = w['replace'](/[^A-Za-z0-9+/=]/g, ''))['length'] / 0x4;
              if (w['charAt'](w['length'] - 0x1) === y['charAt'](0x40) && B--,
                w['charAt'](w['length'] - 0x2) === y['charAt'](0x40) && B--,
                B % 0x1 != 0x0)
                throw new Error('Invalid\x20base64\x20input,\x20bad\x20content\x20length.');
              for (Z = F['uint8array'] ? new Uint8Array(0x0 | B) : new Array(0x0 | B); j < w['length'];)
                Y = y['indexOf'](w['charAt'](j++)) << 0x2 | (E = y['indexOf'](w['charAt'](j++))) >> 0x4,
                  T = (0xf & E) << 0x4 | (W = y['indexOf'](w['charAt'](j++))) >> 0x2,
                  X = (0x3 & W) << 0x6 | (I = y['indexOf'](w['charAt'](j++))),
                  Z[D++] = Y,
                  0x40 !== W && (Z[D++] = T),
                  0x40 !== I && (Z[D++] = X);
              return Z;
            }
            ;
        }
          , {
          './support': 0x1e,
          './utils': 0x20
        }],
        0x2: [function (c, H, x) {
          'use strict';
          var p = c('./external')
            , F = c('./stream/DataWorker')
            , y = c('./stream/Crc32Probe')
            , w = c('./stream/DataLengthProbe');
          function h (u, Y, T, X, E) {
            this['compressedSize'] = u,
              this['uncompressedSize'] = Y,
              this['crc32'] = T,
              this['compression'] = X,
              this['compressedContent'] = E;
          }
          h['prototype'] = {
            'getContentWorker': function () {
              var u = new F(p['Promise']['resolve'](this['compressedContent']))['pipe'](this['compression']['uncompressWorker']())['pipe'](new w('data_length'))
                , Y = this;
              return u['on']('end', function () {
                if (this['streamInfo']['data_length'] !== Y['uncompressedSize'])
                  throw new Error('Bug\x20:\x20uncompressed\x20data\x20size\x20mismatch');
              }),
                u;
            },
            'getCompressedWorker': function () {
              return new F(p['Promise']['resolve'](this['compressedContent']))['withStreamInfo']('compressedSize', this['compressedSize'])['withStreamInfo']('uncompressedSize', this['uncompressedSize'])['withStreamInfo']('crc32', this['crc32'])['withStreamInfo']('compression', this['compression']);
            }
          },
            h['createWorkerFrom'] = function (u, Y, T) {
              return u['pipe'](new y())['pipe'](new w('uncompressedSize'))['pipe'](Y['compressWorker'](T))['pipe'](new w('compressedSize'))['withStreamInfo']('compression', Y);
            }
            ,
            H['exports'] = h;
        }
          , {
          './external': 0x6,
          './stream/Crc32Probe': 0x19,
          './stream/DataLengthProbe': 0x1a,
          './stream/DataWorker': 0x1b
        }],
        0x3: [function (c, H, x) {
          'use strict';
          var p = c('./stream/GenericWorker');
          x['STORE'] = {
            'magic': '\x00\x00',
            'compressWorker': function () {
              return new p('STORE\x20compression');
            },
            'uncompressWorker': function () {
              return new p('STORE\x20decompression');
            }
          },
            x['DEFLATE'] = c('./flate');
        }
          , {
          './flate': 0x7,
          './stream/GenericWorker': 0x1c
        }],
        0x4: [function (c, H, x) {
          'use strict';
          var p = c('./utils')
            , F = function () {
              for (var y, w = [], s = 0x0; s < 0x100; s++) {
                y = s;
                for (var h = 0x0; h < 0x8; h++)
                  y = 0x1 & y ? 0xedb88320 ^ y >>> 0x1 : y >>> 0x1;
                w[s] = y;
              }
              return w;
            }();
          H['exports'] = function (y, w) {
            return undefined !== y && y['length'] ? 'string' !== p['getTypeOf'](y) ? function (h, u, Y, T) {
              var X = F
                , E = 0x0 + Y;
              h ^= -0x1;
              for (var f = 0x0; f < E; f++)
                h = h >>> 0x8 ^ X[0xff & (h ^ u[f])];
              return -0x1 ^ h;
            }(0x0 | w, y, y['length']) : function (h, u, Y, T) {
              var X = F
                , E = 0x0 + Y;
              h ^= -0x1;
              for (var f = 0x0; f < E; f++)
                h = h >>> 0x8 ^ X[0xff & (h ^ u['charCodeAt'](f))];
              return -0x1 ^ h;
            }(0x0 | w, y, y['length']) : 0x0;
          }
            ;
        }
          , {
          './utils': 0x20
        }],
        0x5: [function (c, H, x) {
          'use strict';
          x['base64'] = false,
            x['binary'] = false,
            x['dir'] = false,
            x['createFolders'] = true,
            x['date'] = null,
            x['compression'] = null,
            x['compressionOptions'] = null,
            x['comment'] = null,
            x['unixPermissions'] = null,
            x['dosPermissions'] = null;
        }
          , {}],
        0x6: [function (c, H, x) {
          'use strict';
          var p;
          p = 'undefined' != typeof Promise ? Promise : c('lie'),
            H['exports'] = {
              'Promise': p
            };
        }
          , {
          'lie': 0x25
        }],
        0x7: [function (c, H, x) {
          'use strict';
          var p = 'undefined' != typeof Uint8Array && 'undefined' != typeof Uint16Array && 'undefined' != typeof Uint32Array
            , F = c('pako')
            , y = c('./utils')
            , w = c('./stream/GenericWorker')
            , h = p ? 'uint8array' : 'array';
          function u (Y, T) {
            w['call'](this, 'FlateWorker/' + Y),
              this['_pako'] = null,
              this['_pakoAction'] = Y,
              this['_pakoOptions'] = T,
              this['meta'] = {};
          }
          x['magic'] = '\x08\x00',
            y['inherits'](u, w),
            u['prototype']['processChunk'] = function (Y) {
              this['meta'] = Y['meta'],
                null === this['_pako'] && this['_createPako'](),
                this['_pako']['push'](y['transformTo'](h, Y['data']), false);
            }
            ,
            u['prototype']['flush'] = function () {
              w['prototype']['flush']['call'](this),
                null === this['_pako'] && this['_createPako'](),
                this['_pako']['push']([], true);
            }
            ,
            u['prototype']['cleanUp'] = function () {
              w['prototype']['cleanUp']['call'](this),
                this['_pako'] = null;
            }
            ,
            u['prototype']['_createPako'] = function () {
              this['_pako'] = new F[this['_pakoAction']]({
                'raw': true,
                'level': this['_pakoOptions']['level'] || -0x1
              });
              var Y = this;
              this['_pako']['onData'] = function (T) {
                Y['push']({
                  'data': T,
                  'meta': Y['meta']
                });
              }
                ;
            }
            ,
            x['compressWorker'] = function (Y) {
              return new u('Deflate', Y);
            }
            ,
            x['uncompressWorker'] = function () {
              return new u('Inflate', {});
            }
            ;
        }
          , {
          './stream/GenericWorker': 0x1c,
          './utils': 0x20,
          'pako': 0x26
        }],
        0x8: [function (c, H, x) {
          'use strict';
          function p (f, W) {
            var I, j = '';
            for (I = 0x0; I < W; I++)
              j += String['fromCharCode'](0xff & f),
                f >>>= 0x8;
            return j;
          }
          function F (W, j, V, Z, B, U) {
            var q, J, G = W['file'], N = W['compression'], M = U !== Y['utf8encode'], z = y['transformTo']('string', U(G['name'])), Q = y['transformTo']('string', Y['utf8encode'](G['name'])), R = G['comment'], v0 = y['transformTo']('string', U(R)), v1 = y['transformTo']('string', Y['utf8encode'](R)), v2 = Q['length'] !== G['name']['length'], v3 = v1['length'] !== R['length'], v4 = '', v5 = '', v6 = '', v7 = G['dir'], v8 = G['date'], v9 = {
              'crc32': 0x0,
              'compressedSize': 0x0,
              'uncompressedSize': 0x0
            };
            j && !V || (v9['crc32'] = W['crc32'],
              v9['compressedSize'] = W['compressedSize'],
              v9['uncompressedSize'] = W['uncompressedSize']);
            var vv = 0x0;
            j && (vv |= 0x8),
              M || !v2 && !v3 || (vv |= 0x800);
            var vA = 0x0
              , vn = 0x0;
            v7 && (vA |= 0x10),
              'UNIX' === B ? (vn = 0x31e,
                vA |= function (vl, vK) {
                  var vi = vl;
                  return vl || (vi = vK ? 0x41fd : 0x81b4),
                    (0xffff & vi) << 0x10;
                }(G['unixPermissions'], v7)) : (vn = 0x14,
                  vA |= function (vl) {
                    return 0x3f & (vl || 0x0);
                  }(G['dosPermissions'])),
              q = v8['getUTCHours'](),
              q <<= 0x6,
              q |= v8['getUTCMinutes'](),
              q <<= 0x5,
              q |= v8['getUTCSeconds']() / 0x2,
              J = v8['getUTCFullYear']() - 0x7bc,
              J <<= 0x4,
              J |= v8['getUTCMonth']() + 0x1,
              J <<= 0x5,
              J |= v8['getUTCDate'](),
              v2 && (v5 = p(0x1, 0x1) + p(T(z), 0x4) + Q,
                v4 += 'up' + p(v5['length'], 0x2) + v5),
              v3 && (v6 = p(0x1, 0x1) + p(T(v0), 0x4) + v1,
                v4 += 'uc' + p(v6['length'], 0x2) + v6);
            var vk = '';
            return vk += '\x0a\x00',
              vk += p(vv, 0x2),
              vk += N['magic'],
              vk += p(q, 0x2),
              vk += p(J, 0x2),
              vk += p(v9['crc32'], 0x4),
              vk += p(v9['compressedSize'], 0x4),
              vk += p(v9['uncompressedSize'], 0x4),
              vk += p(z['length'], 0x2),
              vk += p(v4['length'], 0x2),
            {
              'fileRecord': X['LOCAL_FILE_HEADER'] + vk + z + v4,
              'dirRecord': X['CENTRAL_FILE_HEADER'] + p(vn, 0x2) + vk + p(v0['length'], 0x2) + '\x00\x00\x00\x00' + p(vA, 0x4) + p(Z, 0x4) + z + v4 + v0
            };
          }
          var y = c('../utils')
            , w = c('../stream/GenericWorker')
            , Y = c('../utf8')
            , T = c('../crc32')
            , X = c('../signature');
          function E (f, W, I, j) {
            w['call'](this, 'ZipFileWorker'),
              this['bytesWritten'] = 0x0,
              this['zipComment'] = W,
              this['zipPlatform'] = I,
              this['encodeFileName'] = j,
              this['streamFiles'] = f,
              this['accumulate'] = false,
              this['contentBuffer'] = [],
              this['dirRecords'] = [],
              this['currentSourceOffset'] = 0x0,
              this['entriesCount'] = 0x0,
              this['currentFile'] = null,
              this['_sources'] = [];
          }
          y['inherits'](E, w),
            E['prototype']['push'] = function (f) {
              var W = f['meta']['percent'] || 0x0
                , I = this['entriesCount']
                , j = this['_sources']['length'];
              this['accumulate'] ? this['contentBuffer']['push'](f) : (this['bytesWritten'] += f['data']['length'],
                w['prototype']['push']['call'](this, {
                  'data': f['data'],
                  'meta': {
                    'currentFile': this['currentFile'],
                    'percent': I ? (W + 0x64 * (I - j - 0x1)) / I : 0x64
                  }
                }));
            }
            ,
            E['prototype']['openedSource'] = function (f) {
              this['currentSourceOffset'] = this['bytesWritten'],
                this['currentFile'] = f['file']['name'];
              var W = this['streamFiles'] && !f['file']['dir'];
              if (W) {
                var I = F(f, W, false, this['currentSourceOffset'], this['zipPlatform'], this['encodeFileName']);
                this['push']({
                  'data': I['fileRecord'],
                  'meta': {
                    'percent': 0x0
                  }
                });
              } else
                this['accumulate'] = true;
            }
            ,
            E['prototype']['closedSource'] = function (f) {
              this['accumulate'] = false;
              var W = this['streamFiles'] && !f['file']['dir']
                , I = F(f, W, true, this['currentSourceOffset'], this['zipPlatform'], this['encodeFileName']);
              if (this['dirRecords']['push'](I['dirRecord']),
                W)
                this['push']({
                  'data': function (j) {
                    return X['DATA_DESCRIPTOR'] + p(j['crc32'], 0x4) + p(j['compressedSize'], 0x4) + p(j['uncompressedSize'], 0x4);
                  }(f),
                  'meta': {
                    'percent': 0x64
                  }
                });
              else {
                for (this['push']({
                  'data': I['fileRecord'],
                  'meta': {
                    'percent': 0x0
                  }
                }); this['contentBuffer']['length'];)
                  this['push'](this['contentBuffer']['shift']());
              }
              this['currentFile'] = null;
            }
            ,
            E['prototype']['flush'] = function () {
              for (var f = this['bytesWritten'], W = 0x0; W < this['dirRecords']['length']; W++)
                this['push']({
                  'data': this['dirRecords'][W],
                  'meta': {
                    'percent': 0x64
                  }
                });
              var I = this['bytesWritten'] - f
                , j = function (D, V, Z, B, S) {
                  var U = y['transformTo']('string', S(B));
                  return X['CENTRAL_DIRECTORY_END'] + '\x00\x00\x00\x00' + p(D, 0x2) + p(D, 0x2) + p(V, 0x4) + p(Z, 0x4) + p(U['length'], 0x2) + U;
                }(this['dirRecords']['length'], I, f, this['zipComment'], this['encodeFileName']);
              this['push']({
                'data': j,
                'meta': {
                  'percent': 0x64
                }
              });
            }
            ,
            E['prototype']['prepareNextSource'] = function () {
              this['previous'] = this['_sources']['shift'](),
                this['openedSource'](this['previous']['streamInfo']),
                this['isPaused'] ? this['previous']['pause']() : this['previous']['resume']();
            }
            ,
            E['prototype']['registerPrevious'] = function (f) {
              this['_sources']['push'](f);
              var W = this;
              return f['on']('data', function (I) {
                W['processChunk'](I);
              }),
                f['on']('end', function () {
                  W['closedSource'](W['previous']['streamInfo']),
                    W['_sources']['length'] ? W['prepareNextSource']() : W['end']();
                }),
                f['on']('error', function (I) {
                  W['error'](I);
                }),
                this;
            }
            ,
            E['prototype']['resume'] = function () {
              return !!w['prototype']['resume']['call'](this) && (!this['previous'] && this['_sources']['length'] ? (this['prepareNextSource'](),
                true) : this['previous'] || this['_sources']['length'] || this['generatedError'] ? undefined : (this['end'](),
                  true));
            }
            ,
            E['prototype']['error'] = function (f) {
              var W = this['_sources'];
              if (!w['prototype']['error']['call'](this, f))
                return false;
              for (var I = 0x0; I < W['length']; I++)
                try {
                  W[I]['error'](f);
                } catch (j) { }
              return true;
            }
            ,
            E['prototype']['lock'] = function () {
              w['prototype']['lock']['call'](this);
              for (var f = this['_sources'], W = 0x0; W < f['length']; W++)
                f[W]['lock']();
            }
            ,
            H['exports'] = E;
        }
          , {
          '../crc32': 0x4,
          '../signature': 0x17,
          '../stream/GenericWorker': 0x1c,
          '../utf8': 0x1f,
          '../utils': 0x20
        }],
        0x9: [function (c, H, x) {
          'use strict';
          var p = c('../compressions')
            , F = c('./ZipFileWorker');
          x['generateWorker'] = function (y, w, h) {
            var u = new F(w['streamFiles'], h, w['platform'], w['encodeFileName'])
              , Y = 0x0;
            try {
              y['forEach'](function (T, X) {
                Y++;
                var E = function (j, D) {
                  var V = j || D
                    , Z = p[V];
                  if (!Z)
                    throw new Error(V + '\x20is\x20not\x20a\x20valid\x20compression\x20method\x20!');
                  return Z;
                }(X['options']['compression'], w['compression'])
                  , f = X['options']['compressionOptions'] || w['compressionOptions'] || {}
                  , W = X['dir']
                  , I = X['date'];
                X['_compressWorker'](E, f)['withStreamInfo']('file', {
                  'name': T,
                  'dir': W,
                  'date': I,
                  'comment': X['comment'] || '',
                  'unixPermissions': X['unixPermissions'],
                  'dosPermissions': X['dosPermissions']
                })['pipe'](u);
              }),
                u['entriesCount'] = Y;
            } catch (T) {
              u['error'](T);
            }
            return u;
          }
            ;
        }
          , {
          '../compressions': 0x3,
          './ZipFileWorker': 0x8
        }],
        0xa: [function (c, H, x) {
          'use strict';
          function p () {
            if (!(this instanceof p))
              return new p();
            if (arguments['length'])
              throw new Error('The\x20constructor\x20with\x20parameters\x20has\x20been\x20removed\x20in\x20JSZip\x203.0,\x20please\x20check\x20the\x20upgrade\x20guide.');
            this['files'] = Object['create'](null),
              this['comment'] = null,
              this['root'] = '',
              this['clone'] = function () {
                var F = new p();
                for (var y in this)
                  'function' != typeof this[y] && (F[y] = this[y]);
                return F;
              }
              ;
          }
          (p['prototype'] = c('./object'))['loadAsync'] = c('./load'),
            p['support'] = c('./support'),
            p['defaults'] = c('./defaults'),
            p['version'] = '3.10.1',
            p['loadAsync'] = function (F, y) {
              return new p()['loadAsync'](F, y);
            }
            ,
            p['external'] = c('./external'),
            H['exports'] = p;
        }
          , {
          './defaults': 0x5,
          './external': 0x6,
          './load': 0xb,
          './object': 0xf,
          './support': 0x1e
        }],
        0xb: [function (c, H, x) {
          'use strict';
          var p = c('./utils')
            , F = c('./external')
            , y = c('./utf8')
            , w = c('./zipEntries')
            , h = c('./stream/Crc32Probe')
            , Y = c('./nodejsUtils');
          function T (X) {
            return new F['Promise'](function (E, f) {
              var W = X['decompressed']['getContentWorker']()['pipe'](new h());
              W['on']('error', function (I) {
                f(I);
              })['on']('end', function () {
                W['streamInfo']['crc32'] !== X['decompressed']['crc32'] ? f(new Error('Corrupted\x20zip\x20:\x20CRC32\x20mismatch')) : E();
              })['resume']();
            }
            );
          }
          H['exports'] = function (X, E) {
            var f = this;
            return E = p['extend'](E || {}, {
              'base64': false,
              'checkCRC32': false,
              'optimizedBinaryString': false,
              'createFolders': false,
              'decodeFileName': y['utf8decode']
            }),
              Y['isNode'] && Y['isStream'](X) ? F['Promise']['reject'](new Error('JSZip\x20can\x27t\x20accept\x20a\x20stream\x20when\x20loading\x20a\x20zip\x20file.')) : p['prepareContent']('the\x20loaded\x20zip\x20file', X, true, E['optimizedBinaryString'], E['base64'])['then'](function (W) {
                var I = new w(E);
                return I['load'](W),
                  I;
              })['then'](function (W) {
                var I = [F['Promise']['resolve'](W)]
                  , j = W['files'];
                if (E['checkCRC32']) {
                  for (var D = 0x0; D < j['length']; D++)
                    I['push'](T(j[D]));
                }
                return F['Promise']['all'](I);
              })['then'](function (W) {
                for (var I = W['shift'](), j = I['files'], D = 0x0; D < j['length']; D++) {
                  var V = j[D]
                    , Z = V['fileNameStr']
                    , B = p['resolve'](V['fileNameStr']);
                  f['file'](B, V['decompressed'], {
                    'binary': true,
                    'optimizedBinaryString': true,
                    'date': V['date'],
                    'dir': V['dir'],
                    'comment': V['fileCommentStr']['length'] ? V['fileCommentStr'] : null,
                    'unixPermissions': V['unixPermissions'],
                    'dosPermissions': V['dosPermissions'],
                    'createFolders': E['createFolders']
                  }),
                    V['dir'] || (f['file'](B)['unsafeOriginalName'] = Z);
                }
                return I['zipComment']['length'] && (f['comment'] = I['zipComment']),
                  f;
              });
          }
            ;
        }
          , {
          './external': 0x6,
          './nodejsUtils': 0xe,
          './stream/Crc32Probe': 0x19,
          './utf8': 0x1f,
          './utils': 0x20,
          './zipEntries': 0x21
        }],
        0xc: [function (c, H, x) {
          'use strict';
          var p = c('../utils')
            , F = c('../stream/GenericWorker');
          function y (w, h) {
            F['call'](this, 'Nodejs\x20stream\x20input\x20adapter\x20for\x20' + w),
              this['_upstreamEnded'] = false,
              this['_bindStream'](h);
          }
          p['inherits'](y, F),
            y['prototype']['_bindStream'] = function (w) {
              var h = this;
              (this['_stream'] = w)['pause'](),
                w['on']('data', function (u) {
                  h['push']({
                    'data': u,
                    'meta': {
                      'percent': 0x0
                    }
                  });
                })['on']('error', function (u) {
                  h['isPaused'] ? this['generatedError'] = u : h['error'](u);
                })['on']('end', function () {
                  h['isPaused'] ? h['_upstreamEnded'] = true : h['end']();
                });
            }
            ,
            y['prototype']['pause'] = function () {
              return !!F['prototype']['pause']['call'](this) && (this['_stream']['pause'](),
                true);
            }
            ,
            y['prototype']['resume'] = function () {
              return !!F['prototype']['resume']['call'](this) && (this['_upstreamEnded'] ? this['end']() : this['_stream']['resume'](),
                true);
            }
            ,
            H['exports'] = y;
        }
          , {
          '../stream/GenericWorker': 0x1c,
          '../utils': 0x20
        }],
        0xd: [function (c, H, x) {
          'use strict';
          var p = c('readable-stream')['Readable'];
          function F (y, w, s) {
            p['call'](this, w),
              this['_helper'] = y;
            var h = this;
            y['on']('data', function (u, Y) {
              h['push'](u) || h['_helper']['pause'](),
                s && s(Y);
            })['on']('error', function (u) {
              h['emit']('error', u);
            })['on']('end', function () {
              h['push'](null);
            });
          }
          c('../utils')['inherits'](F, p),
            F['prototype']['_read'] = function () {
              this['_helper']['resume']();
            }
            ,
            H['exports'] = F;
        }
          , {
          '../utils': 0x20,
          'readable-stream': 0x10
        }],
        0xe: [function (c, H, x) {
          'use strict';
          H['exports'] = {
            'isNode': 'undefined' != typeof Buffer,
            'newBufferFrom': function (p, F) {
              if (Buffer['from'] && Buffer['from'] !== Uint8Array['from'])
                return Buffer['from'](p, F);
              if ('number' == typeof p)
                throw new Error('The\x20\x22data\x22\x20argument\x20must\x20not\x20be\x20a\x20number');
              return new Buffer(p, F);
            },
            'allocBuffer': function (p) {
              if (Buffer['alloc'])
                return Buffer['alloc'](p);
              var F = new Buffer(p);
              return F['fill'](0x0),
                F;
            },
            'isBuffer': function (p) {
              return Buffer['isBuffer'](p);
            },
            'isStream': function (p) {
              return p && 'function' == typeof p['on'] && 'function' == typeof p['pause'] && 'function' == typeof p['resume'];
            }
          };
        }
          , {}],
        0xf: [function (H, x, F) {
          'use strict';
          function w (C, O, G) {
            var N, P = T['getTypeOf'](O), M = T['extend'](G || {}, W);
            M['date'] = M['date'] || new Date(),
              null !== M['compression'] && (M['compression'] = M['compression']['toUpperCase']()),
              'string' == typeof M['unixPermissions'] && (M['unixPermissions'] = parseInt(M['unixPermissions'], 0x8)),
              M['unixPermissions'] && 0x4000 & M['unixPermissions'] && (M['dir'] = true),
              M['dosPermissions'] && 0x10 & M['dosPermissions'] && (M['dir'] = true),
              M['dir'] && (C = S(C)),
              M['createFolders'] && (N = B(C)) && U['call'](this, N, true);
            var z = 'string' === P && false === M['binary'] && false === M['base64'];
            G && undefined !== G['binary'] || (M['binary'] = !z),
              (O instanceof I && 0x0 === O['uncompressedSize'] || M['dir'] || !O || 0x0 === O['length']) && (M['base64'] = false,
                M['binary'] = true,
                O = '',
                M['compression'] = 'STORE',
                P = 'string');
            var Q;
            Q = O instanceof I || O instanceof X ? O : V['isNode'] && V['isStream'](O) ? new Z(C, O) : T['prepareContent'](C, O, M['binary'], M['optimizedBinaryString'], M['base64']);
            var L = new j(C, Q, M);
            this['files'][C] = L;
          }
          var Y = H('./utf8')
            , T = H('./utils')
            , X = H('./stream/GenericWorker')
            , E = H('./stream/StreamHelper')
            , W = H('./defaults')
            , I = H('./compressedObject')
            , j = H('./zipObject')
            , D = H('./generate')
            , V = H('./nodejsUtils')
            , Z = H('./nodejs/NodejsStreamInputAdapter')
            , B = function (C) {
              '/' === C['slice'](-0x1) && (C = C['substring'](0x0, C['length'] - 0x1));
              var O = C['lastIndexOf']('/');
              return 0x0 < O ? C['substring'](0x0, O) : '';
            }
            , S = function (C) {
              return '/' !== C['slice'](-0x1) && (C += '/'),
                C;
            }
            , U = function (C, O) {
              return O = undefined !== O ? O : W['createFolders'],
                C = S(C),
                this['files'][C] || w['call'](this, C, null, {
                  'dir': true,
                  'createFolders': O
                }),
                this['files'][C];
            };
          function q (C) {
            return '[object\x20RegExp]' === Object['prototype']['toString']['call'](C);
          }
          var J = {
            'load': function () {
              throw new Error('This\x20method\x20has\x20been\x20removed\x20in\x20JSZip\x203.0,\x20please\x20check\x20the\x20upgrade\x20guide.');
            },
            'forEach': function (C) {
              var O, G, N;
              for (O in this['files'])
                N = this['files'][O],
                  (G = O['slice'](this['root']['length'], O['length'])) && O['slice'](0x0, this['root']['length']) === this['root'] && C(G, N);
            },
            'filter': function (C) {
              var O = [];
              return this['forEach'](function (G, N) {
                C(G, N) && O['push'](N);
              }),
                O;
            },
            'file': function (C, O, G) {
              if (0x1 !== arguments['length'])
                return C = this['root'] + C,
                  w['call'](this, C, O, G),
                  this;
              if (q(C)) {
                var N = C;
                return this['filter'](function (M, z) {
                  return !z['dir'] && N['test'](M);
                });
              }
              var P = this['files'][this['root'] + C];
              return P && !P['dir'] ? P : null;
            },
            'folder': function (C) {
              if (!C)
                return this;
              if (q(C))
                return this['filter'](function (P, M) {
                  return M['dir'] && C['test'](P);
                });
              var O = this['root'] + C
                , G = U['call'](this, O)
                , N = this['clone']();
              return N['root'] = G['name'],
                N;
            },
            'remove': function (C) {
              C = this['root'] + C;
              var O = this['files'][C];
              if (O || ('/' !== C['slice'](-0x1) && (C += '/'),
                O = this['files'][C]),
                O && !O['dir'])
                delete this['files'][C];
              else {
                for (var G = this['filter'](function (P, M) {
                  return M['name']['slice'](0x0, C['length']) === C;
                }), N = 0x0; N < G['length']; N++)
                  delete this['files'][G[N]['name']];
              }
              return this;
            },
            'generate': function () {
              throw new Error('This\x20method\x20has\x20been\x20removed\x20in\x20JSZip\x203.0,\x20please\x20check\x20the\x20upgrade\x20guide.');
            },
            'generateInternalStream': function (C) {
              var O, G = {};
              try {
                if ((G = T['extend'](C || {}, {
                  'streamFiles': false,
                  'compression': 'STORE',
                  'compressionOptions': null,
                  'type': '',
                  'platform': 'DOS',
                  'comment': null,
                  'mimeType': 'application/zip',
                  'encodeFileName': Y['utf8encode']
                }))['type'] = G['type']['toLowerCase'](),
                  G['compression'] = G['compression']['toUpperCase'](),
                  'binarystring' === G['type'] && (G['type'] = 'string'),
                  !G['type'])
                  throw new Error('No\x20output\x20type\x20specified.');
                T['checkSupport'](G['type']),
                  'darwin' !== G['platform'] && 'freebsd' !== G['platform'] && 'linux' !== G['platform'] && 'sunos' !== G['platform'] || (G['platform'] = 'UNIX'),
                  'win32' === G['platform'] && (G['platform'] = 'DOS');
                var N = G['comment'] || this['comment'] || '';
                O = D['generateWorker'](this, G, N);
              } catch (P) {
                (O = new X('error'))['error'](P);
              }
              return new E(O, G['type'] || 'string', G['mimeType']);
            },
            'generateAsync': function (C, O) {
              return this['generateInternalStream'](C)['accumulate'](O);
            },
            'generateNodeStream': function (C, O) {
              return (C = C || {})['type'] || (C['type'] = 'nodebuffer'),
                this['generateInternalStream'](C)['toNodejsStream'](O);
            }
          };
          x['exports'] = J;
        }
          , {
          './compressedObject': 0x2,
          './defaults': 0x5,
          './generate': 0x9,
          './nodejs/NodejsStreamInputAdapter': 0xc,
          './nodejsUtils': 0xe,
          './stream/GenericWorker': 0x1c,
          './stream/StreamHelper': 0x1d,
          './utf8': 0x1f,
          './utils': 0x20,
          './zipObject': 0x23
        }],
        0x10: [function (c, H, x) {
          'use strict';
          H['exports'] = c('stream');
        }
          , {
          'stream': undefined
        }],
        0x11: [function (c, H, x) {
          'use strict';
          var p = c('./DataReader');
          function F (y) {
            p['call'](this, y);
            for (var w = 0x0; w < this['data']['length']; w++)
              y[w] = 0xff & y[w];
          }
          c('../utils')['inherits'](F, p),
            F['prototype']['byteAt'] = function (y) {
              return this['data'][this['zero'] + y];
            }
            ,
            F['prototype']['lastIndexOfSignature'] = function (y) {
              for (var w = y['charCodeAt'](0x0), h = y['charCodeAt'](0x1), u = y['charCodeAt'](0x2), Y = y['charCodeAt'](0x3), T = this['length'] - 0x4; 0x0 <= T; --T)
                if (this['data'][T] === w && this['data'][T + 0x1] === h && this['data'][T + 0x2] === u && this['data'][T + 0x3] === Y)
                  return T - this['zero'];
              return -0x1;
            }
            ,
            F['prototype']['readAndCheckSignature'] = function (y) {
              var w = y['charCodeAt'](0x0)
                , h = y['charCodeAt'](0x1)
                , u = y['charCodeAt'](0x2)
                , Y = y['charCodeAt'](0x3)
                , T = this['readData'](0x4);
              return w === T[0x0] && h === T[0x1] && u === T[0x2] && Y === T[0x3];
            }
            ,
            F['prototype']['readData'] = function (y) {
              if (this['checkOffset'](y),
                0x0 === y)
                return [];
              var w = this['data']['slice'](this['zero'] + this['index'], this['zero'] + this['index'] + y);
              return this['index'] += y,
                w;
            }
            ,
            H['exports'] = F;
        }
          , {
          '../utils': 0x20,
          './DataReader': 0x12
        }],
        0x12: [function (c, H, x) {
          'use strict';
          var p = c('../utils');
          function F (y) {
            this['data'] = y,
              this['length'] = y['length'],
              this['index'] = 0x0,
              this['zero'] = 0x0;
          }
          F['prototype'] = {
            'checkOffset': function (y) {
              this['checkIndex'](this['index'] + y);
            },
            'checkIndex': function (y) {
              if (this['length'] < this['zero'] + y || y < 0x0)
                throw new Error('End\x20of\x20data\x20reached\x20(data\x20length\x20=\x20' + this['length'] + ',\x20asked\x20index\x20=\x20' + y + ').\x20Corrupted\x20zip\x20?');
            },
            'setIndex': function (y) {
              this['checkIndex'](y),
                this['index'] = y;
            },
            'skip': function (y) {
              this['setIndex'](this['index'] + y);
            },
            'byteAt': function () { },
            'readInt': function (y) {
              var w, s = 0x0;
              for (this['checkOffset'](y),
                w = this['index'] + y - 0x1; w >= this['index']; w--)
                s = (s << 0x8) + this['byteAt'](w);
              return this['index'] += y,
                s;
            },
            'readString': function (y) {
              return p['transformTo']('string', this['readData'](y));
            },
            'readData': function () { },
            'lastIndexOfSignature': function () { },
            'readAndCheckSignature': function () { },
            'readDate': function () {
              var y = this['readInt'](0x4);
              return new Date(Date['UTC'](0x7bc + (y >> 0x19 & 0x7f), (y >> 0x15 & 0xf) - 0x1, y >> 0x10 & 0x1f, y >> 0xb & 0x1f, y >> 0x5 & 0x3f, (0x1f & y) << 0x1));
            }
          },
            H['exports'] = F;
        }
          , {
          '../utils': 0x20
        }],
        0x13: [function (c, H, x) {
          'use strict';
          var p = c('./Uint8ArrayReader');
          function F (y) {
            p['call'](this, y);
          }
          c('../utils')['inherits'](F, p),
            F['prototype']['readData'] = function (y) {
              this['checkOffset'](y);
              var w = this['data']['slice'](this['zero'] + this['index'], this['zero'] + this['index'] + y);
              return this['index'] += y,
                w;
            }
            ,
            H['exports'] = F;
        }
          , {
          '../utils': 0x20,
          './Uint8ArrayReader': 0x15
        }],
        0x14: [function (c, H, x) {
          'use strict';
          var p = c('./DataReader');
          function F (y) {
            p['call'](this, y);
          }
          c('../utils')['inherits'](F, p),
            F['prototype']['byteAt'] = function (y) {
              return this['data']['charCodeAt'](this['zero'] + y);
            }
            ,
            F['prototype']['lastIndexOfSignature'] = function (y) {
              return this['data']['lastIndexOf'](y) - this['zero'];
            }
            ,
            F['prototype']['readAndCheckSignature'] = function (y) {
              return y === this['readData'](0x4);
            }
            ,
            F['prototype']['readData'] = function (y) {
              this['checkOffset'](y);
              var w = this['data']['slice'](this['zero'] + this['index'], this['zero'] + this['index'] + y);
              return this['index'] += y,
                w;
            }
            ,
            H['exports'] = F;
        }
          , {
          '../utils': 0x20,
          './DataReader': 0x12
        }],
        0x15: [function (c, H, x) {
          'use strict';
          var p = c('./ArrayReader');
          function F (y) {
            p['call'](this, y);
          }
          c('../utils')['inherits'](F, p),
            F['prototype']['readData'] = function (y) {
              if (this['checkOffset'](y),
                0x0 === y)
                return new Uint8Array(0x0);
              var w = this['data']['subarray'](this['zero'] + this['index'], this['zero'] + this['index'] + y);
              return this['index'] += y,
                w;
            }
            ,
            H['exports'] = F;
        }
          , {
          '../utils': 0x20,
          './ArrayReader': 0x11
        }],
        0x16: [function (c, H, x) {
          'use strict';
          var p = c('../utils')
            , F = c('../support')
            , y = c('./ArrayReader')
            , w = c('./StringReader')
            , h = c('./NodeBufferReader')
            , u = c('./Uint8ArrayReader');
          H['exports'] = function (Y) {
            var T = p['getTypeOf'](Y);
            return p['checkSupport'](T),
              'string' !== T || F['uint8array'] ? 'nodebuffer' === T ? new h(Y) : F['uint8array'] ? new u(p['transformTo']('uint8array', Y)) : new y(p['transformTo']('array', Y)) : new w(Y);
          }
            ;
        }
          , {
          '../support': 0x1e,
          '../utils': 0x20,
          './ArrayReader': 0x11,
          './NodeBufferReader': 0x13,
          './StringReader': 0x14,
          './Uint8ArrayReader': 0x15
        }],
        0x17: [function (c, H, x) {
          'use strict';
          x['LOCAL_FILE_HEADER'] = 'PK\x03\x04',
            x['CENTRAL_FILE_HEADER'] = 'PK\x01\x02',
            x['CENTRAL_DIRECTORY_END'] = 'PK\x05\x06',
            x['ZIP64_CENTRAL_DIRECTORY_LOCATOR'] = 'PK\x06\x07',
            x['ZIP64_CENTRAL_DIRECTORY_END'] = 'PK\x06\x06',
            x['DATA_DESCRIPTOR'] = 'PK\x07\x08';
        }
          , {}],
        0x18: [function (c, H, x) {
          'use strict';
          var p = c('./GenericWorker')
            , F = c('../utils');
          function y (w) {
            p['call'](this, 'ConvertWorker\x20to\x20' + w),
              this['destType'] = w;
          }
          F['inherits'](y, p),
            y['prototype']['processChunk'] = function (w) {
              this['push']({
                'data': F['transformTo'](this['destType'], w['data']),
                'meta': w['meta']
              });
            }
            ,
            H['exports'] = y;
        }
          , {
          '../utils': 0x20,
          './GenericWorker': 0x1c
        }],
        0x19: [function (c, H, x) {
          'use strict';
          var p = c('./GenericWorker')
            , F = c('../crc32');
          function y () {
            p['call'](this, 'Crc32Probe'),
              this['withStreamInfo']('crc32', 0x0);
          }
          c('../utils')['inherits'](y, p),
            y['prototype']['processChunk'] = function (w) {
              this['streamInfo']['crc32'] = F(w['data'], this['streamInfo']['crc32'] || 0x0),
                this['push'](w);
            }
            ,
            H['exports'] = y;
        }
          , {
          '../crc32': 0x4,
          '../utils': 0x20,
          './GenericWorker': 0x1c
        }],
        0x1a: [function (c, H, x) {
          'use strict';
          var p = c('../utils')
            , F = c('./GenericWorker');
          function y (w) {
            F['call'](this, 'DataLengthProbe\x20for\x20' + w),
              this['propName'] = w,
              this['withStreamInfo'](w, 0x0);
          }
          p['inherits'](y, F),
            y['prototype']['processChunk'] = function (w) {
              if (w) {
                var h = this['streamInfo'][this['propName']] || 0x0;
                this['streamInfo'][this['propName']] = h + w['data']['length'];
              }
              F['prototype']['processChunk']['call'](this, w);
            }
            ,
            H['exports'] = y;
        }
          , {
          '../utils': 0x20,
          './GenericWorker': 0x1c
        }],
        0x1b: [function (c, H, x) {
          'use strict';
          var p = c('../utils')
            , F = c('./GenericWorker');
          function y (w) {
            F['call'](this, 'DataWorker');
            var h = this;
            this['dataIsReady'] = false,
              this['index'] = 0x0,
              this['max'] = 0x0,
              this['data'] = null,
              this['type'] = '',
              this['_tickScheduled'] = false,
              w['then'](function (u) {
                h['dataIsReady'] = true,
                  h['data'] = u,
                  h['max'] = u && u['length'] || 0x0,
                  h['type'] = p['getTypeOf'](u),
                  h['isPaused'] || h['_tickAndRepeat']();
              }, function (u) {
                h['error'](u);
              });
          }
          p['inherits'](y, F),
            y['prototype']['cleanUp'] = function () {
              F['prototype']['cleanUp']['call'](this),
                this['data'] = null;
            }
            ,
            y['prototype']['resume'] = function () {
              return !!F['prototype']['resume']['call'](this) && (!this['_tickScheduled'] && this['dataIsReady'] && (this['_tickScheduled'] = true,
                p['delay'](this['_tickAndRepeat'], [], this)),
                true);
            }
            ,
            y['prototype']['_tickAndRepeat'] = function () {
              this['_tickScheduled'] = false,
                this['isPaused'] || this['isFinished'] || (this['_tick'](),
                  this['isFinished'] || (p['delay'](this['_tickAndRepeat'], [], this),
                    this['_tickScheduled'] = true));
            }
            ,
            y['prototype']['_tick'] = function () {
              if (this['isPaused'] || this['isFinished'])
                return false;
              var w = null
                , h = Math['min'](this['max'], this['index'] + 0x4000);
              if (this['index'] >= this['max'])
                return this['end']();
              switch (this['type']) {
                case 'string':
                  w = this['data']['substring'](this['index'], h);
                  break;
                case 'uint8array':
                  w = this['data']['subarray'](this['index'], h);
                  break;
                case 'array':
                case 'nodebuffer':
                  w = this['data']['slice'](this['index'], h);
              }
              return this['index'] = h,
                this['push']({
                  'data': w,
                  'meta': {
                    'percent': this['max'] ? this['index'] / this['max'] * 0x64 : 0x0
                  }
                });
            }
            ,
            H['exports'] = y;
        }
          , {
          '../utils': 0x20,
          './GenericWorker': 0x1c
        }],
        0x1c: [function (c, H, x) {
          'use strict';
          function p (F) {
            this['name'] = F || 'default',
              this['streamInfo'] = {},
              this['generatedError'] = null,
              this['extraStreamInfo'] = {},
              this['isPaused'] = true,
              this['isFinished'] = false,
              this['isLocked'] = false,
              this['_listeners'] = {
                'data': [],
                'end': [],
                'error': []
              },
              this['previous'] = null;
          }
          p['prototype'] = {
            'push': function (F) {
              this['emit']('data', F);
            },
            'end': function () {
              if (this['isFinished'])
                return false;
              this['flush']();
              try {
                this['emit']('end'),
                  this['cleanUp'](),
                  this['isFinished'] = true;
              } catch (F) {
                this['emit']('error', F);
              }
              return true;
            },
            'error': function (F) {
              return !this['isFinished'] && (this['isPaused'] ? this['generatedError'] = F : (this['isFinished'] = true,
                this['emit']('error', F),
                this['previous'] && this['previous']['error'](F),
                this['cleanUp']()),
                true);
            },
            'on': function (F, y) {
              return this['_listeners'][F]['push'](y),
                this;
            },
            'cleanUp': function () {
              this['streamInfo'] = this['generatedError'] = this['extraStreamInfo'] = null,
                this['_listeners'] = [];
            },
            'emit': function (F, y) {
              if (this['_listeners'][F]) {
                for (var w = 0x0; w < this['_listeners'][F]['length']; w++)
                  this['_listeners'][F][w]['call'](this, y);
              }
            },
            'pipe': function (F) {
              return F['registerPrevious'](this);
            },
            'registerPrevious': function (F) {
              if (this['isLocked'])
                throw new Error('The\x20stream\x20\x27' + this + '\x27\x20has\x20already\x20been\x20used.');
              this['streamInfo'] = F['streamInfo'],
                this['mergeStreamInfo'](),
                this['previous'] = F;
              var y = this;
              return F['on']('data', function (w) {
                y['processChunk'](w);
              }),
                F['on']('end', function () {
                  y['end']();
                }),
                F['on']('error', function (w) {
                  y['error'](w);
                }),
                this;
            },
            'pause': function () {
              return !this['isPaused'] && !this['isFinished'] && (this['isPaused'] = true,
                this['previous'] && this['previous']['pause'](),
                true);
            },
            'resume': function () {
              if (!this['isPaused'] || this['isFinished'])
                return false;
              var F = this['isPaused'] = false;
              return this['generatedError'] && (this['error'](this['generatedError']),
                F = true),
                this['previous'] && this['previous']['resume'](),
                !F;
            },
            'flush': function () { },
            'processChunk': function (F) {
              this['push'](F);
            },
            'withStreamInfo': function (F, y) {
              return this['extraStreamInfo'][F] = y,
                this['mergeStreamInfo'](),
                this;
            },
            'mergeStreamInfo': function () {
              for (var F in this['extraStreamInfo'])
                Object['prototype']['hasOwnProperty']['call'](this['extraStreamInfo'], F) && (this['streamInfo'][F] = this['extraStreamInfo'][F]);
            },
            'lock': function () {
              if (this['isLocked'])
                throw new Error('The\x20stream\x20\x27' + this + '\x27\x20has\x20already\x20been\x20used.');
              this['isLocked'] = true,
                this['previous'] && this['previous']['lock']();
            },
            'toString': function () {
              var F = 'Worker\x20' + this['name'];
              return this['previous'] ? this['previous'] + '\x20->\x20' + F : F;
            }
          },
            H['exports'] = p;
        }
          , {}],
        0x1d: [function (c, H, x) {
          'use strict';
          var p = c('../utils')
            , F = c('./ConvertWorker')
            , y = c('./GenericWorker')
            , w = c('../base64')
            , Y = c('../support')
            , T = c('../external')
            , X = null;
          if (Y['nodestream'])
            try {
              X = c('../nodejs/NodejsStreamOutputAdapter');
            } catch (f) { }
          function E (W, I, j) {
            var D = I;
            switch (I) {
              case 'blob':
              case 'arraybuffer':
                D = 'uint8array';
                break;
              case 'base64':
                D = 'string';
            }
            try {
              this['_internalType'] = D,
                this['_outputType'] = I,
                this['_mimeType'] = j,
                p['checkSupport'](D),
                this['_worker'] = W['pipe'](new F(D)),
                W['lock']();
            } catch (V) {
              this['_worker'] = new y('error'),
                this['_worker']['error'](V);
            }
          }
          E['prototype'] = {
            'accumulate': function (W) {
              return function (I, j) {
                return new T['Promise'](function (D, V) {
                  var Z = []
                    , B = I['_internalType']
                    , S = I['_outputType']
                    , U = I['_mimeType'];
                  I['on']('data', function (d, q) {
                    Z['push'](d),
                      j && j(q);
                  })['on']('error', function (d) {
                    Z = [],
                      V(d);
                  })['on']('end', function () {
                    try {
                      var d = function (q, J, C) {
                        switch (q) {
                          case 'blob':
                            return p['newBlob'](p['transformTo']('arraybuffer', J), C);
                          case 'base64':
                            return w['encode'](J);
                          default:
                            return p['transformTo'](q, J);
                        }
                      }(S, function (q, J) {
                        var C, O = 0x0, G = null, g = 0x0;
                        for (C = 0x0; C < J['length']; C++)
                          g += J[C]['length'];
                        switch (q) {
                          case 'string':
                            return J['join']('');
                          case 'array':
                            return Array['prototype']['concat']['apply']([], J);
                          case 'uint8array':
                            for (G = new Uint8Array(g),
                              C = 0x0; C < J['length']; C++)
                              G['set'](J[C], O),
                                O += J[C]['length'];
                            return G;
                          case 'nodebuffer':
                            return Buffer['concat'](J);
                          default:
                            throw new Error('concat\x20:\x20unsupported\x20type\x20\x27' + q + '\x27');
                        }
                      }(B, Z), U);
                      D(d);
                    } catch (q) {
                      V(q);
                    }
                    Z = [];
                  })['resume']();
                }
                );
              }(this, W);
            },
            'on': function (W, I) {
              var j = this;
              return 'data' === W ? this['_worker']['on'](W, function (D) {
                I['call'](j, D['data'], D['meta']);
              }) : this['_worker']['on'](W, function () {
                p['delay'](I, arguments, j);
              }),
                this;
            },
            'resume': function () {
              return p['delay'](this['_worker']['resume'], [], this['_worker']),
                this;
            },
            'pause': function () {
              return this['_worker']['pause'](),
                this;
            },
            'toNodejsStream': function (W) {
              if (p['checkSupport']('nodestream'),
                'nodebuffer' !== this['_outputType'])
                throw new Error(this['_outputType'] + '\x20is\x20not\x20supported\x20by\x20this\x20method');
              return new X(this, {
                'objectMode': 'nodebuffer' !== this['_outputType']
              }, W);
            }
          },
            H['exports'] = E;
        }
          , {
          '../base64': 0x1,
          '../external': 0x6,
          '../nodejs/NodejsStreamOutputAdapter': 0xd,
          '../support': 0x1e,
          '../utils': 0x20,
          './ConvertWorker': 0x18,
          './GenericWorker': 0x1c
        }],
        0x1e: [function (c, H, x) {
          'use strict';
          if (x['base64'] = true,
            x['array'] = true,
            x['string'] = true,
            x['arraybuffer'] = 'undefined' != typeof ArrayBuffer && 'undefined' != typeof Uint8Array,
            x['nodebuffer'] = 'undefined' != typeof Buffer,
            x['uint8array'] = 'undefined' != typeof Uint8Array,
            'undefined' == typeof ArrayBuffer)
            x['blob'] = false;
          else {
            var p = new ArrayBuffer(0x0);
            try {
              x['blob'] = 0x0 === new Blob([p], {
                'type': 'application/zip'
              })['size'];
            } catch (y) {
              try {
                var F = new (self['BlobBuilder'] || self['WebKitBlobBuilder'] || self['MozBlobBuilder'] || self['MSBlobBuilder'])();
                F['append'](p),
                  x['blob'] = 0x0 === F['getBlob']('application/zip')['size'];
              } catch (w) {
                x['blob'] = false;
              }
            }
          }
          try {
            x['nodestream'] = !!c('readable-stream')['Readable'];
          } catch (s) {
            x['nodestream'] = false;
          }
        }
          , {
          'readable-stream': 0x10
        }],
        0x1f: [function (c, H, x) {
          'use strict';
          for (var p = c('./utils'), F = c('./support'), y = c('./nodejsUtils'), w = c('./stream/GenericWorker'), Y = new Array(0x100), T = 0x0; T < 0x100; T++)
            Y[T] = 0xfc <= T ? 0x6 : 0xf8 <= T ? 0x5 : 0xf0 <= T ? 0x4 : 0xe0 <= T ? 0x3 : 0xc0 <= T ? 0x2 : 0x1;
          function X () {
            w['call'](this, 'utf-8\x20decode'),
              this['leftOver'] = null;
          }
          function E () {
            w['call'](this, 'utf-8\x20encode');
          }
          Y[0xfe] = Y[0xfe] = 0x1,
            x['utf8encode'] = function (f) {
              return F['nodebuffer'] ? y['newBufferFrom'](f, 'utf-8') : function (W) {
                var I, j, D, V, Z, B = W['length'], S = 0x0;
                for (V = 0x0; V < B; V++)
                  0xd800 == (0xfc00 & (j = W['charCodeAt'](V))) && V + 0x1 < B && 0xdc00 == (0xfc00 & (D = W['charCodeAt'](V + 0x1))) && (j = 0x10000 + (j - 0xd800 << 0xa) + (D - 0xdc00),
                    V++),
                    S += j < 0x80 ? 0x1 : j < 0x800 ? 0x2 : j < 0x10000 ? 0x3 : 0x4;
                for (I = F['uint8array'] ? new Uint8Array(S) : new Array(S),
                  V = Z = 0x0; Z < S; V++)
                  0xd800 == (0xfc00 & (j = W['charCodeAt'](V))) && V + 0x1 < B && 0xdc00 == (0xfc00 & (D = W['charCodeAt'](V + 0x1))) && (j = 0x10000 + (j - 0xd800 << 0xa) + (D - 0xdc00),
                    V++),
                    j < 0x80 ? I[Z++] = j : (j < 0x800 ? I[Z++] = 0xc0 | j >>> 0x6 : (j < 0x10000 ? I[Z++] = 0xe0 | j >>> 0xc : (I[Z++] = 0xf0 | j >>> 0x12,
                      I[Z++] = 0x80 | j >>> 0xc & 0x3f),
                      I[Z++] = 0x80 | j >>> 0x6 & 0x3f),
                      I[Z++] = 0x80 | 0x3f & j);
                return I;
              }(f);
            }
            ,
            x['utf8decode'] = function (f) {
              return F['nodebuffer'] ? p['transformTo']('nodebuffer', f)['toString']('utf-8') : function (W) {
                var I, j, D, V, Z = W['length'], B = new Array(0x2 * Z);
                for (I = j = 0x0; I < Z;)
                  if ((D = W[I++]) < 0x80)
                    B[j++] = D;
                  else {
                    if (0x4 < (V = Y[D]))
                      B[j++] = 0xfffd,
                        I += V - 0x1;
                    else {
                      for (D &= 0x2 === V ? 0x1f : 0x3 === V ? 0xf : 0x7; 0x1 < V && I < Z;)
                        D = D << 0x6 | 0x3f & W[I++],
                          V--;
                      0x1 < V ? B[j++] = 0xfffd : D < 0x10000 ? B[j++] = D : (D -= 0x10000,
                        B[j++] = 0xd800 | D >> 0xa & 0x3ff,
                        B[j++] = 0xdc00 | 0x3ff & D);
                    }
                  }
                return B['length'] !== j && (B['subarray'] ? B = B['subarray'](0x0, j) : B['length'] = j),
                  p['applyFromCharCode'](B);
              }(f = p['transformTo'](F['uint8array'] ? 'uint8array' : 'array', f));
            }
            ,
            p['inherits'](X, w),
            X['prototype']['processChunk'] = function (f) {
              var W = p['transformTo'](F['uint8array'] ? 'uint8array' : 'array', f['data']);
              if (this['leftOver'] && this['leftOver']['length']) {
                if (F['uint8array']) {
                  var I = W;
                  (W = new Uint8Array(I['length'] + this['leftOver']['length']))['set'](this['leftOver'], 0x0),
                    W['set'](I, this['leftOver']['length']);
                } else
                  W = this['leftOver']['concat'](W);
                this['leftOver'] = null;
              }
              var j = function (V, Z) {
                var B;
                for ((Z = Z || V['length']) > V['length'] && (Z = V['length']),
                  B = Z - 0x1; 0x0 <= B && 0x80 == (0xc0 & V[B]);)
                  B--;
                return B < 0x0 || 0x0 === B ? Z : B + Y[V[B]] > Z ? B : Z;
              }(W)
                , D = W;
              j !== W['length'] && (F['uint8array'] ? (D = W['subarray'](0x0, j),
                this['leftOver'] = W['subarray'](j, W['length'])) : (D = W['slice'](0x0, j),
                  this['leftOver'] = W['slice'](j, W['length']))),
                this['push']({
                  'data': x['utf8decode'](D),
                  'meta': f['meta']
                });
            }
            ,
            X['prototype']['flush'] = function () {
              this['leftOver'] && this['leftOver']['length'] && (this['push']({
                'data': x['utf8decode'](this['leftOver']),
                'meta': {}
              }),
                this['leftOver'] = null);
            }
            ,
            x['Utf8DecodeWorker'] = X,
            p['inherits'](E, w),
            E['prototype']['processChunk'] = function (f) {
              this['push']({
                'data': x['utf8encode'](f['data']),
                'meta': f['meta']
              });
            }
            ,
            x['Utf8EncodeWorker'] = E;
        }
          , {
          './nodejsUtils': 0xe,
          './stream/GenericWorker': 0x1c,
          './support': 0x1e,
          './utils': 0x20
        }],
        0x20: [function (H, x, p) {
          'use strict';
          var F = H('./support')
            , y = H('./base64')
            , w = H('./nodejsUtils')
            , Y = H('./external');
          function T (j) {
            return j;
          }
          function X (j, D) {
            for (var V = 0x0; V < j['length']; ++V)
              D[V] = 0xff & j['charCodeAt'](V);
            return D;
          }
          H('setimmediate'),
            p['newBlob'] = function (j, D) {
              p['checkSupport']('blob');
              try {
                return new Blob([j], {
                  'type': D
                });
              } catch (Z) {
                try {
                  var V = new (self['BlobBuilder'] || self['WebKitBlobBuilder'] || self['MozBlobBuilder'] || self['MSBlobBuilder'])();
                  return V['append'](j),
                    V['getBlob'](D);
                } catch (B) {
                  throw new Error('Bug\x20:\x20can\x27t\x20construct\x20the\x20Blob.');
                }
              }
            }
            ;
          var E = {
            'stringifyByChunk': function (j, D, V) {
              var Z = []
                , B = 0x0
                , S = j['length'];
              if (S <= V)
                return String['fromCharCode']['apply'](null, j);
              for (; B < S;)
                'array' === D || 'nodebuffer' === D ? Z['push'](String['fromCharCode']['apply'](null, j['slice'](B, Math['min'](B + V, S)))) : Z['push'](String['fromCharCode']['apply'](null, j['subarray'](B, Math['min'](B + V, S)))),
                  B += V;
              return Z['join']('');
            },
            'stringifyByChar': function (j) {
              for (var D = '', V = 0x0; V < j['length']; V++)
                D += String['fromCharCode'](j[V]);
              return D;
            },
            'applyCanBeUsed': {
              'uint8array': function () {
                try {
                  return F['uint8array'] && 0x1 === String['fromCharCode']['apply'](null, new Uint8Array(0x1))['length'];
                } catch (j) {
                  return false;
                }
              }(),
              'nodebuffer': function () {
                try {
                  return F['nodebuffer'] && 0x1 === String['fromCharCode']['apply'](null, w['allocBuffer'](0x1))['length'];
                } catch (j) {
                  return false;
                }
              }()
            }
          };
          function f (j) {
            var D = 0x10000
              , V = p['getTypeOf'](j)
              , Z = true;
            if ('uint8array' === V ? Z = E['applyCanBeUsed']['uint8array'] : 'nodebuffer' === V && (Z = E['applyCanBeUsed']['nodebuffer']),
              Z) {
              for (; 0x1 < D;)
                try {
                  return E['stringifyByChunk'](j, V, D);
                } catch (B) {
                  D = Math['floor'](D / 0x2);
                }
            }
            return E['stringifyByChar'](j);
          }
          function W (j, D) {
            for (var V = 0x0; V < j['length']; V++)
              D[V] = j[V];
            return D;
          }
          p['applyFromCharCode'] = f;
          var I = {};
          I['string'] = {
            'string': T,
            'array': function (j) {
              return X(j, new Array(j['length']));
            },
            'arraybuffer': function (j) {
              return I['string']['uint8array'](j)['buffer'];
            },
            'uint8array': function (j) {
              return X(j, new Uint8Array(j['length']));
            },
            'nodebuffer': function (j) {
              return X(j, w['allocBuffer'](j['length']));
            }
          },
            I['array'] = {
              'string': f,
              'array': T,
              'arraybuffer': function (j) {
                return new Uint8Array(j)['buffer'];
              },
              'uint8array': function (j) {
                return new Uint8Array(j);
              },
              'nodebuffer': function (j) {
                return w['newBufferFrom'](j);
              }
            },
            I['arraybuffer'] = {
              'string': function (j) {
                return f(new Uint8Array(j));
              },
              'array': function (j) {
                return W(new Uint8Array(j), new Array(j['byteLength']));
              },
              'arraybuffer': T,
              'uint8array': function (j) {
                return new Uint8Array(j);
              },
              'nodebuffer': function (j) {
                return w['newBufferFrom'](new Uint8Array(j));
              }
            },
            I['uint8array'] = {
              'string': f,
              'array': function (j) {
                return W(j, new Array(j['length']));
              },
              'arraybuffer': function (j) {
                return j['buffer'];
              },
              'uint8array': T,
              'nodebuffer': function (j) {
                return w['newBufferFrom'](j);
              }
            },
            I['nodebuffer'] = {
              'string': f,
              'array': function (j) {
                return W(j, new Array(j['length']));
              },
              'arraybuffer': function (j) {
                return I['nodebuffer']['uint8array'](j)['buffer'];
              },
              'uint8array': function (j) {
                return W(j, new Uint8Array(j['length']));
              },
              'nodebuffer': T
            },
            p['transformTo'] = function (j, D) {
              if (D = D || '',
                !j)
                return D;
              p['checkSupport'](j);
              var V = p['getTypeOf'](D);
              return I[V][j](D);
            }
            ,
            p['resolve'] = function (j) {
              for (var D = j['split']('/'), V = [], Z = 0x0; Z < D['length']; Z++) {
                var B = D[Z];
                '.' === B || '' === B && 0x0 !== Z && Z !== D['length'] - 0x1 || ('..' === B ? V['pop']() : V['push'](B));
              }
              return V['join']('/');
            }
            ,
            p['getTypeOf'] = function (j) {
              return 'string' == typeof j ? 'string' : '[object\x20Array]' === Object['prototype']['toString']['call'](j) ? 'array' : F['nodebuffer'] && w['isBuffer'](j) ? 'nodebuffer' : F['uint8array'] && j instanceof Uint8Array ? 'uint8array' : F['arraybuffer'] && j instanceof ArrayBuffer ? 'arraybuffer' : undefined;
            }
            ,
            p['checkSupport'] = function (j) {
              if (!F[j['toLowerCase']()])
                throw new Error(j + '\x20is\x20not\x20supported\x20by\x20this\x20platform');
            }
            ,
            p['MAX_VALUE_16BITS'] = 0xffff,
            p['MAX_VALUE_32BITS'] = -0x1,
            p['pretty'] = function (j) {
              var D, V, Z = '';
              for (V = 0x0; V < (j || '')['length']; V++)
                Z += '\x5cx' + ((D = j['charCodeAt'](V)) < 0x10 ? '0' : '') + D['toString'](0x10)['toUpperCase']();
              return Z;
            }
            ,
            p['delay'] = function (j, D, V) {
              setImmediate(function () {
                j['apply'](V || null, D || []);
              });
            }
            ,
            p['inherits'] = function (j, D) {
              function V () { }
              V['prototype'] = D['prototype'],
                j['prototype'] = new V();
            }
            ,
            p['extend'] = function () {
              var j, D, V = {};
              for (j = 0x0; j < arguments['length']; j++)
                for (D in arguments[j])
                  Object['prototype']['hasOwnProperty']['call'](arguments[j], D) && undefined === V[D] && (V[D] = arguments[j][D]);
              return V;
            }
            ,
            p['prepareContent'] = function (j, D, V, Z, B) {
              return Y['Promise']['resolve'](D)['then'](function (S) {
                return F['blob'] && (S instanceof Blob || -0x1 !== ['[object\x20File]', '[object\x20Blob]']['indexOf'](Object['prototype']['toString']['call'](S))) && 'undefined' != typeof FileReader ? new Y['Promise'](function (U, q) {
                  var J = new FileReader();
                  J['onload'] = function (C) {
                    U(C['target']['result']);
                  }
                    ,
                    J['onerror'] = function (C) {
                      q(C['target']['error']);
                    }
                    ,
                    J['readAsArrayBuffer'](S);
                }
                ) : S;
              })['then'](function (S) {
                var U = p['getTypeOf'](S);
                return U ? ('arraybuffer' === U ? S = p['transformTo']('uint8array', S) : 'string' === U && (B ? S = y['decode'](S) : V && true !== Z && (S = function (q) {
                  return X(q, F['uint8array'] ? new Uint8Array(q['length']) : new Array(q['length']));
                }(S))),
                  S) : Y['Promise']['reject'](new Error('Can\x27t\x20read\x20the\x20data\x20of\x20\x27' + j + '\x27.\x20Is\x20it\x20in\x20a\x20supported\x20JavaScript\x20type\x20(String,\x20Blob,\x20ArrayBuffer,\x20etc)\x20?'));
              });
            }
            ;
        }
          , {
          './base64': 0x1,
          './external': 0x6,
          './nodejsUtils': 0xe,
          './support': 0x1e,
          'setimmediate': 0x36
        }],
        0x21: [function (c, H, x) {
          'use strict';
          var p = c('./reader/readerFor')
            , F = c('./utils')
            , y = c('./signature')
            , w = c('./zipEntry')
            , h = c('./support');
          function u (Y) {
            this['files'] = [],
              this['loadOptions'] = Y;
          }
          u['prototype'] = {
            'checkSignature': function (Y) {
              if (!this['reader']['readAndCheckSignature'](Y)) {
                this['reader']['index'] -= 0x4;
                var T = this['reader']['readString'](0x4);
                throw new Error('Corrupted\x20zip\x20or\x20bug:\x20unexpected\x20signature\x20(' + F['pretty'](T) + ',\x20expected\x20' + F['pretty'](Y) + ')');
              }
            },
            'isSignature': function (Y, T) {
              var X = this['reader']['index'];
              this['reader']['setIndex'](Y);
              var E = this['reader']['readString'](0x4) === T;
              return this['reader']['setIndex'](X),
                E;
            },
            'readBlockEndOfCentral': function () {
              this['diskNumber'] = this['reader']['readInt'](0x2),
                this['diskWithCentralDirStart'] = this['reader']['readInt'](0x2),
                this['centralDirRecordsOnThisDisk'] = this['reader']['readInt'](0x2),
                this['centralDirRecords'] = this['reader']['readInt'](0x2),
                this['centralDirSize'] = this['reader']['readInt'](0x4),
                this['centralDirOffset'] = this['reader']['readInt'](0x4),
                this['zipCommentLength'] = this['reader']['readInt'](0x2);
              var Y = this['reader']['readData'](this['zipCommentLength'])
                , T = h['uint8array'] ? 'uint8array' : 'array'
                , X = F['transformTo'](T, Y);
              this['zipComment'] = this['loadOptions']['decodeFileName'](X);
            },
            'readBlockZip64EndOfCentral': function () {
              this['zip64EndOfCentralSize'] = this['reader']['readInt'](0x8),
                this['reader']['skip'](0x4),
                this['diskNumber'] = this['reader']['readInt'](0x4),
                this['diskWithCentralDirStart'] = this['reader']['readInt'](0x4),
                this['centralDirRecordsOnThisDisk'] = this['reader']['readInt'](0x8),
                this['centralDirRecords'] = this['reader']['readInt'](0x8),
                this['centralDirSize'] = this['reader']['readInt'](0x8),
                this['centralDirOffset'] = this['reader']['readInt'](0x8),
                this['zip64ExtensibleData'] = {};
              for (var Y, T, X, E = this['zip64EndOfCentralSize'] - 0x2c; 0x0 < E;)
                Y = this['reader']['readInt'](0x2),
                  T = this['reader']['readInt'](0x4),
                  X = this['reader']['readData'](T),
                  this['zip64ExtensibleData'][Y] = {
                    'id': Y,
                    'length': T,
                    'value': X
                  };
            },
            'readBlockZip64EndOfCentralLocator': function () {
              if (this['diskWithZip64CentralDirStart'] = this['reader']['readInt'](0x4),
                this['relativeOffsetEndOfZip64CentralDir'] = this['reader']['readInt'](0x8),
                this['disksCount'] = this['reader']['readInt'](0x4),
                0x1 < this['disksCount'])
                throw new Error('Multi-volumes\x20zip\x20are\x20not\x20supported');
            },
            'readLocalFiles': function () {
              var Y, T;
              for (Y = 0x0; Y < this['files']['length']; Y++)
                T = this['files'][Y],
                  this['reader']['setIndex'](T['localHeaderOffset']),
                  this['checkSignature'](y['LOCAL_FILE_HEADER']),
                  T['readLocalPart'](this['reader']),
                  T['handleUTF8'](),
                  T['processAttributes']();
            },
            'readCentralDir': function () {
              var Y;
              for (this['reader']['setIndex'](this['centralDirOffset']); this['reader']['readAndCheckSignature'](y['CENTRAL_FILE_HEADER']);)
                (Y = new w({
                  'zip64': this['zip64']
                }, this['loadOptions']))['readCentralPart'](this['reader']),
                  this['files']['push'](Y);
              if (this['centralDirRecords'] !== this['files']['length'] && 0x0 !== this['centralDirRecords'] && 0x0 === this['files']['length'])
                throw new Error('Corrupted\x20zip\x20or\x20bug:\x20expected\x20' + this['centralDirRecords'] + '\x20records\x20in\x20central\x20dir,\x20got\x20' + this['files']['length']);
            },
            'readEndOfCentral': function () {
              var Y = this['reader']['lastIndexOfSignature'](y['CENTRAL_DIRECTORY_END']);
              if (Y < 0x0)
                throw this['isSignature'](0x0, y['LOCAL_FILE_HEADER']) ? new Error('Corrupted\x20zip:\x20can\x27t\x20find\x20end\x20of\x20central\x20directory') : new Error('Can\x27t\x20find\x20end\x20of\x20central\x20directory\x20:\x20is\x20this\x20a\x20zip\x20file\x20?\x20If\x20it\x20is,\x20see\x20https://stuk.github.io/jszip/documentation/howto/read_zip.html');
              this['reader']['setIndex'](Y);
              var T = Y;
              if (this['checkSignature'](y['CENTRAL_DIRECTORY_END']),
                this['readBlockEndOfCentral'](),
                this['diskNumber'] === F['MAX_VALUE_16BITS'] || this['diskWithCentralDirStart'] === F['MAX_VALUE_16BITS'] || this['centralDirRecordsOnThisDisk'] === F['MAX_VALUE_16BITS'] || this['centralDirRecords'] === F['MAX_VALUE_16BITS'] || this['centralDirSize'] === F['MAX_VALUE_32BITS'] || this['centralDirOffset'] === F['MAX_VALUE_32BITS']) {
                if (this['zip64'] = true,
                  (Y = this['reader']['lastIndexOfSignature'](y['ZIP64_CENTRAL_DIRECTORY_LOCATOR'])) < 0x0)
                  throw new Error('Corrupted\x20zip:\x20can\x27t\x20find\x20the\x20ZIP64\x20end\x20of\x20central\x20directory\x20locator');
                if (this['reader']['setIndex'](Y),
                  this['checkSignature'](y['ZIP64_CENTRAL_DIRECTORY_LOCATOR']),
                  this['readBlockZip64EndOfCentralLocator'](),
                  !this['isSignature'](this['relativeOffsetEndOfZip64CentralDir'], y['ZIP64_CENTRAL_DIRECTORY_END']) && (this['relativeOffsetEndOfZip64CentralDir'] = this['reader']['lastIndexOfSignature'](y['ZIP64_CENTRAL_DIRECTORY_END']),
                    this['relativeOffsetEndOfZip64CentralDir'] < 0x0))
                  throw new Error('Corrupted\x20zip:\x20can\x27t\x20find\x20the\x20ZIP64\x20end\x20of\x20central\x20directory');
                this['reader']['setIndex'](this['relativeOffsetEndOfZip64CentralDir']),
                  this['checkSignature'](y['ZIP64_CENTRAL_DIRECTORY_END']),
                  this['readBlockZip64EndOfCentral']();
              }
              var X = this['centralDirOffset'] + this['centralDirSize'];
              this['zip64'] && (X += 0x14,
                X += 0xc + this['zip64EndOfCentralSize']);
              var E = T - X;
              if (0x0 < E)
                this['isSignature'](T, y['CENTRAL_FILE_HEADER']) || (this['reader']['zero'] = E);
              else {
                if (E < 0x0)
                  throw new Error('Corrupted\x20zip:\x20missing\x20' + Math['abs'](E) + '\x20bytes.');
              }
            },
            'prepareReader': function (Y) {
              this['reader'] = p(Y);
            },
            'load': function (Y) {
              this['prepareReader'](Y),
                this['readEndOfCentral'](),
                this['readCentralDir'](),
                this['readLocalFiles']();
            }
          },
            H['exports'] = u;
        }
          , {
          './reader/readerFor': 0x16,
          './signature': 0x17,
          './support': 0x1e,
          './utils': 0x20,
          './zipEntry': 0x22
        }],
        0x22: [function (c, H, x) {
          'use strict';
          var p = c('./reader/readerFor')
            , F = c('./utils')
            , y = c('./compressedObject')
            , w = c('./crc32')
            , Y = c('./utf8')
            , T = c('./compressions')
            , X = c('./support');
          function E (f, W) {
            this['options'] = f,
              this['loadOptions'] = W;
          }
          E['prototype'] = {
            'isEncrypted': function () {
              return 0x1 == (0x1 & this['bitFlag']);
            },
            'useUTF8': function () {
              return 0x800 == (0x800 & this['bitFlag']);
            },
            'readLocalPart': function (f) {
              var W, I;
              if (f['skip'](0x16),
                this['fileNameLength'] = f['readInt'](0x2),
                I = f['readInt'](0x2),
                this['fileName'] = f['readData'](this['fileNameLength']),
                f['skip'](I),
                -0x1 === this['compressedSize'] || -0x1 === this['uncompressedSize'])
                throw new Error('Bug\x20or\x20corrupted\x20zip\x20:\x20didn\x27t\x20get\x20enough\x20information\x20from\x20the\x20central\x20directory\x20(compressedSize\x20===\x20-1\x20||\x20uncompressedSize\x20===\x20-1)');
              if (null === (W = function (j) {
                for (var D in T)
                  if (Object['prototype']['hasOwnProperty']['call'](T, D) && T[D]['magic'] === j)
                    return T[D];
                return null;
              }(this['compressionMethod'])))
                throw new Error('Corrupted\x20zip\x20:\x20compression\x20' + F['pretty'](this['compressionMethod']) + '\x20unknown\x20(inner\x20file\x20:\x20' + F['transformTo']('string', this['fileName']) + ')');
              this['decompressed'] = new y(this['compressedSize'], this['uncompressedSize'], this['crc32'], W, f['readData'](this['compressedSize']));
            },
            'readCentralPart': function (f) {
              this['versionMadeBy'] = f['readInt'](0x2),
                f['skip'](0x2),
                this['bitFlag'] = f['readInt'](0x2),
                this['compressionMethod'] = f['readString'](0x2),
                this['date'] = f['readDate'](),
                this['crc32'] = f['readInt'](0x4),
                this['compressedSize'] = f['readInt'](0x4),
                this['uncompressedSize'] = f['readInt'](0x4);
              var W = f['readInt'](0x2);
              if (this['extraFieldsLength'] = f['readInt'](0x2),
                this['fileCommentLength'] = f['readInt'](0x2),
                this['diskNumberStart'] = f['readInt'](0x2),
                this['internalFileAttributes'] = f['readInt'](0x2),
                this['externalFileAttributes'] = f['readInt'](0x4),
                this['localHeaderOffset'] = f['readInt'](0x4),
                this['isEncrypted']())
                throw new Error('Encrypted\x20zip\x20are\x20not\x20supported');
              f['skip'](W),
                this['readExtraFields'](f),
                this['parseZIP64ExtraField'](f),
                this['fileComment'] = f['readData'](this['fileCommentLength']);
            },
            'processAttributes': function () {
              this['unixPermissions'] = null,
                this['dosPermissions'] = null;
              var f = this['versionMadeBy'] >> 0x8;
              this['dir'] = !!(0x10 & this['externalFileAttributes']),
                0x0 == f && (this['dosPermissions'] = 0x3f & this['externalFileAttributes']),
                0x3 == f && (this['unixPermissions'] = this['externalFileAttributes'] >> 0x10 & 0xffff),
                this['dir'] || '/' !== this['fileNameStr']['slice'](-0x1) || (this['dir'] = true);
            },
            'parseZIP64ExtraField': function () {
              if (this['extraFields'][0x1]) {
                var f = p(this['extraFields'][0x1]['value']);
                this['uncompressedSize'] === F['MAX_VALUE_32BITS'] && (this['uncompressedSize'] = f['readInt'](0x8)),
                  this['compressedSize'] === F['MAX_VALUE_32BITS'] && (this['compressedSize'] = f['readInt'](0x8)),
                  this['localHeaderOffset'] === F['MAX_VALUE_32BITS'] && (this['localHeaderOffset'] = f['readInt'](0x8)),
                  this['diskNumberStart'] === F['MAX_VALUE_32BITS'] && (this['diskNumberStart'] = f['readInt'](0x4));
              }
            },
            'readExtraFields': function (f) {
              var W, I, j, D = f['index'] + this['extraFieldsLength'];
              for (this['extraFields'] || (this['extraFields'] = {}); f['index'] + 0x4 < D;)
                W = f['readInt'](0x2),
                  I = f['readInt'](0x2),
                  j = f['readData'](I),
                  this['extraFields'][W] = {
                    'id': W,
                    'length': I,
                    'value': j
                  };
              f['setIndex'](D);
            },
            'handleUTF8': function () {
              var f = X['uint8array'] ? 'uint8array' : 'array';
              if (this['useUTF8']())
                this['fileNameStr'] = Y['utf8decode'](this['fileName']),
                  this['fileCommentStr'] = Y['utf8decode'](this['fileComment']);
              else {
                var W = this['findExtraFieldUnicodePath']();
                if (null !== W)
                  this['fileNameStr'] = W;
                else {
                  var I = F['transformTo'](f, this['fileName']);
                  this['fileNameStr'] = this['loadOptions']['decodeFileName'](I);
                }
                var j = this['findExtraFieldUnicodeComment']();
                if (null !== j)
                  this['fileCommentStr'] = j;
                else {
                  var D = F['transformTo'](f, this['fileComment']);
                  this['fileCommentStr'] = this['loadOptions']['decodeFileName'](D);
                }
              }
            },
            'findExtraFieldUnicodePath': function () {
              var f = this['extraFields'][0x7075];
              if (f) {
                var W = p(f['value']);
                return 0x1 !== W['readInt'](0x1) || w(this['fileName']) !== W['readInt'](0x4) ? null : Y['utf8decode'](W['readData'](f['length'] - 0x5));
              }
              return null;
            },
            'findExtraFieldUnicodeComment': function () {
              var f = this['extraFields'][0x6375];
              if (f) {
                var W = p(f['value']);
                return 0x1 !== W['readInt'](0x1) || w(this['fileComment']) !== W['readInt'](0x4) ? null : Y['utf8decode'](W['readData'](f['length'] - 0x5));
              }
              return null;
            }
          },
            H['exports'] = E;
        }
          , {
          './compressedObject': 0x2,
          './compressions': 0x3,
          './crc32': 0x4,
          './reader/readerFor': 0x16,
          './support': 0x1e,
          './utf8': 0x1f,
          './utils': 0x20
        }],
        0x23: [function (c, H, x) {
          'use strict';
          function p (W, I, j) {
            this['name'] = W,
              this['dir'] = j['dir'],
              this['date'] = j['date'],
              this['comment'] = j['comment'],
              this['unixPermissions'] = j['unixPermissions'],
              this['dosPermissions'] = j['dosPermissions'],
              this['_data'] = I,
              this['_dataBinary'] = j['binary'],
              this['options'] = {
                'compression': j['compression'],
                'compressionOptions': j['compressionOptions']
              };
          }
          var F = c('./stream/StreamHelper')
            , y = c('./stream/DataWorker')
            , w = c('./utf8')
            , Y = c('./compressedObject')
            , T = c('./stream/GenericWorker');
          p['prototype'] = {
            'internalStream': function (W) {
              var I = null
                , j = 'string';
              try {
                if (!W)
                  throw new Error('No\x20output\x20type\x20specified.');
                var D = 'string' === (j = W['toLowerCase']()) || 'text' === j;
                'binarystring' !== j && 'text' !== j || (j = 'string'),
                  I = this['_decompressWorker']();
                var V = !this['_dataBinary'];
                V && !D && (I = I['pipe'](new w['Utf8EncodeWorker']())),
                  !V && D && (I = I['pipe'](new w['Utf8DecodeWorker']()));
              } catch (Z) {
                (I = new T('error'))['error'](Z);
              }
              return new F(I, j, '');
            },
            'async': function (W, I) {
              return this['internalStream'](W)['accumulate'](I);
            },
            'nodeStream': function (W, I) {
              return this['internalStream'](W || 'nodebuffer')['toNodejsStream'](I);
            },
            '_compressWorker': function (W, I) {
              if (this['_data'] instanceof Y && this['_data']['compression']['magic'] === W['magic'])
                return this['_data']['getCompressedWorker']();
              var j = this['_decompressWorker']();
              return this['_dataBinary'] || (j = j['pipe'](new w['Utf8EncodeWorker']())),
                Y['createWorkerFrom'](j, W, I);
            },
            '_decompressWorker': function () {
              return this['_data'] instanceof Y ? this['_data']['getContentWorker']() : this['_data'] instanceof T ? this['_data'] : new y(this['_data']);
            }
          };
          for (var X = ['asText', 'asBinary', 'asNodeBuffer', 'asUint8Array', 'asArrayBuffer'], E = function () {
            throw new Error('This\x20method\x20has\x20been\x20removed\x20in\x20JSZip\x203.0,\x20please\x20check\x20the\x20upgrade\x20guide.');
          }, f = 0x0; f < X['length']; f++)
            p['prototype'][X[f]] = E;
          H['exports'] = p;
        }
          , {
          './compressedObject': 0x2,
          './stream/DataWorker': 0x1b,
          './stream/GenericWorker': 0x1c,
          './stream/StreamHelper': 0x1d,
          './utf8': 0x1f
        }],
        0x24: [function (c, H, x) {
          (function (p) {
            'use strict';
            var F, y, w = p['MutationObserver'] || p['WebKitMutationObserver'];
            if (w) {
              var Y = 0x0
                , T = new w(W)
                , X = p['document']['createTextNode']('');
              T['observe'](X, {
                'characterData': true
              }),
                F = function () {
                  X['data'] = Y = ++Y % 0x2;
                }
                ;
            } else {
              if (p['setImmediate'] || undefined === p['MessageChannel'])
                F = 'document' in p && 'onreadystatechange' in p['document']['createElement']('script') ? function () {
                  var I = p['document']['createElement']('script');
                  I['onreadystatechange'] = function () {
                    W(),
                      I['onreadystatechange'] = null,
                      I['parentNode']['removeChild'](I),
                      I = null;
                  }
                    ,
                    p['document']['documentElement']['appendChild'](I);
                }
                  : function () {
                    setTimeout(W, 0x0);
                  }
                  ;
              else {
                var E = new p['MessageChannel']();
                E['port1']['onmessage'] = W,
                  F = function () {
                    E['port2']['postMessage'](0x0);
                  }
                  ;
              }
            }
            var f = [];
            function W () {
              var I, j;
              y = true;
              for (var D = f['length']; D;) {
                for (j = f,
                  f = [],
                  I = -0x1; ++I < D;)
                  j[I]();
                D = f['length'];
              }
              y = false;
            }
            H['exports'] = function (I) {
              0x1 !== f['push'](I) || y || F();
            }
              ;
          }
          ['call'](this, 'undefined' != typeof global ? global : 'undefined' != typeof self ? self : 'undefined' != typeof window ? window : {}));
        }
          , {}],
        0x25: [function (H, x, F) {
          'use strict';
          var y = H('immediate');
          function w () { }
          var Y = {}
            , T = ['REJECTED']
            , X = ['FULFILLED']
            , E = ['PENDING'];
          function W (B) {
            if ('function' != typeof B)
              throw new TypeError('resolver\x20must\x20be\x20a\x20function');
            this['state'] = E,
              this['queue'] = [],
              this['outcome'] = undefined,
              B !== w && V(this, B);
          }
          function I (B, S, U) {
            this['promise'] = B,
              'function' == typeof S && (this['onFulfilled'] = S,
                this['callFulfilled'] = this['otherCallFulfilled']),
              'function' == typeof U && (this['onRejected'] = U,
                this['callRejected'] = this['otherCallRejected']);
          }
          function j (B, S, U) {
            y(function () {
              var q;
              try {
                q = S(U);
              } catch (J) {
                return Y['reject'](B, J);
              }
              q === B ? Y['reject'](B, new TypeError('Cannot\x20resolve\x20promise\x20with\x20itself')) : Y['resolve'](B, q);
            });
          }
          function D (B) {
            var S = B && B['then'];
            if (B && ('object' == typeof B || 'function' == typeof B) && 'function' == typeof S)
              return function () {
                S['apply'](B, arguments);
              }
                ;
          }
          function V (B, S) {
            var U = false;
            function q (O) {
              U || (U = true,
                Y['reject'](B, O));
            }
            function J (O) {
              U || (U = true,
                Y['resolve'](B, O));
            }
            var C = Z(function () {
              S(J, q);
            });
            'error' === C['status'] && q(C['value']);
          }
          function Z (B, S) {
            var U = {};
            try {
              U['value'] = B(S),
                U['status'] = 'success';
            } catch (q) {
              U['status'] = 'error',
                U['value'] = q;
            }
            return U;
          }
          (x['exports'] = W)['prototype']['finally'] = function (B) {
            if ('function' != typeof B)
              return this;
            var S = this['constructor'];
            return this['then'](function (U) {
              return S['resolve'](B())['then'](function () {
                return U;
              });
            }, function (U) {
              return S['resolve'](B())['then'](function () {
                throw U;
              });
            });
          }
            ,
            W['prototype']['catch'] = function (B) {
              return this['then'](null, B);
            }
            ,
            W['prototype']['then'] = function (B, S) {
              if ('function' != typeof B && this['state'] === X || 'function' != typeof S && this['state'] === T)
                return this;
              var U = new this['constructor'](w);
              return this['state'] !== E ? j(U, this['state'] === X ? B : S, this['outcome']) : this['queue']['push'](new I(U, B, S)),
                U;
            }
            ,
            I['prototype']['callFulfilled'] = function (B) {
              Y['resolve'](this['promise'], B);
            }
            ,
            I['prototype']['otherCallFulfilled'] = function (B) {
              j(this['promise'], this['onFulfilled'], B);
            }
            ,
            I['prototype']['callRejected'] = function (B) {
              Y['reject'](this['promise'], B);
            }
            ,
            I['prototype']['otherCallRejected'] = function (B) {
              j(this['promise'], this['onRejected'], B);
            }
            ,
            Y['resolve'] = function (B, S) {
              var U = Z(D, S);
              if ('error' === U['status'])
                return Y['reject'](B, U['value']);
              var q = U['value'];
              if (q)
                V(B, q);
              else {
                B['state'] = X,
                  B['outcome'] = S;
                for (var J = -0x1, C = B['queue']['length']; ++J < C;)
                  B['queue'][J]['callFulfilled'](S);
              }
              return B;
            }
            ,
            Y['reject'] = function (B, S) {
              B['state'] = T,
                B['outcome'] = S;
              for (var U = -0x1, q = B['queue']['length']; ++U < q;)
                B['queue'][U]['callRejected'](S);
              return B;
            }
            ,
            W['resolve'] = function (B) {
              return B instanceof this ? B : Y['resolve'](new this(w), B);
            }
            ,
            W['reject'] = function (B) {
              var S = new this(w);
              return Y['reject'](S, B);
            }
            ,
            W['all'] = function (B) {
              var S = this;
              if ('[object\x20Array]' !== Object['prototype']['toString']['call'](B))
                return this['reject'](new TypeError('must\x20be\x20an\x20array'));
              var U = B['length']
                , q = false;
              if (!U)
                return this['resolve']([]);
              for (var J = new Array(U), C = 0x0, O = -0x1, G = new this(w); ++O < U;)
                g(B[O], O);
              return G;
              function g (N, P) {
                S['resolve'](N)['then'](function (M) {
                  J[P] = M,
                    ++C !== U || q || (q = true,
                      Y['resolve'](G, J));
                }, function (M) {
                  q || (q = true,
                    Y['reject'](G, M));
                });
              }
            }
            ,
            W['race'] = function (B) {
              if ('[object\x20Array]' !== Object['prototype']['toString']['call'](B))
                return this['reject'](new TypeError('must\x20be\x20an\x20array'));
              var S = B['length']
                , U = false;
              if (!S)
                return this['resolve']([]);
              for (var q, J = -0x1, C = new this(w); ++J < S;)
                q = B[J],
                  this['resolve'](q)['then'](function (O) {
                    U || (U = true,
                      Y['resolve'](C, O));
                  }, function (O) {
                    U || (U = true,
                      Y['reject'](C, O));
                  });
              return C;
            }
            ;
        }
          , {
          'immediate': 0x24
        }],
        0x26: [function (c, H, x) {
          'use strict';
          var p = {};
          (0x0,
            c('./lib/utils/common')['assign'])(p, c('./lib/deflate'), c('./lib/inflate'), c('./lib/zlib/constants')),
            H['exports'] = p;
        }
          , {
          './lib/deflate': 0x27,
          './lib/inflate': 0x28,
          './lib/utils/common': 0x29,
          './lib/zlib/constants': 0x2c
        }],
        0x27: [function (H, x, F) {
          'use strict';
          var y = H('./zlib/deflate')
            , w = H('./utils/common')
            , Y = H('./utils/strings')
            , T = H('./zlib/messages')
            , X = H('./zlib/zstream')
            , E = Object['prototype']['toString']
            , W = 0x0
            , I = -0x1
            , j = 0x0
            , D = 0x8;
          function V (B) {
            if (!(this instanceof V))
              return new V(B);
            this['options'] = w['assign']({
              'level': I,
              'method': D,
              'chunkSize': 0x4000,
              'windowBits': 0xf,
              'memLevel': 0x8,
              'strategy': j,
              'to': ''
            }, B || {});
            var S = this['options'];
            S['raw'] && 0x0 < S['windowBits'] ? S['windowBits'] = -S['windowBits'] : S['gzip'] && 0x0 < S['windowBits'] && S['windowBits'] < 0x10 && (S['windowBits'] += 0x10),
              this['err'] = 0x0,
              this['msg'] = '',
              this['ended'] = false,
              this['chunks'] = [],
              this['strm'] = new X(),
              this['strm']['avail_out'] = 0x0;
            var U = y['deflateInit2'](this['strm'], S['level'], S['method'], S['windowBits'], S['memLevel'], S['strategy']);
            if (U !== W)
              throw new Error(T[U]);
            if (S['header'] && y['deflateSetHeader'](this['strm'], S['header']),
              S['dictionary']) {
              var q;
              if (q = 'string' == typeof S['dictionary'] ? Y['string2buf'](S['dictionary']) : '[object\x20ArrayBuffer]' === E['call'](S['dictionary']) ? new Uint8Array(S['dictionary']) : S['dictionary'],
                (U = y['deflateSetDictionary'](this['strm'], q)) !== W)
                throw new Error(T[U]);
              this['_dict_set'] = true;
            }
          }
          function Z (B, S) {
            var U = new V(S);
            if (U['push'](B, true),
              U['err'])
              throw U['msg'] || T[U['err']];
            return U['result'];
          }
          V['prototype']['push'] = function (B, S) {
            var U, q, J = this['strm'], C = this['options']['chunkSize'];
            if (this['ended'])
              return false;
            q = S === ~~S ? S : true === S ? 0x4 : 0x0,
              'string' == typeof B ? J['input'] = Y['string2buf'](B) : '[object\x20ArrayBuffer]' === E['call'](B) ? J['input'] = new Uint8Array(B) : J['input'] = B,
              J['next_in'] = 0x0,
              J['avail_in'] = J['input']['length'];
            do {
              if (0x0 === J['avail_out'] && (J['output'] = new w['Buf8'](C),
                J['next_out'] = 0x0,
                J['avail_out'] = C),
                0x1 !== (U = y['deflate'](J, q)) && U !== W)
                return this['onEnd'](U),
                  !(this['ended'] = true);
              0x0 !== J['avail_out'] && (0x0 !== J['avail_in'] || 0x4 !== q && 0x2 !== q) || ('string' === this['options']['to'] ? this['onData'](Y['buf2binstring'](w['shrinkBuf'](J['output'], J['next_out']))) : this['onData'](w['shrinkBuf'](J['output'], J['next_out'])));
            } while ((0x0 < J['avail_in'] || 0x0 === J['avail_out']) && 0x1 !== U);
            return 0x4 === q ? (U = y['deflateEnd'](this['strm']),
              this['onEnd'](U),
              this['ended'] = true,
              U === W) : 0x2 !== q || (this['onEnd'](W),
                !(J['avail_out'] = 0x0));
          }
            ,
            V['prototype']['onData'] = function (B) {
              this['chunks']['push'](B);
            }
            ,
            V['prototype']['onEnd'] = function (B) {
              B === W && ('string' === this['options']['to'] ? this['result'] = this['chunks']['join']('') : this['result'] = w['flattenChunks'](this['chunks'])),
                this['chunks'] = [],
                this['err'] = B,
                this['msg'] = this['strm']['msg'];
            }
            ,
            F['Deflate'] = V,
            F['deflate'] = Z,
            F['deflateRaw'] = function (B, S) {
              return (S = S || {})['raw'] = true,
                Z(B, S);
            }
            ,
            F['gzip'] = function (B, S) {
              return (S = S || {})['gzip'] = true,
                Z(B, S);
            }
            ;
        }
          , {
          './utils/common': 0x29,
          './utils/strings': 0x2a,
          './zlib/deflate': 0x2e,
          './zlib/messages': 0x33,
          './zlib/zstream': 0x35
        }],
        0x28: [function (H, x, p) {
          'use strict';
          var F = H('./zlib/inflate')
            , y = H('./utils/common')
            , w = H('./utils/strings')
            , Y = H('./zlib/constants')
            , T = H('./zlib/messages')
            , X = H('./zlib/zstream')
            , E = H('./zlib/gzheader')
            , f = Object['prototype']['toString'];
          function W (j) {
            if (!(this instanceof W))
              return new W(j);
            this['options'] = y['assign']({
              'chunkSize': 0x4000,
              'windowBits': 0x0,
              'to': ''
            }, j || {});
            var D = this['options'];
            D['raw'] && 0x0 <= D['windowBits'] && D['windowBits'] < 0x10 && (D['windowBits'] = -D['windowBits'],
              0x0 === D['windowBits'] && (D['windowBits'] = -0xf)),
              !(0x0 <= D['windowBits'] && D['windowBits'] < 0x10) || j && j['windowBits'] || (D['windowBits'] += 0x20),
              0xf < D['windowBits'] && D['windowBits'] < 0x30 && 0x0 == (0xf & D['windowBits']) && (D['windowBits'] |= 0xf),
              this['err'] = 0x0,
              this['msg'] = '',
              this['ended'] = false,
              this['chunks'] = [],
              this['strm'] = new X(),
              this['strm']['avail_out'] = 0x0;
            var V = F['inflateInit2'](this['strm'], D['windowBits']);
            if (V !== Y['Z_OK'])
              throw new Error(T[V]);
            this['header'] = new E(),
              F['inflateGetHeader'](this['strm'], this['header']);
          }
          function I (j, D) {
            var V = new W(D);
            if (V['push'](j, true),
              V['err'])
              throw V['msg'] || T[V['err']];
            return V['result'];
          }
          W['prototype']['push'] = function (j, D) {
            var V, Z, B, S, U, q, J = this['strm'], C = this['options']['chunkSize'], O = this['options']['dictionary'], G = false;
            if (this['ended'])
              return false;
            Z = D === ~~D ? D : true === D ? Y['Z_FINISH'] : Y['Z_NO_FLUSH'],
              'string' == typeof j ? J['input'] = w['binstring2buf'](j) : '[object\x20ArrayBuffer]' === f['call'](j) ? J['input'] = new Uint8Array(j) : J['input'] = j,
              J['next_in'] = 0x0,
              J['avail_in'] = J['input']['length'];
            do {
              if (0x0 === J['avail_out'] && (J['output'] = new y['Buf8'](C),
                J['next_out'] = 0x0,
                J['avail_out'] = C),
                (V = F['inflate'](J, Y['Z_NO_FLUSH'])) === Y['Z_NEED_DICT'] && O && (q = 'string' == typeof O ? w['string2buf'](O) : '[object\x20ArrayBuffer]' === f['call'](O) ? new Uint8Array(O) : O,
                  V = F['inflateSetDictionary'](this['strm'], q)),
                V === Y['Z_BUF_ERROR'] && true === G && (V = Y['Z_OK'],
                  G = false),
                V !== Y['Z_STREAM_END'] && V !== Y['Z_OK'])
                return this['onEnd'](V),
                  !(this['ended'] = true);
              J['next_out'] && (0x0 !== J['avail_out'] && V !== Y['Z_STREAM_END'] && (0x0 !== J['avail_in'] || Z !== Y['Z_FINISH'] && Z !== Y['Z_SYNC_FLUSH']) || ('string' === this['options']['to'] ? (B = w['utf8border'](J['output'], J['next_out']),
                S = J['next_out'] - B,
                U = w['buf2string'](J['output'], B),
                J['next_out'] = S,
                J['avail_out'] = C - S,
                S && y['arraySet'](J['output'], J['output'], B, S, 0x0),
                this['onData'](U)) : this['onData'](y['shrinkBuf'](J['output'], J['next_out'])))),
                0x0 === J['avail_in'] && 0x0 === J['avail_out'] && (G = true);
            } while ((0x0 < J['avail_in'] || 0x0 === J['avail_out']) && V !== Y['Z_STREAM_END']);
            return V === Y['Z_STREAM_END'] && (Z = Y['Z_FINISH']),
              Z === Y['Z_FINISH'] ? (V = F['inflateEnd'](this['strm']),
                this['onEnd'](V),
                this['ended'] = true,
                V === Y['Z_OK']) : Z !== Y['Z_SYNC_FLUSH'] || (this['onEnd'](Y['Z_OK']),
                  !(J['avail_out'] = 0x0));
          }
            ,
            W['prototype']['onData'] = function (j) {
              this['chunks']['push'](j);
            }
            ,
            W['prototype']['onEnd'] = function (j) {
              j === Y['Z_OK'] && ('string' === this['options']['to'] ? this['result'] = this['chunks']['join']('') : this['result'] = y['flattenChunks'](this['chunks'])),
                this['chunks'] = [],
                this['err'] = j,
                this['msg'] = this['strm']['msg'];
            }
            ,
            p['Inflate'] = W,
            p['inflate'] = I,
            p['inflateRaw'] = function (j, D) {
              return (D = D || {})['raw'] = true,
                I(j, D);
            }
            ,
            p['ungzip'] = I;
        }
          , {
          './utils/common': 0x29,
          './utils/strings': 0x2a,
          './zlib/constants': 0x2c,
          './zlib/gzheader': 0x2f,
          './zlib/inflate': 0x31,
          './zlib/messages': 0x33,
          './zlib/zstream': 0x35
        }],
        0x29: [function (c, H, x) {
          'use strict';
          var p = 'undefined' != typeof Uint8Array && 'undefined' != typeof Uint16Array && 'undefined' != typeof Int32Array;
          x['assign'] = function (w) {
            for (var h = Array['prototype']['slice']['call'](arguments, 0x1); h['length'];) {
              var u = h['shift']();
              if (u) {
                if ('object' != typeof u)
                  throw new TypeError(u + 'must\x20be\x20non-object');
                for (var Y in u)
                  u['hasOwnProperty'](Y) && (w[Y] = u[Y]);
              }
            }
            return w;
          }
            ,
            x['shrinkBuf'] = function (w, h) {
              return w['length'] === h ? w : w['subarray'] ? w['subarray'](0x0, h) : (w['length'] = h,
                w);
            }
            ;
          var F = {
            'arraySet': function (w, h, u, Y, T) {
              if (h['subarray'] && w['subarray'])
                w['set'](h['subarray'](u, u + Y), T);
              else {
                for (var X = 0x0; X < Y; X++)
                  w[T + X] = h[u + X];
              }
            },
            'flattenChunks': function (w) {
              var h, u, Y, T, X, E;
              for (h = Y = 0x0,
                u = w['length']; h < u; h++)
                Y += w[h]['length'];
              for (E = new Uint8Array(Y),
                h = T = 0x0,
                u = w['length']; h < u; h++)
                X = w[h],
                  E['set'](X, T),
                  T += X['length'];
              return E;
            }
          }
            , y = {
              'arraySet': function (w, h, u, Y, T) {
                for (var X = 0x0; X < Y; X++)
                  w[T + X] = h[u + X];
              },
              'flattenChunks': function (w) {
                return []['concat']['apply']([], w);
              }
            };
          x['setTyped'] = function (w) {
            w ? (x['Buf8'] = Uint8Array,
              x['Buf16'] = Uint16Array,
              x['Buf32'] = Int32Array,
              x['assign'](x, F)) : (x['Buf8'] = Array,
                x['Buf16'] = Array,
                x['Buf32'] = Array,
                x['assign'](x, y));
          }
            ,
            x['setTyped'](p);
        }
          , {}],
        0x2a: [function (c, H, x) {
          'use strict';
          var p = c('./common')
            , F = true
            , y = true;
          try {
            String['fromCharCode']['apply'](null, [0x0]);
          } catch (Y) {
            F = false;
          }
          try {
            String['fromCharCode']['apply'](null, new Uint8Array(0x1));
          } catch (T) {
            y = false;
          }
          for (var w = new p['Buf8'](0x100), h = 0x0; h < 0x100; h++)
            w[h] = 0xfc <= h ? 0x6 : 0xf8 <= h ? 0x5 : 0xf0 <= h ? 0x4 : 0xe0 <= h ? 0x3 : 0xc0 <= h ? 0x2 : 0x1;
          function u (X, E) {
            if (E < 0x10001 && (X['subarray'] && y || !X['subarray'] && F))
              return String['fromCharCode']['apply'](null, p['shrinkBuf'](X, E));
            for (var f = '', W = 0x0; W < E; W++)
              f += String['fromCharCode'](X[W]);
            return f;
          }
          w[0xfe] = w[0xfe] = 0x1,
            x['string2buf'] = function (X) {
              var E, f, W, I, j, D = X['length'], V = 0x0;
              for (I = 0x0; I < D; I++)
                0xd800 == (0xfc00 & (f = X['charCodeAt'](I))) && I + 0x1 < D && 0xdc00 == (0xfc00 & (W = X['charCodeAt'](I + 0x1))) && (f = 0x10000 + (f - 0xd800 << 0xa) + (W - 0xdc00),
                  I++),
                  V += f < 0x80 ? 0x1 : f < 0x800 ? 0x2 : f < 0x10000 ? 0x3 : 0x4;
              for (E = new p['Buf8'](V),
                I = j = 0x0; j < V; I++)
                0xd800 == (0xfc00 & (f = X['charCodeAt'](I))) && I + 0x1 < D && 0xdc00 == (0xfc00 & (W = X['charCodeAt'](I + 0x1))) && (f = 0x10000 + (f - 0xd800 << 0xa) + (W - 0xdc00),
                  I++),
                  f < 0x80 ? E[j++] = f : (f < 0x800 ? E[j++] = 0xc0 | f >>> 0x6 : (f < 0x10000 ? E[j++] = 0xe0 | f >>> 0xc : (E[j++] = 0xf0 | f >>> 0x12,
                    E[j++] = 0x80 | f >>> 0xc & 0x3f),
                    E[j++] = 0x80 | f >>> 0x6 & 0x3f),
                    E[j++] = 0x80 | 0x3f & f);
              return E;
            }
            ,
            x['buf2binstring'] = function (X) {
              return u(X, X['length']);
            }
            ,
            x['binstring2buf'] = function (X) {
              for (var E = new p['Buf8'](X['length']), f = 0x0, W = E['length']; f < W; f++)
                E[f] = X['charCodeAt'](f);
              return E;
            }
            ,
            x['buf2string'] = function (X, E) {
              var f, W, I, j, D = E || X['length'], V = new Array(0x2 * D);
              for (f = W = 0x0; f < D;)
                if ((I = X[f++]) < 0x80)
                  V[W++] = I;
                else {
                  if (0x4 < (j = w[I]))
                    V[W++] = 0xfffd,
                      f += j - 0x1;
                  else {
                    for (I &= 0x2 === j ? 0x1f : 0x3 === j ? 0xf : 0x7; 0x1 < j && f < D;)
                      I = I << 0x6 | 0x3f & X[f++],
                        j--;
                    0x1 < j ? V[W++] = 0xfffd : I < 0x10000 ? V[W++] = I : (I -= 0x10000,
                      V[W++] = 0xd800 | I >> 0xa & 0x3ff,
                      V[W++] = 0xdc00 | 0x3ff & I);
                  }
                }
              return u(V, W);
            }
            ,
            x['utf8border'] = function (X, E) {
              var f;
              for ((E = E || X['length']) > X['length'] && (E = X['length']),
                f = E - 0x1; 0x0 <= f && 0x80 == (0xc0 & X[f]);)
                f--;
              return f < 0x0 || 0x0 === f ? E : f + w[X[f]] > E ? f : E;
            }
            ;
        }
          , {
          './common': 0x29
        }],
        0x2b: [function (c, H, x) {
          'use strict';
          H['exports'] = function (p, F, y, w) {
            for (var h = 0xffff & p | 0x0, u = p >>> 0x10 & 0xffff | 0x0, Y = 0x0; 0x0 !== y;) {
              for (y -= Y = 0x7d0 < y ? 0x7d0 : y; u = u + (h = h + F[w++] | 0x0) | 0x0,
                --Y;)
                ;
              h %= 0xfff1,
                u %= 0xfff1;
            }
            return h | u << 0x10 | 0x0;
          }
            ;
        }
          , {}],
        0x2c: [function (c, H, x) {
          'use strict';
          H['exports'] = {
            'Z_NO_FLUSH': 0x0,
            'Z_PARTIAL_FLUSH': 0x1,
            'Z_SYNC_FLUSH': 0x2,
            'Z_FULL_FLUSH': 0x3,
            'Z_FINISH': 0x4,
            'Z_BLOCK': 0x5,
            'Z_TREES': 0x6,
            'Z_OK': 0x0,
            'Z_STREAM_END': 0x1,
            'Z_NEED_DICT': 0x2,
            'Z_ERRNO': -0x1,
            'Z_STREAM_ERROR': -0x2,
            'Z_DATA_ERROR': -0x3,
            'Z_BUF_ERROR': -0x5,
            'Z_NO_COMPRESSION': 0x0,
            'Z_BEST_SPEED': 0x1,
            'Z_BEST_COMPRESSION': 0x9,
            'Z_DEFAULT_COMPRESSION': -0x1,
            'Z_FILTERED': 0x1,
            'Z_HUFFMAN_ONLY': 0x2,
            'Z_RLE': 0x3,
            'Z_FIXED': 0x4,
            'Z_DEFAULT_STRATEGY': 0x0,
            'Z_BINARY': 0x0,
            'Z_TEXT': 0x1,
            'Z_UNKNOWN': 0x2,
            'Z_DEFLATED': 0x8
          };
        }
          , {}],
        0x2d: [function (c, H, x) {
          'use strict';
          var p = function () {
            for (var F, y = [], w = 0x0; w < 0x100; w++) {
              F = w;
              for (var s = 0x0; s < 0x8; s++)
                F = 0x1 & F ? 0xedb88320 ^ F >>> 0x1 : F >>> 0x1;
              y[w] = F;
            }
            return y;
          }();
          H['exports'] = function (F, y, w, h) {
            var u = p
              , Y = h + w;
            F ^= -0x1;
            for (var T = h; T < Y; T++)
              F = F >>> 0x8 ^ u[0xff & (F ^ y[T])];
            return -0x1 ^ F;
          }
            ;
        }
          , {}],
        0x2e: [function (H, Y, X) {
          'use strict';
          var W, j = H('../utils/common'), V = H('./trees'), Z = H('./adler32'), q = H('./crc32'), J = H('./messages'), G = 0x0, N = 0x0, Q = -0x2, v0 = 0x2, v1 = 0x8, v2 = 0x11e, v3 = 0x1e, v4 = 0x13, v5 = 0x2 * v2 + 0x1, v6 = 0xf, v7 = 0x3, v8 = 0x102, v9 = v8 + v7 + 0x1, vv = 0x2a, vA = 0x71;
          function vn (vs, vh) {
            return vs['msg'] = J[vh],
              vh;
          }
          function vk (vs) {
            return (vs << 0x1) - (0x4 < vs ? 0x9 : 0x0);
          }
          function vl (vs) {
            for (var vh = vs['length']; 0x0 <= --vh;)
              vs[vh] = 0x0;
          }
          function vK (vs) {
            var vh = vs['state']
              , vu = vh['pending'];
            vu > vs['avail_out'] && (vu = vs['avail_out']),
              0x0 !== vu && (j['arraySet'](vs['output'], vh['pending_buf'], vh['pending_out'], vu, vs['next_out']),
                vs['next_out'] += vu,
                vh['pending_out'] += vu,
                vs['total_out'] += vu,
                vs['avail_out'] -= vu,
                vh['pending'] -= vu,
                0x0 === vh['pending'] && (vh['pending_out'] = 0x0));
          }
          function vi (vs, vh) {
            V['_tr_flush_block'](vs, 0x0 <= vs['block_start'] ? vs['block_start'] : -0x1, vs['strstart'] - vs['block_start'], vh),
              vs['block_start'] = vs['strstart'],
              vK(vs['strm']);
          }
          function vb (vs, vh) {
            vs['pending_buf'][vs['pending']++] = vh;
          }
          function ve (vs, vh) {
            vs['pending_buf'][vs['pending']++] = vh >>> 0x8 & 0xff,
              vs['pending_buf'][vs['pending']++] = 0xff & vh;
          }
          function vc (vs, vh) {
            var vu, vY, vT = vs['max_chain_length'], vX = vs['strstart'], Quadtree = vs['prev_length'], vf = vs['nice_match'], vW = vs['strstart'] > vs['w_size'] - v9 ? vs['strstart'] - (vs['w_size'] - v9) : 0x0, vI = vs['window'], vj = vs['w_mask'], vD = vs['prev'], vV = vs['strstart'] + v8, vZ = vI[vX + Quadtree - 0x1], vB = vI[vX + Quadtree];
            vs['prev_length'] >= vs['good_match'] && (vT >>= 0x2),
              vf > vs['lookahead'] && (vf = vs['lookahead']);
            do {
              if (vI[(vu = vh) + Quadtree] === vB && vI[vu + Quadtree - 0x1] === vZ && vI[vu] === vI[vX] && vI[++vu] === vI[vX + 0x1]) {
                vX += 0x2,
                  vu++;
                do { } while (vI[++vX] === vI[++vu] && vI[++vX] === vI[++vu] && vI[++vX] === vI[++vu] && vI[++vX] === vI[++vu] && vI[++vX] === vI[++vu] && vI[++vX] === vI[++vu] && vI[++vX] === vI[++vu] && vI[++vX] === vI[++vu] && vX < vV);
                if (vY = v8 - (vV - vX),
                  vX = vV - v8,
                  Quadtree < vY) {
                  if (vs['match_start'] = vh,
                    vf <= (Quadtree = vY))
                    break;
                  vZ = vI[vX + Quadtree - 0x1],
                    vB = vI[vX + Quadtree];
                }
              }
            } while ((vh = vD[vh & vj]) > vW && 0x0 != --vT);
            return Quadtree <= vs['lookahead'] ? Quadtree : vs['lookahead'];
          }
          function vH (vs) {
            var vh, vu, vY, vT, vX, Quadtree, vf, vW, vI, vj, vD = vs['w_size'];
            do {
              if (vT = vs['window_size'] - vs['lookahead'] - vs['strstart'],
                vs['strstart'] >= vD + (vD - v9)) {
                for (j['arraySet'](vs['window'], vs['window'], vD, vD, 0x0),
                  vs['match_start'] -= vD,
                  vs['strstart'] -= vD,
                  vs['block_start'] -= vD,
                  vh = vu = vs['hash_size']; vY = vs['head'][--vh],
                  vs['head'][vh] = vD <= vY ? vY - vD : 0x0,
                  --vu;)
                  ;
                for (vh = vu = vD; vY = vs['prev'][--vh],
                  vs['prev'][vh] = vD <= vY ? vY - vD : 0x0,
                  --vu;)
                  ;
                vT += vD;
              }
              if (0x0 === vs['strm']['avail_in'])
                break;
              if (Quadtree = vs['strm'],
                vf = vs['window'],
                vW = vs['strstart'] + vs['lookahead'],
                vj = undefined,
                (vI = vT) < (vj = Quadtree['avail_in']) && (vj = vI),
                vu = 0x0 === vj ? 0x0 : (Quadtree['avail_in'] -= vj,
                  j['arraySet'](vf, Quadtree['input'], Quadtree['next_in'], vj, vW),
                  0x1 === Quadtree['state']['wrap'] ? Quadtree['adler'] = Z(Quadtree['adler'], vf, vj, vW) : 0x2 === Quadtree['state']['wrap'] && (Quadtree['adler'] = q(Quadtree['adler'], vf, vj, vW)),
                  Quadtree['next_in'] += vj,
                  Quadtree['total_in'] += vj,
                  vj),
                vs['lookahead'] += vu,
                vs['lookahead'] + vs['insert'] >= v7) {
                for (vX = vs['strstart'] - vs['insert'],
                  vs['ins_h'] = vs['window'][vX],
                  vs['ins_h'] = (vs['ins_h'] << vs['hash_shift'] ^ vs['window'][vX + 0x1]) & vs['hash_mask']; vs['insert'] && (vs['ins_h'] = (vs['ins_h'] << vs['hash_shift'] ^ vs['window'][vX + v7 - 0x1]) & vs['hash_mask'],
                    vs['prev'][vX & vs['w_mask']] = vs['head'][vs['ins_h']],
                    vs['head'][vs['ins_h']] = vX,
                    vX++,
                    vs['insert']--,
                    !(vs['lookahead'] + vs['insert'] < v7));)
                  ;
              }
            } while (vs['lookahead'] < v9 && 0x0 !== vs['strm']['avail_in']);
          }
          function vt (vs, vh) {
            for (var vu, vY; ;) {
              if (vs['lookahead'] < v9) {
                if (vH(vs),
                  vs['lookahead'] < v9 && vh === G)
                  return 0x1;
                if (0x0 === vs['lookahead'])
                  break;
              }
              if (vu = 0x0,
                vs['lookahead'] >= v7 && (vs['ins_h'] = (vs['ins_h'] << vs['hash_shift'] ^ vs['window'][vs['strstart'] + v7 - 0x1]) & vs['hash_mask'],
                  vu = vs['prev'][vs['strstart'] & vs['w_mask']] = vs['head'][vs['ins_h']],
                  vs['head'][vs['ins_h']] = vs['strstart']),
                0x0 !== vu && vs['strstart'] - vu <= vs['w_size'] - v9 && (vs['match_length'] = vc(vs, vu)),
                vs['match_length'] >= v7) {
                if (vY = V['_tr_tally'](vs, vs['strstart'] - vs['match_start'], vs['match_length'] - v7),
                  vs['lookahead'] -= vs['match_length'],
                  vs['match_length'] <= vs['max_lazy_match'] && vs['lookahead'] >= v7) {
                  for (vs['match_length']--; vs['strstart']++,
                    vs['ins_h'] = (vs['ins_h'] << vs['hash_shift'] ^ vs['window'][vs['strstart'] + v7 - 0x1]) & vs['hash_mask'],
                    vu = vs['prev'][vs['strstart'] & vs['w_mask']] = vs['head'][vs['ins_h']],
                    vs['head'][vs['ins_h']] = vs['strstart'],
                    0x0 != --vs['match_length'];)
                    ;
                  vs['strstart']++;
                } else
                  vs['strstart'] += vs['match_length'],
                    vs['match_length'] = 0x0,
                    vs['ins_h'] = vs['window'][vs['strstart']],
                    vs['ins_h'] = (vs['ins_h'] << vs['hash_shift'] ^ vs['window'][vs['strstart'] + 0x1]) & vs['hash_mask'];
              } else
                vY = V['_tr_tally'](vs, 0x0, vs['window'][vs['strstart']]),
                  vs['lookahead']--,
                  vs['strstart']++;
              if (vY && (vi(vs, false),
                0x0 === vs['strm']['avail_out']))
                return 0x1;
            }
            return vs['insert'] = vs['strstart'] < v7 - 0x1 ? vs['strstart'] : v7 - 0x1,
              0x4 === vh ? (vi(vs, true),
                0x0 === vs['strm']['avail_out'] ? 0x3 : 0x4) : vs['last_lit'] && (vi(vs, false),
                  0x0 === vs['strm']['avail_out']) ? 0x1 : 0x2;
          }
          function vx (vs, vh) {
            for (var vu, vY, vT; ;) {
              if (vs['lookahead'] < v9) {
                if (vH(vs),
                  vs['lookahead'] < v9 && vh === G)
                  return 0x1;
                if (0x0 === vs['lookahead'])
                  break;
              }
              if (vu = 0x0,
                vs['lookahead'] >= v7 && (vs['ins_h'] = (vs['ins_h'] << vs['hash_shift'] ^ vs['window'][vs['strstart'] + v7 - 0x1]) & vs['hash_mask'],
                  vu = vs['prev'][vs['strstart'] & vs['w_mask']] = vs['head'][vs['ins_h']],
                  vs['head'][vs['ins_h']] = vs['strstart']),
                vs['prev_length'] = vs['match_length'],
                vs['prev_match'] = vs['match_start'],
                vs['match_length'] = v7 - 0x1,
                0x0 !== vu && vs['prev_length'] < vs['max_lazy_match'] && vs['strstart'] - vu <= vs['w_size'] - v9 && (vs['match_length'] = vc(vs, vu),
                  vs['match_length'] <= 0x5 && (0x1 === vs['strategy'] || vs['match_length'] === v7 && 0x1000 < vs['strstart'] - vs['match_start']) && (vs['match_length'] = v7 - 0x1)),
                vs['prev_length'] >= v7 && vs['match_length'] <= vs['prev_length']) {
                for (vT = vs['strstart'] + vs['lookahead'] - v7,
                  vY = V['_tr_tally'](vs, vs['strstart'] - 0x1 - vs['prev_match'], vs['prev_length'] - v7),
                  vs['lookahead'] -= vs['prev_length'] - 0x1,
                  vs['prev_length'] -= 0x2; ++vs['strstart'] <= vT && (vs['ins_h'] = (vs['ins_h'] << vs['hash_shift'] ^ vs['window'][vs['strstart'] + v7 - 0x1]) & vs['hash_mask'],
                    vu = vs['prev'][vs['strstart'] & vs['w_mask']] = vs['head'][vs['ins_h']],
                    vs['head'][vs['ins_h']] = vs['strstart']),
                  0x0 != --vs['prev_length'];)
                  ;
                if (vs['match_available'] = 0x0,
                  vs['match_length'] = v7 - 0x1,
                  vs['strstart']++,
                  vY && (vi(vs, false),
                    0x0 === vs['strm']['avail_out']))
                  return 0x1;
              } else {
                if (vs['match_available']) {
                  if ((vY = V['_tr_tally'](vs, 0x0, vs['window'][vs['strstart'] - 0x1])) && vi(vs, false),
                    vs['strstart']++,
                    vs['lookahead']--,
                    0x0 === vs['strm']['avail_out'])
                    return 0x1;
                } else
                  vs['match_available'] = 0x1,
                    vs['strstart']++,
                    vs['lookahead']--;
              }
            }
            return vs['match_available'] && (vY = V['_tr_tally'](vs, 0x0, vs['window'][vs['strstart'] - 0x1]),
              vs['match_available'] = 0x0),
              vs['insert'] = vs['strstart'] < v7 - 0x1 ? vs['strstart'] : v7 - 0x1,
              0x4 === vh ? (vi(vs, true),
                0x0 === vs['strm']['avail_out'] ? 0x3 : 0x4) : vs['last_lit'] && (vi(vs, false),
                  0x0 === vs['strm']['avail_out']) ? 0x1 : 0x2;
          }
          function vp (vs, vh, vu, vY, vT) {
            this['good_length'] = vs,
              this['max_lazy'] = vh,
              this['nice_length'] = vu,
              this['max_chain'] = vY,
              this['func'] = vT;
          }
          function vF () {
            this['strm'] = null,
              this['status'] = 0x0,
              this['pending_buf'] = null,
              this['pending_buf_size'] = 0x0,
              this['pending_out'] = 0x0,
              this['pending'] = 0x0,
              this['wrap'] = 0x0,
              this['gzhead'] = null,
              this['gzindex'] = 0x0,
              this['method'] = v1,
              this['last_flush'] = -0x1,
              this['w_size'] = 0x0,
              this['w_bits'] = 0x0,
              this['w_mask'] = 0x0,
              this['window'] = null,
              this['window_size'] = 0x0,
              this['prev'] = null,
              this['head'] = null,
              this['ins_h'] = 0x0,
              this['hash_size'] = 0x0,
              this['hash_bits'] = 0x0,
              this['hash_mask'] = 0x0,
              this['hash_shift'] = 0x0,
              this['block_start'] = 0x0,
              this['match_length'] = 0x0,
              this['prev_match'] = 0x0,
              this['match_available'] = 0x0,
              this['strstart'] = 0x0,
              this['match_start'] = 0x0,
              this['lookahead'] = 0x0,
              this['prev_length'] = 0x0,
              this['max_chain_length'] = 0x0,
              this['max_lazy_match'] = 0x0,
              this['level'] = 0x0,
              this['strategy'] = 0x0,
              this['good_match'] = 0x0,
              this['nice_match'] = 0x0,
              this['dyn_ltree'] = new j['Buf16'](0x2 * v5),
              this['dyn_dtree'] = new j['Buf16'](0x2 * (0x2 * v3 + 0x1)),
              this['bl_tree'] = new j['Buf16'](0x2 * (0x2 * v4 + 0x1)),
              vl(this['dyn_ltree']),
              vl(this['dyn_dtree']),
              vl(this['bl_tree']),
              this['l_desc'] = null,
              this['d_desc'] = null,
              this['bl_desc'] = null,
              this['bl_count'] = new j['Buf16'](v6 + 0x1),
              this['heap'] = new j['Buf16'](0x2 * v2 + 0x1),
              vl(this['heap']),
              this['heap_len'] = 0x0,
              this['heap_max'] = 0x0,
              this['depth'] = new j['Buf16'](0x2 * v2 + 0x1),
              vl(this['depth']),
              this['l_buf'] = 0x0,
              this['lit_bufsize'] = 0x0,
              this['last_lit'] = 0x0,
              this['d_buf'] = 0x0,
              this['opt_len'] = 0x0,
              this['static_len'] = 0x0,
              this['matches'] = 0x0,
              this['insert'] = 0x0,
              this['bi_buf'] = 0x0,
              this['bi_valid'] = 0x0;
          }
          function vy (vs) {
            var vh;
            return vs && vs['state'] ? (vs['total_in'] = vs['total_out'] = 0x0,
              vs['data_type'] = v0,
              (vh = vs['state'])['pending'] = 0x0,
              vh['pending_out'] = 0x0,
              vh['wrap'] < 0x0 && (vh['wrap'] = -vh['wrap']),
              vh['status'] = vh['wrap'] ? vv : vA,
              vs['adler'] = 0x2 === vh['wrap'] ? 0x0 : 0x1,
              vh['last_flush'] = G,
              V['_tr_init'](vh),
              N) : vn(vs, Q);
          }
          function vr (vs) {
            var vh = vy(vs);
            return vh === N && function (vu) {
              vu['window_size'] = 0x2 * vu['w_size'],
                vl(vu['head']),
                vu['max_lazy_match'] = W[vu['level']]['max_lazy'],
                vu['good_match'] = W[vu['level']]['good_length'],
                vu['nice_match'] = W[vu['level']]['nice_length'],
                vu['max_chain_length'] = W[vu['level']]['max_chain'],
                vu['strstart'] = 0x0,
                vu['block_start'] = 0x0,
                vu['lookahead'] = 0x0,
                vu['insert'] = 0x0,
                vu['match_length'] = vu['prev_length'] = v7 - 0x1,
                vu['match_available'] = 0x0,
                vu['ins_h'] = 0x0;
            }(vs['state']),
              vh;
          }
          function vw (vs, vh, vu, vY, vT, vX) {
            if (!vs)
              return Q;
            var Quadtree = 0x1;
            if (-0x1 === vh && (vh = 0x6),
              vY < 0x0 ? (Quadtree = 0x0,
                vY = -vY) : 0xf < vY && (Quadtree = 0x2,
                  vY -= 0x10),
              vT < 0x1 || 0x9 < vT || vu !== v1 || vY < 0x8 || 0xf < vY || vh < 0x0 || 0x9 < vh || vX < 0x0 || 0x4 < vX)
              return vn(vs, Q);
            0x8 === vY && (vY = 0x9);
            var vf = new vF();
            return (vs['state'] = vf)['strm'] = vs,
              vf['wrap'] = Quadtree,
              vf['gzhead'] = null,
              vf['w_bits'] = vY,
              vf['w_size'] = 0x1 << vf['w_bits'],
              vf['w_mask'] = vf['w_size'] - 0x1,
              vf['hash_bits'] = vT + 0x7,
              vf['hash_size'] = 0x1 << vf['hash_bits'],
              vf['hash_mask'] = vf['hash_size'] - 0x1,
              vf['hash_shift'] = ~~((vf['hash_bits'] + v7 - 0x1) / v7),
              vf['window'] = new j['Buf8'](0x2 * vf['w_size']),
              vf['head'] = new j['Buf16'](vf['hash_size']),
              vf['prev'] = new j['Buf16'](vf['w_size']),
              vf['lit_bufsize'] = 0x1 << vT + 0x6,
              vf['pending_buf_size'] = 0x4 * vf['lit_bufsize'],
              vf['pending_buf'] = new j['Buf8'](vf['pending_buf_size']),
              vf['d_buf'] = 0x1 * vf['lit_bufsize'],
              vf['l_buf'] = 0x3 * vf['lit_bufsize'],
              vf['level'] = vh,
              vf['strategy'] = vX,
              vf['method'] = vu,
              vr(vs);
          }
          W = [new vp(0x0, 0x0, 0x0, 0x0, function (vs, vh) {
            var vu = 0xffff;
            for (vu > vs['pending_buf_size'] - 0x5 && (vu = vs['pending_buf_size'] - 0x5); ;) {
              if (vs['lookahead'] <= 0x1) {
                if (vH(vs),
                  0x0 === vs['lookahead'] && vh === G)
                  return 0x1;
                if (0x0 === vs['lookahead'])
                  break;
              }
              vs['strstart'] += vs['lookahead'],
                vs['lookahead'] = 0x0;
              var vY = vs['block_start'] + vu;
              if ((0x0 === vs['strstart'] || vs['strstart'] >= vY) && (vs['lookahead'] = vs['strstart'] - vY,
                vs['strstart'] = vY,
                vi(vs, false),
                0x0 === vs['strm']['avail_out']))
                return 0x1;
              if (vs['strstart'] - vs['block_start'] >= vs['w_size'] - v9 && (vi(vs, false),
                0x0 === vs['strm']['avail_out']))
                return 0x1;
            }
            return vs['insert'] = 0x0,
              0x4 === vh ? (vi(vs, true),
                0x0 === vs['strm']['avail_out'] ? 0x3 : 0x4) : (vs['strstart'] > vs['block_start'] && (vi(vs, false),
                  vs['strm']['avail_out']),
                  0x1);
          }
          ), new vp(0x4, 0x4, 0x8, 0x4, vt), new vp(0x4, 0x5, 0x10, 0x8, vt), new vp(0x4, 0x6, 0x20, 0x20, vt), new vp(0x4, 0x4, 0x10, 0x10, vx), new vp(0x8, 0x10, 0x20, 0x20, vx), new vp(0x8, 0x10, 0x80, 0x80, vx), new vp(0x8, 0x20, 0x80, 0x100, vx), new vp(0x20, 0x80, 0x102, 0x400, vx), new vp(0x20, 0x102, 0x102, 0x1000, vx)],
            X['deflateInit'] = function (vs, vh) {
              return vw(vs, vh, v1, 0xf, 0x8, 0x0);
            }
            ,
            X['deflateInit2'] = vw,
            X['deflateReset'] = vr,
            X['deflateResetKeep'] = vy,
            X['deflateSetHeader'] = function (vs, vh) {
              return vs && vs['state'] ? 0x2 !== vs['state']['wrap'] ? Q : (vs['state']['gzhead'] = vh,
                N) : Q;
            }
            ,
            X['deflate'] = function (vs, vh) {
              var vu, vY, vT, vX;
              if (!vs || !vs['state'] || 0x5 < vh || vh < 0x0)
                return vs ? vn(vs, Q) : Q;
              if (vY = vs['state'],
                !vs['output'] || !vs['input'] && 0x0 !== vs['avail_in'] || 0x29a === vY['status'] && 0x4 !== vh)
                return vn(vs, 0x0 === vs['avail_out'] ? -0x5 : Q);
              if (vY['strm'] = vs,
                vu = vY['last_flush'],
                vY['last_flush'] = vh,
                vY['status'] === vv) {
                if (0x2 === vY['wrap'])
                  vs['adler'] = 0x0,
                    vb(vY, 0x1f),
                    vb(vY, 0x8b),
                    vb(vY, 0x8),
                    vY['gzhead'] ? (vb(vY, (vY['gzhead']['text'] ? 0x1 : 0x0) + (vY['gzhead']['hcrc'] ? 0x2 : 0x0) + (vY['gzhead']['extra'] ? 0x4 : 0x0) + (vY['gzhead']['name'] ? 0x8 : 0x0) + (vY['gzhead']['comment'] ? 0x10 : 0x0)),
                      vb(vY, 0xff & vY['gzhead']['time']),
                      vb(vY, vY['gzhead']['time'] >> 0x8 & 0xff),
                      vb(vY, vY['gzhead']['time'] >> 0x10 & 0xff),
                      vb(vY, vY['gzhead']['time'] >> 0x18 & 0xff),
                      vb(vY, 0x9 === vY['level'] ? 0x2 : 0x2 <= vY['strategy'] || vY['level'] < 0x2 ? 0x4 : 0x0),
                      vb(vY, 0xff & vY['gzhead']['os']),
                      vY['gzhead']['extra'] && vY['gzhead']['extra']['length'] && (vb(vY, 0xff & vY['gzhead']['extra']['length']),
                        vb(vY, vY['gzhead']['extra']['length'] >> 0x8 & 0xff)),
                      vY['gzhead']['hcrc'] && (vs['adler'] = q(vs['adler'], vY['pending_buf'], vY['pending'], 0x0)),
                      vY['gzindex'] = 0x0,
                      vY['status'] = 0x45) : (vb(vY, 0x0),
                        vb(vY, 0x0),
                        vb(vY, 0x0),
                        vb(vY, 0x0),
                        vb(vY, 0x0),
                        vb(vY, 0x9 === vY['level'] ? 0x2 : 0x2 <= vY['strategy'] || vY['level'] < 0x2 ? 0x4 : 0x0),
                        vb(vY, 0x3),
                        vY['status'] = vA);
                else {
                  var Quadtree = v1 + (vY['w_bits'] - 0x8 << 0x4) << 0x8;
                  Quadtree |= (0x2 <= vY['strategy'] || vY['level'] < 0x2 ? 0x0 : vY['level'] < 0x6 ? 0x1 : 0x6 === vY['level'] ? 0x2 : 0x3) << 0x6,
                    0x0 !== vY['strstart'] && (Quadtree |= 0x20),
                    Quadtree += 0x1f - Quadtree % 0x1f,
                    vY['status'] = vA,
                    ve(vY, Quadtree),
                    0x0 !== vY['strstart'] && (ve(vY, vs['adler'] >>> 0x10),
                      ve(vY, 0xffff & vs['adler'])),
                    vs['adler'] = 0x1;
                }
              }
              if (0x45 === vY['status']) {
                if (vY['gzhead']['extra']) {
                  for (vT = vY['pending']; vY['gzindex'] < (0xffff & vY['gzhead']['extra']['length']) && (vY['pending'] !== vY['pending_buf_size'] || (vY['gzhead']['hcrc'] && vY['pending'] > vT && (vs['adler'] = q(vs['adler'], vY['pending_buf'], vY['pending'] - vT, vT)),
                    vK(vs),
                    vT = vY['pending'],
                    vY['pending'] !== vY['pending_buf_size']));)
                    vb(vY, 0xff & vY['gzhead']['extra'][vY['gzindex']]),
                      vY['gzindex']++;
                  vY['gzhead']['hcrc'] && vY['pending'] > vT && (vs['adler'] = q(vs['adler'], vY['pending_buf'], vY['pending'] - vT, vT)),
                    vY['gzindex'] === vY['gzhead']['extra']['length'] && (vY['gzindex'] = 0x0,
                      vY['status'] = 0x49);
                } else
                  vY['status'] = 0x49;
              }
              if (0x49 === vY['status']) {
                if (vY['gzhead']['name']) {
                  vT = vY['pending'];
                  do {
                    if (vY['pending'] === vY['pending_buf_size'] && (vY['gzhead']['hcrc'] && vY['pending'] > vT && (vs['adler'] = q(vs['adler'], vY['pending_buf'], vY['pending'] - vT, vT)),
                      vK(vs),
                      vT = vY['pending'],
                      vY['pending'] === vY['pending_buf_size'])) {
                      vX = 0x1;
                      break;
                    }
                    vX = vY['gzindex'] < vY['gzhead']['name']['length'] ? 0xff & vY['gzhead']['name']['charCodeAt'](vY['gzindex']++) : 0x0,
                      vb(vY, vX);
                  } while (0x0 !== vX);
                  vY['gzhead']['hcrc'] && vY['pending'] > vT && (vs['adler'] = q(vs['adler'], vY['pending_buf'], vY['pending'] - vT, vT)),
                    0x0 === vX && (vY['gzindex'] = 0x0,
                      vY['status'] = 0x5b);
                } else
                  vY['status'] = 0x5b;
              }
              if (0x5b === vY['status']) {
                if (vY['gzhead']['comment']) {
                  vT = vY['pending'];
                  do {
                    if (vY['pending'] === vY['pending_buf_size'] && (vY['gzhead']['hcrc'] && vY['pending'] > vT && (vs['adler'] = q(vs['adler'], vY['pending_buf'], vY['pending'] - vT, vT)),
                      vK(vs),
                      vT = vY['pending'],
                      vY['pending'] === vY['pending_buf_size'])) {
                      vX = 0x1;
                      break;
                    }
                    vX = vY['gzindex'] < vY['gzhead']['comment']['length'] ? 0xff & vY['gzhead']['comment']['charCodeAt'](vY['gzindex']++) : 0x0,
                      vb(vY, vX);
                  } while (0x0 !== vX);
                  vY['gzhead']['hcrc'] && vY['pending'] > vT && (vs['adler'] = q(vs['adler'], vY['pending_buf'], vY['pending'] - vT, vT)),
                    0x0 === vX && (vY['status'] = 0x67);
                } else
                  vY['status'] = 0x67;
              }
              if (0x67 === vY['status'] && (vY['gzhead']['hcrc'] ? (vY['pending'] + 0x2 > vY['pending_buf_size'] && vK(vs),
                vY['pending'] + 0x2 <= vY['pending_buf_size'] && (vb(vY, 0xff & vs['adler']),
                  vb(vY, vs['adler'] >> 0x8 & 0xff),
                  vs['adler'] = 0x0,
                  vY['status'] = vA)) : vY['status'] = vA),
                0x0 !== vY['pending']) {
                if (vK(vs),
                  0x0 === vs['avail_out'])
                  return vY['last_flush'] = -0x1,
                    N;
              } else {
                if (0x0 === vs['avail_in'] && vk(vh) <= vk(vu) && 0x4 !== vh)
                  return vn(vs, -0x5);
              }
              if (0x29a === vY['status'] && 0x0 !== vs['avail_in'])
                return vn(vs, -0x5);
              if (0x0 !== vs['avail_in'] || 0x0 !== vY['lookahead'] || vh !== G && 0x29a !== vY['status']) {
                var vf = 0x2 === vY['strategy'] ? function (vW, vI) {
                  for (var vj; ;) {
                    if (0x0 === vW['lookahead'] && (vH(vW),
                      0x0 === vW['lookahead'])) {
                      if (vI === G)
                        return 0x1;
                      break;
                    }
                    if (vW['match_length'] = 0x0,
                      vj = V['_tr_tally'](vW, 0x0, vW['window'][vW['strstart']]),
                      vW['lookahead']--,
                      vW['strstart']++,
                      vj && (vi(vW, false),
                        0x0 === vW['strm']['avail_out']))
                      return 0x1;
                  }
                  return vW['insert'] = 0x0,
                    0x4 === vI ? (vi(vW, true),
                      0x0 === vW['strm']['avail_out'] ? 0x3 : 0x4) : vW['last_lit'] && (vi(vW, false),
                        0x0 === vW['strm']['avail_out']) ? 0x1 : 0x2;
                }(vY, vh) : 0x3 === vY['strategy'] ? function (vW, vI) {
                  for (var vj, vD, vV, vZ, vB = vW['window']; ;) {
                    if (vW['lookahead'] <= v8) {
                      if (vH(vW),
                        vW['lookahead'] <= v8 && vI === G)
                        return 0x1;
                      if (0x0 === vW['lookahead'])
                        break;
                    }
                    if (vW['match_length'] = 0x0,
                      vW['lookahead'] >= v7 && 0x0 < vW['strstart'] && (vD = vB[vV = vW['strstart'] - 0x1]) === vB[++vV] && vD === vB[++vV] && vD === vB[++vV]) {
                      vZ = vW['strstart'] + v8;
                      do { } while (vD === vB[++vV] && vD === vB[++vV] && vD === vB[++vV] && vD === vB[++vV] && vD === vB[++vV] && vD === vB[++vV] && vD === vB[++vV] && vD === vB[++vV] && vV < vZ);
                      vW['match_length'] = v8 - (vZ - vV),
                        vW['match_length'] > vW['lookahead'] && (vW['match_length'] = vW['lookahead']);
                    }
                    if (vW['match_length'] >= v7 ? (vj = V['_tr_tally'](vW, 0x1, vW['match_length'] - v7),
                      vW['lookahead'] -= vW['match_length'],
                      vW['strstart'] += vW['match_length'],
                      vW['match_length'] = 0x0) : (vj = V['_tr_tally'](vW, 0x0, vW['window'][vW['strstart']]),
                        vW['lookahead']--,
                        vW['strstart']++),
                      vj && (vi(vW, false),
                        0x0 === vW['strm']['avail_out']))
                      return 0x1;
                  }
                  return vW['insert'] = 0x0,
                    0x4 === vI ? (vi(vW, true),
                      0x0 === vW['strm']['avail_out'] ? 0x3 : 0x4) : vW['last_lit'] && (vi(vW, false),
                        0x0 === vW['strm']['avail_out']) ? 0x1 : 0x2;
                }(vY, vh) : W[vY['level']]['func'](vY, vh);
                if (0x3 !== vf && 0x4 !== vf || (vY['status'] = 0x29a),
                  0x1 === vf || 0x3 === vf)
                  return 0x0 === vs['avail_out'] && (vY['last_flush'] = -0x1),
                    N;
                if (0x2 === vf && (0x1 === vh ? V['_tr_align'](vY) : 0x5 !== vh && (V['_tr_stored_block'](vY, 0x0, 0x0, false),
                  0x3 === vh && (vl(vY['head']),
                    0x0 === vY['lookahead'] && (vY['strstart'] = 0x0,
                      vY['block_start'] = 0x0,
                      vY['insert'] = 0x0))),
                  vK(vs),
                  0x0 === vs['avail_out']))
                  return vY['last_flush'] = -0x1,
                    N;
              }
              return 0x4 !== vh ? N : vY['wrap'] <= 0x0 ? 0x1 : (0x2 === vY['wrap'] ? (vb(vY, 0xff & vs['adler']),
                vb(vY, vs['adler'] >> 0x8 & 0xff),
                vb(vY, vs['adler'] >> 0x10 & 0xff),
                vb(vY, vs['adler'] >> 0x18 & 0xff),
                vb(vY, 0xff & vs['total_in']),
                vb(vY, vs['total_in'] >> 0x8 & 0xff),
                vb(vY, vs['total_in'] >> 0x10 & 0xff),
                vb(vY, vs['total_in'] >> 0x18 & 0xff)) : (ve(vY, vs['adler'] >>> 0x10),
                  ve(vY, 0xffff & vs['adler'])),
                vK(vs),
                0x0 < vY['wrap'] && (vY['wrap'] = -vY['wrap']),
                0x0 !== vY['pending'] ? N : 0x1);
            }
            ,
            X['deflateEnd'] = function (vs) {
              var vh;
              return vs && vs['state'] ? (vh = vs['state']['status']) !== vv && 0x45 !== vh && 0x49 !== vh && 0x5b !== vh && 0x67 !== vh && vh !== vA && 0x29a !== vh ? vn(vs, Q) : (vs['state'] = null,
                vh === vA ? vn(vs, -0x3) : N) : Q;
            }
            ,
            X['deflateSetDictionary'] = function (vs, vh) {
              var vu, vY, vT, vX, Quadtree, vf, vW, vI, vj = vh['length'];
              if (!vs || !vs['state'])
                return Q;
              if (0x2 === (vX = (vu = vs['state'])['wrap']) || 0x1 === vX && vu['status'] !== vv || vu['lookahead'])
                return Q;
              for (0x1 === vX && (vs['adler'] = Z(vs['adler'], vh, vj, 0x0)),
                vu['wrap'] = 0x0,
                vj >= vu['w_size'] && (0x0 === vX && (vl(vu['head']),
                  vu['strstart'] = 0x0,
                  vu['block_start'] = 0x0,
                  vu['insert'] = 0x0),
                  vI = new j['Buf8'](vu['w_size']),
                  j['arraySet'](vI, vh, vj - vu['w_size'], vu['w_size'], 0x0),
                  vh = vI,
                  vj = vu['w_size']),
                Quadtree = vs['avail_in'],
                vf = vs['next_in'],
                vW = vs['input'],
                vs['avail_in'] = vj,
                vs['next_in'] = 0x0,
                vs['input'] = vh,
                vH(vu); vu['lookahead'] >= v7;) {
                for (vY = vu['strstart'],
                  vT = vu['lookahead'] - (v7 - 0x1); vu['ins_h'] = (vu['ins_h'] << vu['hash_shift'] ^ vu['window'][vY + v7 - 0x1]) & vu['hash_mask'],
                  vu['prev'][vY & vu['w_mask']] = vu['head'][vu['ins_h']],
                  vu['head'][vu['ins_h']] = vY,
                  vY++,
                  --vT;)
                  ;
                vu['strstart'] = vY,
                  vu['lookahead'] = v7 - 0x1,
                  vH(vu);
              }
              return vu['strstart'] += vu['lookahead'],
                vu['block_start'] = vu['strstart'],
                vu['insert'] = vu['lookahead'],
                vu['lookahead'] = 0x0,
                vu['match_length'] = vu['prev_length'] = v7 - 0x1,
                vu['match_available'] = 0x0,
                vs['next_in'] = vf,
                vs['input'] = vW,
                vs['avail_in'] = Quadtree,
                vu['wrap'] = vX,
                N;
            }
            ,
            X['deflateInfo'] = 'pako\x20deflate\x20(from\x20Nodeca\x20project)';
        }
          , {
          '../utils/common': 0x29,
          './adler32': 0x2b,
          './crc32': 0x2d,
          './messages': 0x33,
          './trees': 0x34
        }],
        0x2f: [function (c, H, x) {
          'use strict';
          H['exports'] = function () {
            this['text'] = 0x0,
              this['time'] = 0x0,
              this['xflags'] = 0x0,
              this['os'] = 0x0,
              this['extra'] = null,
              this['extra_len'] = 0x0,
              this['name'] = '',
              this['comment'] = '',
              this['hcrc'] = 0x0,
              this['done'] = false;
          }
            ;
        }
          , {}],
        0x30: [function (c, H, x) {
          'use strict';
          H['exports'] = function (F, Y) {
            var T, X, E, W, j, D, V, Z, B, U, q, J, C, O, G, N, M, z, Q, L, R, v0, v1, v2, v3;
            T = F['state'],
              X = F['next_in'],
              v2 = F['input'],
              E = X + (F['avail_in'] - 0x5),
              W = F['next_out'],
              v3 = F['output'],
              j = W - (Y - F['avail_out']),
              D = W + (F['avail_out'] - 0x101),
              V = T['dmax'],
              Z = T['wsize'],
              B = T['whave'],
              U = T['wnext'],
              q = T['window'],
              J = T['hold'],
              C = T['bits'],
              O = T['lencode'],
              G = T['distcode'],
              N = (0x1 << T['lenbits']) - 0x1,
              M = (0x1 << T['distbits']) - 0x1;
            v4: do {
              C < 0xf && (J += v2[X++] << C,
                C += 0x8,
                J += v2[X++] << C,
                C += 0x8),
                z = O[J & N];
              v5: for (; ;) {
                if (J >>>= Q = z >>> 0x18,
                  C -= Q,
                  0x0 == (Q = z >>> 0x10 & 0xff))
                  v3[W++] = 0xffff & z;
                else {
                  if (!(0x10 & Q)) {
                    if (0x0 == (0x40 & Q)) {
                      z = O[(0xffff & z) + (J & (0x1 << Q) - 0x1)];
                      continue v5;
                    }
                    if (0x20 & Q) {
                      T['mode'] = 0xc;
                      break v4;
                    }
                    F['msg'] = 'invalid\x20literal/length\x20code',
                      T['mode'] = 0x1e;
                    break v4;
                  }
                  L = 0xffff & z,
                    (Q &= 0xf) && (C < Q && (J += v2[X++] << C,
                      C += 0x8),
                      L += J & (0x1 << Q) - 0x1,
                      J >>>= Q,
                      C -= Q),
                    C < 0xf && (J += v2[X++] << C,
                      C += 0x8,
                      J += v2[X++] << C,
                      C += 0x8),
                    z = G[J & M];
                  v6: for (; ;) {
                    if (J >>>= Q = z >>> 0x18,
                      C -= Q,
                      !(0x10 & (Q = z >>> 0x10 & 0xff))) {
                      if (0x0 == (0x40 & Q)) {
                        z = G[(0xffff & z) + (J & (0x1 << Q) - 0x1)];
                        continue v6;
                      }
                      F['msg'] = 'invalid\x20distance\x20code',
                        T['mode'] = 0x1e;
                      break v4;
                    }
                    if (R = 0xffff & z,
                      C < (Q &= 0xf) && (J += v2[X++] << C,
                        (C += 0x8) < Q && (J += v2[X++] << C,
                          C += 0x8)),
                      V < (R += J & (0x1 << Q) - 0x1)) {
                      F['msg'] = 'invalid\x20distance\x20too\x20far\x20back',
                        T['mode'] = 0x1e;
                      break v4;
                    }
                    if (J >>>= Q,
                      C -= Q,
                      (Q = W - j) < R) {
                      if (B < (Q = R - Q) && T['sane']) {
                        F['msg'] = 'invalid\x20distance\x20too\x20far\x20back',
                          T['mode'] = 0x1e;
                        break v4;
                      }
                      if (v1 = q,
                        (v0 = 0x0) === U) {
                        if (v0 += Z - Q,
                          Q < L) {
                          for (L -= Q; v3[W++] = q[v0++],
                            --Q;)
                            ;
                          v0 = W - R,
                            v1 = v3;
                        }
                      } else {
                        if (U < Q) {
                          if (v0 += Z + U - Q,
                            (Q -= U) < L) {
                            for (L -= Q; v3[W++] = q[v0++],
                              --Q;)
                              ;
                            if (v0 = 0x0,
                              U < L) {
                              for (L -= Q = U; v3[W++] = q[v0++],
                                --Q;)
                                ;
                              v0 = W - R,
                                v1 = v3;
                            }
                          }
                        } else {
                          if (v0 += U - Q,
                            Q < L) {
                            for (L -= Q; v3[W++] = q[v0++],
                              --Q;)
                              ;
                            v0 = W - R,
                              v1 = v3;
                          }
                        }
                      }
                      for (; 0x2 < L;)
                        v3[W++] = v1[v0++],
                          v3[W++] = v1[v0++],
                          v3[W++] = v1[v0++],
                          L -= 0x3;
                      L && (v3[W++] = v1[v0++],
                        0x1 < L && (v3[W++] = v1[v0++]));
                    } else {
                      for (v0 = W - R; v3[W++] = v3[v0++],
                        v3[W++] = v3[v0++],
                        v3[W++] = v3[v0++],
                        0x2 < (L -= 0x3);)
                        ;
                      L && (v3[W++] = v3[v0++],
                        0x1 < L && (v3[W++] = v3[v0++]));
                    }
                    break;
                  }
                }
                break;
              }
            } while (X < E && W < D);
            X -= L = C >> 0x3,
              J &= (0x1 << (C -= L << 0x3)) - 0x1,
              F['next_in'] = X,
              F['next_out'] = W,
              F['avail_in'] = X < E ? E - X + 0x5 : 0x5 - (X - E),
              F['avail_out'] = W < D ? D - W + 0x101 : 0x101 - (W - D),
              T['hold'] = J,
              T['bits'] = C;
          }
            ;
        }
          , {}],
        0x31: [function (H, F, Y) {
          'use strict';
          var T = H('../utils/common')
            , X = H('./adler32')
            , E = H('./crc32')
            , W = H('./inffast')
            , I = H('./inftrees')
            , j = 0x0
            , D = -0x2
            , V = 0x1
            , Z = 0x354
            , B = 0x250;
          function U (L) {
            return (L >>> 0x18 & 0xff) + (L >>> 0x8 & 0xff00) + ((0xff00 & L) << 0x8) + ((0xff & L) << 0x18);
          }
          function q () {
            this['mode'] = 0x0,
              this['last'] = false,
              this['wrap'] = 0x0,
              this['havedict'] = false,
              this['flags'] = 0x0,
              this['dmax'] = 0x0,
              this['check'] = 0x0,
              this['total'] = 0x0,
              this['head'] = null,
              this['wbits'] = 0x0,
              this['wsize'] = 0x0,
              this['whave'] = 0x0,
              this['wnext'] = 0x0,
              this['window'] = null,
              this['hold'] = 0x0,
              this['bits'] = 0x0,
              this['length'] = 0x0,
              this['offset'] = 0x0,
              this['extra'] = 0x0,
              this['lencode'] = null,
              this['distcode'] = null,
              this['lenbits'] = 0x0,
              this['distbits'] = 0x0,
              this['ncode'] = 0x0,
              this['nlen'] = 0x0,
              this['ndist'] = 0x0,
              this['have'] = 0x0,
              this['next'] = null,
              this['lens'] = new T['Buf16'](0x140),
              this['work'] = new T['Buf16'](0x120),
              this['lendyn'] = null,
              this['distdyn'] = null,
              this['sane'] = 0x0,
              this['back'] = 0x0,
              this['was'] = 0x0;
          }
          function J (L) {
            var R;
            return L && L['state'] ? (R = L['state'],
              L['total_in'] = L['total_out'] = R['total'] = 0x0,
              L['msg'] = '',
              R['wrap'] && (L['adler'] = 0x1 & R['wrap']),
              R['mode'] = V,
              R['last'] = 0x0,
              R['havedict'] = 0x0,
              R['dmax'] = 0x8000,
              R['head'] = null,
              R['hold'] = 0x0,
              R['bits'] = 0x0,
              R['lencode'] = R['lendyn'] = new T['Buf32'](Z),
              R['distcode'] = R['distdyn'] = new T['Buf32'](B),
              R['sane'] = 0x1,
              R['back'] = -0x1,
              j) : D;
          }
          function C (L) {
            var R;
            return L && L['state'] ? ((R = L['state'])['wsize'] = 0x0,
              R['whave'] = 0x0,
              R['wnext'] = 0x0,
              J(L)) : D;
          }
          function O (L, R) {
            var v0, v1;
            return L && L['state'] ? (v1 = L['state'],
              R < 0x0 ? (v0 = 0x0,
                R = -R) : (v0 = 0x1 + (R >> 0x4),
                  R < 0x30 && (R &= 0xf)),
              R && (R < 0x8 || 0xf < R) ? D : (null !== v1['window'] && v1['wbits'] !== R && (v1['window'] = null),
                v1['wrap'] = v0,
                v1['wbits'] = R,
                C(L))) : D;
          }
          function G (L, R) {
            var v0, v1;
            return L ? (v1 = new q(),
              (L['state'] = v1)['window'] = null,
              (v0 = O(L, R)) !== j && (L['state'] = null),
              v0) : D;
          }
          var N, P, M = true;
          function z (L) {
            if (M) {
              var R;
              for (N = new T['Buf32'](0x200),
                P = new T['Buf32'](0x20),
                R = 0x0; R < 0x90;)
                L['lens'][R++] = 0x8;
              for (; R < 0x100;)
                L['lens'][R++] = 0x9;
              for (; R < 0x118;)
                L['lens'][R++] = 0x7;
              for (; R < 0x120;)
                L['lens'][R++] = 0x8;
              for (I(0x1, L['lens'], 0x0, 0x120, N, 0x0, L['work'], {
                'bits': 0x9
              }),
                R = 0x0; R < 0x20;)
                L['lens'][R++] = 0x5;
              I(0x2, L['lens'], 0x0, 0x20, P, 0x0, L['work'], {
                'bits': 0x5
              }),
                M = false;
            }
            L['lencode'] = N,
              L['lenbits'] = 0x9,
              L['distcode'] = P,
              L['distbits'] = 0x5;
          }
          function Q (L, R, v0, v1) {
            var v2, v3 = L['state'];
            return null === v3['window'] && (v3['wsize'] = 0x1 << v3['wbits'],
              v3['wnext'] = 0x0,
              v3['whave'] = 0x0,
              v3['window'] = new T['Buf8'](v3['wsize'])),
              v1 >= v3['wsize'] ? (T['arraySet'](v3['window'], R, v0 - v3['wsize'], v3['wsize'], 0x0),
                v3['wnext'] = 0x0,
                v3['whave'] = v3['wsize']) : (v1 < (v2 = v3['wsize'] - v3['wnext']) && (v2 = v1),
                  T['arraySet'](v3['window'], R, v0 - v1, v2, v3['wnext']),
                  (v1 -= v2) ? (T['arraySet'](v3['window'], R, v0 - v1, v1, 0x0),
                    v3['wnext'] = v1,
                    v3['whave'] = v3['wsize']) : (v3['wnext'] += v2,
                      v3['wnext'] === v3['wsize'] && (v3['wnext'] = 0x0),
                      v3['whave'] < v3['wsize'] && (v3['whave'] += v2))),
              0x0;
          }
          Y['inflateReset'] = C,
            Y['inflateReset2'] = O,
            Y['inflateResetKeep'] = J,
            Y['inflateInit'] = function (L) {
              return G(L, 0xf);
            }
            ,
            Y['inflateInit2'] = G,
            Y['inflate'] = function (v0, v1) {
              var v2, v3, v4, v5, v6, v7, v8, v9, vv, vA, vn, vk, vl, vK, vi, vb, ve, vc, vH, vt, vx, vp, vF, vy, vr = 0x0, vw = new T['Buf8'](0x4), vs = [0x10, 0x11, 0x12, 0x0, 0x8, 0x7, 0x9, 0x6, 0xa, 0x5, 0xb, 0x4, 0xc, 0x3, 0xd, 0x2, 0xe, 0x1, 0xf];
              if (!v0 || !v0['state'] || !v0['output'] || !v0['input'] && 0x0 !== v0['avail_in'])
                return D;
              0xc === (v2 = v0['state'])['mode'] && (v2['mode'] = 0xd),
                v6 = v0['next_out'],
                v4 = v0['output'],
                v8 = v0['avail_out'],
                v5 = v0['next_in'],
                v3 = v0['input'],
                v7 = v0['avail_in'],
                v9 = v2['hold'],
                vv = v2['bits'],
                vA = v7,
                vn = v8,
                vp = j;
              vh: for (; ;)
                switch (v2['mode']) {
                  case V:
                    if (0x0 === v2['wrap']) {
                      v2['mode'] = 0xd;
                      break;
                    }
                    for (; vv < 0x10;) {
                      if (0x0 === v7)
                        break vh;
                      v7--,
                        v9 += v3[v5++] << vv,
                        vv += 0x8;
                    }
                    if (0x2 & v2['wrap'] && 0x8b1f === v9) {
                      vw[v2['check'] = 0x0] = 0xff & v9,
                        vw[0x1] = v9 >>> 0x8 & 0xff,
                        v2['check'] = E(v2['check'], vw, 0x2, 0x0),
                        vv = v9 = 0x0,
                        v2['mode'] = 0x2;
                      break;
                    }
                    if (v2['flags'] = 0x0,
                      v2['head'] && (v2['head']['done'] = false),
                      !(0x1 & v2['wrap']) || (((0xff & v9) << 0x8) + (v9 >> 0x8)) % 0x1f) {
                      v0['msg'] = 'incorrect\x20header\x20check',
                        v2['mode'] = 0x1e;
                      break;
                    }
                    if (0x8 != (0xf & v9)) {
                      v0['msg'] = 'unknown\x20compression\x20method',
                        v2['mode'] = 0x1e;
                      break;
                    }
                    if (vv -= 0x4,
                      vx = 0x8 + (0xf & (v9 >>>= 0x4)),
                      0x0 === v2['wbits'])
                      v2['wbits'] = vx;
                    else {
                      if (vx > v2['wbits']) {
                        v0['msg'] = 'invalid\x20window\x20size',
                          v2['mode'] = 0x1e;
                        break;
                      }
                    }
                    v2['dmax'] = 0x1 << vx,
                      v0['adler'] = v2['check'] = 0x1,
                      v2['mode'] = 0x200 & v9 ? 0xa : 0xc,
                      vv = v9 = 0x0;
                    break;
                  case 0x2:
                    for (; vv < 0x10;) {
                      if (0x0 === v7)
                        break vh;
                      v7--,
                        v9 += v3[v5++] << vv,
                        vv += 0x8;
                    }
                    if (v2['flags'] = v9,
                      0x8 != (0xff & v2['flags'])) {
                      v0['msg'] = 'unknown\x20compression\x20method',
                        v2['mode'] = 0x1e;
                      break;
                    }
                    if (0xe000 & v2['flags']) {
                      v0['msg'] = 'unknown\x20header\x20flags\x20set',
                        v2['mode'] = 0x1e;
                      break;
                    }
                    v2['head'] && (v2['head']['text'] = v9 >> 0x8 & 0x1),
                      0x200 & v2['flags'] && (vw[0x0] = 0xff & v9,
                        vw[0x1] = v9 >>> 0x8 & 0xff,
                        v2['check'] = E(v2['check'], vw, 0x2, 0x0)),
                      vv = v9 = 0x0,
                      v2['mode'] = 0x3;
                  case 0x3:
                    for (; vv < 0x20;) {
                      if (0x0 === v7)
                        break vh;
                      v7--,
                        v9 += v3[v5++] << vv,
                        vv += 0x8;
                    }
                    v2['head'] && (v2['head']['time'] = v9),
                      0x200 & v2['flags'] && (vw[0x0] = 0xff & v9,
                        vw[0x1] = v9 >>> 0x8 & 0xff,
                        vw[0x2] = v9 >>> 0x10 & 0xff,
                        vw[0x3] = v9 >>> 0x18 & 0xff,
                        v2['check'] = E(v2['check'], vw, 0x4, 0x0)),
                      vv = v9 = 0x0,
                      v2['mode'] = 0x4;
                  case 0x4:
                    for (; vv < 0x10;) {
                      if (0x0 === v7)
                        break vh;
                      v7--,
                        v9 += v3[v5++] << vv,
                        vv += 0x8;
                    }
                    v2['head'] && (v2['head']['xflags'] = 0xff & v9,
                      v2['head']['os'] = v9 >> 0x8),
                      0x200 & v2['flags'] && (vw[0x0] = 0xff & v9,
                        vw[0x1] = v9 >>> 0x8 & 0xff,
                        v2['check'] = E(v2['check'], vw, 0x2, 0x0)),
                      vv = v9 = 0x0,
                      v2['mode'] = 0x5;
                  case 0x5:
                    if (0x400 & v2['flags']) {
                      for (; vv < 0x10;) {
                        if (0x0 === v7)
                          break vh;
                        v7--,
                          v9 += v3[v5++] << vv,
                          vv += 0x8;
                      }
                      v2['length'] = v9,
                        v2['head'] && (v2['head']['extra_len'] = v9),
                        0x200 & v2['flags'] && (vw[0x0] = 0xff & v9,
                          vw[0x1] = v9 >>> 0x8 & 0xff,
                          v2['check'] = E(v2['check'], vw, 0x2, 0x0)),
                        vv = v9 = 0x0;
                    } else
                      v2['head'] && (v2['head']['extra'] = null);
                    v2['mode'] = 0x6;
                  case 0x6:
                    if (0x400 & v2['flags'] && (v7 < (vk = v2['length']) && (vk = v7),
                      vk && (v2['head'] && (vx = v2['head']['extra_len'] - v2['length'],
                        v2['head']['extra'] || (v2['head']['extra'] = new Array(v2['head']['extra_len'])),
                        T['arraySet'](v2['head']['extra'], v3, v5, vk, vx)),
                        0x200 & v2['flags'] && (v2['check'] = E(v2['check'], v3, vk, v5)),
                        v7 -= vk,
                        v5 += vk,
                        v2['length'] -= vk),
                      v2['length']))
                      break vh;
                    v2['length'] = 0x0,
                      v2['mode'] = 0x7;
                  case 0x7:
                    if (0x800 & v2['flags']) {
                      if (0x0 === v7)
                        break vh;
                      for (vk = 0x0; vx = v3[v5 + vk++],
                        v2['head'] && vx && v2['length'] < 0x10000 && (v2['head']['name'] += String['fromCharCode'](vx)),
                        vx && vk < v7;)
                        ;
                      if (0x200 & v2['flags'] && (v2['check'] = E(v2['check'], v3, vk, v5)),
                        v7 -= vk,
                        v5 += vk,
                        vx)
                        break vh;
                    } else
                      v2['head'] && (v2['head']['name'] = null);
                    v2['length'] = 0x0,
                      v2['mode'] = 0x8;
                  case 0x8:
                    if (0x1000 & v2['flags']) {
                      if (0x0 === v7)
                        break vh;
                      for (vk = 0x0; vx = v3[v5 + vk++],
                        v2['head'] && vx && v2['length'] < 0x10000 && (v2['head']['comment'] += String['fromCharCode'](vx)),
                        vx && vk < v7;)
                        ;
                      if (0x200 & v2['flags'] && (v2['check'] = E(v2['check'], v3, vk, v5)),
                        v7 -= vk,
                        v5 += vk,
                        vx)
                        break vh;
                    } else
                      v2['head'] && (v2['head']['comment'] = null);
                    v2['mode'] = 0x9;
                  case 0x9:
                    if (0x200 & v2['flags']) {
                      for (; vv < 0x10;) {
                        if (0x0 === v7)
                          break vh;
                        v7--,
                          v9 += v3[v5++] << vv,
                          vv += 0x8;
                      }
                      if (v9 !== (0xffff & v2['check'])) {
                        v0['msg'] = 'header\x20crc\x20mismatch',
                          v2['mode'] = 0x1e;
                        break;
                      }
                      vv = v9 = 0x0;
                    }
                    v2['head'] && (v2['head']['hcrc'] = v2['flags'] >> 0x9 & 0x1,
                      v2['head']['done'] = true),
                      v0['adler'] = v2['check'] = 0x0,
                      v2['mode'] = 0xc;
                    break;
                  case 0xa:
                    for (; vv < 0x20;) {
                      if (0x0 === v7)
                        break vh;
                      v7--,
                        v9 += v3[v5++] << vv,
                        vv += 0x8;
                    }
                    v0['adler'] = v2['check'] = U(v9),
                      vv = v9 = 0x0,
                      v2['mode'] = 0xb;
                  case 0xb:
                    if (0x0 === v2['havedict'])
                      return v0['next_out'] = v6,
                        v0['avail_out'] = v8,
                        v0['next_in'] = v5,
                        v0['avail_in'] = v7,
                        v2['hold'] = v9,
                        v2['bits'] = vv,
                        0x2;
                    v0['adler'] = v2['check'] = 0x1,
                      v2['mode'] = 0xc;
                  case 0xc:
                    if (0x5 === v1 || 0x6 === v1)
                      break vh;
                  case 0xd:
                    if (v2['last']) {
                      v9 >>>= 0x7 & vv,
                        vv -= 0x7 & vv,
                        v2['mode'] = 0x1b;
                      break;
                    }
                    for (; vv < 0x3;) {
                      if (0x0 === v7)
                        break vh;
                      v7--,
                        v9 += v3[v5++] << vv,
                        vv += 0x8;
                    }
                    switch (v2['last'] = 0x1 & v9,
                    vv -= 0x1,
                    0x3 & (v9 >>>= 0x1)) {
                      case 0x0:
                        v2['mode'] = 0xe;
                        break;
                      case 0x1:
                        if (z(v2),
                          v2['mode'] = 0x14,
                          0x6 !== v1)
                          break;
                        v9 >>>= 0x2,
                          vv -= 0x2;
                        break vh;
                      case 0x2:
                        v2['mode'] = 0x11;
                        break;
                      case 0x3:
                        v0['msg'] = 'invalid\x20block\x20type',
                          v2['mode'] = 0x1e;
                    }
                    v9 >>>= 0x2,
                      vv -= 0x2;
                    break;
                  case 0xe:
                    for (v9 >>>= 0x7 & vv,
                      vv -= 0x7 & vv; vv < 0x20;) {
                      if (0x0 === v7)
                        break vh;
                      v7--,
                        v9 += v3[v5++] << vv,
                        vv += 0x8;
                    }
                    if ((0xffff & v9) != (v9 >>> 0x10 ^ 0xffff)) {
                      v0['msg'] = 'invalid\x20stored\x20block\x20lengths',
                        v2['mode'] = 0x1e;
                      break;
                    }
                    if (v2['length'] = 0xffff & v9,
                      vv = v9 = 0x0,
                      v2['mode'] = 0xf,
                      0x6 === v1)
                      break vh;
                  case 0xf:
                    v2['mode'] = 0x10;
                  case 0x10:
                    if (vk = v2['length']) {
                      if (v7 < vk && (vk = v7),
                        v8 < vk && (vk = v8),
                        0x0 === vk)
                        break vh;
                      T['arraySet'](v4, v3, v5, vk, v6),
                        v7 -= vk,
                        v5 += vk,
                        v8 -= vk,
                        v6 += vk,
                        v2['length'] -= vk;
                      break;
                    }
                    v2['mode'] = 0xc;
                    break;
                  case 0x11:
                    for (; vv < 0xe;) {
                      if (0x0 === v7)
                        break vh;
                      v7--,
                        v9 += v3[v5++] << vv,
                        vv += 0x8;
                    }
                    if (v2['nlen'] = 0x101 + (0x1f & v9),
                      v9 >>>= 0x5,
                      vv -= 0x5,
                      v2['ndist'] = 0x1 + (0x1f & v9),
                      v9 >>>= 0x5,
                      vv -= 0x5,
                      v2['ncode'] = 0x4 + (0xf & v9),
                      v9 >>>= 0x4,
                      vv -= 0x4,
                      0x11e < v2['nlen'] || 0x1e < v2['ndist']) {
                      v0['msg'] = 'too\x20many\x20length\x20or\x20distance\x20symbols',
                        v2['mode'] = 0x1e;
                      break;
                    }
                    v2['have'] = 0x0,
                      v2['mode'] = 0x12;
                  case 0x12:
                    for (; v2['have'] < v2['ncode'];) {
                      for (; vv < 0x3;) {
                        if (0x0 === v7)
                          break vh;
                        v7--,
                          v9 += v3[v5++] << vv,
                          vv += 0x8;
                      }
                      v2['lens'][vs[v2['have']++]] = 0x7 & v9,
                        v9 >>>= 0x3,
                        vv -= 0x3;
                    }
                    for (; v2['have'] < 0x13;)
                      v2['lens'][vs[v2['have']++]] = 0x0;
                    if (v2['lencode'] = v2['lendyn'],
                      v2['lenbits'] = 0x7,
                      vF = {
                        'bits': v2['lenbits']
                      },
                      vp = I(0x0, v2['lens'], 0x0, 0x13, v2['lencode'], 0x0, v2['work'], vF),
                      v2['lenbits'] = vF['bits'],
                      vp) {
                      v0['msg'] = 'invalid\x20code\x20lengths\x20set',
                        v2['mode'] = 0x1e;
                      break;
                    }
                    v2['have'] = 0x0,
                      v2['mode'] = 0x13;
                  case 0x13:
                    for (; v2['have'] < v2['nlen'] + v2['ndist'];) {
                      for (; vb = (vr = v2['lencode'][v9 & (0x1 << v2['lenbits']) - 0x1]) >>> 0x10 & 0xff,
                        ve = 0xffff & vr,
                        !((vi = vr >>> 0x18) <= vv);) {
                        if (0x0 === v7)
                          break vh;
                        v7--,
                          v9 += v3[v5++] << vv,
                          vv += 0x8;
                      }
                      if (ve < 0x10)
                        v9 >>>= vi,
                          vv -= vi,
                          v2['lens'][v2['have']++] = ve;
                      else {
                        if (0x10 === ve) {
                          for (vy = vi + 0x2; vv < vy;) {
                            if (0x0 === v7)
                              break vh;
                            v7--,
                              v9 += v3[v5++] << vv,
                              vv += 0x8;
                          }
                          if (v9 >>>= vi,
                            vv -= vi,
                            0x0 === v2['have']) {
                            v0['msg'] = 'invalid\x20bit\x20length\x20repeat',
                              v2['mode'] = 0x1e;
                            break;
                          }
                          vx = v2['lens'][v2['have'] - 0x1],
                            vk = 0x3 + (0x3 & v9),
                            v9 >>>= 0x2,
                            vv -= 0x2;
                        } else {
                          if (0x11 === ve) {
                            for (vy = vi + 0x3; vv < vy;) {
                              if (0x0 === v7)
                                break vh;
                              v7--,
                                v9 += v3[v5++] << vv,
                                vv += 0x8;
                            }
                            vv -= vi,
                              vx = 0x0,
                              vk = 0x3 + (0x7 & (v9 >>>= vi)),
                              v9 >>>= 0x3,
                              vv -= 0x3;
                          } else {
                            for (vy = vi + 0x7; vv < vy;) {
                              if (0x0 === v7)
                                break vh;
                              v7--,
                                v9 += v3[v5++] << vv,
                                vv += 0x8;
                            }
                            vv -= vi,
                              vx = 0x0,
                              vk = 0xb + (0x7f & (v9 >>>= vi)),
                              v9 >>>= 0x7,
                              vv -= 0x7;
                          }
                        }
                        if (v2['have'] + vk > v2['nlen'] + v2['ndist']) {
                          v0['msg'] = 'invalid\x20bit\x20length\x20repeat',
                            v2['mode'] = 0x1e;
                          break;
                        }
                        for (; vk--;)
                          v2['lens'][v2['have']++] = vx;
                      }
                    }
                    if (0x1e === v2['mode'])
                      break;
                    if (0x0 === v2['lens'][0x100]) {
                      v0['msg'] = 'invalid\x20code\x20--\x20missing\x20end-of-block',
                        v2['mode'] = 0x1e;
                      break;
                    }
                    if (v2['lenbits'] = 0x9,
                      vF = {
                        'bits': v2['lenbits']
                      },
                      vp = I(0x1, v2['lens'], 0x0, v2['nlen'], v2['lencode'], 0x0, v2['work'], vF),
                      v2['lenbits'] = vF['bits'],
                      vp) {
                      v0['msg'] = 'invalid\x20literal/lengths\x20set',
                        v2['mode'] = 0x1e;
                      break;
                    }
                    if (v2['distbits'] = 0x6,
                      v2['distcode'] = v2['distdyn'],
                      vF = {
                        'bits': v2['distbits']
                      },
                      vp = I(0x2, v2['lens'], v2['nlen'], v2['ndist'], v2['distcode'], 0x0, v2['work'], vF),
                      v2['distbits'] = vF['bits'],
                      vp) {
                      v0['msg'] = 'invalid\x20distances\x20set',
                        v2['mode'] = 0x1e;
                      break;
                    }
                    if (v2['mode'] = 0x14,
                      0x6 === v1)
                      break vh;
                  case 0x14:
                    v2['mode'] = 0x15;
                  case 0x15:
                    if (0x6 <= v7 && 0x102 <= v8) {
                      v0['next_out'] = v6,
                        v0['avail_out'] = v8,
                        v0['next_in'] = v5,
                        v0['avail_in'] = v7,
                        v2['hold'] = v9,
                        v2['bits'] = vv,
                        W(v0, vn),
                        v6 = v0['next_out'],
                        v4 = v0['output'],
                        v8 = v0['avail_out'],
                        v5 = v0['next_in'],
                        v3 = v0['input'],
                        v7 = v0['avail_in'],
                        v9 = v2['hold'],
                        vv = v2['bits'],
                        0xc === v2['mode'] && (v2['back'] = -0x1);
                      break;
                    }
                    for (v2['back'] = 0x0; vb = (vr = v2['lencode'][v9 & (0x1 << v2['lenbits']) - 0x1]) >>> 0x10 & 0xff,
                      ve = 0xffff & vr,
                      !((vi = vr >>> 0x18) <= vv);) {
                      if (0x0 === v7)
                        break vh;
                      v7--,
                        v9 += v3[v5++] << vv,
                        vv += 0x8;
                    }
                    if (vb && 0x0 == (0xf0 & vb)) {
                      for (vc = vi,
                        vH = vb,
                        vt = ve; vb = (vr = v2['lencode'][vt + ((v9 & (0x1 << vc + vH) - 0x1) >> vc)]) >>> 0x10 & 0xff,
                        ve = 0xffff & vr,
                        !(vc + (vi = vr >>> 0x18) <= vv);) {
                        if (0x0 === v7)
                          break vh;
                        v7--,
                          v9 += v3[v5++] << vv,
                          vv += 0x8;
                      }
                      v9 >>>= vc,
                        vv -= vc,
                        v2['back'] += vc;
                    }
                    if (v9 >>>= vi,
                      vv -= vi,
                      v2['back'] += vi,
                      v2['length'] = ve,
                      0x0 === vb) {
                      v2['mode'] = 0x1a;
                      break;
                    }
                    if (0x20 & vb) {
                      v2['back'] = -0x1,
                        v2['mode'] = 0xc;
                      break;
                    }
                    if (0x40 & vb) {
                      v0['msg'] = 'invalid\x20literal/length\x20code',
                        v2['mode'] = 0x1e;
                      break;
                    }
                    v2['extra'] = 0xf & vb,
                      v2['mode'] = 0x16;
                  case 0x16:
                    if (v2['extra']) {
                      for (vy = v2['extra']; vv < vy;) {
                        if (0x0 === v7)
                          break vh;
                        v7--,
                          v9 += v3[v5++] << vv,
                          vv += 0x8;
                      }
                      v2['length'] += v9 & (0x1 << v2['extra']) - 0x1,
                        v9 >>>= v2['extra'],
                        vv -= v2['extra'],
                        v2['back'] += v2['extra'];
                    }
                    v2['was'] = v2['length'],
                      v2['mode'] = 0x17;
                  case 0x17:
                    for (; vb = (vr = v2['distcode'][v9 & (0x1 << v2['distbits']) - 0x1]) >>> 0x10 & 0xff,
                      ve = 0xffff & vr,
                      !((vi = vr >>> 0x18) <= vv);) {
                      if (0x0 === v7)
                        break vh;
                      v7--,
                        v9 += v3[v5++] << vv,
                        vv += 0x8;
                    }
                    if (0x0 == (0xf0 & vb)) {
                      for (vc = vi,
                        vH = vb,
                        vt = ve; vb = (vr = v2['distcode'][vt + ((v9 & (0x1 << vc + vH) - 0x1) >> vc)]) >>> 0x10 & 0xff,
                        ve = 0xffff & vr,
                        !(vc + (vi = vr >>> 0x18) <= vv);) {
                        if (0x0 === v7)
                          break vh;
                        v7--,
                          v9 += v3[v5++] << vv,
                          vv += 0x8;
                      }
                      v9 >>>= vc,
                        vv -= vc,
                        v2['back'] += vc;
                    }
                    if (v9 >>>= vi,
                      vv -= vi,
                      v2['back'] += vi,
                      0x40 & vb) {
                      v0['msg'] = 'invalid\x20distance\x20code',
                        v2['mode'] = 0x1e;
                      break;
                    }
                    v2['offset'] = ve,
                      v2['extra'] = 0xf & vb,
                      v2['mode'] = 0x18;
                  case 0x18:
                    if (v2['extra']) {
                      for (vy = v2['extra']; vv < vy;) {
                        if (0x0 === v7)
                          break vh;
                        v7--,
                          v9 += v3[v5++] << vv,
                          vv += 0x8;
                      }
                      v2['offset'] += v9 & (0x1 << v2['extra']) - 0x1,
                        v9 >>>= v2['extra'],
                        vv -= v2['extra'],
                        v2['back'] += v2['extra'];
                    }
                    if (v2['offset'] > v2['dmax']) {
                      v0['msg'] = 'invalid\x20distance\x20too\x20far\x20back',
                        v2['mode'] = 0x1e;
                      break;
                    }
                    v2['mode'] = 0x19;
                  case 0x19:
                    if (0x0 === v8)
                      break vh;
                    if (vk = vn - v8,
                      v2['offset'] > vk) {
                      if ((vk = v2['offset'] - vk) > v2['whave'] && v2['sane']) {
                        v0['msg'] = 'invalid\x20distance\x20too\x20far\x20back',
                          v2['mode'] = 0x1e;
                        break;
                      }
                      vl = vk > v2['wnext'] ? (vk -= v2['wnext'],
                        v2['wsize'] - vk) : v2['wnext'] - vk,
                        vk > v2['length'] && (vk = v2['length']),
                        vK = v2['window'];
                    } else
                      vK = v4,
                        vl = v6 - v2['offset'],
                        vk = v2['length'];
                    for (v8 < vk && (vk = v8),
                      v8 -= vk,
                      v2['length'] -= vk; v4[v6++] = vK[vl++],
                      --vk;)
                      ;
                    0x0 === v2['length'] && (v2['mode'] = 0x15);
                    break;
                  case 0x1a:
                    if (0x0 === v8)
                      break vh;
                    v4[v6++] = v2['length'],
                      v8--,
                      v2['mode'] = 0x15;
                    break;
                  case 0x1b:
                    if (v2['wrap']) {
                      for (; vv < 0x20;) {
                        if (0x0 === v7)
                          break vh;
                        v7--,
                          v9 |= v3[v5++] << vv,
                          vv += 0x8;
                      }
                      if (vn -= v8,
                        v0['total_out'] += vn,
                        v2['total'] += vn,
                        vn && (v0['adler'] = v2['check'] = v2['flags'] ? E(v2['check'], v4, vn, v6 - vn) : X(v2['check'], v4, vn, v6 - vn)),
                        vn = v8,
                        (v2['flags'] ? v9 : U(v9)) !== v2['check']) {
                        v0['msg'] = 'incorrect\x20data\x20check',
                          v2['mode'] = 0x1e;
                        break;
                      }
                      vv = v9 = 0x0;
                    }
                    v2['mode'] = 0x1c;
                  case 0x1c:
                    if (v2['wrap'] && v2['flags']) {
                      for (; vv < 0x20;) {
                        if (0x0 === v7)
                          break vh;
                        v7--,
                          v9 += v3[v5++] << vv,
                          vv += 0x8;
                      }
                      if (v9 !== (0xffffffff & v2['total'])) {
                        v0['msg'] = 'incorrect\x20length\x20check',
                          v2['mode'] = 0x1e;
                        break;
                      }
                      vv = v9 = 0x0;
                    }
                    v2['mode'] = 0x1d;
                  case 0x1d:
                    vp = 0x1;
                    break vh;
                  case 0x1e:
                    vp = -0x3;
                    break vh;
                  case 0x1f:
                    return -0x4;
                  default:
                    return D;
                }
              return v0['next_out'] = v6,
                v0['avail_out'] = v8,
                v0['next_in'] = v5,
                v0['avail_in'] = v7,
                v2['hold'] = v9,
                v2['bits'] = vv,
                (v2['wsize'] || vn !== v0['avail_out'] && v2['mode'] < 0x1e && (v2['mode'] < 0x1b || 0x4 !== v1)) && Q(v0, v0['output'], v0['next_out'], vn - v0['avail_out']) ? (v2['mode'] = 0x1f,
                  -0x4) : (vA -= v0['avail_in'],
                    vn -= v0['avail_out'],
                    v0['total_in'] += vA,
                    v0['total_out'] += vn,
                    v2['total'] += vn,
                    v2['wrap'] && vn && (v0['adler'] = v2['check'] = v2['flags'] ? E(v2['check'], v4, vn, v0['next_out'] - vn) : X(v2['check'], v4, vn, v0['next_out'] - vn)),
                    v0['data_type'] = v2['bits'] + (v2['last'] ? 0x40 : 0x0) + (0xc === v2['mode'] ? 0x80 : 0x0) + (0x14 === v2['mode'] || 0xf === v2['mode'] ? 0x100 : 0x0),
                    (0x0 == vA && 0x0 === vn || 0x4 === v1) && vp === j && (vp = -0x5),
                    vp);
            }
            ,
            Y['inflateEnd'] = function (L) {
              if (!L || !L['state'])
                return D;
              var R = L['state'];
              return R['window'] && (R['window'] = null),
                L['state'] = null,
                j;
            }
            ,
            Y['inflateGetHeader'] = function (L, R) {
              var v0;
              return L && L['state'] ? 0x0 == (0x2 & (v0 = L['state'])['wrap']) ? D : ((v0['head'] = R)['done'] = false,
                j) : D;
            }
            ,
            Y['inflateSetDictionary'] = function (L, R) {
              var v0, v1 = R['length'];
              return L && L['state'] ? 0x0 !== (v0 = L['state'])['wrap'] && 0xb !== v0['mode'] ? D : 0xb === v0['mode'] && X(0x1, R, v1, 0x0) !== v0['check'] ? -0x3 : Q(L, R, v1, v1) ? (v0['mode'] = 0x1f,
                -0x4) : (v0['havedict'] = 0x1,
                  j) : D;
            }
            ,
            Y['inflateInfo'] = 'pako\x20inflate\x20(from\x20Nodeca\x20project)';
        }
          , {
          '../utils/common': 0x29,
          './adler32': 0x2b,
          './crc32': 0x2d,
          './inffast': 0x30,
          './inftrees': 0x32
        }],
        0x32: [function (c, H, x) {
          'use strict';
          var p = c('../utils/common')
            , F = [0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xd, 0xf, 0x11, 0x13, 0x17, 0x1b, 0x1f, 0x23, 0x2b, 0x33, 0x3b, 0x43, 0x53, 0x63, 0x73, 0x83, 0xa3, 0xc3, 0xe3, 0x102, 0x0, 0x0]
            , y = [0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x11, 0x11, 0x11, 0x11, 0x12, 0x12, 0x12, 0x12, 0x13, 0x13, 0x13, 0x13, 0x14, 0x14, 0x14, 0x14, 0x15, 0x15, 0x15, 0x15, 0x10, 0x48, 0x4e]
            , w = [0x1, 0x2, 0x3, 0x4, 0x5, 0x7, 0x9, 0xd, 0x11, 0x19, 0x21, 0x31, 0x41, 0x61, 0x81, 0xc1, 0x101, 0x181, 0x201, 0x301, 0x401, 0x601, 0x801, 0xc01, 0x1001, 0x1801, 0x2001, 0x3001, 0x4001, 0x6001, 0x0, 0x0]
            , h = [0x10, 0x10, 0x10, 0x10, 0x11, 0x11, 0x12, 0x12, 0x13, 0x13, 0x14, 0x14, 0x15, 0x15, 0x16, 0x16, 0x17, 0x17, 0x18, 0x18, 0x19, 0x19, 0x1a, 0x1a, 0x1b, 0x1b, 0x1c, 0x1c, 0x1d, 0x1d, 0x40, 0x40];
          H['exports'] = function (Y, X, W, j, V, Z, U, q) {
            var J, G, N, Q, v0, v1, v2, v3, v4, v5 = q['bits'], v6 = 0x0, v7 = 0x0, v8 = 0x0, v9 = 0x0, vv = 0x0, vA = 0x0, vn = 0x0, vk = 0x0, vl = 0x0, vK = 0x0, vi = null, vb = 0x0, ve = new p['Buf16'](0x10), vc = new p['Buf16'](0x10), vH = null, vt = 0x0;
            for (v6 = 0x0; v6 <= 0xf; v6++)
              ve[v6] = 0x0;
            for (v7 = 0x0; v7 < j; v7++)
              ve[X[W + v7]]++;
            for (vv = v5,
              v9 = 0xf; 0x1 <= v9 && 0x0 === ve[v9]; v9--)
              ;
            if (v9 < vv && (vv = v9),
              0x0 === v9)
              return V[Z++] = 0x1400000,
                V[Z++] = 0x1400000,
                q['bits'] = 0x1,
                0x0;
            for (v8 = 0x1; v8 < v9 && 0x0 === ve[v8]; v8++)
              ;
            for (vv < v8 && (vv = v8),
              v6 = vk = 0x1; v6 <= 0xf; v6++)
              if (vk <<= 0x1,
                (vk -= ve[v6]) < 0x0)
                return -0x1;
            if (0x0 < vk && (0x0 === Y || 0x1 !== v9))
              return -0x1;
            for (vc[0x1] = 0x0,
              v6 = 0x1; v6 < 0xf; v6++)
              vc[v6 + 0x1] = vc[v6] + ve[v6];
            for (v7 = 0x0; v7 < j; v7++)
              0x0 !== X[W + v7] && (U[vc[X[W + v7]]++] = v7);
            if (v1 = 0x0 === Y ? (vi = vH = U,
              0x13) : 0x1 === Y ? (vi = F,
                vb -= 0x101,
                vH = y,
                vt -= 0x101,
                0x100) : (vi = w,
                  vH = h,
                  -0x1),
              v6 = v8,
              v0 = Z,
              vn = v7 = vK = 0x0,
              N = -0x1,
              Q = (vl = 0x1 << (vA = vv)) - 0x1,
              0x1 === Y && 0x354 < vl || 0x2 === Y && 0x250 < vl)
              return 0x1;
            for (; ;) {
              for (v2 = v6 - vn,
                v4 = U[v7] < v1 ? (v3 = 0x0,
                  U[v7]) : U[v7] > v1 ? (v3 = vH[vt + U[v7]],
                    vi[vb + U[v7]]) : (v3 = 0x60,
                      0x0),
                J = 0x1 << v6 - vn,
                v8 = G = 0x1 << vA; V[v0 + (vK >> vn) + (G -= J)] = v2 << 0x18 | v3 << 0x10 | v4 | 0x0,
                0x0 !== G;)
                ;
              for (J = 0x1 << v6 - 0x1; vK & J;)
                J >>= 0x1;
              if (0x0 !== J ? (vK &= J - 0x1,
                vK += J) : vK = 0x0,
                v7++,
                0x0 == --ve[v6]) {
                if (v6 === v9)
                  break;
                v6 = X[W + U[v7]];
              }
              if (vv < v6 && (vK & Q) !== N) {
                for (0x0 === vn && (vn = vv),
                  v0 += v8,
                  vk = 0x1 << (vA = v6 - vn); vA + vn < v9 && !((vk -= ve[vA + vn]) <= 0x0);)
                  vA++,
                    vk <<= 0x1;
                if (vl += 0x1 << vA,
                  0x1 === Y && 0x354 < vl || 0x2 === Y && 0x250 < vl)
                  return 0x1;
                V[N = vK & Q] = vv << 0x18 | vA << 0x10 | v0 - Z | 0x0;
              }
            }
            return 0x0 !== vK && (V[v0 + vK] = v6 - vn << 0x18 | 0x40 << 0x10 | 0x0),
              q['bits'] = vv,
              0x0;
          }
            ;
        }
          , {
          '../utils/common': 0x29
        }],
        0x33: [function (c, H, x) {
          'use strict';
          H['exports'] = {
            0x2: 'need\x20dictionary',
            0x1: 'stream\x20end',
            0x0: '',
            '-1': 'file\x20error',
            '-2': 'stream\x20error',
            '-3': 'data\x20error',
            '-4': 'insufficient\x20memory',
            '-5': 'buffer\x20error',
            '-6': 'incompatible\x20version'
          };
        }
          , {}],
        0x34: [function (H, Y, X) {
          'use strict';
          var W = H('../utils/common');
          function j (vu) {
            for (var vY = vu['length']; 0x0 <= --vY;)
              vu[vY] = 0x0;
          }
          var Z = 0x100
            , q = 0x11e
            , J = 0x1e
            , G = 0xf
            , N = 0x10
            , Q = [0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x1, 0x1, 0x2, 0x2, 0x2, 0x2, 0x3, 0x3, 0x3, 0x3, 0x4, 0x4, 0x4, 0x4, 0x5, 0x5, 0x5, 0x5, 0x0]
            , v0 = [0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x2, 0x2, 0x3, 0x3, 0x4, 0x4, 0x5, 0x5, 0x6, 0x6, 0x7, 0x7, 0x8, 0x8, 0x9, 0x9, 0xa, 0xa, 0xb, 0xb, 0xc, 0xc, 0xd, 0xd]
            , v1 = [0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x3, 0x7]
            , v2 = [0x10, 0x11, 0x12, 0x0, 0x8, 0x7, 0x9, 0x6, 0xa, 0x5, 0xb, 0x4, 0xc, 0x3, 0xd, 0x2, 0xe, 0x1, 0xf]
            , v3 = new Array(0x240);
          j(v3);
          var v4 = new Array(0x3c);
          j(v4);
          var v5 = new Array(0x200);
          j(v5);
          var v6 = new Array(0x100);
          j(v6);
          var v7 = new Array(0x1d);
          j(v7);
          var v8, v9, vv, vA = new Array(J);
          function vn (vu, vY, vT, vX, Quadtree) {
            this['static_tree'] = vu,
              this['extra_bits'] = vY,
              this['extra_base'] = vT,
              this['elems'] = vX,
              this['max_length'] = Quadtree,
              this['has_stree'] = vu && vu['length'];
          }
          function vk (vu, vY) {
            this['dyn_tree'] = vu,
              this['max_code'] = 0x0,
              this['stat_desc'] = vY;
          }
          function vl (vu) {
            return vu < 0x100 ? v5[vu] : v5[0x100 + (vu >>> 0x7)];
          }
          function vK (vu, vY) {
            vu['pending_buf'][vu['pending']++] = 0xff & vY,
              vu['pending_buf'][vu['pending']++] = vY >>> 0x8 & 0xff;
          }
          function vi (vu, vY, vT) {
            vu['bi_valid'] > N - vT ? (vu['bi_buf'] |= vY << vu['bi_valid'] & 0xffff,
              vK(vu, vu['bi_buf']),
              vu['bi_buf'] = vY >> N - vu['bi_valid'],
              vu['bi_valid'] += vT - N) : (vu['bi_buf'] |= vY << vu['bi_valid'] & 0xffff,
                vu['bi_valid'] += vT);
          }
          function vb (vu, vY, vT) {
            vi(vu, vT[0x2 * vY], vT[0x2 * vY + 0x1]);
          }
          function ve (vu, vY) {
            for (var vT = 0x0; vT |= 0x1 & vu,
              vu >>>= 0x1,
              vT <<= 0x1,
              0x0 < --vY;)
              ;
            return vT >>> 0x1;
          }
          function vc (vu, vY, vT) {
            var vX, Quadtree, vf = new Array(G + 0x1), vW = 0x0;
            for (vX = 0x1; vX <= G; vX++)
              vf[vX] = vW = vW + vT[vX - 0x1] << 0x1;
            for (Quadtree = 0x0; Quadtree <= vY; Quadtree++) {
              var vI = vu[0x2 * Quadtree + 0x1];
              0x0 !== vI && (vu[0x2 * Quadtree] = ve(vf[vI]++, vI));
            }
          }
          function vH (vu) {
            var vY;
            for (vY = 0x0; vY < q; vY++)
              vu['dyn_ltree'][0x2 * vY] = 0x0;
            for (vY = 0x0; vY < J; vY++)
              vu['dyn_dtree'][0x2 * vY] = 0x0;
            for (vY = 0x0; vY < 0x13; vY++)
              vu['bl_tree'][0x2 * vY] = 0x0;
            vu['dyn_ltree'][0x200] = 0x1,
              vu['opt_len'] = vu['static_len'] = 0x0,
              vu['last_lit'] = vu['matches'] = 0x0;
          }
          function vt (vu) {
            0x8 < vu['bi_valid'] ? vK(vu, vu['bi_buf']) : 0x0 < vu['bi_valid'] && (vu['pending_buf'][vu['pending']++] = vu['bi_buf']),
              vu['bi_buf'] = 0x0,
              vu['bi_valid'] = 0x0;
          }
          function vx (vu, vY, vT, vX) {
            var Quadtree = 0x2 * vY
              , vf = 0x2 * vT;
            return vu[Quadtree] < vu[vf] || vu[Quadtree] === vu[vf] && vX[vY] <= vX[vT];
          }
          function vp (vu, vY, vT) {
            for (var vX = vu['heap'][vT], Quadtree = vT << 0x1; Quadtree <= vu['heap_len'] && (Quadtree < vu['heap_len'] && vx(vY, vu['heap'][Quadtree + 0x1], vu['heap'][Quadtree], vu['depth']) && Quadtree++,
              !vx(vY, vX, vu['heap'][Quadtree], vu['depth']));)
              vu['heap'][vT] = vu['heap'][Quadtree],
                vT = Quadtree,
                Quadtree <<= 0x1;
            vu['heap'][vT] = vX;
          }
          function vF (vu, vY, vT) {
            var vX, Quadtree, vf, vW, vI = 0x0;
            if (0x0 !== vu['last_lit']) {
              for (; vX = vu['pending_buf'][vu['d_buf'] + 0x2 * vI] << 0x8 | vu['pending_buf'][vu['d_buf'] + 0x2 * vI + 0x1],
                Quadtree = vu['pending_buf'][vu['l_buf'] + vI],
                vI++,
                0x0 === vX ? vb(vu, Quadtree, vY) : (vb(vu, (vf = v6[Quadtree]) + Z + 0x1, vY),
                  0x0 !== (vW = Q[vf]) && vi(vu, Quadtree -= v7[vf], vW),
                  vb(vu, vf = vl(--vX), vT),
                  0x0 !== (vW = v0[vf]) && vi(vu, vX -= vA[vf], vW)),
                vI < vu['last_lit'];)
                ;
            }
            vb(vu, 0x100, vY);
          }
          function vy (vu, vY) {
            var vT, vX, Quadtree, vf = vY['dyn_tree'], vW = vY['stat_desc']['static_tree'], vI = vY['stat_desc']['has_stree'], vj = vY['stat_desc']['elems'], vD = -0x1;
            for (vu['heap_len'] = 0x0,
              vu['heap_max'] = 0x23d,
              vT = 0x0; vT < vj; vT++)
              0x0 !== vf[0x2 * vT] ? (vu['heap'][++vu['heap_len']] = vD = vT,
                vu['depth'][vT] = 0x0) : vf[0x2 * vT + 0x1] = 0x0;
            for (; vu['heap_len'] < 0x2;)
              vf[0x2 * (Quadtree = vu['heap'][++vu['heap_len']] = vD < 0x2 ? ++vD : 0x0)] = 0x1,
                vu['depth'][Quadtree] = 0x0,
                vu['opt_len']--,
                vI && (vu['static_len'] -= vW[0x2 * Quadtree + 0x1]);
            for (vY['max_code'] = vD,
              vT = vu['heap_len'] >> 0x1; 0x1 <= vT; vT--)
              vp(vu, vf, vT);
            for (Quadtree = vj; vT = vu['heap'][0x1],
              vu['heap'][0x1] = vu['heap'][vu['heap_len']--],
              vp(vu, vf, 0x1),
              vX = vu['heap'][0x1],
              vu['heap'][--vu['heap_max']] = vT,
              vu['heap'][--vu['heap_max']] = vX,
              vf[0x2 * Quadtree] = vf[0x2 * vT] + vf[0x2 * vX],
              vu['depth'][Quadtree] = (vu['depth'][vT] >= vu['depth'][vX] ? vu['depth'][vT] : vu['depth'][vX]) + 0x1,
              vf[0x2 * vT + 0x1] = vf[0x2 * vX + 0x1] = Quadtree,
              vu['heap'][0x1] = Quadtree++,
              vp(vu, vf, 0x1),
              0x2 <= vu['heap_len'];)
              ;
            vu['heap'][--vu['heap_max']] = vu['heap'][0x1],
              function (vV, vZ) {
                var vB, vS, vU, vd, vq, vJ, vo = vZ['dyn_tree'], vC = vZ['max_code'], vO = vZ['stat_desc']['static_tree'], vG = vZ['stat_desc']['has_stree'], vg = vZ['stat_desc']['extra_bits'], vN = vZ['stat_desc']['extra_base'], vP = vZ['stat_desc']['max_length'], vM = 0x0;
                for (vd = 0x0; vd <= G; vd++)
                  vV['bl_count'][vd] = 0x0;
                for (vo[0x2 * vV['heap'][vV['heap_max']] + 0x1] = 0x0,
                  vB = vV['heap_max'] + 0x1; vB < 0x23d; vB++)
                  vP < (vd = vo[0x2 * vo[0x2 * (vS = vV['heap'][vB]) + 0x1] + 0x1] + 0x1) && (vd = vP,
                    vM++),
                    vo[0x2 * vS + 0x1] = vd,
                    vC < vS || (vV['bl_count'][vd]++,
                      vq = 0x0,
                      vN <= vS && (vq = vg[vS - vN]),
                      vJ = vo[0x2 * vS],
                      vV['opt_len'] += vJ * (vd + vq),
                      vG && (vV['static_len'] += vJ * (vO[0x2 * vS + 0x1] + vq)));
                if (0x0 !== vM) {
                  do {
                    for (vd = vP - 0x1; 0x0 === vV['bl_count'][vd];)
                      vd--;
                    vV['bl_count'][vd]--,
                      vV['bl_count'][vd + 0x1] += 0x2,
                      vV['bl_count'][vP]--,
                      vM -= 0x2;
                  } while (0x0 < vM);
                  for (vd = vP; 0x0 !== vd; vd--)
                    for (vS = vV['bl_count'][vd]; 0x0 !== vS;)
                      vC < (vU = vV['heap'][--vB]) || (vo[0x2 * vU + 0x1] !== vd && (vV['opt_len'] += (vd - vo[0x2 * vU + 0x1]) * vo[0x2 * vU],
                        vo[0x2 * vU + 0x1] = vd),
                        vS--);
                }
              }(vu, vY),
              vc(vf, vD, vu['bl_count']);
          }
          function vr (vu, vY, vT) {
            var vX, Quadtree, vf = -0x1, vW = vY[0x1], vI = 0x0, vj = 0x7, vD = 0x4;
            for (0x0 === vW && (vj = 0x8a,
              vD = 0x3),
              vY[0x2 * (vT + 0x1) + 0x1] = 0xffff,
              vX = 0x0; vX <= vT; vX++)
              Quadtree = vW,
                vW = vY[0x2 * (vX + 0x1) + 0x1],
                ++vI < vj && Quadtree === vW || (vI < vD ? vu['bl_tree'][0x2 * Quadtree] += vI : 0x0 !== Quadtree ? (Quadtree !== vf && vu['bl_tree'][0x2 * Quadtree]++,
                  vu['bl_tree'][0x20]++) : vI <= 0xa ? vu['bl_tree'][0x22]++ : vu['bl_tree'][0x24]++,
                  vf = Quadtree,
                  vD = (vI = 0x0) === vW ? (vj = 0x8a,
                    0x3) : Quadtree === vW ? (vj = 0x6,
                      0x3) : (vj = 0x7,
                        0x4));
          }
          function vw (vu, vY, vT) {
            var vX, Quadtree, vf = -0x1, vW = vY[0x1], vI = 0x0, vj = 0x7, vD = 0x4;
            for (0x0 === vW && (vj = 0x8a,
              vD = 0x3),
              vX = 0x0; vX <= vT; vX++)
              if (Quadtree = vW,
                vW = vY[0x2 * (vX + 0x1) + 0x1],
                !(++vI < vj && Quadtree === vW)) {
                if (vI < vD) {
                  for (; vb(vu, Quadtree, vu['bl_tree']),
                    0x0 != --vI;)
                    ;
                } else
                  0x0 !== Quadtree ? (Quadtree !== vf && (vb(vu, Quadtree, vu['bl_tree']),
                    vI--),
                    vb(vu, 0x10, vu['bl_tree']),
                    vi(vu, vI - 0x3, 0x2)) : vI <= 0xa ? (vb(vu, 0x11, vu['bl_tree']),
                      vi(vu, vI - 0x3, 0x3)) : (vb(vu, 0x12, vu['bl_tree']),
                        vi(vu, vI - 0xb, 0x7));
                vf = Quadtree,
                  vD = (vI = 0x0) === vW ? (vj = 0x8a,
                    0x3) : Quadtree === vW ? (vj = 0x6,
                      0x3) : (vj = 0x7,
                        0x4);
              }
          }
          j(vA);
          var vs = false;
          function vh (vu, vY, vT, vX) {
            vi(vu, 0x0 + (vX ? 0x1 : 0x0), 0x3),
              function (Quadtree, vf, vW, vI) {
                vt(Quadtree),
                  vK(Quadtree, vW),
                  vK(Quadtree, ~vW),
                  W['arraySet'](Quadtree['pending_buf'], Quadtree['window'], vf, vW, Quadtree['pending']),
                  Quadtree['pending'] += vW;
              }(vu, vY, vT);
          }
          X['_tr_init'] = function (vu) {
            vs || (function () {
              var vY, vT, vX, Quadtree, vf, vW = new Array(G + 0x1);
              for (Quadtree = vX = 0x0; Quadtree < 0x1c; Quadtree++)
                for (v7[Quadtree] = vX,
                  vY = 0x0; vY < 0x1 << Q[Quadtree]; vY++)
                  v6[vX++] = Quadtree;
              for (v6[vX - 0x1] = Quadtree,
                Quadtree = vf = 0x0; Quadtree < 0x10; Quadtree++)
                for (vA[Quadtree] = vf,
                  vY = 0x0; vY < 0x1 << v0[Quadtree]; vY++)
                  v5[vf++] = Quadtree;
              for (vf >>= 0x7; Quadtree < J; Quadtree++)
                for (vA[Quadtree] = vf << 0x7,
                  vY = 0x0; vY < 0x1 << v0[Quadtree] - 0x7; vY++)
                  v5[0x100 + vf++] = Quadtree;
              for (vT = 0x0; vT <= G; vT++)
                vW[vT] = 0x0;
              for (vY = 0x0; vY <= 0x8f;)
                v3[0x2 * vY + 0x1] = 0x8,
                  vY++,
                  vW[0x8]++;
              for (; vY <= 0xff;)
                v3[0x2 * vY + 0x1] = 0x9,
                  vY++,
                  vW[0x9]++;
              for (; vY <= 0x117;)
                v3[0x2 * vY + 0x1] = 0x7,
                  vY++,
                  vW[0x7]++;
              for (; vY <= 0x11f;)
                v3[0x2 * vY + 0x1] = 0x8,
                  vY++,
                  vW[0x8]++;
              for (vc(v3, 0x11f, vW),
                vY = 0x0; vY < J; vY++)
                v4[0x2 * vY + 0x1] = 0x5,
                  v4[0x2 * vY] = ve(vY, 0x5);
              v8 = new vn(v3, Q, 0x101, q, G),
                v9 = new vn(v4, v0, 0x0, J, G),
                vv = new vn(new Array(0x0), v1, 0x0, 0x13, 0x7);
            }(),
              vs = true),
              vu['l_desc'] = new vk(vu['dyn_ltree'], v8),
              vu['d_desc'] = new vk(vu['dyn_dtree'], v9),
              vu['bl_desc'] = new vk(vu['bl_tree'], vv),
              vu['bi_buf'] = 0x0,
              vu['bi_valid'] = 0x0,
              vH(vu);
          }
            ,
            X['_tr_stored_block'] = vh,
            X['_tr_flush_block'] = function (vu, vY, vT, vX) {
              var Quadtree, vf, vW = 0x0;
              0x0 < vu['level'] ? (0x2 === vu['strm']['data_type'] && (vu['strm']['data_type'] = function (vI) {
                var vj, vD = 0xf3ffc07f;
                for (vj = 0x0; vj <= 0x1f; vj++,
                  vD >>>= 0x1)
                  if (0x1 & vD && 0x0 !== vI['dyn_ltree'][0x2 * vj])
                    return 0x0;
                if (0x0 !== vI['dyn_ltree'][0x12] || 0x0 !== vI['dyn_ltree'][0x14] || 0x0 !== vI['dyn_ltree'][0x1a])
                  return 0x1;
                for (vj = 0x20; vj < Z; vj++)
                  if (0x0 !== vI['dyn_ltree'][0x2 * vj])
                    return 0x1;
                return 0x0;
              }(vu)),
                vy(vu, vu['l_desc']),
                vy(vu, vu['d_desc']),
                vW = function (vI) {
                  var vj;
                  for (vr(vI, vI['dyn_ltree'], vI['l_desc']['max_code']),
                    vr(vI, vI['dyn_dtree'], vI['d_desc']['max_code']),
                    vy(vI, vI['bl_desc']),
                    vj = 0x12; 0x3 <= vj && 0x0 === vI['bl_tree'][0x2 * v2[vj] + 0x1]; vj--)
                    ;
                  return vI['opt_len'] += 0x3 * (vj + 0x1) + 0x5 + 0x5 + 0x4,
                    vj;
                }(vu),
                Quadtree = vu['opt_len'] + 0x3 + 0x7 >>> 0x3,
                (vf = vu['static_len'] + 0x3 + 0x7 >>> 0x3) <= Quadtree && (Quadtree = vf)) : Quadtree = vf = vT + 0x5,
                vT + 0x4 <= Quadtree && -0x1 !== vY ? vh(vu, vY, vT, vX) : 0x4 === vu['strategy'] || vf === Quadtree ? (vi(vu, 0x2 + (vX ? 0x1 : 0x0), 0x3),
                  vF(vu, v3, v4)) : (vi(vu, 0x4 + (vX ? 0x1 : 0x0), 0x3),
                    function (vI, vj, vD, vV) {
                      var vZ;
                      for (vi(vI, vj - 0x101, 0x5),
                        vi(vI, vD - 0x1, 0x5),
                        vi(vI, vV - 0x4, 0x4),
                        vZ = 0x0; vZ < vV; vZ++)
                        vi(vI, vI['bl_tree'][0x2 * v2[vZ] + 0x1], 0x3);
                      vw(vI, vI['dyn_ltree'], vj - 0x1),
                        vw(vI, vI['dyn_dtree'], vD - 0x1);
                    }(vu, vu['l_desc']['max_code'] + 0x1, vu['d_desc']['max_code'] + 0x1, vW + 0x1),
                    vF(vu, vu['dyn_ltree'], vu['dyn_dtree'])),
                vH(vu),
                vX && vt(vu);
            }
            ,
            X['_tr_tally'] = function (vu, vY, vT) {
              return vu['pending_buf'][vu['d_buf'] + 0x2 * vu['last_lit']] = vY >>> 0x8 & 0xff,
                vu['pending_buf'][vu['d_buf'] + 0x2 * vu['last_lit'] + 0x1] = 0xff & vY,
                vu['pending_buf'][vu['l_buf'] + vu['last_lit']] = 0xff & vT,
                vu['last_lit']++,
                0x0 === vY ? vu['dyn_ltree'][0x2 * vT]++ : (vu['matches']++,
                  vY--,
                  vu['dyn_ltree'][0x2 * (v6[vT] + Z + 0x1)]++,
                  vu['dyn_dtree'][0x2 * vl(vY)]++),
                vu['last_lit'] === vu['lit_bufsize'] - 0x1;
            }
            ,
            X['_tr_align'] = function (vu) {
              vi(vu, 0x2, 0x3),
                vb(vu, 0x100, v3),
                function (vY) {
                  0x10 === vY['bi_valid'] ? (vK(vY, vY['bi_buf']),
                    vY['bi_buf'] = 0x0,
                    vY['bi_valid'] = 0x0) : 0x8 <= vY['bi_valid'] && (vY['pending_buf'][vY['pending']++] = 0xff & vY['bi_buf'],
                      vY['bi_buf'] >>= 0x8,
                      vY['bi_valid'] -= 0x8);
                }(vu);
            }
            ;
        }
          , {
          '../utils/common': 0x29
        }],
        0x35: [function (c, H, x) {
          'use strict';
          H['exports'] = function () {
            this['input'] = null,
              this['next_in'] = 0x0,
              this['avail_in'] = 0x0,
              this['total_in'] = 0x0,
              this['output'] = null,
              this['next_out'] = 0x0,
              this['avail_out'] = 0x0,
              this['total_out'] = 0x0,
              this['msg'] = '',
              this['state'] = null,
              this['data_type'] = 0x2,
              this['adler'] = 0x0;
          }
            ;
        }
          , {}],
        0x36: [function (c, H, x) {
          (function (p) {
            !function (F, y) {
              'use strict';
              if (!F['setImmediate']) {
                var w, Y, T, X, E = 0x1, W = {}, I = false, j = F['document'], D = Object['getPrototypeOf'] && Object['getPrototypeOf'](F);
                D = D && D['setTimeout'] ? D : F,
                  w = '[object\x20process]' === {}['toString']['call'](F['process']) ? function (S) {
                    process['nextTick'](function () {
                      Z(S);
                    });
                  }
                    : function () {
                      if (F['postMessage'] && !F['importScripts']) {
                        var S = true
                          , U = F['onmessage'];
                        return F['onmessage'] = function () {
                          S = false;
                        }
                          ,
                          F['postMessage']('', '*'),
                          F['onmessage'] = U,
                          S;
                      }
                    }() ? (X = 'setImmediate$' + Math['random']() + '$',
                      F['addEventListener'] ? F['addEventListener']('message', B, false) : F['attachEvent']('onmessage', B),
                      function (S) {
                        F['postMessage'](X + S, '*');
                      }
                    ) : F['MessageChannel'] ? ((T = new MessageChannel())['port1']['onmessage'] = function (S) {
                      Z(S['data']);
                    }
                      ,
                      function (S) {
                        T['port2']['postMessage'](S);
                      }
                    ) : j && 'onreadystatechange' in j['createElement']('script') ? (Y = j['documentElement'],
                      function (S) {
                        var U = j['createElement']('script');
                        U['onreadystatechange'] = function () {
                          Z(S),
                            U['onreadystatechange'] = null,
                            Y['removeChild'](U),
                            U = null;
                        }
                          ,
                          Y['appendChild'](U);
                      }
                    ) : function (S) {
                      setTimeout(Z, 0x0, S);
                    }
                  ,
                  D['setImmediate'] = function (S) {
                    'function' != typeof S && (S = new Function('' + S));
                    for (var U = new Array(arguments['length'] - 0x1), q = 0x0; q < U['length']; q++)
                      U[q] = arguments[q + 0x1];
                    var J = {
                      'callback': S,
                      'args': U
                    };
                    return W[E] = J,
                      w(E),
                      E++;
                  }
                  ,
                  D['clearImmediate'] = V;
              }
              function V (S) {
                delete W[S];
              }
              function Z (S) {
                if (I)
                  setTimeout(Z, 0x0, S);
                else {
                  var U = W[S];
                  if (U) {
                    I = true;
                    try {
                      !function (q) {
                        var J = q['callback']
                          , C = q['args'];
                        switch (C['length']) {
                          case 0x0:
                            J();
                            break;
                          case 0x1:
                            J(C[0x0]);
                            break;
                          case 0x2:
                            J(C[0x0], C[0x1]);
                            break;
                          case 0x3:
                            J(C[0x0], C[0x1], C[0x2]);
                            break;
                          default:
                            J['apply'](y, C);
                        }
                      }(U);
                    } finally {
                      V(S),
                        I = false;
                    }
                  }
                }
              }
              function B (S) {
                S['source'] === F && 'string' == typeof S['data'] && 0x0 === S['data']['indexOf'](X) && Z(+S['data']['slice'](X['length']));
              }
            }('undefined' == typeof self ? undefined === p ? this : p : self);
          }
          ['call'](this, 'undefined' != typeof global ? global : 'undefined' != typeof self ? self : 'undefined' != typeof window ? window : {}));
        }
          , {}]
      }, {}, [0xa])(0xa);
    }
    ,
    0x346: (l, K, i) => {
      'use strict';
      i['d'](K, {
        'v': () => b
      });
      const b = {
        'Debug': true,
        'resourcePath': 'public',
        'defaultLegendPath': 'public/styles/colors',
        'fieldLoaderIndicator': '#',
        'fieldPropertiesIndicator': '$',
        'themeIndicator': '@',
        'functionIndicator': '//!QuickEarth',
        'customPanes': {
          'feature': {
            'name': 'featurePane',
            'zIdx': 0x1c2
          },
          'filled': {
            'name': 'filledPane',
            'zIdx': 0x17c
          },
          'topmap': {
            'name': 'tommapPane',
            'zIdx': 0x1ae
          },
          'bottommap': {
            'name': 'bottommapPane',
            'zIdx': 0x104
          },
          'station': {
            'name': 'stationPane',
            'zIdx': 0x1e0
          },
          'bellowtile': {
            'name': 'bellowtilePane',
            'zIdx': 0x64
          }
        },
        'defaultUndef': 0xf423f,
        'useWebGL2': true,
        'checkRetina': true,
        'retinaRatio': undefined,
        'licPath': 'public/qe.lic',
        'wasmPath': 'public/libs/wasm',
        'workerPath': 'public/libs/workers'
      };
      b['defaultLegendPath'] = b['resourcePath'] + '/styles/colors',
        b['licPath'] = b['resourcePath'] + '/qe.lic',
        b['wasmPath'] = b['resourcePath'] + '/libs/wasm';
    }
    ,
    0x393: (l, K, b) => {
      'use strict';
      b['d'](K, {
        'c': () => p
      });
      var c = b(0x39b)
        , H = b(0x1);
      function x () {
        return false;
      }
      class p {
        constructor() {
          this['_events'] = {},
            this['_firingCount'] = 0x0,
            this['_eventParents'] = {},
            this['_locked'] = 0x0,
            this['_lockedEvents'] = {};
        }
        ['on'] (F, y, w) {
          if ('object' == typeof F) {
            for (var h in F)
              this['_on'](h, F[h], y);
          } else {
            for (var u = 0x0, Y = (F = (0x0,
              H['nf'])(F))['length']; u < Y; u++)
              this['_on'](F[u], y, w);
          }
          return this;
        }
        ['off'] (F, y, w) {
          if (F) {
            if ('object' == typeof F) {
              for (var h in F)
                this['_off'](h, F[h], y);
            } else {
              for (var u = 0x0, Y = (F = (0x0,
                H['nf'])(F))['length']; u < Y; u++)
                this['_off'](F[u], y, w);
            }
          } else
            delete this['_events'];
          return this;
        }
        ['lock'] () {
          return this['_locked']++,
            this;
        }
        ['unlock'] (F = true) {
          if (this['_locked']--,
            this['_locked'] < 0x0 && (this['_locked'] = 0x0),
            0x0 === this['_locked'] && F) {
            const y = Object['keys'](this['_lockedEvents']);
            for (const w of y)
              this['fire'](w, this['_lockedEvents'][w]['data'], this['_lockedEvents'][w]['prop']);
            y['length'] > 0x0 && c['kg']['debug']('locked\x20msg\x20fired,count\x20' + y['length']);
          }
        }
        ['_on'] (F, y, w) {
          this['_events'] = this['_events'] || {};
          var h = this['_events'][F];
          h || (h = [],
            this['_events'][F] = h),
            w === this && (w = undefined);
          for (var u = {
            'fn': y,
            'ctx': w
          }, Y = h, T = 0x0, X = Y['length']; T < X; T++)
            if (Y[T]['fn'] === y && Y[T]['ctx'] === w)
              return;
          Y['push'](u);
        }
        ['_off'] (F, y, w) {
          var h, u, Y;
          if (this['_events'] && (h = this['_events'][F])) {
            if (y) {
              if (w === this && (w = undefined),
                h)
                for (u = 0x0,
                  Y = h['length']; u < Y; u++) {
                  var T = h[u];
                  if (T['ctx'] === w && T['fn'] === y)
                    return T['fn'] = x,
                      this['_firingCount'] && (this['_events'][F] = h = h['slice']()),
                      void h['splice'](u, 0x1);
                }
            } else {
              for (u = 0x0,
                Y = h['length']; u < Y; u++)
                h[u]['fn'] = x;
              delete this['_events'][F];
            }
          }
        }
        ['fire'] (F, y, w) {
          if (!(this['_locked'] > 0x0)) {
            if (!this['listens'](F, w))
              return this;
            var h = (0x0,
              H['l7'])({}, y, {
                'type': F,
                'target': this,
                'sourceTarget': y && y['firer'] || this
              });
            if (this['_events']) {
              var u = this['_events'][F];
              if (u) {
                this['_firingCount'] = this['_firingCount'] + 0x1 || 0x1;
                for (var Y = 0x0, T = u['length']; Y < T; Y++) {
                  var X = u[Y];
                  X['fn']['call'](X['ctx'] || this, h);
                }
                this['_firingCount']--;
              }
            }
            return w && this['_propagateEvent'](h),
              this;
          }
          this['_lockedEvents'][F] = {
            'data': y,
            'prop': w
          };
        }
        ['listens'] (F, y) {
          var w = this['_events'] && this['_events'][F];
          if (w && w['length'])
            return true;
          if (y) {
            for (var h in this['_eventParents'])
              if (this['_eventParents'][h]['listens'](F, y))
                return true;
          }
          return false;
        }
        ['once'] (F, y, w) {
          if ('object' == typeof F) {
            for (var h in F)
              this['once'](h, F[h], y);
            return this;
          }
          var u = function (Y, T) {
            var X = Array['prototype']['slice'];
            if (Y['bind'])
              return Y['bind']['apply'](Y, X['call'](arguments, 0x1));
            var E = X['call'](arguments, 0x2);
            return function () {
              return Y['apply'](T, E['length'] ? E['concat'](X['call'](arguments)) : arguments);
            }
              ;
          }(function () {
            this['off'](F, y, w)['off'](F, u, w);
          }, this);
          return this['on'](F, y, w)['on'](F, u, w);
        }
        ['addEventParent'] (F) {
          return this['_eventParents'] = this['_eventParents'] || {},
            this['_eventParents'][(0x0,
              H['Rc'])(F)] = F,
            this;
        }
        ['removeEventParent'] (F) {
          return this['_eventParents'] && delete this['_eventParents'][(0x0,
            H['Rc'])(F)],
            this;
        }
        ['_propagateEvent'] (F) {
          for (var y in this['_eventParents'])
            this['_eventParents'][y]['fire'](F['type'], (0x0,
              H['l7'])({
                'layer': F['target'],
                'propagatedFrom': F['target']
              }, F), true);
        }
      }
    }
    ,
    0x19d: (K, H, F) => {
      'use strict';
      F['d'](H, {
        'CI': () => L,
        'Fj': () => q,
        'JW': () => U,
        'Jf': () => O,
        'M': () => v3,
        'NX': () => v4,
        'PE': () => Q,
        'SC': () => R,
        'Tw': () => M,
        'Xx': () => v0,
        '_7': () => v1,
        'cQ': () => G,
        'oL': () => z,
        'pd': () => J,
        'q$': () => C,
        'rJ': () => N,
        'sC': () => v2
      });
      var Y = F(0x39b)
        , T = F(0xfb)
        , X = F(0x1)
        , W = F(0x346)
        , j = F(0x240)
        , D = F(0x1de)
        , V = F(0x260)
        , Z = F(0x133);
      function B (v5, v6) {
        let v7, v8, v9 = v6;
        if (v6['indexOf'](W['v']['fieldLoaderIndicator']) > 0x0) {
          const vA = v9['split'](W['v']['fieldLoaderIndicator']);
          v9 = vA[0x0];
          const vn = vA[0x1]['split']('?');
          v8 = (0x0,
            Z['vl'])(vn[0x1]),
            v7 = (0x0,
              T['nA'])(vn[0x0]);
        } else
          0x0 === v6['indexOf'](W['v']['fieldLoaderIndicator']) && (v9 = v6['slice'](0x1),
            Y['kg']['error']('引用类型字段中的loader标记不能是第一个字符！' + v6));
        const vv = v5['properties'] && v5['properties'][v9];
        if (null != vv)
          return v7 ? v7(vv, Object['assign'](Object['assign']({}, v8), {
            'feature': v5,
            'fieldName': v9
          })) : vv;
      }
      function U (v5) {
        const v6 = (0x0,
          Z['it'])(v5);
        if ('number' == typeof v6)
          return v7 => v6;
        if ('function' == typeof v6)
          return v6;
        if ('object' == typeof v6 && v6['stops']) {
          const v7 = new V['NB'](v6, v8 => (v8['stop'] = parseFloat(v8['stop']),
            v8));
          return v8 => v7['getRule'](v8['properties'][v7['fieldName']])['stop'];
        }
        if ('string' == typeof v6) {
          if (v6['startsWith'](W['v']['fieldPropertiesIndicator'])) {
            const v8 = v6['substr'](0x1);
            return v9 => B(v9, v8);
          }
          {
            const v9 = parseFloat(v6);
            return undefined === v9 && Y['kg']['error']('提供了非数值属性' + v6 + '！'),
              vv => v9;
          }
        }
        Y['kg']['error']('数字字段不支持当前类型：' + typeof v6);
      }
      function q (v5) {
        const v6 = (0x0,
          Z['it'])(v5);
        if ('number' == typeof v6) {
          const v7 = v6['toString']();
          return v8 => v7;
        }
        if ('function' == typeof v6)
          return v6;
        if ('object' == typeof v6 && v6['stops']) {
          const v8 = new V['NB'](v6, v9 => (v9['stop']['toString'] && v9['stop']['toString'](),
            v9));
          return v9 => v8['getRule'](v9['properties'][v8['fieldName']])['stop'];
        }
        if ('string' == typeof v6) {
          if (v6['startsWith'](W['v']['fieldPropertiesIndicator'])) {
            let v9 = v6['substr'](0x1);
            return vv => B(vv, v9);
          }
          return vv => v6;
        }
        Y['kg']['error']('字符串字段不支持当前类型：' + typeof v6);
      }
      function J (v5) {
        const v6 = (0x0,
          Z['it'])(v5);
        if ('number' == typeof v6) {
          const v7 = 0x0 !== v6;
          return v8 => v7;
        }
        if ('boolean' == typeof v6)
          return v8 => v6;
        if ('function' == typeof v6)
          return v6;
        if ('object' == typeof v6 && v6['stops']) {
          const v8 = new V['NB'](v6);
          return v9 => v8['getRule'](v9['properties'][v8['fieldName']])['stop'];
        }
        if ('string' == typeof v6) {
          if (v6['startsWith'](W['v']['fieldPropertiesIndicator'])) {
            const v9 = v6['substr'](0x1);
            return vv => {
              const vA = B(vv, v9);
              return !!vA && ('number' == typeof vA ? 0x0 !== vA : 'string' == typeof vA ? '0' !== vA && 'false' !== vA['toLowerCase']() : false !== vA);
            }
              ;
          }
          {
            const vv = '0' !== v6 && 'false' !== v6['toLowerCase']();
            return vA => vv;
          }
        }
        Y['kg']['error']('逻辑字段不支持当前类型：' + typeof v6);
      }
      function C (v5) {
        const v6 = (0x0,
          Z['it'])(v5);
        if (v6 instanceof Array)
          return v7 => v6;
        if ('function' == typeof v6)
          return v6;
        if ('object' == typeof v6 && v6['stops']) {
          const v7 = new V['NB'](v6);
          return v8 => v7['getRule'](v8['properties'][v7['fieldName']])['stop'];
        }
        Y['kg']['error']('数值数组字段不支持当前类型：' + typeof v6);
      }
      function O (v5) {
        const v6 = (0x0,
          Z['it'])(v5);
        if ('string' == typeof v6) {
          if (v6['startsWith'](W['v']['fieldPropertiesIndicator'])) {
            const v7 = v6['substr'](0x1);
            return v8 => {
              const v9 = B(v8, v7);
              return v9 ? 'string' == typeof v9 ? (0x0,
                Z['$P'])(v9) : 'number' == typeof v9 ? (0x0,
                  Z['lW'])(v9) : v9 instanceof D['t'] ? v9 : v9 instanceof Array ? (0x0,
                    Z['LH'])(v9) : void Y['kg']['error']('不能识别的颜色类型！' + v9) : new D['t']('black');
            }
              ;
          }
          {
            const v8 = (0x0,
              Z['$P'])(v6);
            return v9 => v8;
          }
        }
        if ('number' == typeof v6) {
          const v9 = (0x0,
            Z['lW'])(v6);
          return vv => v9;
        }
        if (v6 instanceof D['t'])
          return vv => v6;
        if (v6 instanceof Array) {
          const vv = new D['t']({
            'r': v6[0x0],
            'g': v6[0x1],
            'b': v6[0x2],
            'a': 0x3 === v6['length'] ? 0x1 : v6[0x3]
          });
          return vA => vv;
        }
        if ('function' == typeof v6)
          return vA => {
            const vn = v6(vA);
            return vn instanceof D['t'] ? vn : 'string' == typeof vn ? (0x0,
              Z['$P'])(vn) : 'number' == typeof vn ? (0x0,
                Z['lW'])(vn) : vn instanceof Array ? (0x0,
                  Z['LH'])(vn) : void Y['kg']['warn']('不支持的颜色类型！');
          }
            ;
        if ('object' == typeof v6 && (undefined !== v6['r'] || undefined !== v6['red'])) {
          const vA = new D['t'](v6);
          return vn => vA;
        }
        if ('object' == typeof v6 && v6['stops']) {
          const vn = new V['NB'](v6, Z['$k']);
          return vk => vn['getRule'](vk['properties'][vn['fieldName']])['stop'];
        }
        Y['kg']['error']('颜色字段不支持当前类型：' + typeof v6);
      }
      function G (v5) {
        const v6 = (0x0,
          Z['it'])(v5);
        if ('string' == typeof v6) {
          if (v6['startsWith'](W['v']['fieldPropertiesIndicator'])) {
            const v7 = v6['substr'](0x1);
            return v8 => B(v8, v7);
          }
          return v8 => v6;
        }
        if (v6 instanceof HTMLImageElement || v6 instanceof HTMLVideoElement || v6 instanceof HTMLCanvasElement)
          return v8 => v6;
        if ('function' == typeof v6)
          return v6;
        if ('object' == typeof v6 && v6['stops']) {
          const v8 = new V['NB'](v6);
          return v9 => v8['getRule'](v9['properties'][v8['fieldName']])['stop'];
        }
        Y['kg']['error']('图像字段不支持当前类型：' + typeof v6);
      }
      class N extends Z['Uw'] {
        ['_createCacheId'] (v5) {
          if ((0x0,
            X['ri'])(v5))
            return v5['id'] || (v5['id'] = (0x0,
              X['hQ'])());
        }
      }
      class M extends N {
        constructor(v5) {
          super(v5),
            v5['data'] || Y['kg']['error']('图像数据是必选字段！'),
            this['_update'](v5, true);
        }
        ['_update'] (v5, v6) {
          v6 ? (this['size'] = C((0x0,
            X['En'])(v5['size'], M['DefaultOptions']['size'])),
            this['data'] = G(v5['data']),
            this['visible'] = J((0x0,
              X['En'])(v5['visible'], M['DefaultOptions']['visible'])),
            this['avoidCollison'] = J((0x0,
              X['En'])(v5['avoidCollison'], M['DefaultOptions']['avoidCollison'])),
            this['shadowOffset'] = C((0x0,
              X['En'])(v5['shadowOffset'], M['DefaultOptions']['shadowOffset'])),
            this['shadowBlur'] = U((0x0,
              X['En'])(v5['shadowBlur'], M['DefaultOptions']['shadowBlur'])),
            this['heightMode'] = (0x0,
              X['En'])(v5['heightMode'], M['DefaultOptions']['heightMode']),
            this['depthTest'] = J((0x0,
              X['En'])(v5['depthTest'], M['DefaultOptions']['depthTest'])),
            this['offset'] = C((0x0,
              X['En'])(v5['offset'], M['DefaultOptions']['offset'])),
            this['eyeOffset'] = C((0x0,
              X['En'])(v5['eyeOffset'], M['DefaultOptions']['eyeOffset'])),
            this['sizeInMeters'] = J((0x0,
              X['En'])(v5['sizeInMeters'], M['DefaultOptions']['sizeInMeters']))) : (this['size'] = (0x0,
                X['Rf'])(v5['size'], this['size'], C),
                this['data'] = (0x0,
                  X['Rf'])(v5['data'], this['data'], G),
                this['visible'] = (0x0,
                  X['Rf'])(v5['visible'], this['visible'], J),
                this['avoidCollison'] = (0x0,
                  X['Rf'])(v5['avoidCollison'], this['avoidCollison'], J),
                this['shadowOffset'] = (0x0,
                  X['Rf'])(v5['shadowOffset'], this['shadowOffset'], C),
                this['shadowBlur'] = (0x0,
                  X['Rf'])(v5['shadowBlur'], this['shadowBlur'], U),
                this['heightMode'] = (0x0,
                  X['Rf'])(v5['heightMode'], this['heightMode']),
                this['depthTest'] = (0x0,
                  X['Rf'])(v5['depthTest'], this['depthTest'], J),
                this['offset'] = (0x0,
                  X['Rf'])(v5['offset'], this['offset'], C),
                this['eyeOffset'] = (0x0,
                  X['Rf'])(v5['eyeOffset'], this['eyeOffset'], C),
                this['sizeInMeters'] = (0x0,
                  X['Rf'])(v5['sizeInMeters'], this['sizeInMeters'], J)),
            this['angle'] = (0x0,
              X['Rf'])(v5['angle'], this['angle'], U),
            this['shadowColor'] = (0x0,
              X['Rf'])(v5['shadowColor'], this['shadowColor'], O),
            this['color'] = (0x0,
              X['Rf'])(v5['color'], this['color'], O);
        }
      }
      M['DefaultOptions'] = {
        'data': undefined,
        'size': [0x20, 0x20],
        'visible': true,
        'avoidCollison': false,
        'shadowBlur': 0x5,
        'shadowOffset': [0x5, 0x5],
        'heightMode': 'none',
        'depthTest': true,
        'offset': [0x0, 0x0],
        'eyeOffset': [0x0, 0x0, 0x0],
        'sizeInMeters': false
      };
      class z extends N {
        constructor(v5) {
          super(v5),
            v5 && v5['data'] || Y['kg']['error']('文本类data字段不能为空！'),
            this['_update'](v5, true);
        }
        ['_update'] (v5, v6) {
          v6 ? (this['data'] = q(v5['data']),
            this['font'] = q((0x0,
              X['En'])(v5['font'], z['DefaultOptions']['font'])),
            this['color'] = O((0x0,
              X['En'])(v5['color'], z['DefaultOptions']['color'])),
            this['visible'] = J((0x0,
              X['En'])(v5['visible'], z['DefaultOptions']['visible'])),
            this['avoidCollison'] = J((0x0,
              X['En'])(v5['avoidCollison'], z['DefaultOptions']['avoidCollison'])),
            this['collisionExtendSize'] = C((0x0,
              X['En'])(v5['collisionExtendSize'], z['DefaultOptions']['collisionExtendSize'])),
            this['backHeight'] = U((0x0,
              X['En'])(v5['backHeight'], z['DefaultOptions']['backHeight'])),
            this['backPadding'] = C((0x0,
              X['En'])(v5['backPadding'], z['DefaultOptions']['backPadding'])),
            this['strokeWidth'] = U((0x0,
              X['En'])(v5['strokeWidth'], z['DefaultOptions']['strokeWidth'])),
            this['backStrokeWidth'] = U((0x0,
              X['En'])(v5['backStrokeWidth'], z['DefaultOptions']['backStrokeWidth'])),
            this['align'] = q((0x0,
              X['En'])(v5['align'], z['DefaultOptions']['align'])),
            this['baseline'] = q((0x0,
              X['En'])(v5['baseline'], z['DefaultOptions']['baseline'])),
            this['backShadowBlur'] = U((0x0,
              X['En'])(v5['backShadowBlur'], z['DefaultOptions']['backShadowBlur'])),
            this['backShadowOffset'] = C((0x0,
              X['En'])(v5['backShadowOffset'], z['DefaultOptions']['backShadowOffset'])),
            this['shadowOffset'] = C((0x0,
              X['En'])(v5['shadowOffset'], z['DefaultOptions']['shadowOffset'])),
            this['shadowBlur'] = U((0x0,
              X['En'])(v5['shadowBlur'], z['DefaultOptions']['shadowBlur'])),
            this['backRoundRadius'] = U((0x0,
              X['En'])(v5['backRoundRadius'], z['DefaultOptions']['backRoundRadius'])),
            this['heightMode'] = (0x0,
              X['En'])(v5['heightMode'], z['DefaultOptions']['heightMode']),
            this['forceImage'] = J((0x0,
              X['En'])(v5['forceImage'], z['DefaultOptions']['forceImage'])),
            this['depthTest'] = J((0x0,
              X['En'])(v5['depthTest'], z['DefaultOptions']['depthTest'])),
            this['eyeOffset'] = C((0x0,
              X['En'])(v5['eyeOffset'], z['DefaultOptions']['eyeOffset']))) : (this['data'] = (0x0,
                X['Rf'])(v5['data'], this['data'], q),
                this['font'] = (0x0,
                  X['Rf'])(v5['font'], this['font'], q),
                this['color'] = (0x0,
                  X['Rf'])(v5['color'], this['color'], O),
                this['visible'] = (0x0,
                  X['Rf'])(v5['visible'], this['visible'], J),
                this['avoidCollison'] = (0x0,
                  X['Rf'])(v5['avoidCollison'], this['avoidCollison'], J),
                this['collisionExtendSize'] = (0x0,
                  X['Rf'])(v5['collisionExtendSize'], this['collisionExtendSize'], C),
                this['backHeight'] = (0x0,
                  X['Rf'])(v5['backHeight'], this['backHeight'], U),
                this['backPadding'] = (0x0,
                  X['Rf'])(v5['backPadding'], this['backPadding'], C),
                this['strokeWidth'] = (0x0,
                  X['Rf'])(v5['strokeWidth'], this['strokeWidth'], U),
                this['backStrokeWidth'] = (0x0,
                  X['Rf'])(v5['backStrokeWidth'], this['backStrokeWidth'], U),
                this['align'] = (0x0,
                  X['Rf'])(v5['align'], this['align'], q),
                this['baseline'] = (0x0,
                  X['Rf'])(v5['baseline'], this['baseline'], q),
                this['backShadowOffset'] = (0x0,
                  X['Rf'])(v5['backShadowOffset'], this['backShadowOffset'], C),
                this['backShadowBlur'] = (0x0,
                  X['Rf'])(v5['backShadowBlur'], this['backShadowBlur'], U),
                this['shadowOffset'] = (0x0,
                  X['Rf'])(v5['shadowOffset'], this['shadowOffset'], C),
                this['shadowBlur'] = (0x0,
                  X['Rf'])(v5['shadowBlur'], this['shadowBlur'], U),
                this['backRoundRadius'] = (0x0,
                  X['Rf'])(v5['backRoundRadius'], this['backRoundRadius'], U),
                this['heightMode'] = (0x0,
                  X['Rf'])(v5['heightMode'], this['heightMode']),
                this['forceImage'] = (0x0,
                  X['Rf'])(v5['forceImage'], this['forceImage'], J),
                this['depthTest'] = (0x0,
                  X['Rf'])(v5['depthTest'], this['depthTest'], J),
                this['eyeOffset'] = (0x0,
                  X['Rf'])(v5['eyeOffset'], this['eyeOffset'], C)),
            this['angle'] = (0x0,
              X['Rf'])(v5['angle'], this['angle'], U),
            this['strokeColor'] = (0x0,
              X['Rf'])(v5['strokeColor'], this['strokeColor'], O),
            this['backColor'] = (0x0,
              X['Rf'])(v5['backColor'], this['backColor'], O),
            this['backCircle'] = (0x0,
              X['Rf'])(v5['backCircle'], this['backCircle'], J),
            this['offset'] = (0x0,
              X['Rf'])(v5['offset'], this['offset'], C),
            this['backStrokeColor'] = (0x0,
              X['Rf'])(v5['backStrokeColor'], this['backStrokeColor'], O),
            this['backRoundRect'] = (0x0,
              X['Rf'])(v5['backRoundRect'], this['backRoundRect'], J),
            this['backShadowColor'] = (0x0,
              X['Rf'])(v5['backShadowColor'], this['backShadowColor'], O),
            this['backStrokeDashArray'] = (0x0,
              X['Rf'])(v5['backStrokeDashArray'], this['backStrokeDashArray'], C),
            this['shadowColor'] = (0x0,
              X['Rf'])(v5['shadowColor'], this['shadowColor'], O),
            this['backWidth'] = (0x0,
              X['Rf'])(v5['backWidth'], this['backWidth'], U),
            this['forceImageSize'] = (0x0,
              X['Rf'])(v5['forceImageSize'], this['forceImageSize'], C);
        }
      }
      z['DefaultOptions'] = {
        'data': undefined,
        'font': '12px\x20微软雅黑',
        'color': 'black',
        'visible': true,
        'avoidCollison': false,
        'collisionExtendSize': [0x0, 0x0],
        'backHeight': 0xe,
        'backPadding': [0x5, 0x4],
        'strokeWidth': 0x1,
        'backStrokeWidth': 0x1,
        'align': 'center',
        'baseline': 'middle',
        'backShadowBlur': 0x6,
        'backShadowOffset': [0x3, 0x3],
        'shadowBlur': 0x6,
        'shadowOffset': [0x3, 0x3],
        'backRoundRadius': 0x6,
        'heightMode': 'none',
        'forceImage': false,
        'depthTest': true,
        'eyeOffset': [0x0, 0x0, 0x0]
      };
      class Q extends N {
        constructor(v5) {
          super(v5),
            v5 || Y['kg']['error']('当提供标签字段时，标签字段选项不能为空！'),
            this['_update'](v5, true);
        }
        ['_update'] (v5, v6) {
          v5['image'] && (this['image'] && !v6 ? this['image']['update'](v5['image']) : this['image'] = new M(v5['image'])),
            v5['text'] && (this['text'] && !v6 ? this['text']['update'](v5['text']) : this['text'] = new z(v5['text']));
        }
      }
      class L extends N {
        constructor(v5) {
          super(v5),
            v5 || Y['kg']['error']('点线面的样式构造参数为空！'),
            this['_update'](v5, true);
        }
        ['_update'] (v5, v6) {
          v6 ? (this['color'] = O((0x0,
            X['En'])(v5['color'], L['DefaultOptions']['color'])),
            this['visible'] = J((0x0,
              X['En'])(v5['visible'], L['DefaultOptions']['visible'])),
            this['shadowOffset'] = C((0x0,
              X['En'])(v5['shadowOffset'], L['DefaultOptions']['shadowOffset'])),
            this['shadowBlur'] = U((0x0,
              X['En'])(v5['shadowBlur'], L['DefaultOptions']['shadowBlur'])),
            this['usePositionHeight'] = J((0x0,
              X['En'])(v5['usePositionHeight'], L['DefaultOptions']['usePositionHeight'])),
            this['height'] = U((0x0,
              X['En'])(v5['height'], L['DefaultOptions']['height'])),
            this['zoomMin'] = U((0x0,
              X['En'])(v5['zoomMin'], L['DefaultOptions']['zoomMin'])),
            this['zoomMax'] = U((0x0,
              X['En'])(v5['zoomMax'], L['DefaultOptions']['zoomMax'])),
            this['heightOffset'] = U((0x0,
              X['En'])(v5['heightOffset'], L['DefaultOptions']['heightOffset'])),
            this['heightMin'] = U((0x0,
              X['En'])(v5['heightMin'], L['DefaultOptions']['heightMin'])),
            this['heightMax'] = U((0x0,
              X['En'])(v5['heightMax'], L['DefaultOptions']['heightMax']))) : (this['color'] = (0x0,
                X['Rf'])(v5['color'], this['color'], O),
                this['visible'] = (0x0,
                  X['Rf'])(v5['visible'], this['visible'], J),
                this['shadowOffset'] = (0x0,
                  X['Rf'])(v5['shadowOffset'], this['shadowOffset'], C),
                this['shadowBlur'] = (0x0,
                  X['Rf'])(v5['shadowBlur'], this['shadowBlur'], U),
                this['usePositionHeight'] = (0x0,
                  X['Rf'])(v5['usePositionHeight'], this['usePositionHeight'], J),
                this['height'] = (0x0,
                  X['Rf'])(v5['height'], this['height'], U),
                this['zoomMin'] = (0x0,
                  X['Rf'])(v5['zoomMin'], this['zoomMin'], U),
                this['zoomMax'] = (0x0,
                  X['Rf'])(v5['zoomMax'], this['zoomMax'], U),
                this['heightOffset'] = (0x0,
                  X['Rf'])(v5['heightOffset'], this['heightOffset'], U),
                this['heightMin'] = (0x0,
                  X['Rf'])(v5['heightMin'], this['heightMin'], U),
                this['heightMax'] = (0x0,
                  X['Rf'])(v5['heightMax'], this['heightMax'], U)),
            this['shadowColor'] = (0x0,
              X['Rf'])(v5['shadowColor'], this['shadowColor'], O);
        }
      }
      L['DefaultOptions'] = {
        'color': 'rgba(22,7,201,0.7)',
        'visible': true,
        'shadowOffset': [0xa, 0xa],
        'shadowBlur': 0xa,
        'usePositionHeight': false,
        'height': 0x0,
        'zoomMin': 0x0,
        'zoomMax': 0x64,
        'heightOffset': 0xa,
        'heightMin': 0x0,
        'heightMax': 0x1 / 0x0
      };
      class R extends L {
        constructor(v5) {
          super(v5),
            this['_update'](v5, true);
        }
        ['updateLabels'] (v5) {
          const v6 = [];
          if (v5['label'] && v5['label']['length'] > 0x0) {
            for (const v7 of v5['label'])
              v6['push'](new Q(v7));
          }
          this['label'] = v6;
        }
        ['_update'] (v5, v6) {
          super['_update'](v5, v6),
            v6 ? (this['size'] = U((0x0,
              X['En'])(v5['size'], R['DefaultOptions']['size'])),
              this['fill'] = J((0x0,
                X['En'])(v5['fill'], R['DefaultOptions']['fill'])),
              this['strokeWidth'] = U((0x0,
                X['En'])(v5['strokeWidth'], R['DefaultOptions']['strokeWidth'])),
              this['collisionBuffer'] = C((0x0,
                X['En'])(v5['collisionBuffer'], R['DefaultOptions']['collisionBuffer']))) : (this['size'] = (0x0,
                  X['Rf'])(v5['size'], this['size'], U),
                  this['fill'] = (0x0,
                    X['Rf'])(v5['fill'], this['fill'], J),
                  this['strokeWidth'] = (0x0,
                    X['Rf'])(v5['strokeWidth'], this['strokeWidth'], U),
                  this['collisionBuffer'] = (0x0,
                    X['Rf'])(v5['collisionBuffer'], this['collisionBuffer'], C)),
            this['strokeColor'] = (0x0,
              X['Rf'])(v5['strokeColor'], this['strokeColor'], O),
            this['strokeDashArray'] = (0x0,
              X['Rf'])(v5['strokeDashArray'], this['strokeDashArray'], C),
            this['avoidCollison'] = (0x0,
              X['Rf'])(v5['avoidCollison'], this['avoidCollison'], J),
            this['updateLabels'](v5);
        }
      }
      R['DefaultOptions'] = {
        'color': 'rgba(22,7,201,0.7)',
        'visible': true,
        'size': 0x5,
        'fill': true,
        'strokeWidth': 0x1,
        'shadowOffset': [0x5, 0x5],
        'shadowBlur': 0xa,
        'collisionBuffer': [0x0, 0x0]
      };
      class v0 extends L {
        constructor(v5) {
          super(v5),
            this['_update'](v5, true);
        }
        ['_update'] (v5, v6) {
          super['_update'](v5, v6),
            v6 ? (this['width'] = U((0x0,
              X['En'])(v5['width'], v0['DefaultOptions']['width'])),
              this['labelDistance'] = U((0x0,
                X['En'])(v5['labelDistance'], v0['DefaultOptions']['labelDistance'])),
              this['labelDistance3D'] = U((0x0,
                X['En'])(v5['labelDistance3D'], v0['DefaultOptions']['labelDistance3D'])),
              this['labelAutoFlip'] = J((0x0,
                X['En'])(v5['labelAutoFlip'], v0['DefaultOptions']['labelAutoFlip']))) : (this['width'] = (0x0,
                  X['Rf'])(v5['width'], this['width'], U),
                  this['labelDistance'] = (0x0,
                    X['Rf'])(v5['labelDistance'], this['labelDistance'], U),
                  this['labelDistance3D'] = (0x0,
                    X['Rf'])(v5['labelDistance3D'], this['labelDistance3D'], U),
                  this['labelAutoFlip'] = (0x0,
                    X['Rf'])(v5['labelAutoFlip'], this['labelAutoFlip'], J)),
            this['dashArray'] = (0x0,
              X['Rf'])(v5['dashArray'], this['dashArray'], C),
            this['alwaysDrawFirstLabel'] = (0x0,
              X['Rf'])(v5['alwaysDrawFirstLabel'], this['alwaysDrawFirstLabel'], J),
            this['lineJoin'] = (0x0,
              X['Rf'])(v5['lineJoin'], this['lineJoin'], q),
            this['lineCap'] = (0x0,
              X['Rf'])(v5['lineCap'], this['lineCap'], q);
          const v7 = [];
          if (v5['label'] && v5['label']['length'] > 0x0) {
            for (const v8 of v5['label'])
              v7['push'](new Q(v8));
          }
          this['label'] = v7;
        }
      }
      v0['DefaultOptions'] = {
        'color': 'rgba(22,7,201,0.7)',
        'visible': true,
        'width': 0x1,
        'labelDistance': 0xc8,
        'labelDistance3D': 0x186a0,
        'labelAutoFlip': true
      };
      class v1 extends L {
        constructor(v5) {
          super(v5),
            this['_update'](v5, true);
        }
        ['updateLabels'] (v5) {
          const v6 = [];
          if (v5['label'] && v5['label']['length'] > 0x0) {
            for (const v7 of v5['label'])
              v6['push'](new Q(v7));
          }
          this['label'] = v6;
        }
        ['updateLineStyle'] (v5) {
          this['lineStyle'] = v5['lineStyle'] && new v0(v5['lineStyle']);
        }
        ['_update'] (v5, v6) {
          super['_update'](v5, v6),
            this['fill'] = v6 ? J((0x0,
              X['En'])(v5['fill'], v1['DefaultOptions']['fill'])) : (0x0,
                X['Rf'])(v5['fill'], this['fill'], J),
            this['fillImage'] = (0x0,
              X['Rf'])(v5['fillImage'], this['fillImage'], G),
            this['updateLineStyle'](v5),
            this['updateLabels'](v5);
        }
      }
      v1['DefaultOptions'] = {
        'color': 'rgba(22,7,201,0.7)',
        'visible': true,
        'fill': true
      };
      class v2 extends N {
        constructor(v5) {
          super(v5),
            this['styleName'] = 'featureStyle',
            this['_update'](v5, true);
        }
        ['_update'] (v5, v6) {
          v5 && (v5['point'] && (this['point'] && !v6 ? this['point']['update'](v5['point']) : this['point'] = new R(v5['point'])),
            v5['polyline'] && (this['polyline'] && !v6 ? this['polyline']['update'](v5['polyline']) : this['polyline'] = new v0(v5['polyline'])),
            v5['polygon'] && (this['polygon'] && !v6 ? this['polygon']['update'](v5['polygon']) : this['polygon'] = new v1(v5['polygon'])),
            this['globalOpacity'] = v6 ? U((0x0,
              X['En'])(v5['globalOpacity'], v2['DefaultOptions']['globalOpacity'])) : (0x0,
                X['Rf'])(v5['globalOpacity'], this['globalOpacity'], U));
        }
      }
      function v3 (v5) {
        const v6 = (0x0,
          Z['it'])(v5);
        if (v6 instanceof Array)
          return () => v6;
        if ('function' == typeof v6)
          return v6;
        if ('object' == typeof v6 && v6['stops']) {
          const v7 = new V['NB'](v6);
          return () => v7['getVals']();
        }
        if ('string' == typeof v5)
          return () => v5['split'](',')['map'](v8 => parseFloat(v8));
        Y['kg']['error']('数值数组字段不支持当前类型：' + typeof v6);
      }
      v2['DefaultOptions'] = {
        'globalOpacity': 0x1
      };
      class v4 extends v2 {
        constructor(v5) {
          v5['analysisValues'] ? super(v5) : Y['kg']['error']('分析值analysisValues必须配置！', true);
        }
        ['_update'] (v5, v6) {
          v6 ? (this['analysisValues'] = v3(v5['analysisValues']),
            this['withShaded'] = (0x0,
              X['En'])(v5['withShaded'], v4['DefaultOptions']['withShaded'])) : (this['analysisValues'] = (0x0,
                X['Rf'])(v5['analysisValues'], this['analysisValues'], v3),
                this['withShaded'] = (0x0,
                  X['Rf'])(v5['withShaded'], this['withShaded'])),
            this['interpField'] = (0x0,
              X['Rf'])(v5['interpField'], this['interpField']),
            this['interpGridOptions'] = (0x0,
              X['Rf'])(v5['interpGridOptions'], this['interpGridOptions']),
            this['interpGridOptions'] && (0x0,
              j['T'])(this['interpGridOptions']),
            this['undef'] = (0x0,
              X['Rf'])(v5['undef'], this['undef']),
            super['_update'](v5, v6);
        }
      }
      v4['DefaultOptions'] = Object['assign'](Object['assign']({}, v2['DefaultOptions']), {
        'withShaded': true,
        'analysisValues': undefined
      });
    }
    ,
    0x240: (l, K, b) => {
      'use strict';
      b['d'](K, {
        'T': () => H,
        'Z': () => p
      });
      var c = b(0x1);
      function H (F) {
        let y = {
          'start': F['xStart'],
          'end': F['xEnd'],
          'delta': F['xDelta'],
          'size': F['xSize']
        };
        x(y),
          F['xStart'] = y['start'],
          F['xEnd'] = y['end'],
          F['xDelta'] = y['delta'],
          F['xSize'] = y['size'];
        let w = {
          'start': F['yStart'],
          'end': F['yEnd'],
          'delta': F['yDelta'],
          'size': F['ySize']
        };
        x(w),
          F['yStart'] = w['start'],
          F['yEnd'] = w['end'],
          F['yDelta'] = w['delta'],
          F['ySize'] = w['size'],
          F['zValues'] || (F['zValues'] = [0x0]),
          F['tCount'] = (0x0,
            c['En'])(F['tCount'], 0x1);
      }
      function x (F) {
        let y = new Error('不完整的参数，无法计算维度信息--from\x20ensureOneDim');
        if (undefined !== F['start']) {
          if (undefined === F['end']) {
            if (undefined === F['start'] || !F['delta'] || !F['size'])
              throw y;
            F['end'] = F['start'] + F['delta'] * (F['size'] - 0x1);
          }
          if (!F['size']) {
            if (undefined === F['start'] || undefined === F['end'] || !F['delta'])
              throw y;
            F['size'] = Math['floor']((F['end'] - F['start']) / F['delta']) + 0x1;
          }
          if (!F['delta']) {
            if (undefined === F['start'] || undefined === F['end'] || !F['size'])
              throw y;
            F['delta'] = (F['end'] - F['start']) / (F['size'] - 0x1);
          }
        } else {
          if (!F['delta'] || undefined === F['end'] || !F['size'])
            throw y;
          F['start'] = F['end'] - F['delta'] * (F['size'] - 0x1);
        }
      }
      function p (F, y = 0x6) {
        var w, h;
        return {
          'minLat': parseFloat(Math['min'](F['yStart'], F['yEnd'])['toFixed'](y)),
          'maxLat': parseFloat(Math['max'](F['yStart'], F['yEnd'])['toFixed'](y)),
          'minLon': parseFloat(Math['min'](F['xStart'], F['xEnd'])['toFixed'](y)),
          'maxLon': parseFloat(Math['max'](F['xStart'], F['xEnd'])['toFixed'](y)),
          'minHeight': (null === (w = F['zValues']) || undefined === w ? undefined : w['length']) > 0x0 ? Math['min'](F['zValues'][0x0], F['zValues'][F['zValues']['length'] - 0x1]) : 0x0,
          'maxHeight': (null === (h = F['zValues']) || undefined === h ? undefined : h['length']) > 0x0 ? Math['max'](F['zValues'][0x0], F['zValues'][F['zValues']['length'] - 0x1]) : 0x0
        };
      }
    }
    ,
    0x338: (K, b, c) => {
      'use strict';
      c['d'](b, {
        'K': () => h,
        'P': () => w
      });
      var H = c(0x39b)
        , x = c(0x95)
        , p = c(0x1)
        , F = c(0x60);
      const y = ((0x0,
        x['Tz'])(),
        Y => new ArrayBuffer(Y));
      class w {
        get ['raw'] () {
          return this['_raw'];
        }
        set ['raw'] (Y) {
          this['_raw'] = Y;
        }
        get ['maxMin'] () {
          return this['_maxMin'] || (this['_maxMin'] = (0x0,
            p['pj'])(this)),
            this['_maxMin'];
        }
        constructor(Y, T, X, E, f, W = 0x0, I = 0x1, j = 0x0, D = true) {
          this['dataType'] = Y,
            this['xSize'] = T,
            this['ySize'] = X,
            this['algo'] = W,
            this['dataScale'] = I,
            this['dataOffset'] = j,
            this['_useAccurateUndef'] = true,
            this['setTypeLen'](),
            E ? this['setRaw'](E) : D && this['setRaw'](T * X),
            this['undef'] = f,
            this['setReadAndWriteFunc']();
        }
        ['setReadAndWriteFunc'] () {
          switch (this['algo']) {
            case undefined:
            case null:
            case 0x0:
              this['readFunc'] = Y => Y,
                this['writeFunc'] = Y => Y;
              break;
            case 0x1:
              this['readFunc'] = Y => Y * this['dataScale'] + this['dataOffset'],
                this['writeFunc'] = Y => (Y - this['dataOffset']) / this['dataScale'];
              break;
            case 0x2:
              this['readFunc'] = Y => (Y + this['dataOffset']) * this['dataScale'],
                this['writeFunc'] = Y => Y / this['dataScale'] - this['dataOffset'];
              break;
            default:
              throw new Error('不支持的算法类型！');
          }
        }
        get ['undef'] () {
          return this['_undef'];
        }
        get ['useAccurateUndef'] () {
          return this['_useAccurateUndef'];
        }
        set ['useAccurateUndef'] (Y) {
          this['_useAccurateUndef'] !== Y && (this['_useAccurateUndef'] = Y,
            this['setUndefFunc'](this['_undef']));
        }
        set ['undef'] (Y) {
          this['_undef'] = Y,
            this['setUndefFunc'](Y);
        }
        ['getBuffer'] () {
          return this['raw']['buffer'];
        }
        ['setUndefFunc'] (Y) {
          this['useAccurateUndef'] ? this['isUndef'] = T => T === Y : this['isUndef'] = undefined === Y ? () => false : Y > 0x0 ? T => T >= Y : T => T <= Y;
        }
        ['setRaw'] (Y) {
          const T = this['xSize'] * this['ySize'];
          if (Y instanceof ArrayBuffer) {
            let X;
            const E = y(T * this['typeLen']);
            switch (this['dataType']) {
              case F['U']['UInt8']:
                X = new Uint8Array(Y),
                  this['raw'] = new Uint8Array(E);
                break;
              case F['U']['Int8']:
                X = new Int8Array(Y),
                  this['raw'] = new Int8Array(E);
                break;
              case F['U']['UInt16']:
                X = new Uint16Array(Y),
                  this['raw'] = new Uint16Array(E);
                break;
              case F['U']['Int16']:
                this['raw'] = new Int16Array(E),
                  X = new Int16Array(Y);
                break;
              case F['U']['UInt32']:
                X = new Uint32Array(Y),
                  this['raw'] = new Uint32Array(E);
                break;
              case F['U']['Int32']:
                X = new Int32Array(Y),
                  this['raw'] = new Int32Array(E);
                break;
              case F['U']['Float32']:
                X = new Float32Array(Y),
                  this['raw'] = new Float32Array(E);
                break;
              case F['U']['Float64']:
                X = new Float64Array(Y),
                  this['raw'] = new Float64Array(E);
                break;
              default:
                throw new Error('not\x20supported\x20grid\x20data\x20type\x20' + this['dataType']);
            }
            this['raw']['set'](X),
              X = undefined;
          } else {
            const f = y(T * this['typeLen']);
            this['raw'] = (0x0,
              p['cM'])(this['dataType'], f),
              Y && Y['length'] && (Y[0x0] instanceof Array && (Y = (0x0,
                p['LG'])(Y)),
                this['raw']['set'](Y));
          }
        }
        ['setTypeLen'] () {
          switch (this['dataType']) {
            case F['U']['UInt8']:
            case F['U']['Int8']:
              this['typeLen'] = 0x1;
              break;
            case F['U']['UInt16']:
            case F['U']['Int16']:
              this['typeLen'] = 0x2;
              break;
            case F['U']['Float64']:
              this['typeLen'] = 0x8;
              break;
            default:
              this['typeLen'] = 0x4;
          }
        }
        ['write1D'] (Y, T) {
          return this['isUndef'](T) || (T = this['writeFunc'](T)),
            this['raw'][Y] = T,
            this;
        }
        ['read1D'] (Y) {
          let T = this['raw'][Y];
          return this['isUndef'](T) ? T : this['readFunc'](T);
        }
        ['write2D'] (Y, T, X) {
          let E = this['getPos'](Y, T);
          return this['write1D'](E, X);
        }
        ['read2D'] (Y, T) {
          let X = this['getPos'](Y, T);
          return this['read1D'](X);
        }
        ['toNumberArr'] (Y = false) {
          let T = [];
          return Y ? this['forEachYx']((X, E, f) => {
            let W = (this['ySize'] - E - 0x1) * this['xSize'] + f;
            T[W] = X;
          }
          ) : this['forEachRealValue'](X => {
            T['push'](X);
          }
          ),
            T;
        }
        ['forEach'] (Y) {
          for (let T = 0x0; T < this['raw']['length']; T++)
            Y(this['raw'][T], T, this['raw']);
        }
        ['forEachRealValue'] (Y) {
          for (let T = 0x0; T < this['raw']['length']; T++)
            Y(this['read1D'](T), T, this['raw']);
        }
        ['forEachYx'] (Y) {
          for (let T = 0x0; T < this['ySize']; T++)
            for (let X = 0x0; X < this['xSize']; X++)
              Y(this['read2D'](T, X), T, X);
        }
        ['getYxArr'] () {
          let Y = [];
          for (let T = 0x0; T < this['ySize']; T++) {
            Y[T] = [];
            for (let X = 0x0; X < this['xSize']; X++)
              Y[T][X] = this['read2D'](T, X);
          }
          return Y;
        }
        ['update'] (Y) {
          Y instanceof Array && Y[0x0] instanceof Array && (Y = (0x0,
            p['LG'])(Y)),
            this['setRaw'](Y);
        }
        ['getPos'] (Y, T) {
          return Y * this['xSize'] + T;
        }
        ['flipY'] (Y = true) {
          let T = this['raw'];
          const X = this['raw'];
          if (Y) {
            const f = y(this['ySize'] * this['xSize'] * this['typeLen']);
            T = (0x0,
              p['cM'])(this['dataType'], f);
          } else
            this['setRaw'](undefined),
              T = this['raw'];
          let E = 0x0;
          for (let W = 0x0; W < this['ySize']; W++) {
            const I = (this['ySize'] - W - 0x1) * this['xSize'];
            T['set'](X['slice'](I, I + this['xSize']), E),
              E += this['xSize'];
          }
          return T;
        }
        ['updateMaxMin'] (Y = false) {
          return this['_maxMin'] && !Y ? this['_maxMin'] : (this['_maxMin'] = undefined,
            this['maxMin']);
        }
      }
      class h extends w {
        constructor(Y, T, X, E, f = false, W = 0x0, I = 0x1, j = 0x0, D = F['U']['UInt8']) {
          super(D, Y, T, undefined, E, W, I, j, false),
            this['xSize'] = Y,
            this['ySize'] = T,
            this['autoLoad'] = f,
            this['algo'] = W,
            this['dataScale'] = I,
            this['dataOffset'] = j,
            this['dataType'] = D,
            this['_decoded'] = false,
            this['imageSource'] = X;
        }
        get ['raw'] () {
          return this['_decoded'] || (this['autoLoad'] ? this['loadImageSource']() : H['kg']['error']('尚未解码该数据！')),
            this['_raw'];
        }
        ['loadImageSource'] () {
          if (this['_decoded'])
            return;
          const Y = performance['now']()
            , T = this['imageSource']
            , X = document['createElement']('canvas');
          let E, f;
          X['width'] = this['xSize'],
            X['height'] = this['ySize'],
            T instanceof HTMLVideoElement ? (E = T['videoWidth'],
              f = T['videoHeight']) : (E = T['width'],
                f = T['height']),
            this['xSize'] !== E && console['warn']('给定的xSize与图片宽度不一致：grid\x20x\x20' + this['xSize'] + ',img\x20width\x20' + E),
            this['ySize'] !== f && console['warn']('给定的ySize与图片高度不一致：grid\x20y\x20' + this['ySize'] + ',img\x20height\x20' + f);
          const W = X['getContext']('2d');
          W['drawImage'](T, 0x0, 0x0, E, f, 0x0, 0x0, this['xSize'], this['ySize']);
          const I = W['getImageData'](0x0, 0x0, X['width'], X['height'])['data'];
          let j;
          if (this['dataType'] === F['U']['UInt8']) {
            j = new Uint8Array(X['width'] * X['height']);
            let D = 0x0;
            for (let V = 0x0; V < I['length']; V += 0x4)
              j[D] = I[V],
                D++;
          } else {
            if (this['dataType'] === F['U']['Float32'])
              j = new Float32Array(I['buffer']);
            else {
              if (this['dataType'] === F['U']['UInt16']) {
                let Z = 0x0;
                j = new Uint16Array(X['width'] * X['height']);
                for (let B = 0x0; B < I['length']; B += 0x4)
                  j[Z++] = 0xff * I[B] + I[B + 0x1];
              } else
                H['kg']['error']('不支持的类型！');
            }
          }
          return this['_raw'] = j,
            this['_decoded'] = true,
            h['ReplaceImageAfterDecode'] && (this['imageSource'] = X),
            H['kg']['debug']('decode\x20grid\x20data\x20costs\x20' + (performance['now']() - Y) + 'ms'),
            X;
        }
      }
      h['ReplaceImageAfterDecode'] = false;
    }
    ,
    0x35a: (K, H, F) => {
      'use strict';
      F['d'](H, {
        '$n': () => G,
        'IW': () => v6,
        'Lh': () => T,
        'Rd': () => v2,
        'S2': () => v8,
        'SR': () => v4,
        'Xm': () => N,
        'Yv': () => v7,
        '_E': () => v1,
        'ce': () => v3,
        'hM': () => z,
        'lj': () => v0,
        'm3': () => J,
        'm_': () => Q,
        'sC': () => L,
        'sW': () => Y,
        'uI': () => M,
        'vS': () => X,
        'we': () => v5
      });
      var Y, T, X, W = F(0x39b), j = F(0x1), D = F(0x19d), V = F(0x219), Z = F(0x1de), B = F(0x260), U = F(0x133);
      function q (v9) {
        return new B['NB']({
          'stops': [{
            'value': 0x0,
            'stop': v9
          }],
          'fieldName': '0'
        });
      }
      function J (v9) {
        let vv = (0x0,
          U['it'])(v9);
        return 'string' == typeof vv && (vv = parseFloat(vv),
          undefined === vv && W['kg']['error']('提供了非数值属性' + vv + '！')),
          'number' == typeof vv ? q(vv) : vv instanceof B['NB'] ? vv : 'object' == typeof vv && vv['stops'] ? new B['NB'](vv, vA => (vA['stop'] = parseFloat(vA['stop']),
            vA)) : void W['kg']['error']('数字字段不支持当前类型：' + typeof vv);
      }
      class G extends V['W6'] {
        ['_createCacheId'] (v9) {
          return '0';
        }
      }
      class N extends G {
        constructor(v9) {
          super(v9),
            (0x0,
              j['ri'])(v9['colorScale']) || W['kg']['error']('BitmapColorScale中的colorScale未配置！'),
            this['_update'](v9, true);
        }
        ['_update'] (v9, vv) {
          this['min'] = (0x0,
            j['Rf'])(v9['min'], this['min']),
            this['max'] = (0x0,
              j['Rf'])(v9['max'], this['max']),
            this['colorScale'] = (0x0,
              j['Rf'])(v9['colorScale'], this['colorScale'], v2);
        }
        static ['createColorScale'] (v9, vv, vA, vn, vk = 0x1) {
          const vl = document['createElement']('canvas');
          if (vl['width'] = v9,
            vl['height'] = vk || 0x1,
            !vn) {
            vn = [];
            const vi = 0x1 / vA['length'];
            vi >= 0x1 && W['kg']['error']('提供的颜色数量超出了图像宽度，无法生成色例！'),
              vA['forEach']((vb, ve) => {
                vn['push'](vi * (ve + 0x1));
              }
              );
          }
          const vK = vl['getContext']('2d');
          if (vv) {
            const vb = vK['createLinearGradient'](0x0, 0x0, v9, 0x0);
            for (let ve = 0x0; ve < vA['length']; ve++) {
              const vc = M(vA[ve])
                , vH = vn[ve];
              vb['addColorStop'](vH, vc['rgbaString']());
            }
            vK['fillStyle'] = vb,
              vK['fillRect'](0x0, 0x0, v9, vk);
          } else {
            let vt = 0x0;
            for (let vx = 0x0; vx < vA['length']; vx++) {
              const vp = M(vA[vx])
                , vF = vn[vx];
              vK['fillStyle'] = vp['rgbaString']();
              let vy = parseInt((vF * v9)['toFixed'](0x1));
              0x0 === vy && (vy = 0x1),
                vK['fillRect'](vt, 0x0, vy - vt, vk),
                vt = vy;
            }
          }
          return vl;
        }
        static ['create'] (v9, vv, vA, vn, vk, vl, vK = 0x1) {
          return new N({
            'min': v9,
            'max': vv,
            'colorScale': N['createColorScale'](vA, vn, vk, vl, vK)
          });
        }
        static ['createFromStopRules'] (v9, vv, vA, vn, vk, vl = 0x1) {
          vk <= 0x0 && (vk = v9['stops']['length'] + vk - 0x1);
          const vK = v9['stops'][vn]['value']
            , vi = v9['stops'][vk]['value']
            , vb = vi - vK
            , ve = []
            , vc = [];
          for (let vH = vn; vH <= vk; vH++) {
            const vt = v9['stops'][vH]
              , vx = vt['stop']
              , vp = (vt['value'] - vK) / vb;
            ve['push'](vx),
              vc['push'](vp);
          }
          return N['create'](vK, vi, vv, vA, ve, vc, vl);
        }
        static ['copyFromStopRules'] (v9, vv, vA, vn, vk, vl, vK, vi, vb, ve = 0x1) {
          vK <= 0x0 && (vK = v9['stops']['length'] + vK - 0x1);
          const vc = vi ? vA - vv : vK - vl
            , vH = []
            , vt = [];
          for (let vx = vl; vx <= vK; vx++) {
            const vp = v9['stops'][vx]
              , vF = vp['stop']
              , vy = vi ? (vp['value'] - vv) / vc : vx / vc;
            vH['push'](vF),
              vt['push'](vy);
          }
          return N['create'](vv, vA, vn, vk, vH, vb || vt, ve);
        }
      }
      function M (v9) {
        const vv = (0x0,
          U['it'])(v9);
        return 'string' == typeof vv ? (0x0,
          U['$P'])(vv) : 'number' == typeof vv ? (0x0,
            U['lW'])(vv) : vv instanceof Z['t'] ? vv : vv instanceof Array ? (0x0,
              U['LH'])(vv) : 'object' != typeof vv || undefined === vv['r'] && undefined === vv['red'] ? void W['kg']['error']('颜色字段不支持当前类型：' + typeof vv) : new Z['t'](vv);
      }
      function z (v9) {
        const vv = M(v9);
        return null == vv ? undefined : vv['glNumberArray']();
      }
      function Q (v9) {
        const vv = (0x0,
          U['it'])(v9);
        return 'string' == typeof vv ? q((0x0,
          U['$P'])(vv)) : 'number' == typeof vv ? q((0x0,
            U['lW'])(vv)) : vv instanceof Z['t'] ? q(vv) : vv instanceof Array ? q((0x0,
              U['LH'])(vv)) : 'object' != typeof vv || undefined === vv['r'] && undefined === vv['red'] ? v9 instanceof B['NB'] ? v9 : 'object' == typeof vv && vv['stops'] ? new B['NB'](vv, U['$k']) : void W['kg']['error']('颜色字段不支持当前类型：' + typeof vv) : q(new Z['t'](vv));
      }
      function L (v9) {
        const vv = (0x0,
          U['it'])(v9);
        return vv instanceof N ? vv : vv['colorScale'] ? new N(vv) : void W['kg']['error']('不能识别的GL色例配置！');
      }
      function R (v9) {
        if ('number' == typeof v9)
          return v9 > 0x4 && W['kg']['error']('不能识别的格点数据填色类型：' + v9),
            v9;
        if ('string' == typeof v9) {
          switch (v9['toLowerCase']()) {
            case 'shaded1':
              return Y['shaded1'];
            case 'pixel2':
              return Y['pixel2'];
            case 'bitmap':
              return Y['bitmap'];
            case 'none':
              return Y['none'];
            case 'shaded2':
              return Y['shaded2'];
          }
          return Y['pixel1'];
        }
        W['kg']['error']('不能识别的格点数据填色类型：' + v9);
      }
      !function (v9) {
        v9[v9['none'] = -0x1] = 'none',
          v9[v9['bitmap'] = 0x0] = 'bitmap',
          v9[v9['pixel1'] = 0x1] = 'pixel1',
          v9[v9['pixel2'] = 0x2] = 'pixel2',
          v9[v9['shaded1'] = 0x4] = 'shaded1',
          v9[v9['shaded2'] = 0x3] = 'shaded2';
      }(Y || (Y = {}));
      class v0 extends G {
        constructor(v9) {
          super(v9),
            v9['fillColor'] || v9['colorScale'] || W['kg']['error']('填色图层中fillColor和colorScale需要设置一个！'),
            this['_update'](v9, true);
        }
        ['getPlaneOptions'] (v9, vv) {
          return super['getPlaneOptions'](v9, false);
        }
        ['_update'] (v9, vv) {
          vv ? (this['pixelRatio'] = (0x0,
            j['En'])(v9['pixelRatio'], v0['DefaultOptions']['pixelRatio']),
            this['fillMode'] = R((0x0,
              j['En'])(v9['fillMode'], v0['DefaultOptions']['fillMode'])),
            this['lineWidth'] = (0x0,
              j['En'])(v9['lineWidth'], v0['DefaultOptions']['lineWidth']),
            this['fillModeForLine'] = R((0x0,
              j['En'])(v9['fillModeForLine'], v1['DefaultOptions']['fillModeForLine'])),
            this['globalOpacity'] = (0x0,
              j['En'])(v9['globalOpacity'], v0['DefaultOptions']['globalOpacity']),
            this['optimizedInterp'] = (0x0,
              j['En'])(v9['optimizedInterp'], v0['DefaultOptions']['optimizedInterp'])) : (this['pixelRatio'] = (0x0,
                j['Rf'])(v9['pixelRatio'], this['pixelRatio']),
                this['fillMode'] = (0x0,
                  j['Rf'])(v9['fillMode'], this['fillMode'], R),
                this['lineWidth'] = (0x0,
                  j['Rf'])(v9['lineWidth'], this['lineWidth']),
                this['fillModeForLine'] = (0x0,
                  j['Rf'])(v9['fillModeForLine'], this['fillModeForLine'], R),
                this['globalOpacity'] = (0x0,
                  j['Rf'])(v9['globalOpacity'], this['globalOpacity']),
                this['optimizedInterp'] = (0x0,
                  j['Rf'])(v9['optimizedInterp'], this['optimizedInterp'])),
            this['fillColor'] = (0x0,
              j['Rf'])(v9['fillColor'], this['fillColor'], Q),
            this['lineColor'] = (0x0,
              j['Rf'])(v9['lineColor'], this['lineColor'], z),
            this['showLine'] = (0x0,
              j['Rf'])(v9['showLine'], this['showLine']),
            this['colorScale'] = (0x0,
              j['Rf'])(v9['colorScale'], this['colorScale'], L),
            this['showRelief'] = (0x0,
              j['Rf'])(v9['showRelief'], this['showRelief']),
            v9['maskLineStyle'] && (this['maskLineStyle'] && !vv ? this['maskLineStyle']['update'](v9['maskLineStyle']) : this['maskLineStyle'] = new D['Xx'](v9['maskLineStyle']));
        }
      }
      v0['DefaultOptions'] = {
        'pixelRatio': 0.3,
        'fillMode': Y['pixel1'],
        'lineWidth': 1.5,
        'fillColor': undefined,
        'fillModeForLine': Y['shaded1'],
        'globalOpacity': 0x1,
        'optimizedInterp': true
      };
      class v1 extends v0 {
        constructor(v9) {
          super(v9);
        }
        ['_update'] (v9, vv) {
          super['_update'](v9, vv),
            vv ? (this['flat'] = (0x0,
              j['En'])(v9['flat'], v1['DefaultOptions']['flat']),
              this['diffuse'] = M((0x0,
                j['En'])(v9['diffuse'], v1['DefaultOptions']['diffuse'])),
              this['emission'] = M((0x0,
                j['En'])(v9['emission'], v1['DefaultOptions']['emission'])),
              this['specular'] = (0x0,
                j['En'])(v9['specular'], v1['DefaultOptions']['specular']),
              this['shininess'] = (0x0,
                j['En'])(v9['shininess'], v1['DefaultOptions']['shininess']),
              this['extrudeScale'] = (0x0,
                j['En'])(v9['extrudeScale'], v1['DefaultOptions']['extrudeScale']),
              this['extrudeOffset'] = (0x0,
                j['En'])(v9['extrudeOffset'], v1['DefaultOptions']['extrudeOffset']),
              this['zScale'] = (0x0,
                j['En'])(v9['zScale'], v1['DefaultOptions']['zScale']),
              this['noHeight'] = (0x0,
                j['En'])(v9['noHeight'], v1['DefaultOptions']['noHeight']),
              this['depthTest'] = (0x0,
                j['En'])(v9['depthTest'], v1['DefaultOptions']['depthTest']),
              this['opaque'] = (0x0,
                j['En'])(v9['opaque'], v1['DefaultOptions']['opaque']),
              this['height'] = (0x0,
                j['En'])(v9['height'], v1['DefaultOptions']['height']),
              this['discardColor'] = z((0x0,
                j['En'])(v9['discardColor'], v1['DefaultOptions']['discardColor']))) : (this['flat'] = (0x0,
                  j['Rf'])(v9['flat'], this['flat']),
                  this['diffuse'] = (0x0,
                    j['Rf'])(v9['diffuse'], this['diffuse'], M),
                  this['emission'] = (0x0,
                    j['Rf'])(v9['emission'], this['emission'], M),
                  this['specular'] = (0x0,
                    j['Rf'])(v9['specular'], this['specular']),
                  this['shininess'] = (0x0,
                    j['Rf'])(v9['shininess'], this['shininess']),
                  this['extrudeScale'] = (0x0,
                    j['Rf'])(v9['extrudeScale'], this['extrudeScale']),
                  this['extrudeOffset'] = (0x0,
                    j['Rf'])(v9['extrudeOffset'], this['extrudeOffset']),
                  this['zScale'] = (0x0,
                    j['Rf'])(v9['zScale'], this['zScale']),
                  this['noHeight'] = (0x0,
                    j['Rf'])(v9['noHeight'], this['noHeight']),
                  this['depthTest'] = (0x0,
                    j['Rf'])(v9['depthTest'], this['depthTest']),
                  this['opaque'] = (0x0,
                    j['Rf'])(v9['opaque'], this['opaque']),
                  this['height'] = (0x0,
                    j['Rf'])(v9['height'], this['height']),
                  this['discardColor'] = (0x0,
                    j['Rf'])(v9['discardColor'], this['discardColor'], z));
        }
      }
      function v2 (v9) {
        if ('string' == typeof v9 && !v9['length'] || !(0x0,
          j['ri'])(v9))
          return;
        const vv = (0x0,
          U['it'])(v9);
        if (vv instanceof HTMLImageElement || vv instanceof HTMLVideoElement || vv instanceof HTMLCanvasElement)
          return vv;
        W['kg']['error']('图像字段不支持当前类型：' + typeof vv);
      }
      function v3 (v9) {
        const vv = (0x0,
          U['it'])(v9);
        return vv instanceof Array ? vv : 'number' == typeof vv || 'string' == typeof vv ? [vv] : void W['kg']['error']('数值数组字段不支持当前类型：' + typeof vv);
      }
      v1['DefaultOptions'] = Object['assign'](Object['assign']({}, v0['DefaultOptions']), {
        'extrudeScale': 0x1,
        'extrudeOffset': 0x0,
        'zScale': 0x1,
        'noHeight': false,
        'depthTest': true,
        'opaque': false,
        'height': 0x0,
        'discardColor': [0xff, 0xff, 0xff, 0x0],
        'flat': true,
        'diffuse': [0x0, 0x0, 0x0],
        'emission': [0x0, 0x0, 0x0],
        'specular': 0.2,
        'shininess': 0x5
      }),
        function (v9) {
          v9[v9['none'] = 0x0] = 'none',
            v9[v9['fast'] = 0x1] = 'fast',
            v9[v9['smooth'] = 0x2] = 'smooth';
        }(T || (T = {}));
      class v4 extends G {
        constructor(v9) {
          super(v9),
            this['_update'](v9, true);
        }
        ['_update'] (v9, vv) {
          vv ? (this['color'] = Q((0x0,
            j['En'])(v9['color'], v4['DefaultOptions']['color'])),
            this['dropRate'] = (0x0,
              j['En'])(v9['dropRate'], v4['DefaultOptions']['dropRate']),
            this['fadeRate'] = (0x0,
              j['En'])(v9['fadeRate'], v4['DefaultOptions']['fadeRate']),
            this['speedFactor'] = (0x0,
              j['En'])(v9['speedFactor'], v4['DefaultOptions']['speedFactor']),
            this['usePoint'] = (0x0,
              j['En'])(v9['usePoint'], v4['DefaultOptions']['usePoint']),
            this['minOpacity'] = (0x0,
              j['En'])(v9['minOpacity'], v4['DefaultOptions']['minOpacity']),
            this['pointSize'] = (0x0,
              j['En'])(v9['pointSize'], v4['DefaultOptions']['pointSize']),
            this['minSpeed'] = (0x0,
              j['En'])(v9['minSpeed'], v4['DefaultOptions']['minSpeed']),
            this['fadeSpeedMax'] = (0x0,
              j['En'])(v9['fadeSpeedMax'], v4['DefaultOptions']['fadeSpeedMax']),
            this['speedFitZoom'] = (0x0,
              j['En'])(v9['speedFitZoom'], v4['DefaultOptions']['speedFitZoom']),
            this['countFitZoom'] = (0x0,
              j['En'])(v9['countFitZoom'], v4['DefaultOptions']['countFitZoom']),
            this['interpMethod'] = (0x0,
              j['En'])(v9['interpMethod'], v4['DefaultOptions']['interpMethod']),
            this['interpSmoothFactor'] = (0x0,
              j['En'])(v9['interpSmoothFactor'], v4['DefaultOptions']['interpSmoothFactor']),
            this['pointDropPosY'] = (0x0,
              j['En'])(v9['pointDropPosY'], v4['DefaultOptions']['pointDropPosY']),
            this['count'] = (0x0,
              j['En'])(v9['count'], v4['DefaultOptions']['count']),
            this['lineMaxDistance'] = (0x0,
              j['En'])(v9['lineMaxDistance'], v4['DefaultOptions']['lineMaxDistance']),
            this['showPixel'] = (0x0,
              j['En'])(v9['showPixel'], v4['DefaultOptions']['showPixel']),
            this['pixelOptions'] = (0x0,
              j['En'])(v9['pixelOptions'], v4['DefaultOptions']['pixelOptions'])) : (this['color'] = (0x0,
                j['Rf'])(v9['color'], this['color'], Q),
                this['dropRate'] = (0x0,
                  j['Rf'])(v9['dropRate'], this['dropRate']),
                this['fadeRate'] = (0x0,
                  j['Rf'])(v9['fadeRate'], this['fadeRate']),
                this['speedFactor'] = (0x0,
                  j['Rf'])(v9['speedFactor'], this['speedFactor']),
                this['usePoint'] = (0x0,
                  j['Rf'])(v9['usePoint'], this['usePoint']),
                this['minOpacity'] = (0x0,
                  j['Rf'])(v9['minOpacity'], this['minOpacity']),
                this['pointSize'] = (0x0,
                  j['Rf'])(v9['pointSize'], this['pointSize']),
                this['minSpeed'] = (0x0,
                  j['Rf'])(v9['minSpeed'], this['minSpeed']),
                this['fadeSpeedMax'] = (0x0,
                  j['Rf'])(v9['fadeSpeedMax'], this['fadeSpeedMax']),
                this['speedFitZoom'] = (0x0,
                  j['Rf'])(v9['speedFitZoom'], this['speedFitZoom']),
                this['countFitZoom'] = (0x0,
                  j['Rf'])(v9['countFitZoom'], this['countFitZoom']),
                this['interpMethod'] = (0x0,
                  j['Rf'])(v9['interpMethod'], this['interpMethod']),
                this['interpSmoothFactor'] = (0x0,
                  j['Rf'])(v9['interpSmoothFactor'], this['interpSmoothFactor']),
                this['pointDropPosY'] = (0x0,
                  j['Rf'])(v9['pointDropPosY'], this['pointDropPosY']),
                this['count'] = (0x0,
                  j['Rf'])(v9['count'], this['count']),
                this['lineMaxDistance'] = (0x0,
                  j['Rf'])(v9['lineMaxDistance'], this['lineMaxDistance']),
                this['showPixel'] = (0x0,
                  j['Rf'])(v9['showPixel'], this['showPixel']),
                this['pixelOptions'] = (0x0,
                  j['Rf'])(v9['pixelOptions'], this['pixelOptions'])),
            this['texture'] = (0x0,
              j['Rf'])(v9['texture'], this['texture'], v2),
            this['mixColor'] = (0x0,
              j['Rf'])(v9['mixColor'], this['mixColor']),
            this['fadeWithSpeed'] = (0x0,
              j['Rf'])(v9['fadeWithSpeed'], this['fadeWithSpeed']),
            this['particleRegion'] = (0x0,
              j['Rf'])(v9['particleRegion'], this['particleRegion']);
        }
      }
      v4['DefaultOptions'] = {
        'color': Z['m']['beige'],
        'dropRate': 0.003,
        'fadeRate': 0.996,
        'speedFactor': 0x1,
        'usePoint': true,
        'minOpacity': 0.5,
        'pointSize': 0x1,
        'minSpeed': 0x0,
        'fadeSpeedMax': 0x14,
        'speedFitZoom': true,
        'countFitZoom': true,
        'interpMethod': T['fast'],
        'interpSmoothFactor': 0.8,
        'pointDropPosY': 0x1,
        'count': 0x40,
        'lineMaxDistance': 0xa,
        'showPixel': false,
        'pixelOptions': {
          'fillColor': 'white'
        }
      };
      class v5 extends v4 {
        constructor(v9) {
          super(v9);
        }
        ['_update'] (v9, vv) {
          super['_update'](v9, vv),
            vv ? (this['zScale'] = (0x0,
              j['En'])(v9['zScale'], v5['DefaultOptions']['zScale']),
              this['zIndex'] = (0x0,
                j['En'])(v9['zIndex'], v5['DefaultOptions']['zIndex']),
              this['hgtOffset'] = (0x0,
                j['En'])(v9['hgtOffset'], v5['DefaultOptions']['hgtOffset']),
              this['zSpeedFactor'] = (0x0,
                j['En'])(v9['zSpeedFactor'], v5['DefaultOptions']['zSpeedFactor']),
              this['onlyZ'] = (0x0,
                j['En'])(v9['onlyZ'], v5['DefaultOptions']['onlyZ']),
              this['colorWith'] = (0x0,
                j['En'])(v9['colorWith'], v5['DefaultOptions']['colorWith'])) : (this['zScale'] = (0x0,
                  j['Rf'])(v9['zScale'], this['zScale']),
                  this['zIndex'] = (0x0,
                    j['Rf'])(v9['zIndex'], this['zIndex']),
                  this['hgtOffset'] = (0x0,
                    j['Rf'])(v9['hgtOffset'], this['hgtOffset']),
                  this['zSpeedFactor'] = (0x0,
                    j['Rf'])(v9['zSpeedFactor'], this['zSpeedFactor']),
                  this['onlyZ'] = (0x0,
                    j['Rf'])(v9['onlyZ'], this['onlyZ']),
                  this['colorWith'] = (0x0,
                    j['Rf'])(v9['colorWith'], this['colorWith']));
        }
      }
      v5['DefaultOptions'] = Object['assign'](Object['assign']({}, v4['DefaultOptions']), {
        'zScale': 0x1,
        'zIndex': 0x0,
        'hgtOffset': 0x0,
        'zSpeedFactor': 0x1,
        'onlyZ': false,
        'colorWith': 'uv'
      });
      class v6 extends G {
        constructor(v9) {
          super(v9),
            v9['color'] || W['kg']['error']('体渲染需要提供颜色！'),
            this['_update'](v9, true);
        }
        ['_update'] (v9, vv) {
          vv ? (this['color'] = Q(v9['color']),
            this['zScale'] = (0x0,
              j['En'])(v9['zScale'], v6['DefaultOptions']['zScale']),
            this['samplingRate'] = (0x0,
              j['En'])(v9['samplingRate'], v6['DefaultOptions']['samplingRate']),
            this['opaque'] = (0x0,
              j['En'])(v9['opaque'], v6['DefaultOptions']['opaque'])) : (this['color'] = (0x0,
                j['Rf'])(v9['color'], this['color'], Q),
                this['zScale'] = (0x0,
                  j['Rf'])(v9['zScale'], this['zScale']),
                this['samplingRate'] = (0x0,
                  j['Rf'])(v9['samplingRate'], v6['DefaultOptions']['samplingRate']),
                this['opaque'] = (0x0,
                  j['Rf'])(v9['opaque'], this['opaque'])),
            this['visibleExtent'] = (0x0,
              j['Rf'])(v9['visibleExtent'], this['visibleExtent']);
        }
      }
      v6['DefaultOptions'] = {
        'color': undefined,
        'zScale': 0x1,
        'samplingRate': 0x1,
        'opaque': false
      },
        function (v9) {
          v9[v9['none'] = 0x0] = 'none',
            v9[v9['rect'] = 0x1] = 'rect',
            v9[v9['tilt'] = 0x2] = 'tilt';
        }(X || (X = {}));
      class v7 extends G {
        constructor(v9) {
          super(v9),
            v9['fillColor'] || v9['colorScale'] || W['kg']['error']('填色图层中fillColor和colorScale需要设置一个！'),
            this['_update'](v9, true);
        }
        ['_update'] (v9, vv) {
          vv ? (this['flat'] = (0x0,
            j['En'])(v9['flat'], v7['DefaultOptions']['flat']),
            this['diffuse'] = M((0x0,
              j['En'])(v9['diffuse'], v7['DefaultOptions']['diffuse'])),
            this['emission'] = M((0x0,
              j['En'])(v9['emission'], v7['DefaultOptions']['emission'])),
            this['globalOpacity'] = (0x0,
              j['En'])(v9['globalOpacity'], v7['DefaultOptions']['globalOpacity']),
            this['specular'] = (0x0,
              j['En'])(v9['specular'], v7['DefaultOptions']['specular']),
            this['shininess'] = (0x0,
              j['En'])(v9['shininess'], v7['DefaultOptions']['shininess']),
            this['fillMode'] = R((0x0,
              j['En'])(v9['fillMode'], v7['DefaultOptions']['fillMode'])),
            this['opaque'] = (0x0,
              j['En'])(v9['opaque'], v7['DefaultOptions']['opaque']),
            this['zScale'] = (0x0,
              j['En'])(v9['zScale'], v7['DefaultOptions']['zScale']),
            this['depthTest'] = (0x0,
              j['En'])(v9['depthTest'], v7['DefaultOptions']['depthTest']),
            this['sectionMode'] = (0x0,
              j['En'])(v9['sectionMode'], v7['DefaultOptions']['sectionMode'])) : (this['flat'] = (0x0,
                j['Rf'])(v9['flat'], this['flat']),
                this['diffuse'] = (0x0,
                  j['Rf'])(v9['diffuse'], this['diffuse'], M),
                this['emission'] = (0x0,
                  j['Rf'])(v9['emission'], this['emission'], M),
                this['globalOpacity'] = (0x0,
                  j['Rf'])(v9['globalOpacity'], this['globalOpacity']),
                this['specular'] = (0x0,
                  j['Rf'])(v9['specular'], this['specular']),
                this['shininess'] = (0x0,
                  j['Rf'])(v9['shininess'], this['shininess']),
                this['fillMode'] = (0x0,
                  j['Rf'])(v9['fillMode'], this['fillMode'], R),
                this['opaque'] = (0x0,
                  j['Rf'])(v9['opaque'], this['opaque']),
                this['zScale'] = (0x0,
                  j['Rf'])(v9['zScale'], this['zScale']),
                this['depthTest'] = (0x0,
                  j['Rf'])(v9['depthTest'], this['depthTest']),
                this['sectionMode'] = (0x0,
                  j['Rf'])(v9['sectionMode'], this['sectionMode'])),
            this['fillColor'] = (0x0,
              j['Rf'])(v9['fillColor'], this['fillColor'], Q),
            this['colorScale'] = (0x0,
              j['Rf'])(v9['colorScale'], this['colorScale'], L),
            this['section'] = (0x0,
              j['Rf'])(v9['section'], this['section']);
        }
      }
      v7['DefaultOptions'] = {
        'flat': false,
        'diffuse': [0x0, 0x0, 0x0],
        'emission': [0x0, 0x0, 0x0],
        'globalOpacity': 0x1,
        'specular': 0x0,
        'shininess': 0x1,
        'fillMode': Y['pixel1'],
        'opaque': true,
        'zScale': 0x1,
        'depthTest': true,
        'sectionMode': X['none']
      };
      class v8 extends v7 {
        constructor(v9) {
          super(v9);
        }
        ['_update'] (v9, vv) {
          super['_update'](v9, vv),
            vv ? (this['baseSpeed'] = (0x0,
              j['En'])(v9['baseSpeed'], v8['DefaultOptions']['baseSpeed']),
              this['headRadius'] = (0x0,
                j['En'])(v9['headRadius'], v8['DefaultOptions']['headRadius']),
              this['headLength'] = (0x0,
                j['En'])(v9['headLength'], v8['DefaultOptions']['headLength']),
              this['headSegments'] = (0x0,
                j['En'])(v9['headSegments'], v8['DefaultOptions']['headSegments']),
              this['bodyTopRadius'] = (0x0,
                j['En'])(v9['bodyTopRadius'], v8['DefaultOptions']['bodyTopRadius']),
              this['bodyBottomRadius'] = (0x0,
                j['En'])(v9['bodyBottomRadius'], v8['DefaultOptions']['bodyBottomRadius']),
              this['bodyLength'] = (0x0,
                j['En'])(v9['bodyLength'], v8['DefaultOptions']['bodyLength']),
              this['bodySegments'] = (0x0,
                j['En'])(v9['bodySegments'], v8['DefaultOptions']['bodySegments']),
              this['shapeNeedsUpdate'] = (0x0,
                j['En'])(v9['shapeNeedsUpdate'], v8['DefaultOptions']['shapeNeedsUpdate']),
              this['maxCount'] = (0x0,
                j['En'])(v9['maxCount'], v8['DefaultOptions']['maxCount']),
              this['shapeScale'] = (0x0,
                j['En'])(v9['shapeScale'], v8['DefaultOptions']['shapeScale']),
              this['verticalDataScale'] = (0x0,
                j['En'])(v9['verticalDataScale'], v8['DefaultOptions']['verticalDataScale']),
              this['flipArrow'] = (0x0,
                j['En'])(v9['flipArrow'], v8['DefaultOptions']['flipArrow'])) : (this['baseSpeed'] = (0x0,
                  j['Rf'])(v9['baseSpeed'], this['baseSpeed']),
                  this['headRadius'] = (0x0,
                    j['Rf'])(v9['headRadius'], this['headRadius']),
                  this['headLength'] = (0x0,
                    j['Rf'])(v9['headLength'], this['headLength']),
                  this['headSegments'] = (0x0,
                    j['Rf'])(v9['headSegments'], this['headSegments']),
                  this['bodyTopRadius'] = (0x0,
                    j['Rf'])(v9['bodyTopRadius'], this['bodyTopRadius']),
                  this['bodyBottomRadius'] = (0x0,
                    j['Rf'])(v9['bodyBottomRadius'], this['bodyBottomRadius']),
                  this['bodyLength'] = (0x0,
                    j['Rf'])(v9['bodyLength'], this['bodyLength']),
                  this['bodySegments'] = (0x0,
                    j['Rf'])(v9['bodySegments'], this['bodySegments']),
                  this['shapeNeedsUpdate'] = (0x0,
                    j['Rf'])(v9['shapeNeedsUpdate'], this['shapeNeedsUpdate']),
                  this['maxCount'] = (0x0,
                    j['Rf'])(v9['maxCount'], this['maxCount']),
                  this['shapeScale'] = (0x0,
                    j['Rf'])(v9['shapeScale'], this['shapeScale']),
                  this['verticalDataScale'] = (0x0,
                    j['Rf'])(v9['verticalDataScale'], this['verticalDataScale']),
                  this['flipArrow'] = (0x0,
                    j['Rf'])(v9['flipArrow'], this['flipArrow'])),
            this['speed'] = (0x0,
              j['Rf'])(v9['speed'], this['speed'], D['JW']),
            this['angle'] = (0x0,
              j['Rf'])(v9['angle'], this['angle'], D['JW']),
            this['height'] = (0x0,
              j['Rf'])(v9['height'], this['height'], D['JW']),
            this['gridPreferSD'] = (0x0,
              j['Rf'])(v9['gridPreferSD'], this['gridPreferSD']);
        }
      }
      v8['DefaultOptions'] = Object['assign'](Object['assign']({}, v7['DefaultOptions']), {
        'baseSpeed': 0x5,
        'headRadius': 0xbb8,
        'headLength': 0x1388,
        'headSegments': 0x1e,
        'bodyTopRadius': 0x3e8,
        'bodyBottomRadius': 0x3e8,
        'bodyLength': 0x2710,
        'bodySegments': 0x1e,
        'maxCount': 0x1f4,
        'shapeNeedsUpdate': false,
        'shapeScale': 0x1,
        'verticalDataScale': 0x1,
        'flipArrow': true
      });
    }
    ,
    0x219: (K, b, H) => {
      'use strict';
      H['d'](b, {
        '$f': () => U,
        'CN': () => Z,
        'Dg': () => W,
        'UZ': () => D,
        'W6': () => B,
        'dl': () => q,
        'no': () => I,
        'se': () => j,
        'vX': () => V,
        'x1': () => S
      });
      var x = H(0x39b)
        , F = H(0xfb)
        , w = H(0x1)
        , Y = H(0x346)
        , T = H(0x1de)
        , X = H(0x260)
        , E = H(0x133);
      function W (J) {
        let C = (0x0,
          E['it'])(J);
        if ('number' == typeof C)
          return O => C;
        if ('function' == typeof C)
          return C;
        if ('object' == typeof C && C['stops']) {
          const O = new X['NB'](C, N => (N['stop'] = parseFloat(N['stop']),
            N));
          let G = parseInt(O['fieldName']) || 0x0;
          return (N, P) => O['getRule'](P[G])['stop'];
        }
        if ('string' == typeof C) {
          if (0x0 === C['trim']()['length'])
            return N => N;
          if (C['startsWith'](Y['v']['fieldPropertiesIndicator']) || C['startsWith'](Y['v']['fieldLoaderIndicator'])) {
            let N = 0x0;
            if (C['indexOf']('|') > 0x0) {
              const P = C['split']('|');
              N = parseInt(P[0x1]) || 0x0,
                C = P[0x0];
            }
            if (C['indexOf'](Y['v']['fieldLoaderIndicator']) < 0x0)
              return (M, z) => z[N];
            {
              const M = C['split'](Y['v']['fieldLoaderIndicator'])
                , z = M[0x1]['split']('?')
                , Q = (0x0,
                  F['nA'])(z[0x0]);
              if (!Q)
                return x['kg']['warn']('当前字段' + M[0x0] + '的loader未找到，将直接使用格点值！'),
                  (L, R) => R[N];
              if (z['length'] > 0x1) {
                const L = (0x0,
                  E['vl'])(z[0x1]);
                return (R, v0) => Q(v0[N], L);
              }
              return (R, v0) => Q(v0[N], undefined);
            }
          }
          {
            const R = parseFloat(C);
            return undefined === R && x['kg']['error']('提供了非数值属性' + C + '！'),
              v0 => R;
          }
        }
        x['kg']['error']('数字字段不支持当前类型：' + typeof C);
      }
      function I (J) {
        let C = (0x0,
          E['it'])(J);
        if ('function' == typeof C)
          return C;
        if ('object' == typeof C && C['stops']) {
          const O = new X['NB'](C, N => (N['stop']['toString'] && N['stop']['toString'](),
            N));
          let G = parseInt(O['fieldName']) || 0x0;
          return (N, P) => O['getRule'](P[G])['stop'];
        }
        if (undefined === C)
          return (N, P) => N['toString']();
        if ('string' == typeof C) {
          if (0x0 === C['trim']()['length'])
            return (N, P) => N['toString']();
          if (C['startsWith'](Y['v']['fieldPropertiesIndicator']) || C['startsWith'](Y['v']['fieldLoaderIndicator'])) {
            let N = 0x0;
            if (C['indexOf']('|') > 0x0) {
              const P = C['split']('|');
              N = parseInt(P[0x1]) || 0x0,
                C = P[0x0];
            }
            if (C['indexOf'](Y['v']['fieldLoaderIndicator']) < 0x0)
              return (M, z) => z[N]['toString']();
            {
              const M = C['split'](Y['v']['fieldLoaderIndicator'])
                , z = M[0x1]['split']('?')
                , Q = (0x0,
                  F['nA'])(z[0x0]);
              if (!Q)
                return x['kg']['warn']('当前字段' + M[0x0] + '的loader未找到，将直接使用格点值！'),
                  (L, R) => R[N]['toString']();
              if (z['length'] > 0x1) {
                const L = (0x0,
                  E['vl'])(z[0x1]);
                return (R, v0) => Q(v0[N], L);
              }
              return (R, v0) => Q(v0[N]);
            }
          }
          return (R, v0) => C;
        }
        x['kg']['error']('字符串字段不支持当前类型：' + typeof C);
      }
      function j (J) {
        const C = (0x0,
          E['it'])(J);
        if ('number' == typeof C) {
          const O = 0x0 !== C;
          return G => O;
        }
        if ('boolean' == typeof C)
          return G => C;
        if ('function' == typeof C)
          return C;
        if ('object' == typeof C && C['stops']) {
          const G = new X['NB'](C);
          let N = parseInt(G['fieldName']) || 0x0;
          return (P, M) => G['getRule'](M[N])['stop'];
        }
        if ('string' == typeof C) {
          const P = '0' !== C && 'false' !== C['toLowerCase']();
          return M => P;
        }
        x['kg']['error']('逻辑字段不支持当前类型：' + typeof C);
      }
      function D (J) {
        const C = (0x0,
          E['it'])(J);
        if (C instanceof Array)
          return O => C;
        if ('function' == typeof C)
          return C;
        if ('object' == typeof C && C['stops']) {
          const O = new X['NB'](C);
          let G = parseInt(O['fieldName']) || 0x0;
          return (N, P) => O['getRule'](P[G])['stop'];
        }
        x['kg']['error']('数值数组字段不支持当前类型：' + typeof C);
      }
      function V (J) {
        const C = (0x0,
          E['it'])(J);
        if ('string' == typeof C) {
          const O = (0x0,
            E['$P'])(C);
          return G => O;
        }
        if ('number' == typeof C) {
          const G = (0x0,
            E['lW'])(C);
          return N => G;
        }
        if (C instanceof T['t'])
          return N => C;
        if (C instanceof Array) {
          const N = new T['t']({
            'r': C[0x0],
            'g': C[0x1],
            'b': C[0x2],
            'a': 0x3 === C['length'] ? 0x1 : C[0x3]
          });
          return P => N;
        }
        if ('function' == typeof C)
          return (P, M) => {
            const z = C(P, M);
            return z instanceof T['t'] ? z : 'string' == typeof z ? (0x0,
              E['$P'])(z) : 'number' == typeof z ? (0x0,
                E['lW'])(z) : z instanceof Array ? (0x0,
                  E['LH'])(z) : void x['kg']['error']('不支持的颜色类型！');
          }
            ;
        if ('object' == typeof C && (undefined !== C['r'] || undefined !== C['red'])) {
          const P = new T['t'](C);
          return M => P;
        }
        if ('object' == typeof C && C['stops']) {
          const M = new X['NB'](C, E['$k']);
          let z = parseInt(M['fieldName']) || 0x0;
          return (Q, L) => M['getRule'](L[z])['stop'];
        }
        x['kg']['error']('颜色字段不支持当前类型：' + typeof C);
      }
      function Z (J) {
        const C = (0x0,
          E['it'])(J);
        if ('string' == typeof C)
          return O => C;
        if (C instanceof HTMLImageElement || C instanceof HTMLVideoElement || C instanceof HTMLCanvasElement)
          return O => C;
        if ('function' == typeof C)
          return C;
        if ('object' == typeof C && C['stops']) {
          const O = new X['NB'](C);
          let G = parseInt(O['fieldName']) || 0x0;
          return (N, P) => O['getRule'](P[G])['stop'];
        }
        x['kg']['error']('图像字段不支持当前类型：' + typeof C);
      }
      class B extends E['Uw'] {
        constructor() {
          super(...arguments),
            this['styleName'] = 'gridStyle';
        }
        ['_createCacheId'] (J) {
          if (undefined !== J && !isNaN(J))
            return J['toString']();
        }
      }
      class S extends B {
        constructor(J) {
          super(J),
            this['_update'](J, true);
        }
        ['_update'] (J, C) {
          C ? (this['data'] = I(J['data']),
            this['font'] = I((0x0,
              w['En'])(J['font'], S['DefaultOptions']['font'])),
            this['color'] = V((0x0,
              w['En'])(J['color'], S['DefaultOptions']['color'])),
            this['visible'] = j((0x0,
              w['En'])(J['visible'], S['DefaultOptions']['visible'])),
            this['backHeight'] = W((0x0,
              w['En'])(J['backHeight'], S['DefaultOptions']['backHeight'])),
            this['backPadding'] = D((0x0,
              w['En'])(J['backPadding'], S['DefaultOptions']['backPadding'])),
            this['strokeWidth'] = W((0x0,
              w['En'])(J['strokeWidth'], S['DefaultOptions']['strokeWidth'])),
            this['backStrokeWidth'] = W((0x0,
              w['En'])(J['backStrokeWidth'], S['DefaultOptions']['backStrokeWidth'])),
            this['align'] = I((0x0,
              w['En'])(J['align'], S['DefaultOptions']['align'])),
            this['baseline'] = I((0x0,
              w['En'])(J['baseline'], S['DefaultOptions']['baseline'])),
            this['backShadowBlur'] = W((0x0,
              w['En'])(J['backShadowBlur'], S['DefaultOptions']['backShadowBlur'])),
            this['backShadowOffset'] = D((0x0,
              w['En'])(J['backShadowOffset'], S['DefaultOptions']['backShadowOffset'])),
            this['shadowOffset'] = D((0x0,
              w['En'])(J['shadowOffset'], S['DefaultOptions']['shadowOffset'])),
            this['shadowBlur'] = W((0x0,
              w['En'])(J['shadowBlur'], S['DefaultOptions']['shadowBlur'])),
            this['backRoundRadius'] = W((0x0,
              w['En'])(J['backRoundRadius'], S['DefaultOptions']['backRoundRadius'])),
            this['zoomMin'] = W((0x0,
              w['En'])(J['zoomMin'], S['DefaultOptions']['zoomMin'])),
            this['zoomMax'] = W((0x0,
              w['En'])(J['zoomMax'], S['DefaultOptions']['zoomMax']))) : (this['data'] = (0x0,
                w['Rf'])(J['data'], this['data'], I),
                this['font'] = (0x0,
                  w['Rf'])(J['font'], this['font'], I),
                this['color'] = (0x0,
                  w['Rf'])(J['color'], this['color'], V),
                this['visible'] = (0x0,
                  w['Rf'])(J['visible'], this['visible'], j),
                this['backHeight'] = (0x0,
                  w['Rf'])(J['backHeight'], this['backHeight'], W),
                this['backPadding'] = (0x0,
                  w['Rf'])(J['backPadding'], this['backPadding'], D),
                this['strokeWidth'] = (0x0,
                  w['Rf'])(J['strokeWidth'], this['strokeWidth'], W),
                this['backStrokeWidth'] = (0x0,
                  w['Rf'])(J['backStrokeWidth'], this['backStrokeWidth'], W),
                this['align'] = (0x0,
                  w['Rf'])(J['align'], this['align'], I),
                this['baseline'] = (0x0,
                  w['Rf'])(J['baseline'], this['baseline'], I),
                this['backShadowOffset'] = (0x0,
                  w['Rf'])(J['backShadowOffset'], this['backShadowOffset'], D),
                this['backShadowBlur'] = (0x0,
                  w['Rf'])(J['backShadowBlur'], this['backShadowBlur'], W),
                this['shadowOffset'] = (0x0,
                  w['Rf'])(J['shadowOffset'], this['shadowOffset'], D),
                this['shadowBlur'] = (0x0,
                  w['Rf'])(J['shadowBlur'], this['shadowBlur'], W),
                this['backRoundRadius'] = (0x0,
                  w['Rf'])(J['backRoundRadius'], this['backRoundRadius'], W),
                this['zoomMin'] = (0x0,
                  w['Rf'])(J['zoomMin'], this['zoomMin'], W),
                this['zoomMax'] = (0x0,
                  w['Rf'])(J['zoomMax'], this['zoomMax'], W)),
            this['angle'] = (0x0,
              w['Rf'])(J['angle'], this['angle'], W),
            this['strokeColor'] = (0x0,
              w['Rf'])(J['strokeColor'], this['strokeColor'], V),
            this['backColor'] = (0x0,
              w['Rf'])(J['backColor'], this['backColor'], V),
            this['backCircle'] = (0x0,
              w['Rf'])(J['backCircle'], this['backCircle'], j),
            this['offset'] = (0x0,
              w['Rf'])(J['offset'], this['offset'], D),
            this['backStrokeColor'] = (0x0,
              w['Rf'])(J['backStrokeColor'], this['backStrokeColor'], V),
            this['backRoundRect'] = (0x0,
              w['Rf'])(J['backRoundRect'], this['backRoundRect'], j),
            this['backShadowColor'] = (0x0,
              w['Rf'])(J['backShadowColor'], this['backShadowColor'], V),
            this['backStrokeDashArray'] = (0x0,
              w['Rf'])(J['backStrokeDashArray'], this['backStrokeDashArray'], D),
            this['shadowColor'] = (0x0,
              w['Rf'])(J['shadowColor'], this['shadowColor'], V);
        }
      }
      S['DefaultOptions'] = {
        'data': undefined,
        'font': '12px\x20微软雅黑',
        'color': 'black',
        'visible': true,
        'backHeight': 0xe,
        'backPadding': [0x3, 0x2],
        'strokeWidth': 0x1,
        'backStrokeWidth': 0x1,
        'align': 'center',
        'baseline': 'middle',
        'backShadowBlur': 0x6,
        'backShadowOffset': [0x3, 0x3],
        'shadowBlur': 0x6,
        'shadowOffset': [0x3, 0x3],
        'backRoundRadius': 0x6,
        'zoomMin': 0x0,
        'zoomMax': 0x19
      };
      class U extends B {
        constructor(J) {
          super(J),
            J['data'] || x['kg']['error']('图像数据是必选字段！'),
            this['_update'](J, true);
        }
        ['_update'] (J, C) {
          C ? (this['size'] = D((0x0,
            w['En'])(J['size'], U['DefaultOptions']['size'])),
            this['data'] = Z(J['data']),
            this['visible'] = j((0x0,
              w['En'])(J['visible'], U['DefaultOptions']['visible'])),
            this['shadowOffset'] = D((0x0,
              w['En'])(J['shadowOffset'], U['DefaultOptions']['shadowOffset'])),
            this['shadowBlur'] = W((0x0,
              w['En'])(J['shadowBlur'], U['DefaultOptions']['shadowBlur'])),
            this['zoomMin'] = W((0x0,
              w['En'])(J['zoomMin'], U['DefaultOptions']['zoomMin'])),
            this['zoomMax'] = W((0x0,
              w['En'])(J['zoomMax'], U['DefaultOptions']['zoomMax']))) : (this['size'] = (0x0,
                w['Rf'])(J['size'], this['size'], D),
                this['data'] = (0x0,
                  w['Rf'])(J['data'], this['data'], Z),
                this['visible'] = (0x0,
                  w['Rf'])(J['visible'], this['visible'], j),
                this['shadowOffset'] = (0x0,
                  w['Rf'])(J['shadowOffset'], this['shadowOffset'], D),
                this['shadowBlur'] = (0x0,
                  w['Rf'])(J['shadowBlur'], this['shadowBlur'], W),
                this['zoomMin'] = (0x0,
                  w['Rf'])(J['zoomMin'], this['zoomMin'], W),
                this['zoomMax'] = (0x0,
                  w['Rf'])(J['zoomMax'], this['zoomMax'], W)),
            this['angle'] = (0x0,
              w['Rf'])(J['angle'], this['angle'], W),
            this['offset'] = (0x0,
              w['Rf'])(J['offset'], this['offset'], D),
            this['shadowColor'] = (0x0,
              w['Rf'])(J['shadowColor'], this['shadowColor'], V),
            this['color'] = (0x0,
              w['Rf'])(J['color'], this['color'], V);
        }
      }
      U['DefaultOptions'] = {
        'data': undefined,
        'size': [0x20, 0x20],
        'visible': true,
        'shadowBlur': 0x5,
        'shadowOffset': [0x5, 0x5],
        'zoomMin': 0x0,
        'zoomMax': 0x19
      };
      class q extends B {
        constructor(J) {
          super(J),
            this['_update'](J, true);
        }
        ['_update'] (J, C) {
          C ? (this['interval'] = (0x0,
            w['En'])(J['interval'], q['DefaultOptions']['interval']),
            this['pos'] = (0x0,
              w['En'])(J['pos'], q['DefaultOptions']['pos'])) : (J['interval'] && (this['interval'] = J['interval']),
                this['pos'] = (0x0,
                  w['Rf'])(J['pos'], this['pos'])),
            J['image'] && (C ? this['image'] = J['image'] && new U(J['image']) : this['image']['update'](J['image'])),
            J['text'] && (C ? this['text'] = J['text'] && new S(J['text']) : this['text']['update'](J['text']));
        }
      }
      q['DefaultOptions'] = {
        'interval': [0x32, 0x32],
        'pos': [0.5, 0.5]
      };
    }
    ,
    0x313: (K, b, H) => {
      'use strict';
      H['d'](b, {
        'K9': () => Z,
        'dO': () => V,
        'uD': () => D,
        'xS': () => X
      });
      var x = H(0x39b)
        , F = H(0x1)
        , y = H(0x346)
        , w = H(0x35a)
        , Y = H(0x260)
        , T = function (B, S, U, q) {
          return new (U || (U = Promise))(function (J, C) {
            function O (P) {
              try {
                N(q['next'](P));
              } catch (M) {
                C(M);
              }
            }
            function G (P) {
              try {
                N(q['throw'](P));
              } catch (M) {
                C(M);
              }
            }
            function N (P) {
              var M;
              P['done'] ? J(P['value']) : (M = P['value'],
                M instanceof U ? M : new U(function (z) {
                  z(M);
                }
                ))['then'](O, G);
            }
            N((q = q['apply'](B, S || []))['next']());
          }
          );
        };
      const X = {
        '3gauss': '3gauss',
        '3saw': '3saw',
        'BkBlAqGrYeOrReViWh200': 'BkBlAqGrYeOrReViWh200',
        'BlAqGrYeOrRe': 'BlAqGrYeOrRe',
        'BlAqGrYeOrReVi200': 'BlAqGrYeOrReVi200',
        'BlGrYeOrReVi200': 'BlGrYeOrReVi200',
        'BlRe': 'BlRe',
        'BlWhRe': 'BlWhRe',
        'BlueDarkOrange18': 'BlueDarkOrange18',
        'BlueDarkRed18': 'BlueDarkRed18',
        'BlueGreen14': 'BlueGreen14',
        'BlueRed': 'BlueRed',
        'BlueRedGray': 'BlueRedGray',
        'BlueWhiteOrangeRed': 'BlueWhiteOrangeRed',
        'BlueYellowRed': 'BlueYellowRed',
        'BrownBlue12': 'BrownBlue12',
        'Cat12': 'Cat12',
        'GHRSST_anomaly': 'GHRSST_anomaly',
        'GMT_cool': 'GMT_cool',
        'GMT_copper': 'GMT_copper',
        'GMT_drywet': 'GMT_drywet',
        'GMT_gebco': 'GMT_gebco',
        'GMT_globe': 'GMT_globe',
        'GMT_gray': 'GMT_gray',
        'GMT_haxby': 'GMT_haxby',
        'GMT_hot': 'GMT_hot',
        'GMT_jet': 'GMT_jet',
        'GMT_nighttime': 'GMT_nighttime',
        'GMT_no_green': 'GMT_no_green',
        'GMT_ocean': 'GMT_ocean',
        'GMT_paired': 'GMT_paired',
        'GMT_panoply': 'GMT_panoply',
        'GMT_polar': 'GMT_polar',
        'GMT_red2green': 'GMT_red2green',
        'GMT_relief': 'GMT_relief',
        'GMT_relief_oceanonly': 'GMT_relief_oceanonly',
        'GMT_seis': 'GMT_seis',
        'GMT_split': 'GMT_split',
        'GMT_topo': 'GMT_topo',
        'GMT_wysiwyg': 'GMT_wysiwyg',
        'GMT_wysiwygcont': 'GMT_wysiwygcont',
        'GrayWhiteGray': 'GrayWhiteGray',
        'GreenMagenta16': 'GreenMagenta16',
        'GreenYellow': 'GreenYellow',
        'MPL_Accent': 'MPL_Accent',
        'MPL_Blues': 'MPL_Blues',
        'MPL_BrBG': 'MPL_BrBG',
        'MPL_BuGn': 'MPL_BuGn',
        'MPL_BuPu': 'MPL_BuPu',
        'MPL_Dark2': 'MPL_Dark2',
        'MPL_GnBu': 'MPL_GnBu',
        'MPL_Greens': 'MPL_Greens',
        'MPL_Greys': 'MPL_Greys',
        'MPL_OrRd': 'MPL_OrRd',
        'MPL_Oranges': 'MPL_Oranges',
        'MPL_PRGn': 'MPL_PRGn',
        'MPL_Paired': 'MPL_Paired',
        'MPL_Pastel1': 'MPL_Pastel1',
        'MPL_Pastel2': 'MPL_Pastel2',
        'MPL_PiYG': 'MPL_PiYG',
        'MPL_PuBu': 'MPL_PuBu',
        'MPL_PuBuGn': 'MPL_PuBuGn',
        'MPL_PuOr': 'MPL_PuOr',
        'MPL_PuRd': 'MPL_PuRd',
        'MPL_Purples': 'MPL_Purples',
        'MPL_RdBu': 'MPL_RdBu',
        'MPL_RdGy': 'MPL_RdGy',
        'MPL_RdPu': 'MPL_RdPu',
        'MPL_RdYlBu': 'MPL_RdYlBu',
        'MPL_RdYlGn': 'MPL_RdYlGn',
        'MPL_Reds': 'MPL_Reds',
        'MPL_Set1': 'MPL_Set1',
        'MPL_Set2': 'MPL_Set2',
        'MPL_Set3': 'MPL_Set3',
        'MPL_Spectral': 'MPL_Spectral',
        'MPL_StepSeq': 'MPL_StepSeq',
        'MPL_YlGn': 'MPL_YlGn',
        'MPL_YlGnBu': 'MPL_YlGnBu',
        'MPL_YlOrBr': 'MPL_YlOrBr',
        'MPL_YlOrRd': 'MPL_YlOrRd',
        'MPL_afmhot': 'MPL_afmhot',
        'MPL_autumn': 'MPL_autumn',
        'MPL_bone': 'MPL_bone',
        'MPL_brg': 'MPL_brg',
        'MPL_bwr': 'MPL_bwr',
        'MPL_cool': 'MPL_cool',
        'MPL_coolwarm': 'MPL_coolwarm',
        'MPL_copper': 'MPL_copper',
        'MPL_cubehelix': 'MPL_cubehelix',
        'MPL_flag': 'MPL_flag',
        'MPL_gist_earth': 'MPL_gist_earth',
        'MPL_gist_gray': 'MPL_gist_gray',
        'MPL_gist_heat': 'MPL_gist_heat',
        'MPL_gist_ncar': 'MPL_gist_ncar',
        'MPL_gist_rainbow': 'MPL_gist_rainbow',
        'MPL_gist_stern': 'MPL_gist_stern',
        'MPL_gist_yarg': 'MPL_gist_yarg',
        'MPL_gnuplot': 'MPL_gnuplot',
        'MPL_gnuplot2': 'MPL_gnuplot2',
        'MPL_hot': 'MPL_hot',
        'MPL_hsv': 'MPL_hsv',
        'MPL_jet': 'MPL_jet',
        'MPL_ocean': 'MPL_ocean',
        'MPL_pink': 'MPL_pink',
        'MPL_prism': 'MPL_prism',
        'MPL_rainbow': 'MPL_rainbow',
        'MPL_s3pcpn': 'MPL_s3pcpn',
        'MPL_s3pcpn_l': 'MPL_s3pcpn_l',
        'MPL_seismic': 'MPL_seismic',
        'MPL_spring': 'MPL_spring',
        'MPL_sstanom': 'MPL_sstanom',
        'MPL_summer': 'MPL_summer',
        'MPL_terrain': 'MPL_terrain',
        'MPL_winter': 'MPL_winter',
        'NCV_banded': 'NCV_banded',
        'NCV_blu_red': 'NCV_blu_red',
        'NCV_blue_red': 'NCV_blue_red',
        'NCV_bright': 'NCV_bright',
        'NCV_gebco': 'NCV_gebco',
        'NCV_jaisnd': 'NCV_jaisnd',
        'NCV_jet': 'NCV_jet',
        'NCV_manga': 'NCV_manga',
        'NCV_rainbow2': 'NCV_rainbow2',
        'NCV_roullet': 'NCV_roullet',
        'OceanLakeLandSnow': 'OceanLakeLandSnow',
        'SVG_Gallet13': 'SVG_Gallet13',
        'SVG_Lindaa06': 'SVG_Lindaa06',
        'SVG_Lindaa07': 'SVG_Lindaa07',
        'SVG_bhw3_22': 'SVG_bhw3_22',
        'SVG_es_landscape_79': 'SVG_es_landscape_79',
        'SVG_feb_sunrise': 'SVG_feb_sunrise',
        'SVG_foggy_sunrise': 'SVG_foggy_sunrise',
        'SVG_fs2006': 'SVG_fs2006',
        'StepSeq25': 'StepSeq25',
        'ViBlGrWhYeOrRe': 'ViBlGrWhYeOrRe',
        'WhBlGrYeRe': 'WhBlGrYeRe',
        'WhBlReWh': 'WhBlReWh',
        'WhViBlGrYeOrRe': 'WhViBlGrYeOrRe',
        'WhViBlGrYeOrReWh': 'WhViBlGrYeOrReWh',
        'WhiteBlue': 'WhiteBlue',
        'WhiteBlueGreenYellowRed': 'WhiteBlueGreenYellowRed',
        'WhiteGreen': 'WhiteGreen',
        'WhiteYellowOrangeRed': 'WhiteYellowOrangeRed',
        'amwg': 'amwg',
        'amwg256': 'amwg256',
        'amwg_blueyellowred': 'amwg_blueyellowred',
        'cb_9step': 'cb_9step',
        'cb_rainbow': 'cb_rainbow',
        'cb_rainbow_inv': 'cb_rainbow_inv',
        'cmp_b2r': 'cmp_b2r',
        'cmp_flux': 'cmp_flux',
        'cmp_haxby': 'cmp_haxby',
        'cosam': 'cosam',
        'cosam12': 'cosam12',
        'cyclic': 'cyclic',
        'default': 'default',
        'detail': 'detail',
        'example': 'example',
        'extrema': 'extrema',
        'grads_default': 'grads_default',
        'grads_rainbow': 'grads_rainbow',
        'gscyclic': 'gscyclic',
        'gsdtol': 'gsdtol',
        'gsltod': 'gsltod',
        'gui_default': 'gui_default',
        'helix': 'helix',
        'helix1': 'helix1',
        'hlu_default': 'hlu_default',
        'hotcold_18lev': 'hotcold_18lev',
        'hotcolr_19lev': 'hotcolr_19lev',
        'hotres': 'hotres',
        'matlab_hot': 'matlab_hot',
        'matlab_hsv': 'matlab_hsv',
        'matlab_jet': 'matlab_jet',
        'matlab_lines': 'matlab_lines',
        'mch_default': 'mch_default',
        'ncl_default': 'ncl_default',
        'ncview_default': 'ncview_default',
        'nice_gfdl': 'nice_gfdl',
        'nrl_sirkes': 'nrl_sirkes',
        'nrl_sirkes_nowhite': 'nrl_sirkes_nowhite',
        'perc2_9lev': 'perc2_9lev',
        'percent_11lev': 'percent_11lev',
        'posneg_1': 'posneg_1',
        'posneg_2': 'posneg_2',
        'prcp_1': 'prcp_1',
        'prcp_2': 'prcp_2',
        'prcp_3': 'prcp_3',
        'precip2_15lev': 'precip2_15lev',
        'precip2_17lev': 'precip2_17lev',
        'precip3_16lev': 'precip3_16lev',
        'precip4_11lev': 'precip4_11lev',
        'precip4_diff_19lev': 'precip4_diff_19lev',
        'precip_11lev': 'precip_11lev',
        'precip_diff_12lev': 'precip_diff_12lev',
        'precip_diff_1lev': 'precip_diff_1lev',
        'psgcap': 'psgcap',
        'radar': 'radar',
        'radar_1': 'radar_1',
        'rainbow+gray': 'rainbow+gray',
        'rainbow+white+gray': 'rainbow+white+gray',
        'rainbow+white': 'rainbow+white',
        'rainbow': 'rainbow',
        'rh_19lev': 'rh_19lev',
        'seaice_1': 'seaice_1',
        'seaice_2': 'seaice_2',
        'so4_21': 'so4_21',
        'so4_23': 'so4_23',
        'spread_15lev': 'spread_15lev',
        'sunshine_9lev': 'sunshine_9lev',
        'sunshine_diff_12lev': 'sunshine_diff_12lev',
        't2m_29lev': 't2m_29lev',
        'tbrAvg1': 'tbrAvg1',
        'tbrStd1': 'tbrStd1',
        'tbrVar1': 'tbrVar1',
        'tbr_240-300': 'tbr_240-300',
        'tbr_stdev_0-30': 'tbr_stdev_0-30',
        'tbr_var_0-500': 'tbr_var_0-500',
        'temp1': 'temp1',
        'temp_19lev': 'temp_19lev',
        'temp_diff_18lev': 'temp_diff_18lev',
        'temp_diff_1lev': 'temp_diff_1lev',
        'testcmap': 'testcmap',
        'thelix': 'thelix',
        'topo_15lev': 'topo_15lev',
        'uniform': 'uniform',
        'wgne15': 'wgne15',
        'wh-bl-gr-ye-re': 'wh-bl-gr-ye-re',
        'wind_17lev': 'wind_17lev',
        'wxpEnIR': 'wxpEnIR'
      }
        , E = {}
        , W = {};
      function I (B, S) {
        let U = 'linear-gradient(90deg,';
        const q = [];
        return B['forEach']((J, C) => {
          const O = J['split'](/\s+/);
          if (0x0 === O[0x0]['trim']()['length'] && O['shift'](),
            isNaN(parseFloat(O[0x0])) || O['length'] < 0x3)
            return void x['kg']['debug']('skip\x20line\x20' + J);
          const G = parseFloat(O[0x0])
            , N = parseFloat(O[0x1])
            , P = parseFloat(O[0x2]);
          let M;
          M = G <= 0x1 && N <= 0x1 && P <= 0x1 ? 'rgb(' + (0xff * G)['toFixed'](0x0) + ',' + (0xff * N)['toFixed'](0x0) + ',' + (0xff * P)['toFixed'](0x0) + ')' : 'rgb(' + O[0x0] + ',' + O[0x1] + ',' + O[0x2] + ')',
            U += M + '\x20' + C / (B['length'] - 0x1) * 0x64 + '%,',
            q['push'](M);
        }
        ),
          B = q,
          U = U['substring'](0x0, U['length'] - 0x1) + ')',
          W[S] = {
            'colors': B,
            'cssColor': U
          },
        {
          'colors': B,
          'cssColor': U
        };
      }
      function j (B) {
        return T(this, undefined, undefined, function* () {
          if (W[B])
            return W[B];
          const S = y['v']['defaultLegendPath']['endsWith']('/') ? y['v']['defaultLegendPath'] : y['v']['defaultLegendPath'] + '/';
          let U = (yield (yield qeFetch(S + '/' + B + '.rgb')['catch'](() => { }
          ))['text']())['split']('\x0a');
          if (!U)
            throw new Error('调色文件不存在！');
          return I(U, B);
        });
      }
      function D (B, S, U, q = 0x0, J, C) {
        return T(this, undefined, undefined, function* () {
          if ((0x0,
            F['ri'])(S) && (0x0,
              F['ri'])(U)) {
            (0x0,
              F['ri'])(J) || (x['kg']['warn']('未提供字段名称，将使用随机值！'),
                J = 'field' + (0x0,
                  F['hQ'])());
            try {
              const { colors: O, cssColor: G } = yield j(B)
                , N = {
                  'stops': [],
                  'fieldName': J
                };
              C && (N['action'] = C);
              let P = 0x0;
              for (let M = 0x0; M < O['length']; M += q + 0x1) {
                const z = S + (U - S) * P / (O['length'] - 0x1);
                N['stops']['push']({
                  'stop': O[M],
                  'value': z
                }),
                  P++;
              }
              return {
                'stopRules': new Y['NB'](N),
                'css': G
              };
            } catch (Q) {
              return void x['kg']['error']('颜色解析错误：' + Q, false);
            }
          } else
            x['kg']['warn']('无法获取分级规则，最大值或最小值未定义');
        });
      }
      function V (B, S, U, q) {
        const J = B + '_' + (q ? '1' : '0');
        if (E[J]) {
          const C = new w['Xm']({
            'min': S,
            'max': U,
            'colorScale': E[J]['canvas']
          });
          return C['css'] = W[B]['cssColor'],
            C;
        }
        try {
          const { colors: O, cssColor: G } = function (M) {
            if (W[M])
              return W[M];
            const z = y['v']['defaultLegendPath']['endsWith']('/') ? y['v']['defaultLegendPath'] : y['v']['defaultLegendPath'] + '/'
              , Q = new XMLHttpRequest();
            return Q['open']('GET', z + '/' + M + '.rgb', false),
              Q['send'](null),
              0xc8 !== Q['status'] ? void x['kg']['error']('色标文件不存在：' + z) : I(Q['responseText']['split']('\x0a'), M);
          }(B)
            , N = w['Xm']['createColorScale'](O['length'] > 0xc8 ? 0x200 : 0x100, q, O, undefined, 0xf)
            , P = new w['Xm']({
              'colorScale': N,
              'min': S,
              'max': U
            });
          return P['css'] = G,
            E[J] = {
              'canvas': N
            },
            P;
        } catch (M) {
          return void x['kg']['error']('颜色解析错误：' + M, false);
        }
      }
      function Z (B, S, U, q) {
        return T(this, undefined, undefined, function* () {
          const J = B + '_' + (q ? '1' : '0');
          if (E[J]) {
            const C = new w['Xm']({
              'min': S,
              'max': U,
              'colorScale': E[J]['canvas']
            });
            return C['css'] = W[B]['cssColor'],
              C;
          }
          try {
            const { colors: O, cssColor: G } = yield j(B)
              , N = w['Xm']['createColorScale'](O['length'] > 0xc8 ? 0x200 : 0x100, q, O, undefined, 0xf)
              , P = new w['Xm']({
                'colorScale': N,
                'min': S,
                'max': U
              });
            return P['css'] = G,
              E[J] = {
                'canvas': N
              },
              P;
          } catch (M) {
            return void x['kg']['error']('颜色解析错误：' + M, false);
          }
        });
      }
    }
    ,
    0x1de: (l, K, b) => {
      'use strict';
      b['d'](K, {
        'm': () => H,
        't': () => x
      });
      var c = {};
      const H = {
        'transparent': [0x0, 0x0, 0x0, 0x0],
        'aliceblue': [0xf0, 0xf8, 0xff],
        'antiquewhite': [0xfa, 0xeb, 0xd7],
        'aqua': [0x0, 0xff, 0xff],
        'aquamarine': [0x7f, 0xff, 0xd4],
        'azure': [0xf0, 0xff, 0xff],
        'beige': [0xf5, 0xf5, 0xdc],
        'bisque': [0xff, 0xe4, 0xc4],
        'black': [0x0, 0x0, 0x0],
        'blanchedalmond': [0xff, 0xeb, 0xcd],
        'blue': [0x0, 0x0, 0xff],
        'blueviolet': [0x8a, 0x2b, 0xe2],
        'brown': [0xa5, 0x2a, 0x2a],
        'burlywood': [0xde, 0xb8, 0x87],
        'cadetblue': [0x5f, 0x9e, 0xa0],
        'chartreuse': [0x7f, 0xff, 0x0],
        'chocolate': [0xd2, 0x69, 0x1e],
        'coral': [0xff, 0x7f, 0x50],
        'cornflowerblue': [0x64, 0x95, 0xed],
        'cornsilk': [0xff, 0xf8, 0xdc],
        'crimson': [0xdc, 0x14, 0x3c],
        'cyan': [0x0, 0xff, 0xff],
        'darkblue': [0x0, 0x0, 0x8b],
        'darkcyan': [0x0, 0x8b, 0x8b],
        'darkgoldenrod': [0xb8, 0x86, 0xb],
        'darkgray': [0xa9, 0xa9, 0xa9],
        'darkgreen': [0x0, 0x64, 0x0],
        'darkgrey': [0xa9, 0xa9, 0xa9],
        'darkkhaki': [0xbd, 0xb7, 0x6b],
        'darkmagenta': [0x8b, 0x0, 0x8b],
        'darkolivegreen': [0x55, 0x6b, 0x2f],
        'darkorange': [0xff, 0x8c, 0x0],
        'darkorchid': [0x99, 0x32, 0xcc],
        'darkred': [0x8b, 0x0, 0x0],
        'darksalmon': [0xe9, 0x96, 0x7a],
        'darkseagreen': [0x8f, 0xbc, 0x8f],
        'darkslateblue': [0x48, 0x3d, 0x8b],
        'darkslategray': [0x2f, 0x4f, 0x4f],
        'darkslategrey': [0x2f, 0x4f, 0x4f],
        'darkturquoise': [0x0, 0xce, 0xd1],
        'darkviolet': [0x94, 0x0, 0xd3],
        'deeppink': [0xff, 0x14, 0x93],
        'deepskyblue': [0x0, 0xbf, 0xff],
        'dimgray': [0x69, 0x69, 0x69],
        'dimgrey': [0x69, 0x69, 0x69],
        'dodgerblue': [0x1e, 0x90, 0xff],
        'firebrick': [0xb2, 0x22, 0x22],
        'floralwhite': [0xff, 0xfa, 0xf0],
        'forestgreen': [0x22, 0x8b, 0x22],
        'fuchsia': [0xff, 0x0, 0xff],
        'gainsboro': [0xdc, 0xdc, 0xdc],
        'ghostwhite': [0xf8, 0xf8, 0xff],
        'gold': [0xff, 0xd7, 0x0],
        'goldenrod': [0xda, 0xa5, 0x20],
        'gray': [0x80, 0x80, 0x80],
        'green': [0x0, 0x80, 0x0],
        'greenyellow': [0xad, 0xff, 0x2f],
        'grey': [0x80, 0x80, 0x80],
        'honeydew': [0xf0, 0xff, 0xf0],
        'hotpink': [0xff, 0x69, 0xb4],
        'indianred': [0xcd, 0x5c, 0x5c],
        'indigo': [0x4b, 0x0, 0x82],
        'ivory': [0xff, 0xff, 0xf0],
        'khaki': [0xf0, 0xe6, 0x8c],
        'lavender': [0xe6, 0xe6, 0xfa],
        'lavenderblush': [0xff, 0xf0, 0xf5],
        'lawngreen': [0x7c, 0xfc, 0x0],
        'lemonchiffon': [0xff, 0xfa, 0xcd],
        'lightblue': [0xad, 0xd8, 0xe6],
        'lightcoral': [0xf0, 0x80, 0x80],
        'lightcyan': [0xe0, 0xff, 0xff],
        'lightgoldenrodyellow': [0xfa, 0xfa, 0xd2],
        'lightgray': [0xd3, 0xd3, 0xd3],
        'lightgreen': [0x90, 0xee, 0x90],
        'lightgrey': [0xd3, 0xd3, 0xd3],
        'lightpink': [0xff, 0xb6, 0xc1],
        'lightsalmon': [0xff, 0xa0, 0x7a],
        'lightseagreen': [0x20, 0xb2, 0xaa],
        'lightskyblue': [0x87, 0xce, 0xfa],
        'lightslategray': [0x77, 0x88, 0x99],
        'lightslategrey': [0x77, 0x88, 0x99],
        'lightsteelblue': [0xb0, 0xc4, 0xde],
        'lightyellow': [0xff, 0xff, 0xe0],
        'lime': [0x0, 0xff, 0x0],
        'limegreen': [0x32, 0xcd, 0x32],
        'linen': [0xfa, 0xf0, 0xe6],
        'magenta': [0xff, 0x0, 0xff],
        'maroon': [0x80, 0x0, 0x0],
        'mediumaquamarine': [0x66, 0xcd, 0xaa],
        'mediumblue': [0x0, 0x0, 0xcd],
        'mediumorchid': [0xba, 0x55, 0xd3],
        'mediumpurple': [0x93, 0x70, 0xdb],
        'mediumseagreen': [0x3c, 0xb3, 0x71],
        'mediumslateblue': [0x7b, 0x68, 0xee],
        'mediumspringgreen': [0x0, 0xfa, 0x9a],
        'mediumturquoise': [0x48, 0xd1, 0xcc],
        'mediumvioletred': [0xc7, 0x15, 0x85],
        'midnightblue': [0x19, 0x19, 0x70],
        'mintcream': [0xf5, 0xff, 0xfa],
        'mistyrose': [0xff, 0xe4, 0xe1],
        'moccasin': [0xff, 0xe4, 0xb5],
        'navajowhite': [0xff, 0xde, 0xad],
        'navy': [0x0, 0x0, 0x80],
        'oldlace': [0xfd, 0xf5, 0xe6],
        'olive': [0x80, 0x80, 0x0],
        'olivedrab': [0x6b, 0x8e, 0x23],
        'orange': [0xff, 0xa5, 0x0],
        'orangered': [0xff, 0x45, 0x0],
        'orchid': [0xda, 0x70, 0xd6],
        'palegoldenrod': [0xee, 0xe8, 0xaa],
        'palegreen': [0x98, 0xfb, 0x98],
        'paleturquoise': [0xaf, 0xee, 0xee],
        'palevioletred': [0xdb, 0x70, 0x93],
        'papayawhip': [0xff, 0xef, 0xd5],
        'peachpuff': [0xff, 0xda, 0xb9],
        'peru': [0xcd, 0x85, 0x3f],
        'pink': [0xff, 0xc0, 0xcb],
        'plum': [0xdd, 0xa0, 0xdd],
        'powderblue': [0xb0, 0xe0, 0xe6],
        'purple': [0x80, 0x0, 0x80],
        'rebeccapurple': [0x66, 0x33, 0x99],
        'red': [0xff, 0x0, 0x0],
        'rosybrown': [0xbc, 0x8f, 0x8f],
        'royalblue': [0x41, 0x69, 0xe1],
        'saddlebrown': [0x8b, 0x45, 0x13],
        'salmon': [0xfa, 0x80, 0x72],
        'sandybrown': [0xf4, 0xa4, 0x60],
        'seagreen': [0x2e, 0x8b, 0x57],
        'seashell': [0xff, 0xf5, 0xee],
        'sienna': [0xa0, 0x52, 0x2d],
        'silver': [0xc0, 0xc0, 0xc0],
        'skyblue': [0x87, 0xce, 0xeb],
        'slateblue': [0x6a, 0x5a, 0xcd],
        'slategray': [0x70, 0x80, 0x90],
        'slategrey': [0x70, 0x80, 0x90],
        'snow': [0xff, 0xfa, 0xfa],
        'springgreen': [0x0, 0xff, 0x7f],
        'steelblue': [0x46, 0x82, 0xb4],
        'tan': [0xd2, 0xb4, 0x8c],
        'teal': [0x0, 0x80, 0x80],
        'thistle': [0xd8, 0xbf, 0xd8],
        'tomato': [0xff, 0x63, 0x47],
        'turquoise': [0x40, 0xe0, 0xd0],
        'violet': [0xee, 0x82, 0xee],
        'wheat': [0xf5, 0xde, 0xb3],
        'white': [0xff, 0xff, 0xff],
        'whitesmoke': [0xf5, 0xf5, 0xf5],
        'yellow': [0xff, 0xff, 0x0],
        'yellowgreen': [0x9a, 0xcd, 0x32]
      };
      c['clamp'] = function (p, F, y) {
        return p = undefined === p ? 0x0 : p,
          F = undefined !== F ? F : 0x0,
          y = undefined !== y ? y : 0x1,
          Math['max'](F, Math['min'](y, p));
      }
        ,
        c['rgbToHsv'] = function (p) {
          var F = {}
            , y = Number(undefined === p['r'] ? 0x0 : p['r']) / 0xff
            , w = Number(undefined === p['g'] ? 0x0 : p['g']) / 0xff
            , h = Number(undefined === p['b'] ? 0x0 : p['b']) / 0xff
            , u = Math['max'](y, w, h)
            , Y = Math['min'](y, w, h)
            , T = u - Y;
          return F['v'] = u,
            0x0 === F['v'] ? (F['h'] = 0x0,
              F['s'] = 0x0) : (F['s'] = (u - Y) / u,
                0x0 === F['s'] ? F['h'] = 0x0 : (F['h'] = u === y ? (w - h) / T : u === w ? 0x2 + (h - y) / T : 0x4 + (y - w) / T,
                  F['h'] *= 0x3c,
                  F['h'] < 0x0 && (F['h'] += 0x168))),
            F;
        }
        ,
        c['hsvToRgb'] = function (p) {
          var F = {
            'r': 0x0,
            'g': 0x0,
            'b': 0x0
          }
            , y = c['clamp'](p['h'] || p['hue'], 0x0, 0x168)
            , w = c['clamp'](p['s'] || p['saturation'], 0x0, 0x1)
            , h = c['clamp'](p['v'] || p['value'])
            , Y = w * h
            , T = y / 0x3c
            , X = Y * (0x1 - Math['abs'](T % 0x2 - 0x1));
          T < 0x1 ? (F['r'] = Y,
            F['g'] = X) : T < 0x2 ? (F['r'] = X,
              F['g'] = Y) : T < 0x3 ? (F['g'] = Y,
                F['b'] = X) : T < 0x4 ? (F['g'] = X,
                  F['b'] = Y) : T < 0x5 ? (F['r'] = X,
                    F['b'] = Y) : (F['r'] = Y,
                      F['b'] = X);
          var E = h - Y;
          return F['r'] += E,
            F['g'] += E,
            F['b'] += E,
            F['r'] *= 0xff,
            F['g'] *= 0xff,
            F['b'] *= 0xff,
            F;
        }
        ,
        c['rgbToHsl'] = function (p) {
          var F = c['rgbToHsv'](p)
            , y = {};
          return y['h'] = F['h'],
            y['l'] = (0x2 - F['s']) * F['v'],
            y['s'] = F['s'] * F['v'],
            y['s'] /= y['l'] <= 0x1 ? y['l'] : 0x2 - y['l'],
            y['l'] /= 0x2,
            isNaN(y['s']) && (y['s'] = 0x0),
            y;
        }
        ,
        c['hslToRgb'] = function (p) {
          var F = c['clamp'](p['h'] || p['hue'], 0x0, 0x168)
            , y = c['clamp'](p['s'] || p['saturation'])
            , w = c['clamp'](p['l'] || p['lightness'])
            , h = {};
          return h['h'] = F,
            y *= w < 0.5 ? w : 0x1 - w,
            h['s'] = 0x2 * y / (w + y),
            h['v'] = w + y,
            c['hsvToRgb'](h);
        }
        ,
        c['rgbToLab'] = function (p) {
          var F, y;
          for (y in p = {
            'r': p['r'] / 0xff,
            'g': p['g'] / 0xff,
            'b': p['b'] / 0xff
          })
            p['hasOwnProperty'](y) && (p[y] > 0.04045 ? p[y] = Math['pow']((p[y] + 0.055) / 1.055, 2.4) : p[y] /= 12.92,
              p[y] = 0x64 * p[y]);
          F = {
            'x': 0.4124 * p['r'] + 0.3576 * p['g'] + 0.1805 * p['b'],
            'y': 0.2126 * p['r'] + 0.7152 * p['g'] + 0.0722 * p['b'],
            'z': 0.0193 * p['r'] + 0.1192 * p['g'] + 0.9505 * p['b']
          };
          var w = {}
            , h = {
              'x': 95.047,
              'y': 0x64,
              'z': 108.883
            };
          for (y in F)
            F['hasOwnProperty'](y) && (w[y] = F[y] / h[y],
              w[y] > 0.008856 ? w[y] = Math['pow'](w[y], 0x1 / 0x3) : w[y] = 7.787 * w[y] + 0x10 / 0x74);
          return {
            'l': 0x74 * w['y'] - 0x10,
            'a': 0x1f4 * (w['x'] - w['y']),
            'b': 0xc8 * (w['y'] - w['z'])
          };
        }
        ,
        c['labToRgb'] = function (p) {
          var F = {}
            , y = {};
          for (var w in (F['y'] = ((p['l'] || p['L']) + 0x10) / 0x74,
            F['x'] = p['a'] / 0x1f4 + F['y'],
            F['z'] = F['y'] - p['b'] / 0xc8,
            F))
            F['hasOwnProperty'](w) && (Math['pow'](F[w], 0x3) > 0.008856 ? F[w] = Math['pow'](F[w], 0x3) : F[w] = (F[w] - 0x10 / 0x74) / 7.787);
          return F['x'] *= 95.047 / 0x64,
            F['y'] *= 0x1,
            F['z'] *= 1.08883,
            y['r'] = 3.2406 * F['x'] + -1.5372 * F['y'] + -0.4986 * F['z'],
            y['g'] = -0.9689 * F['x'] + 1.8758 * F['y'] + 0.0415 * F['z'],
            y['b'] = 0.0557 * F['x'] + -0.204 * F['y'] + 1.057 * F['z'],
            y['r'] > 0.0031308 ? y['r'] = 1.055 * Math['pow'](y['r'], 0x1 / 2.4) - 0.055 : y['r'] *= 12.92,
            y['g'] > 0.0031308 ? y['g'] = 1.055 * Math['pow'](y['g'], 0x1 / 2.4) - 0.055 : y['g'] *= 12.92,
            y['b'] > 0.0031308 ? y['b'] = 1.055 * Math['pow'](y['b'], 0x1 / 2.4) - 0.055 : y['b'] *= 12.92,
            y['r'] = c['clamp'](0xff * y['r'], 0x0, 0xff),
            y['g'] = c['clamp'](0xff * y['g'], 0x0, 0xff),
            y['b'] = c['clamp'](0xff * y['b'], 0x0, 0xff),
            y;
        }
        ,
        c['parseCss'] = function (p) {
          var F = {};
          if (p['match'](/^#[0-9a-f]{3}$/i))
            return F = {
              'r': 0x11 * parseInt(p['charAt'](0x1), 0x10),
              'g': 0x11 * parseInt(p['charAt'](0x2), 0x10),
              'b': 0x11 * parseInt(p['charAt'](0x3), 0x10)
            },
              c['normalize'](F);
          if (p['match'](/^#[0-9a-f]{6}$/i))
            return F = {
              'r': parseInt(p['slice'](0x1, 0x3), 0x10),
              'g': parseInt(p['slice'](0x3, 0x5), 0x10),
              'b': parseInt(p['slice'](0x5, 0x7), 0x10)
            },
              c['normalize'](F);
          var y = p['match'](/^rgb\(\s*([0-9]+),\s*([0-9]+),\s*([0-9]+)\s*\)$/i);
          if (y)
            return F = {
              'r': parseInt(y[0x1], 0xa),
              'g': parseInt(y[0x2], 0xa),
              'b': parseInt(y[0x3], 0xa)
            },
              c['normalize'](F);
          var w = p['match'](/^rgba\(\s*([0-9]+),\s*([0-9]+),\s*([0-9]+),\s*([0-9\.]+)\s*\)$/i);
          if (w)
            return F = {
              'r': parseInt(w[0x1], 0xa),
              'g': parseInt(w[0x2], 0xa),
              'b': parseInt(w[0x3], 0xa),
              'a': parseFloat(w[0x4])
            },
              c['normalize'](F);
          throw new TypeError(p + '\x20is\x20not\x20a\x20valid\x20CSS\x20string\x20for\x20Spectra.');
        }
        ,
        c['parsePredefinedColor'] = function (p) {
          return new x(H[p]);
        }
        ,
        c['normalize'] = function (p) {
          p['a'] = undefined === p['a'] ? 0x1 : p['a'];
          var F = p;
          return undefined !== F['hsv'] ? (F = c['hsvToRgb'](F['hsv']))['a'] = p['a'] : undefined !== F['hsl'] ? (F = c['hslToRgb'](F['hsl']))['a'] = p['a'] : undefined !== F['css'] ? F = c['parseCss'](F['css']) : undefined !== F['lab'] && ((F = c['labToRgb'](F['lab']))['a'] = p['a']),
            F['r'] = F['red'] || F['r'],
            F['g'] = F['green'] || F['g'],
            F['b'] = F['blue'] || F['b'],
            F['a'] = F['alpha'] || F['a'],
            F['r'] = c['clamp'](F['r'], 0x0, 0xff),
            F['g'] = c['clamp'](F['g'], 0x0, 0xff),
            F['b'] = c['clamp'](F['b'], 0x0, 0xff),
            F['a'] = c['clamp'](F['a'], 0x0, 0x1),
            F['r1'] = F['r'] / 0xff,
            F['g1'] = F['g'] / 0xff,
            F['Array2DGridDataProvider'] = F['b'] / 0xff,
            F;
        }
        ;
      class x {
        constructor(p) {
          var F, y, w, h;
          if (null == p)
            throw new TypeError('Spectra\x20argument\x20must\x20be\x20defined.');
          if (this['toString'] = this['rgbaString'],
            this['toJSON'] = this['rgbaString'],
            p instanceof x) {
            for (const u in p)
              this[u] = p[u];
          } else {
            if (p instanceof Array) {
              const Y = {
                'r': p[0x0],
                'g': p[0x1],
                'b': p[0x2],
                'a': p['length'] > 0x3 ? p[0x3] : 0x1
              };
              this['color'] = c['normalize'](Y);
            } else {
              if ('object' == typeof p) {
                if (undefined !== p['r'] || undefined !== p['red'])
                  this['color'] = c['normalize']({
                    'r': null !== (F = p['r']) && undefined !== F ? F : p['red'],
                    'g': null !== (y = p['g']) && undefined !== y ? y : p['green'],
                    'b': null !== (w = p['b']) && undefined !== w ? w : p['blue'],
                    'a': null !== (h = p['a']) && undefined !== h ? h : p['alpha']
                  });
                else {
                  if (undefined !== p['v'] || undefined !== p['value'])
                    this['color'] = c['normalize']({
                      'hsv': p,
                      'a': p['a']
                    });
                  else {
                    if (undefined === p['l'] && undefined === p['lightness'] || undefined === p['s'] && undefined === p['saturation']) {
                      if (undefined === p['l'] && undefined === p['L'] || undefined === p['a'])
                        throw new TypeError('Spectra\x20argument\x20' + p + '\x20is\x20invalid.');
                      this['color'] = c['normalize']({
                        'lab': p,
                        'a': p['a'] || p['alpha']
                      });
                    } else
                      this['color'] = c['normalize']({
                        'hsl': p,
                        'a': p['a'] || p['alpha']
                      });
                  }
                }
              } else {
                if ('string' != typeof p)
                  throw new TypeError('Spectra\x20argument\x20' + p + '\x20is\x20invalid.');
                if (p['toLowerCase']() in H)
                  return c['parsePredefinedColor'](p);
                this['color'] = c['normalize']({
                  'css': p
                });
              }
            }
          }
        }
        ['red'] (p) {
          var F = this['color'];
          return arguments['length'] ? (F['r'] = p,
            this['color'] = c['normalize'](F),
            this) : Math['round'](F['r']);
        }
        ['green'] (p) {
          var F = this['color'];
          return arguments['length'] ? (F['g'] = p,
            this['color'] = c['normalize'](F),
            this) : Math['round'](F['g']);
        }
        ['blue'] (p) {
          var F = this['color'];
          return arguments['length'] ? (F['b'] = p,
            this['color'] = c['normalize'](F),
            this) : Math['round'](F['b']);
        }
        ['hue'] (p) {
          var F = c['rgbToHsv'](this['color']);
          return arguments['length'] ? (F['h'] = p,
            this['color'] = c['normalize']({
              'hsv': F,
              'a': this['color']['a']
            }),
            this) : Math['round'](F['h']);
        }
        ['saturationv'] (p) {
          var F = c['rgbToHsv'](this['color']);
          return arguments['length'] ? (F['s'] = p,
            this['color'] = c['normalize']({
              'hsv': F,
              'a': this['color']['a']
            }),
            this) : F['s'];
        }
        ['value'] (p) {
          var F = c['rgbToHsv'](this['color']);
          return arguments['length'] ? (F['v'] = p,
            this['color'] = c['normalize']({
              'hsv': F,
              'a': this['color']['a']
            }),
            this) : F['v'];
        }
        ['saturation'] (p) {
          var F = c['rgbToHsl'](this['color']);
          return arguments['length'] ? (F['s'] = p,
            this['color'] = c['normalize']({
              'hsl': F,
              'a': this['color']['a']
            }),
            this) : F['s'];
        }
        ['lightness'] (p) {
          var F = c['rgbToHsl'](this['color']);
          return arguments['length'] ? (F['l'] = p,
            this['color'] = c['normalize']({
              'hsl': F,
              'a': this['color']['a']
            }),
            this) : F['l'];
        }
        ['alpha'] (p) {
          var F = this['color'];
          return arguments['length'] ? (F['a'] = p,
            this) : F['a'];
        }
        ['hexNumber'] () {
          return '0x' + ('0' + this['red']()['toString'](0x10))['slice'](-0x2) + ('0' + this['green']()['toString'](0x10))['slice'](-0x2) + ('0' + this['blue']()['toString'](0x10))['slice'](-0x2);
        }
        ['hexWidthAlpha'] () {
          var p = ('0' + Math['round'](0xff * this['alpha']())['toString'](0x10))['slice'](-0x2);
          return this['hex']() + p;
        }
        ['hex'] () {
          return '#' + ('0' + this['red']()['toString'](0x10))['slice'](-0x2) + ('0' + this['green']()['toString'](0x10))['slice'](-0x2) + ('0' + this['blue']()['toString'](0x10))['slice'](-0x2);
        }
        ['rgbaString'] () {
          var p, F;
          return 'rgba(' + this['red']() + ',' + this['green']() + ',' + this['blue']() + ',' + (null === (F = (p = this['alpha']())['toFixed']) || undefined === F ? undefined : F['call'](p, 0x2)) + ')';
        }
        ['hslString'] () {
          return 'hsl(' + this['hue']() + ',' + this['saturation']() + ',' + Math['round'](0x64 * this['lightness']()) / 0x64 + ')';
        }
        ['hslaString'] () {
          return 'hsla(' + this['hue']() + ',' + this['saturation']() + ',' + Math['round'](0x64 * this['lightness']()) / 0x64 + ',' + this['alpha']() + ')';
        }
        ['rgbNumber'] () {
          return this['red']() << 0x10 | this['green']() << 0x8 | this['blue']();
        }
        ['labObject'] () {
          return c['rgbToLab'](this['color']);
        }
        ['glNumberArray'] () {
          return [this['color']['r1'], this['color']['g1'], this['color']['Array2DGridDataProvider'], this['alpha']()];
        }
        ['getColor'] () {
          return this['color'];
        }
        ['equals'] (p) {
          var F = p;
          return arguments['length'] < 0x1 ? this === F : this['near'](F, 0x0);
        }
        ['near'] (p, F) {
          var y = this
            , w = p
            , h = (F = Math['abs'](undefined === F ? 0x0 : F)) / 0x64 * 0xff;
          return Math['abs'](w['red']() - y['red']()) <= h && Math['abs'](w['green']() - y['green']()) <= h && Math['abs'](w['blue']() - y['blue']()) <= h && Math['abs'](w['alpha']() - y['alpha']()) <= F / 0x64;
        }
        ['complement'] () {
          var p = new x(this['color']);
          return p['hue']((p['hue']() + 0xb4) % 0x168),
            p;
        }
        ['negate'] () {
          var p = new x(this['color']);
          return p['red'](0xff - p['red']()),
            p['green'](0xff - p['green']()),
            p['blue'](0xff - p['blue']()),
            p;
        }
        ['lighten'] (p) {
          var F = new x(this['color'])
            , y = c['clamp'](F['lightness']() + p / 0x64, 0x0, 0x1);
          return F['lightness'](y),
            F;
        }
        ['darken'] (p) {
          return this['lighten'](-p);
        }
        ['randomColorRange'] (p) {
          var F = (0x2 * Math['random']() - 0x1) * p
            , y = new x(this['color']);
          return y['lighten'](F);
        }
        ['saturate'] (p) {
          var F = p / 0x64
            , y = new x(this['color']);
          return y['saturation'](y['saturation']() + F),
            y;
        }
        ['desaturate'] (p) {
          var F = p / 0x64
            , y = new x(this['color']);
          return y['saturation'](y['saturation']() - F),
            y;
        }
        ['fadeIn'] (p) {
          var F = p / 0x64
            , y = new x(this['color']);
          return y['alpha'](y['alpha']() + F),
            y;
        }
        ['fadeOut'] (p) {
          var F = p / 0x64
            , y = new x(this['color']);
          return y['alpha'](y['alpha']() - F),
            y;
        }
        ['luma'] () {
          return 0.2126 * this['red']() + 0.7152 * this['green']() + 0.0722 * this['blue']();
        }
        ['grayscale'] () {
          return this['desaturate'](0x64);
        }
        ['isDark'] () {
          return (0x12b * this['red']() + 0x24b * this['green']() + 0x90 * this['blue']()) / 0x3e8 < 131.5;
        }
        ['isLight'] () {
          return !this['isDark']();
        }
        ['mix'] (p, F) {
          p = new x(p);
          var y = arguments['length'] < 0x2 ? 0.5 : F / 0x64;
          return new x({
            'r': this['red']() * (0x1 - y) + p['red']() * y,
            'g': this['green']() * (0x1 - y) + p['green']() * y,
            'b': this['blue']() * (0x1 - y) + p['blue']() * y,
            'a': this['alpha']() * (0x1 - y) + p['alpha']() * y
          });
        }
        ['contrast'] (p) {
          return p = new x(p),
            (Math['max'](this['red'](), p['red']()) - Math['min'](this['red'](), p['red']()) + Math['max'](this['green'](), p['green']()) - Math['min'](this['green'](), p['green']()) + Math['max'](this['blue'](), p['blue']()) - Math['min'](this['blue'](), p['blue']())) / 0x2fd;
        }
        ['gradient'] (p, F) {
          p = new x(p);
          for (var y = [], w = this['red'](), Y = this['green'](), T = this['blue'](), X = (p['red']() - this['red']()) / (F - 0x1), E = (p['green']() - this['green']()) / (F - 0x1), f = (p['blue']() - this['blue']()) / (F - 0x1), W = 0x0; W < F; W++)
            y['push'](new x({
              'r': w,
              'g': Y,
              'b': T
            })),
              w += X,
              Y += E,
              T += f;
          return y;
        }
        ['harmony'] (p, F) {
          F = 'number' == typeof F ? Math['abs'](parseInt(F, 0xa)) : 0x0;
          var y = []
            , w = c['rgbToHsv'](this['color'])
            , h = [0x0, 0xb4];
          switch (p) {
            case 'analogous':
              h = [0x0, 0x1e, 0x3c];
              break;
            case 'triad':
              h = [0x0, 0x78, 0xf0];
              break;
            case 'split-complementary':
              h = [0x0, 0x96, 0xd2];
              break;
            case 'rectangle':
              h = [0x0, 0x3c, 0xb4, 0xf0];
              break;
            case 'square':
              h = [0x0, 0x5a, 0xb4, 0x10e];
              break;
            case 'complementary':
              h = [0x0, 0xb4];
          }
          for (var Y = h['length'], T = h[F % Y], X = 0x0; X < Y; X++)
            y['push'](new x({
              'h': (w['h'] + h[X] - T) % 0x168,
              's': w['s'],
              'v': w['v'],
              'a': this['color']['a']
            }));
          return y;
        }
        static ['random'] () {
          return new x({
            'r': Math['floor'](0xff * Math['random']()),
            'g': Math['floor'](0xff * Math['random']()),
            'b': Math['floor'](0xff * Math['random']())
          });
        }
      }
    }
    ,
    0x260: (K, b, c) => {
      'use strict';
      c['d'](b, {
        'DY': () => H,
        'Mg': () => x,
        'NB': () => T
      });
      var H, x, p = c(0x39b), F = c(0xfb), y = c(0x1), w = c(0x346), Y = c(0x133);
      !function (X) {
        X['greater'] = 'greater',
          X['less'] = 'less',
          X['inside'] = 'inside',
          X['outside'] = 'outside';
      }(H || (H = {})),
        function (X) {
          X['class'] = 'class',
            X['less'] = 'less',
            X['less_and_equal'] = 'less_and_equal',
            X['greater'] = 'greater',
            X['greater_and_equal'] = 'greater_and_equal',
            X['unique'] = 'unique',
            X['equal'] = 'equal';
        }(x || (x = {}));
      class T {
        constructor(X, E) {
          this['options'] = X,
            this['stopConverter'] = E,
            X['fieldName'] && X['stops'] || (p['kg']['warn']('分段渲染需要提供字段名和分段配置！当前配置：'),
              p['kg']['error'](X)),
            this['options'] instanceof T && (this['options'] = {
              'stops': this['options']['stops'],
              'fieldName': this['options']['fieldName'],
              'action': this['options']['action']
            }),
            this['options']['action'] === x['unique'] || this['options']['action'] === x['equal'] ? (this['getCurrentRule'] = this['_getUniqueCurrentRule'],
              this['getPreRule'] = this['_getUniquePreRule'],
              this['getNextRule'] = this['_getUniqueNextRule'],
              this['getRuleIndex'] = this['_getUniqueRuleIndex'],
              this['getDesc'] = this['_getUniqueDesc']) : this['options']['action'] === x['greater'] ? (this['getCurrentRule'] = this['_getGreaterCurrentRule'],
                this['getPreRule'] = this['_getGreaterPreRule'],
                this['getNextRule'] = this['_getGreaterNextRule'],
                this['getRuleIndex'] = this['_getGreaterRuleIndex'],
                this['getDesc'] = this['_getGreaterDesc']) : this['options']['action'] === x['greater_and_equal'] ? (this['getCurrentRule'] = this['_getGreaterAndEqualCurrentRule'],
                  this['getPreRule'] = this['_getGreaterAndEqualPreRule'],
                  this['getNextRule'] = this['_getGreaterAndEqualNextRule'],
                  this['getRuleIndex'] = this['_getGreaterAndEqualRuleIndex'],
                  this['getDesc'] = this['_getGreaterAndEqualDesc']) : this['options']['action'] === x['less'] ? (this['getCurrentRule'] = this['_getLessCurrentRule'],
                    this['getPreRule'] = this['_getLessPreRule'],
                    this['getNextRule'] = this['_getLessNextRule'],
                    this['getRuleIndex'] = this['_getLessRuleIndex'],
                    this['getDesc'] = this['_getLessDesc']) : (this['getCurrentRule'] = this['_getClassCurrentRule'],
                      this['getPreRule'] = this['_getClassPreRule'],
                      this['getNextRule'] = this['_getClassNextRule'],
                      this['getRuleIndex'] = this['_getClassRuleIndex'],
                      this['getDesc'] = this['_getClassDesc']),
            this['originalOptions'] = JSON['parse'](JSON['stringify'](this['options'])),
            (0x0,
              y['Ov'])(this, this['options']),
            this['action'] || (this['action'] = x['class']),
            this['deserialize']();
        }
        ['deserialize'] () {
          let X = 0x0;
          for (const E of this['stops']) {
            if ('string' == typeof E['stop'] && E['stop']['trim']()['indexOf'](w['v']['fieldLoaderIndicator']) > 0x0) {
              const f = E['stop']['split'](w['v']['fieldLoaderIndicator'])
                , W = f[0x0]
                , I = f[0x1]['split']('?')
                , j = (0x0,
                  F['nA'])(I[0x0]);
              let D;
              j || (console['warn']('未能找到对应指定的loader' + f[0x1]),
                E['stop'] = W),
                I['length'] > 0x1 && (D = (0x0,
                  Y['vl'])(I[0x1]));
              const V = j(W, D);
              null == V && p['kg']['warn']('stop\x20rule中的loader返回了无效值！'),
                E['stop'] = V;
            }
            E['stop'] = this['stopConverter'] ? this['stopConverter'](E)['stop'] : E['stop'],
              E['idx'] = X++;
          }
        }
        static ['updateStopValuesByMaxMin'] (X, E, f, W = 0x1, I = 0x0, j = -0x1) {
          if (j = X['length'] - 0x1 + j,
            E = parseFloat(E),
            f = parseFloat(f),
            !(0x0,
              y['ri'])(E) || !(0x0,
                y['ri'])(f))
            return void p['kg']['warn']('用来更新色标的最大最小值错误！');
          const D = parseFloat((0x1 * (f - E) / (j - I))['toFixed'](W));
          for (let V = I; V < j; V++)
            X[V]['value'] = E + parseFloat(((V - I) * D)['toFixed'](W));
          X[j]['value'] = f;
        }
        ['updateValuesByMaxMin'] (X, E, f = 0x1, W = 0x0, I = -0x1) {
          T['updateStopValuesByMaxMin'](this['stops'], X, E, f, W, I);
        }
        ['getRule'] (X, E = 'current') {
          if (!this['stops'] || 0x0 === this['stops']['length'])
            throw new Error('尚未初始化该调色板');
          return 'next' === E ? this['getNextRule'](X) : 'pre' === E ? this['getPreRule'](X) : this['getCurrentRule'](X);
        }
        ['getVal'] (X, E) {
          let f = {}
            , W = E(X)
            , I = 0x0;
          for (let j of this['stops']) {
            if (W === E(j['stop']))
              break;
            I++;
          }
          return 0x0 === I ? f['max'] = this['stops'][0x0] : I >= this['stops']['length'] - 0x1 ? f['min'] = this['stops'][this['stops']['length'] - 0x1] : (f['min'] = this['stops'][I - 0x1],
            f['max'] = this['stops'][I]),
            f;
        }
        ['getVals'] () {
          return this['stops']['map'](X => X['value']);
        }
        ['getStops'] () {
          return this['stops']['map'](X => X['stop']);
        }
        ['clone'] (X = false, E = false) {
          const f = E ? this['originalOptions'] : this['options'];
          return new T(X ? JSON['parse'](JSON['stringify'](f)) : f);
        }
        ['reset'] () {
          (0x0,
            y['Ov'])(this, this['originalOptions']),
            this['deserialize']();
        }
        ['setOpacityByIndex'] (X, E, f, W) {
          if (X < 0x0 || X >= this['stops']['length'])
            return void p['kg']['warn']('开始序号超出了stop数量！');
          if (W = (0x0,
            y['En'])(W, this['stops']['length'] - 0x1),
            f = (0x0,
              y['En'])(f, 0x0),
            (0x0,
              y['ri'])(W) && (W < 0x0 || W >= this['stops']['length']))
            return void p['kg']['warn']('结束序号超出了stop数量！');
          if (X > W)
            return void p['kg']['warn']('开始序号大于了结束序号');
          const I = (j, D) => {
            for (let V = j; V <= D; V++)
              this['stops'][V]['stop']['alpha'](f);
          }
            ;
          E === H['greater'] ? I(X, this['stops']['length'] - 0x1) : E === H['less'] ? I(0x0, X - 0x1) : E === H['inside'] ? I(X + 0x1, W) : (I(0x0, X - 0x1),
            I(W, this['stops']['length'] - 0x1));
        }
        ['_getUniqueCurrentRule'] (X) {
          for (let E of this['stops'])
            if (X == E['value'])
              return E;
          return this['stops'][this['stops']['length'] - 0x1];
        }
        ['_getUniquePreRule'] (X) {
          for (let E = 0x0; E < this['stops']['length']; E++) {
            let f = this['stops'][E];
            if (X == f['value'])
              return 0x0 === E ? f : this['stops'][E - 0x1];
          }
          return this['stops'][this['stops']['length'] - 0x1];
        }
        ['_getUniqueNextRule'] (X) {
          for (let E = 0x0; E < this['stops']['length']; E++) {
            let f = this['stops'][E];
            if (X == f['value'])
              return E === this['stops']['length'] - 0x1 ? f : this['stops'][E + 0x1];
          }
          return this['stops'][this['stops']['length'] - 0x1];
        }
        ['_getUniqueRuleIndex'] (X) {
          for (let E = 0x0; E < this['stops']['length']; E++)
            if (X == this['stops'][E]['value'])
              return E;
          return this['stops']['length'] - 0x1;
        }
        ['_getUniqueDesc'] (X) {
          return this['getCurrentRule'](X)['value']['toString']();
        }
        ['_getClassCurrentRule'] (X) {
          for (let E of this['stops'])
            if (X <= E['value'])
              return E;
          return this['stops'][this['stops']['length'] - 0x1];
        }
        ['_getClassPreRule'] (X) {
          for (let E = 0x0; E < this['stops']['length']; E++) {
            let f = this['stops'][E];
            if (X <= f['value'])
              return 0x0 === E ? f : this['stops'][E - 0x1];
          }
          return this['stops'][this['stops']['length'] - 0x1];
        }
        ['_getClassNextRule'] (X) {
          for (let E = 0x0; E < this['stops']['length']; E++) {
            let f = this['stops'][E];
            if (X <= f['value'])
              return E === this['stops']['length'] - 0x1 ? f : this['stops'][E + 0x1];
          }
          return this['stops'][this['stops']['length'] - 0x1];
        }
        ['_getClassRuleIndex'] (X) {
          for (let E = 0x0; E < this['stops']['length']; E++)
            if (X <= this['stops'][E]['value'])
              return E;
          return this['stops']['length'] - 0x1;
        }
        ['_getClassDesc'] (X) {
          let E = this['getPreRule'](X);
          if (!E || E['value'] === X)
            return '<=' + X;
          let f = this['getNextRule'](X);
          return f && f['value'] !== X ? E['value'] + '-' + X : '>' + E['value'];
        }
        ['_getGreaterCurrentRule'] (X) {
          for (let E = this['stops']['length'] - 0x1; E >= 0x0; E--)
            if (X > this['stops'][E]['value'])
              return this['stops'][E];
          return this['stops'][this['stops']['length'] - 0x1];
        }
        ['_getGreaterPreRule'] (X) {
          for (let E = this['stops']['length'] - 0x1; E >= 0x0; E--) {
            let f = this['stops'][E];
            if (X > f['value'])
              return 0x0 === E ? f : this['stops'][E - 0x1];
          }
          return this['stops'][this['stops']['length'] - 0x1];
        }
        ['_getGreaterNextRule'] (X) {
          for (let E = this['stops']['length'] - 0x1; E >= 0x0; E--) {
            let f = this['stops'][E];
            if (X > f['value'])
              return E === this['stops']['length'] - 0x1 ? f : this['stops'][E + 0x1];
          }
          return this['stops'][this['stops']['length'] - 0x1];
        }
        ['_getGreaterRuleIndex'] (X) {
          for (let E = this['stops']['length'] - 0x1; E >= 0x0; E--)
            if (X > this['stops'][E]['value'])
              return E;
          return 0x0;
        }
        ['_getGreaterDesc'] (X) {
          let E = this['getNextRule'](X);
          return E && E['value'] !== X ? X + '-' + E['value'] : '>' + X;
        }
        ['_getGreaterAndEqualCurrentRule'] (X) {
          for (let E = this['stops']['length'] - 0x1; E >= 0x0; E--)
            if (X >= this['stops'][E]['value'])
              return this['stops'][E];
          return this['stops'][this['stops']['length'] - 0x1];
        }
        ['_getGreaterAndEqualPreRule'] (X) {
          for (let E = this['stops']['length'] - 0x1; E >= 0x0; E--) {
            let f = this['stops'][E];
            if (X >= f['value'])
              return 0x0 === E ? f : this['stops'][E - 0x1];
          }
          return this['stops'][this['stops']['length'] - 0x1];
        }
        ['_getGreaterAndEqualNextRule'] (X) {
          for (let E = this['stops']['length'] - 0x1; E >= 0x0; E--) {
            let f = this['stops'][E];
            if (X >= f['value'])
              return E === this['stops']['length'] - 0x1 ? f : this['stops'][E + 0x1];
          }
          return this['stops'][this['stops']['length'] - 0x1];
        }
        ['_getGreaterAndEqualRuleIndex'] (X) {
          for (let E = this['stops']['length'] - 0x1; E >= 0x0; E--)
            if (X >= this['stops'][E]['value'])
              return E;
          return 0x0;
        }
        ['_getGreaterAndEqualDesc'] (X) {
          let E = this['getNextRule'](X);
          return E && E['value'] !== X ? X + '-' + E['value'] : '>=' + X;
        }
        ['_getLessCurrentRule'] (X) {
          for (let E of this['stops'])
            if (X < E['value'])
              return E;
          return this['stops'][this['stops']['length'] - 0x1];
        }
        ['_getLessPreRule'] (X) {
          for (let E = 0x0; E < this['stops']['length']; E++) {
            let f = this['stops'][E];
            if (X < f['value'])
              return 0x0 === E ? f : this['stops'][E - 0x1];
          }
          return this['stops'][this['stops']['length'] - 0x1];
        }
        ['_getLessNextRule'] (X) {
          for (let E = 0x0; E < this['stops']['length']; E++) {
            let f = this['stops'][E];
            if (X < f['value'])
              return E === this['stops']['length'] - 0x1 ? f : this['stops'][E + 0x1];
          }
          return this['stops'][this['stops']['length'] - 0x1];
        }
        ['_getLessRuleIndex'] (X) {
          for (let E = 0x0; E < this['stops']['length']; E++)
            if (X < this['stops'][E]['value'])
              return E;
          return this['stops']['length'] - 0x1;
        }
        ['_getLessDesc'] (X) {
          let E = this['getPreRule'](X);
          if (!E || E['value'] === X)
            return '<' + X;
          let f = this['getNextRule'](X);
          return f && f['value'] !== X ? E['value'] + '-' + X : '>' + E['value'];
        }
      }
    }
    ,
    0x133: (l, K, i) => {
      'use strict';
      i['d'](K, {
        '$P': () => F,
        '$k': () => s,
        'LH': () => r,
        'Uw': () => w,
        'it': () => p,
        'lW': () => y,
        'vl': () => x
      });
      var b = i(0x39b)
        , e = i(0x13c)
        , c = i(0xfb)
        , H = i(0x346)
        , t = i(0x1de);
      function x (h, u = '&', Y = '=') {
        const T = {};
        if (!h || 0x0 === h['trim']()['length'])
          return T;
        const X = h['split'](u)
          , E = [];
        for (var f = 0x0; f < X['length']; f++) {
          var W = X[f]['indexOf'](Y);
          let I, j;
          -0x1 == W ? (I = X[f],
            j = undefined) : (I = X[f]['substring'](0x0, W),
              j = X[f]['substring'](W + 0x1)),
            T[I] = j,
            E['push'](I);
        }
        return T['__order'] = E,
          T;
      }
      function p (h) {
        var u;
        if (null != h) {
          if ('string' == typeof h) {
            if (h = h['trim'](),
              0x0 === h['length'] || h['startsWith'](H['v']['fieldPropertiesIndicator']) || h['startsWith'](H['v']['fieldLoaderIndicator']))
              return h;
            if (h['indexOf'](H['v']['fieldLoaderIndicator']) > 0x0) {
              const Y = h['split'](H['v']['fieldLoaderIndicator'])
                , T = Y[0x1]['split']('?')
                , X = (0x0,
                  c['nA'])(T[0x0]);
              if (X) {
                if (T['length'] > 0x1) {
                  const E = x(T[0x1]);
                  h = X(Y[0x0], E);
                } else
                  h = X(Y[0x0], {});
              } else
                b['kg']['warn']('当前字段' + Y[0x0] + '的loader未找到，将直接使用字段值！'),
                  h = Y[0x0];
            } else
              e['Zc']['hasResource'](h) && (h = null === (u = e['Zc']['getResource'](h)) || undefined === u ? undefined : u['instance']);
            if ('string' == typeof h && h['trim']()['startsWith'](H['v']['functionIndicator'])) {
              h = h['trim']();
              const f = eval(h['substring'](H['v']['functionIndicator']['length']));
              return 'function' == typeof f ? (...W) => f(...W) : h;
            }
            return h;
          }
          return h;
        }
        b['kg']['warn']('字段配置为空！');
      }
      const F = h => h['startsWith']('0x') ? (h = '#' + h['slice'](0x2),
        new t['t'](h)) : new t['t'](h)
        , y = h => {
          const u = '#' + h['toString'](0x10);
          return F(u);
        }
        , r = h => 0x3 === h['length'] ? new t['t']({
          'r': h[0x0],
          'g': h[0x1],
          'b': h[0x2]
        }) : new t['t']({
          'r': h[0x0],
          'g': h[0x1],
          'b': h[0x2],
          'a': h[0x3]
        });
      class w {
        constructor(h) {
          this['sourceOptions'] = h,
            this['_cache'] = {},
            this['styleName'] = 'qeStyle';
        }
        ['isStyle'] () {
          return true;
        }
        ['getPublicKeys'] () {
          const h = Object['keys'](this)
            , u = [];
          for (const Y of h)
            Y['startsWith']('_') || u['push'](Y);
          return u;
        }
        ['clearCaches'] () {
          this['_cache'] = {};
          const h = this['getPublicKeys']();
          for (const u of h) {
            if ('string' != typeof u) {
              b['kg']['warn']('key不是字符串！');
              continue;
            }
            const Y = this[u]
              , T = X => {
                if (undefined !== X && null != X) {
                  if (X['isStyle'] && X['isStyle']())
                    X['clearCaches'] && X['clearCaches']();
                  else {
                    if (X instanceof Array) {
                      for (const E of X)
                        T(E);
                    }
                  }
                }
              }
              ;
            T(Y);
          }
        }
        ['update'] (h, u = false) {
          if (this['_cache'] = {},
            u) {
            const T = this['getPublicKeys']();
            for (const X of T)
              this[X] = undefined;
            return void this['_update'](h, true);
          }
          const Y = Object['assign']({}, h);
          for (const E of Object['keys'](h))
            undefined === h[E] && this[E] && (this[E] = undefined,
              delete Y[E]);
          this['_update'](Y, false);
        }
        ['getPlaneOptions'] (h, u = true, Y) {
          const T = this['_createCacheId'](h);
          if (u && undefined !== this['_cache'][T])
            return this['_cache'][T];
          const X = {}
            , E = this['getPublicKeys']();
          for (const f of E) {
            if ('string' != typeof f) {
              b['kg']['warn']('key不是字符串！');
              continue;
            }
            const W = this[f]
              , I = j => {
                if (undefined !== j && null != j) {
                  if (j['isStyle'] && j['isStyle']())
                    return j['getPlaneOptions'](h, u, Y);
                  if (j instanceof Array) {
                    const D = [];
                    for (const V of j)
                      D['push'](I(V));
                    return D;
                  }
                  return 'function' == typeof j ? j(h, Y) : j;
                }
              }
              ;
            X[f] = I(W);
          }
          return u && T && (this['_cache'][T] = X),
            X;
        }
      }
      const s = h => (h['stop'] instanceof t['t'] || ('string' == typeof h['stop'] ? h['stop'] = F(h['stop']) : 'number' == typeof h['stop'] ? h['stop'] = y(h['stop']) : h['stop'] instanceof Array ? h['stop'] = r(h['stop']) : 'object' != typeof h['stop'] || undefined === h['stop']['r'] && undefined === h['stop']['red'] ? b['kg']['error']('调色板中不能识别的颜色配置：' + h['stop']) : h['stop'] = new t['t'](h['stop'])),
        h);
    }
    ,
    0x60: (l, K, i) => {
      'use strict';
      var b;
      i['d'](K, {
        'U': () => b
      }),
        function (c) {
          c[c['Int8'] = 0x0] = 'Int8',
            c[c['UInt8'] = 0x1] = 'UInt8',
            c[c['Int16'] = 0x2] = 'Int16',
            c[c['UInt16'] = 0x3] = 'UInt16',
            c[c['Int32'] = 0x4] = 'Int32',
            c[c['UInt32'] = 0x5] = 'UInt32',
            c[c['Float32'] = 0x6] = 'Float32',
            c[c['Float64'] = 0x7] = 'Float64';
        }(b || (b = {}));
    }
    ,
    0x24d: (l, K, b) => {
      'use strict';
      b['d'](K, {
        'r': () => x
      });
      var c = b(0x393)
        , H = b(0x1);
      class x extends c['c'] {
        constructor(p) {
          super(),
            this['eventNames'] = {
              'tChanged': 'tChanged',
              'zChanged': 'zChanged',
              'tzChanged': 'tzChanged',
              'iTChanged': 'iTChanged',
              'iZChanged': 'iZChanged',
              'iTZChanged': 'iTZChanged',
              'activeTZDataUpated': 'activeTZDataUpated'
            },
            this['meta'] = {},
            this['_currentTIdx'] = 0x0,
            this['_currentZIdx'] = 0x0,
            this['grids'] = [],
            this['options'] = (0x0,
              H['Ov'])(this['options'], p, {
                'maxTimeCount': 0x0
              });
        }
        ['addGridTo'] (p, F, y, w, h, u) {
          F = parseInt(F),
            y = parseInt(y);
          const Y = this['getIntTIdx']()
            , T = this['getIntZIdx']();
          return u[F] = u[F] || [],
            u[F][y] = p,
            this['gridOptions']['tCount'] = u['length'],
            (0x0,
              H['ri'])(w) && this['gridOptions']['zValues'] && (this['gridOptions']['zValues'][y] = w),
            F === Y && y === T ? this['fire'](this['eventNames']['activeTZDataUpated'], {
              'firer': this,
              'msg': this
            }) : h && (this['lock'](),
              this['currentTIdx'] = F,
              this['currentZIdx'] = y,
              this['unlock']()),
            this;
        }
        get ['currentTIdx'] () {
          return this['_currentTIdx'];
        }
        set ['currentTIdx'] (p) {
          if (this['grids'] && p >= this['grids']['length'])
            return;
          if (p === this['currentTIdx'])
            return;
          const F = this['getIntTIdx']();
          this['_currentTIdx'] = p,
            F !== this['getIntTIdx']() ? (this['fire'](this['eventNames']['iTChanged'], {
              'firer': this,
              'msg': this
            }),
              this['fire'](this['eventNames']['iTZChanged'], {
                'firer': this,
                'msg': this
              })) : (this['fire'](this['eventNames']['tChanged'], {
                'firer': this,
                'msg': this
              }),
                this['fire'](this['eventNames']['tzChanged'], {
                  'firer': this,
                  'msg': this
                }));
        }
        get ['currentZIdx'] () {
          return this['_currentZIdx'];
        }
        set ['currentZIdx'] (p) {
          var F;
          if (this['grids'] && p >= (null === (F = this['grids'][this['getIntTIdx']()]) || undefined === F ? undefined : F['length']))
            return;
          if (p === this['currentZIdx'])
            return;
          const y = this['getIntZIdx']();
          this['_currentZIdx'] = p,
            y !== this['getIntZIdx']() ? (this['fire'](this['eventNames']['iZChanged'], {
              'firer': this,
              'msg': this
            }),
              this['fire'](this['eventNames']['iTZChanged'], {
                'firer': this,
                'msg': this
              })) : (this['fire'](this['eventNames']['zChanged'], {
                'firer': this,
                'msg': this
              }),
                this['fire'](this['eventNames']['tzChanged'], {
                  'firer': this,
                  'msg': this
                }));
        }
        ['centerLon'] () {
          return (this['gridOptions']['xStart'] + this['gridOptions']['xEnd']) / 0x2;
        }
        ['centerLat'] () {
          return (this['gridOptions']['yStart'] + this['gridOptions']['yEnd']) / 0x2;
        }
        ['centerZ'] () {
          var p, F, y;
          return (null === (p = this['gridOptions']) || undefined === p ? undefined : p['zValues']['length']) > 0x1 ? (this['gridOptions']['zValues'][0x0] + this['gridOptions']['zValues'][this['gridOptions']['zValues']['length'] - 0x1]) / 0x2 : null !== (y = null === (F = this['gridOptions']) || undefined === F ? undefined : F['zValues'][0x0]) && undefined !== y ? y : 0x0;
        }
        ['center'] () {
          return {
            'lon': this['centerLon'](),
            'lat': this['centerLat'](),
            'z': this['centerZ']()
          };
        }
        ['getGrid'] (p, F) {
          var y, w;
          return undefined === p && (p = this['getIntTIdx']()),
            undefined === F && (F = this['getIntZIdx']()),
            null === (w = null === (y = this['grids']) || undefined === y ? undefined : y[p]) || undefined === w ? undefined : w[F];
        }
        ['allGrids'] () {
          return this['grids'];
        }
        ['updateGrid'] (p, F, y, w, h) {
          return this['addGridTo'](p, F, y, w, h, this['allGrids']());
        }
        ['getIntTIdx'] () {
          return parseInt(this['_currentTIdx']);
        }
        ['getIntZIdx'] () {
          return parseInt(this['_currentZIdx']);
        }
        ['onTChanged'] (p) {
          return this['on'](this['eventNames']['tChanged'], p),
            this;
        }
        ['onZChanged'] (p) {
          return this['on'](this['eventNames']['zChanged'], p),
            this;
        }
        ['onTZChanged'] (p) {
          return this['on'](this['eventNames']['tzChanged'], p),
            this;
        }
        ['onIntTChanged'] (p) {
          return this['on'](this['eventNames']['iTChanged'], p),
            this;
        }
        ['onIntZChanged'] (p) {
          return this['on'](this['eventNames']['iZChanged'], p),
            this;
        }
        ['onIntTZChanged'] (p) {
          return this['on'](this['eventNames']['iTZChanged'], p),
            this;
        }
        ['offTChanged'] (p) {
          return this['off'](this['eventNames']['tChanged'], p),
            this;
        }
        ['offZChanged'] (p) {
          return this['off'](this['eventNames']['zChanged'], p),
            this;
        }
        ['offTZChanged'] (p) {
          return this['off'](this['eventNames']['tzChanged'], p),
            this;
        }
        ['offIntTChanged'] (p) {
          return this['off'](this['eventNames']['iTChanged'], p),
            this;
        }
        ['offIntZChanged'] (p) {
          return this['off'](this['eventNames']['iZChanged'], p),
            this;
        }
        ['offIntTZChanged'] (p) {
          return this['off'](this['eventNames']['iTZChanged'], p),
            this;
        }
        ['onActiveGridUpdated'] (p) {
          return this['on'](this['eventNames']['activeTZDataUpated'], p),
            this;
        }
        ['offActiveGridUpdated'] (p) {
          return this['off'](this['eventNames']['activeTZDataUpated'], p),
            this;
        }
        ['pickValue'] (p, F, y, w) {
          const h = this['getGrid'](y, w);
          if (!h)
            return;
          const u = (0x0,
            H['tr'])(this['gridOptions']['xStart'], this['gridOptions']['xDelta'], p)
            , Y = (0x0,
              H['tr'])(this['gridOptions']['yStart'], this['gridOptions']['yDelta'], F);
          return h['read2D'](Y, u);
        }
      }
    }
    ,
    0x1ca: (l, K, b) => {
      'use strict';
      b['d'](K, {
        'o': () => H
      });
      var c = b(0x24d);
      class H extends c['r'] {
        constructor(x, p) {
          var F;
          super(p),
            this['grids'] = x || [],
            this['gridOptions'] = this['options']['gridOptions'],
            this['meta'] = null !== (F = this['options']['meta']) && undefined !== F ? F : {};
        }
      }
    }
    ,
    0x11d: (l, K, i) => {
      'use strict';
      i['d'](K, {
        'Bn': () => j,
        'b_': () => W,
        'cF': () => I,
        'ko': () => f
      });
      var b = ['byte', 'int', 'uint', 'int16', 'uint16', 'int32', 'uint32', 'float32', 'float64', 'string', 'url', 'alias']
        , e = ['Sequence', 'Structure', 'Dataset']
        , c = '(\x5c\x5c=|\x5c\x5c\x5c]|[^\x5c]=])+'
        , H = '\x5cd+'
        , t = '\x5cw+'
        , x = '(\x5c\x5c;|\x5c\x5c\x5c[|[^\x5c[;])+'
        , p = '(\x5c\x5c;|[^;])+'
        , F = '(\x5c\x5c;|[^;])+'
        , y = '\x22.*?[^\x5c\x5c]\x22|[^;,]+'
        , r = '\x5cw+'
        , w = '(\x5c\x5c\x5cs|[^\x5cs])+'
        , s = '(\x5c\x5c{|[^{])+'
        , h = '(\x5c\x5c{|[^{])+'
        , u = '\x22.*?[^\x5c\x5c]\x22|[^;,]+'
        , Y = '\x22(\x5c\x5c\x5c\x5c|\x5c\x5c\x22|[^\x22])*\x22'
        , T = '\x5cw+'
        , X = '\x22.*?[^\x5c\x5c]\x22|[^;,]+';
      function E (D) {
        return eval('(' + D + ')');
      }
      class f {
        constructor(D) {
          this['type'] = D,
            this['attributes'] = {};
        }
      }
      class W {
        constructor(D) {
          this['stream'] = D;
        }
        ['peek'] (D) {
          var V = new RegExp('^' + D, 'i')
            , Z = this['stream']['match'](V);
          return Z ? Z[0x0] : '';
        }
        ['consume'] (D) {
          var V = new RegExp('^' + D, 'i')
            , Z = this['stream']['match'](V);
          if (Z)
            return this['stream'] = this['stream']['substr'](Z[0x0]['length'])['trimStart'](),
              Z[0x0];
          throw new Error('Unable\x20to\x20parse\x20stream:\x20' + this['stream']['substr'](0x0, 0xa));
        }
      }
      class I extends W {
        ['parse'] () {
          return this['_dataset']();
        }
        ['_dataset'] () {
          var D = new f('Dataset');
          for (this['consume']('dataset'),
            this['consume']('{'); !this['peek']('}');) {
            var V = this['_declaration']();
            D[V['name']] = V;
          }
          return this['consume']('}'),
            D['id'] = D['name'] = this['consume'](p)['trim'](),
            this['consume'](';'),
            function Z (B, S) {
              for (var U in B) {
                var d = B[U];
                d['type'] && (d['id'] = d['name'],
                  S && (d['id'] = B['id'] + '.' + d['id']),
                  Z(d, true));
              }
            }(D, false),
            D;
        }
        ['_declaration'] () {
          switch (this['peek'](t)['toLowerCase']()) {
            case 'grid':
              return this['_grid']();
            case 'structure':
              return this['_structure']('Structure');
            case 'sequence':
              return this['_structure']('Sequence');
            default:
              return this['_base_declaration']();
          }
        }
        ['_base_declaration'] () {
          var D = new f();
          for (D['type'] = this['consume'](t)['trim'](),
            D['name'] = this['consume'](x)['trim'](),
            D['dimensions'] = [],
            D['shape'] = []; !this['peek'](';');) {
            this['consume']('\x5c[');
            var V = this['consume'](c)['trim']();
            this['peek']('=') && (D['dimensions']['push'](V),
              this['consume']('='),
              V = this['consume'](H)['trim']()),
              D['shape']['push'](parseInt(V)),
              this['consume']('\x5c]');
          }
          return this['consume'](';'),
            D;
        }
        ['_grid'] () {
          var D = new f('Grid');
          for (this['consume']('grid'),
            this['consume']('{'),
            this['consume']('array'),
            this['consume'](':'),
            D['array'] = this['_base_declaration'](),
            this['consume']('maps'),
            this['consume'](':'),
            D['maps'] = {}; !this['peek']('}');) {
            var V = this['_base_declaration']();
            D['maps'][V['name']] = V;
          }
          return this['consume']('}'),
            D['name'] = this['_name'](),
            D;
        }
        ['_structure'] (D) {
          var V = new f(D);
          for (this['consume'](D),
            this['consume']('{'); !this['peek']('}');) {
            var Z = this['_declaration']();
            V[Z['name']] = Z;
          }
          return this['consume']('}'),
            V['name'] = this['_name'](),
            V;
        }
        ['_name'] () {
          var D = this['consume'](F)['trim']();
          return this['consume'](';'),
            D;
        }
      }
      class j extends W {
        constructor(D, V) {
          super(D),
            this['dataset'] = V;
        }
        ['parse'] () {
          for (this['_target'] = this['dataset'],
            this['consume']('attributes'),
            this['consume']('{'); !this['peek']('}');)
            this['_attr_container']();
          return this['consume']('}'),
            this['dataset'];
        }
        ['_attr_container'] () {
          if (-0x1 !== b['indexOf'](this['peek'](T)['toLowerCase']())) {
            if (this['_attribute'](this['_target']['attributes']),
              'Grid' === this['_target']['type']) {
              for (var D in this['_target']['maps'])
                if (this['dataset'][D]) {
                  var V = this['_target']['maps'][D];
                  for (var Z in V['attributes'])
                    this['dataset'][D]['attributes'][Z] = V['attributes'][Z];
                }
            }
          } else
            this['_container']();
        }
        ['_container'] () {
          var D, V = this['consume'](s)['trim']();
          if (this['consume']('{'),
            V['indexOf']('.') > -0x1) {
            var Z = V['split']('.');
            D = this['_target'];
            for (var B = 0x0; B < Z['length']; B++)
              this['_target'] = this['_target'][Z[B]];
            for (; !this['peek']('}');)
              this['_attr_container']();
            this['consume']('}'),
              this['_target'] = D;
          } else {
            if (e['includes'](this['_target']['type']) && this['_target'][V]) {
              for (D = this['_target'],
                this['_target'] = D[V]; !this['peek']('}');)
                this['_attr_container']();
              this['consume']('}'),
                this['_target'] = D;
            } else
              this['_target']['attributes'][V] = this['_metadata'](),
                this['consume']('}');
          }
        }
        ['_metadata'] () {
          for (var D = {}; !this['peek']('}');)
            if (b['includes'](this['peek'](T)['toLowerCase']()))
              this['_attribute'](D);
            else {
              var V = this['consume'](h)['trim']();
              this['consume']('{'),
                D[V] = this['_metadata'](),
                this['consume']('}');
            }
          return D;
        }
        ['_attribute'] (D) {
          for (var V, Z = this['consume'](r)['trim'](), B = this['consume'](w)['trim'](), S = []; !this['peek'](';');) {
            if ('string' === Z['toLowerCase']())
              V = (V = this['consume'](Y)['trim']())['substr'](0x1, V['length'] - 0x2);
            else {
              if ('url' === Z['toLowerCase']())
                V = this['consume'](X)['trim']();
              else {
                if ('alias' === Z['toLowerCase']()) {
                  var U, d;
                  (V = this['consume'](y)['trim']())['match'](/^\\./) ? (d = V['substring'](0x1)['split']('.'),
                    U = this['dataset']) : (d = V['split']('.'),
                      U = this['_target']);
                  for (var q = 0x0; q < d['length']; q++) {
                    var J = d[q];
                    V = U = U[J] ? U[J] : U['array']['name'] === J ? U['array'] : U['maps'][J] ? U['maps'][J] : U['attributes'][J];
                  }
                } else
                  V = 'nan' === (V = this['consume'](u)['trim']())['toLowerCase']() ? NaN : 'inf' === V['toLowerCase']() ? 0x1 / 0x0 : '-inf' === V['toLowerCase']() ? -0x1 / 0x0 : E(V);
              }
            }
            S['push'](V),
              this['peek'](',') && this['consume'](',');
          }
          this['consume'](';'),
            0x1 === S['length'] && (S = S[0x0]),
            D[B] = S;
        }
      }
    }
    ,
    0x39b: (l, K, b) => {
      'use strict';
      b['d'](K, {
        '$V': () => H,
        'kg': () => x,
        'qr': () => p
      });
      var c = b(0x346);
      class H {
        ['error'] (F, y = true, w = undefined, h = undefined) {
          h && h(F);
          const u = w && w['name'] ? '[' + w['name'] + ']' : '';
          if ('object' == typeof F ? console['log'](F) : console['error']('%c[error]' + u + '\x20' + F, H['DefaultStyles']['errorStyle']),
            y)
            throw new Error(F);
        }
        ['warn'] (F, y = undefined, w = undefined) {
          w && w(F);
          const h = y && y['name'] ? '[' + y['name'] + ']' : '';
          console['warn']('%c[warn]' + h + '\x20' + F, H['DefaultStyles']['warnStyle']);
        }
        ['log'] (F, y = undefined, w = undefined) {
          w && w(F);
          const h = y && y['name'] ? '[' + y['name'] + ']' : '';
          'object' == typeof F ? (console['log']('%c[info]', H['DefaultStyles']['logStyle']),
            console['log'](F)) : console['log']('%c[info]' + h + '\x20' + F, H['DefaultStyles']['logStyle']);
        }
        ['debug'] (F, y = undefined, w = undefined) {
          w && w(F);
          const h = y && y['name'] ? '[' + y['name'] + ']' : ''
            , u = '[debug][' + new Date()['toLocaleString']() + ']';
          'object' == typeof F ? (console['log']('' + u),
            console['log'](F)) : console['log']('' + u + h + '\x20' + F);
        }
        ['note'] (F, y = undefined, w = undefined) {
          w && w(F);
          const h = y && y['name'] ? '[' + y['name'] + ']' : ''
            , u = '[note][' + new Date()['toLocaleString']() + ']';
          'object' == typeof F ? (console['log']('%c' + u),
            console['log'](F)) : console['log']('%c' + u + h + '\x20******' + F + '******', H['DefaultStyles']['noteStyle']);
        }
        ['custom'] (F, y, w = undefined, h = undefined) {
          h && h(F);
          const u = w && w['name'] ? '[' + w['name'] + ']' : ''
            , Y = '[custom][' + new Date()['toLocaleString']() + ']';
          'object' == typeof F ? (console['log']('%c' + Y, y || 'color:black'),
            console['log'](F)) : console['log']('%c' + Y + u + '\x20' + F, y || 'color:black');
        }
      }
      H['DefaultStyles'] = {
        'logStyle': 'color:blue',
        'warnStyle': 'color:orange',
        'errorStyle': 'color:red',
        'noteStyle': 'color:green;font:bold'
      };
      const x = new H()
        , p = () => {
          c['v']['Debug'] || (x['debug'] = (F, y = undefined) => { }
          );
        }
        ;
    }
    ,
    0x13c: (K, H, x) => {
      'use strict';
      x['d'](H, {
        'GB': () => U,
        'I$': () => S,
        'MM': () => V,
        'Xf': () => Z,
        'Zc': () => G,
        'gD': () => J,
        'pQ': () => B,
        'qg': () => q,
        'xR': () => C,
        'zc': () => O
      });
      var F = x(0x346)
        , Y = x(0x393)
        , T = x(0x19d)
        , X = x(0x260)
        , E = x(0x1)
        , W = x(0x39b)
        , I = x(0x17a)
        , j = x['n'](I)
        , D = function (N, P, M, z) {
          return new (M || (M = Promise))(function (Q, L) {
            function R (v2) {
              try {
                v1(z['next'](v2));
              } catch (v3) {
                L(v3);
              }
            }
            function v0 (v2) {
              try {
                v1(z['throw'](v2));
              } catch (v3) {
                L(v3);
              }
            }
            function v1 (v2) {
              var v3;
              v2['done'] ? Q(v2['value']) : (v3 = v2['value'],
                v3 instanceof M ? v3 : new M(function (v4) {
                  v4(v3);
                }
                ))['then'](R, v0);
            }
            v1((z = z['apply'](N, P || []))['next']());
          }
          );
        };
      const V = {
        'images': 'images',
        'stopRules': 'stopRules',
        'featureStyles': 'featureStyles',
        'gridStyles': 'gridStyles',
        'jsonFiles': 'jsonFiles',
        'rawFiles': 'rawFiles',
        'texts': 'texts',
        'colorScales': 'colorScales'
      }
        , Z = N => D(undefined, undefined, undefined, function* () {
          let { resourceType: P, requestInfo: M, init: z, key: Q } = N;
          const L = {
            'source': N,
            'resourceType': P
          };
          return N instanceof HTMLImageElement || N instanceof HTMLCanvasElement || N instanceof HTMLVideoElement ? (L['instance'] = N,
            Promise['resolve'](L)) : new Promise((R, v0) => {
              if ('string' == typeof M) {
                const v1 = document['createElement']('img');
                v1['crossOrigin'] = '',
                  v1['onload'] = () => {
                    L['instance'] = v1,
                      R(L);
                  }
                  ,
                  v1['onerror'] = v2 => {
                    v0(v2);
                  }
                  ,
                  v1['src'] = M;
              } else
                W['kg']['error']('不支持的图片资源构建器参数：' + M, true, undefined, v0);
            }
            );
        })
        , B = (N, P, M, z = true) => D(undefined, undefined, undefined, function* () {
          let { resourceType: Q, requestInfo: L, init: R, key: v0 } = N;
          const v1 = {
            'source': N,
            'resourceType': Q
          };
          return P(L) ? (v1['instance'] = L,
            W['kg']['warn']('当前资源存放的是实例而不是实例的构造参数！' + v0),
            Promise['resolve'](v1)) : M(L) ? (v1['instance'] = L,
              Promise['resolve'](v1)) : qeFetch(L)['then'](v2 => 'string' == typeof L && L['endsWith']('zip') || L instanceof Request && L['url']['endsWith']('zip') ? v2['arrayBuffer']()['then'](v3 => new (j())()['loadAsync'](v3)['then'](v4 => D(undefined, undefined, undefined, function* () {
                Object['keys'](v4['files'])['length'];
                for (let v5 in v4['files']) {
                  let v6 = v5;
                  if (!(v6['indexOf']('MACOSX') >= 0x0))
                    return v4['files'][v6]['async'](z ? 'text' : 'arraybuffer')['then'](v7 => Promise['resolve'](z ? JSON['parse'](v7) : v7));
                }
              }))['catch'](W['kg']['debug']))['catch'](W['kg']['debug']) : z ? v2['json']() : v2['arrayBuffer']())['then'](v2 => (v1['instance'] = v2,
                Promise['resolve'](v1)))['catch'](W['kg']['debug']);
        })
        , S = N => D(undefined, undefined, undefined, function* () {
          return B(N, P => false, P => 'object' == typeof P);
        })
        , U = N => D(undefined, undefined, undefined, function* () {
          return B(N, P => P instanceof ArrayBuffer, P => false, false);
        })
        , q = N => D(undefined, undefined, undefined, function* () {
          return B(N, P => P instanceof X['NB'], P => 'object' == typeof P && P['stops']);
        })
        , J = N => D(undefined, undefined, undefined, function* () {
          return B(N, P => P instanceof T['sC'], P => 'object' == typeof P && (P['point'] || P['polygon'] || P['polyline'] || 0x0 === Object['keys'](P)['length']));
        })
        , C = N => D(undefined, undefined, undefined, function* () {
          return B(N, P => 'gridStyle' === (null == P ? undefined : P['styleName']), P => 'object' == typeof P);
        });
      class O extends Y['c'] {
        constructor() {
          super(...arguments),
            this['registerCreator'] = O['registerCreator'],
            this['creators'] = O['creators'],
            this['resources'] = {};
        }
        static ['registerCreator'] (N, P) {
          O['creators'][N] && W['kg']['warn']('名为' + N + '的资源构建器已经存在，将使用新的替换！'),
            O['creators'][N] = P;
        }
        get ['allResources'] () {
          return this['resources'];
        }
        ['addResource'] (N, P, M = false) {
          if (!N || !this['hasResource'](N) || M) {
            if (P && P['instance'] && P['resourceType'] || W['kg']['error']('资源信息中的实例、类型不能为空！'),
              this['hasResource'](N)) {
              const z = this['getResource'](N);
              this['resources'][N] = P,
                this['fire'](O['EventTypes']['resUpdated'], {
                  'firer': this,
                  'msg': {
                    'oldResource': z,
                    'newResource': P
                  }
                }),
                this['fire'](O['EventTypes']['resUpdated'] + ':' + N, {
                  'firer': this,
                  'msg': {
                    'oldResource': z,
                    'newResource': P
                  }
                })
              // W['kg']['debug']('资源' + N + '已更新！');
            } else
              this['resources'][N] = P,
                this['fire'](O['EventTypes']['resAdd'], {
                  'firer': this,
                  'msg': P
                }),
                this['fire'](O['EventTypes']['resAdd'] + ':' + N, {
                  'firer': this,
                  'msg': P
                });
            this['fire'](O['EventTypes']['resLoaded'], {
              'firer': this,
              'msg': P
            }),
              this['fire'](O['EventTypes']['resLoaded'] + ':' + N, {
                'firer': this,
                'msg': P
              })
            // W['kg']['debug']('资源' + N + '已增加！');
          }
        }
        ['loadResource'] (N, P = false) {
          return D(this, undefined, undefined, function* () {
            if (N['key'] && this['hasResource'](N['key']) && !P)
              return Promise['resolve'](this['getResource'](N['key']));
            const M = this['creators'][N['resourceType']];
            if (!M)
              return W['kg']['error']('尚未注册类型为' + N['resourceType'] + '的资源构建器！'),
                Promise['reject']('尚未注册类型为' + N['resourceType'] + '的资源构建器！');
            'string' == typeof N['requestInfo'] && (N['requestInfo']['startsWith']('http') || N['requestInfo']['startsWith']('/') || (N['requestInfo'] = F['v']['resourcePath'] + '/' + N['requestInfo']));
            const z = yield M(N)['catch'](W['kg']['debug']);
            if (!z)
              throw W['kg']['error']('构建资源实例失败'),
              '构建资源实例失败！';
            return z['resourceType'] || (z['resourceType'] = N['resourceType']),
              this['addResource'](N['key'], z, P),
              z;
          });
        }
        ['loadResources'] (N) {
          return D(this, undefined, undefined, function* () {
            if (!N || 0x0 === N['length'])
              return Promise['resolve']([]);
            const P = [];
            for (const M of N) {
              const z = yield this['loadResource'](M)['catch'](W['kg']['debug']);
              P['push'](z);
            }
            return Promise['resolve'](P);
          });
        }
        ['loadResourceFromConfig'] (N, P = false) {
          return D(this, undefined, undefined, function* () {
            if (!N || 0x0 === Object['keys'](N)['length'])
              return Promise['resolve']([]);
            const M = (v7, v8) => D(this, undefined, undefined, function* () {
              if (!v7)
                return Promise['resolve']([]);
              const v9 = [];
              for (const vv in v7) {
                const vA = v7[vv]
                  , vn = {
                    'resourceType': v8,
                    'requestInfo': vA,
                    'key': vv
                  }
                  , vk = yield this['loadResource'](vn, P)['catch'](W['kg']['debug']);
                v9['push'](vk);
              }
              return Promise['resolve'](v9);
            })
              , z = Object['assign']({}, N)
              , Q = N
              , L = [];
            if (Q['texts'])
              for (const v7 in Q['texts']) {
                const v8 = {
                  'resourceType': V['texts'],
                  'source': {
                    'resourceType': V['texts'],
                    'requestInfo': undefined,
                    'key': v7
                  },
                  'instance': Q['texts'][v7]
                };
                this['addResource'](v7, v8, true),
                  L['push'](v8);
              }
            const R = yield M(Q['jsonFiles'], V['jsonFiles'])['catch'](W['kg']['debug']);
            delete z['jsonFiles'];
            const v0 = yield M(Q['rawFiles'], V['rawFiles'])['catch'](W['kg']['debug']);
            delete z['rawObjs'];
            const v1 = yield M(Q['images'], V['images'])['catch'](W['kg']['debug']);
            delete z['images'];
            const v2 = yield M(Q['colorScales'], V['colorScales'])['catch'](W['kg']['debug']);
            delete z['colorScales'];
            const v3 = yield M(Q['stopRules'], V['stopRules'])['catch'](W['kg']['debug']);
            delete z['stopRules'];
            const v4 = yield M(Q['featureStyles'], V['featureStyles'])['catch'](W['kg']['debug']);
            delete z['featureStyles'];
            const v5 = yield M(Q['gridStyles'], V['gridStyles'])['catch'](W['kg']['debug']);
            delete z['gridStyles'];
            const v6 = [...L, ...R, ...v0, ...v1, ...v3, ...v4, ...v5, ...v2];
            for (const v9 in z) {
              const vv = yield M(z[v9], v9)['catch'](W['kg']['debug']);
              v6['push'](...vv);
            }
            return v6;
          });
        }
        ['loadResourceFromConfigPath'] (N, P, M = false) {
          return D(this, undefined, undefined, function* () {
            return 'string' == typeof N && (N['startsWith']('http') || N['startsWith']('/') || (N = F['v']['resourcePath'] + '/' + N)),
              (0x0,
                E['TN'])(N, P)['then'](z => z['json']())['then'](z => this['loadResourceFromConfig'](z, M))['catch'](W['kg']['debug']);
          });
        }
        ['getResource'] (N) {
          return this['resources'][N] ? this['resources'][N] : (W['kg']['warn']('ID为' + N + '的资源不存在，请先使用资源管理器进行加载！'),
          {
            'instance': undefined
          });
        }
        ['removeResource'] (N) {
          const P = this['resources'][N]
            , M = delete this['resources'][N];
          return P && this['fire'](O['EventTypes']['resRemoved'], {
            'firer': this,
            'msg': P
          }),
            M;
        }
        ['hasResource'] (N) {
          return undefined !== this['resources'][N];
        }
        ['whenResourceAdded'] (N, P) {
          let M = this['getResource'](N);
          if (M)
            return Promise['resolve'](M);
          this['on'](O['EventTypes']['resLoaded'] + ':' + N, z => {
            P(z['msg']);
          }
          );
        }
        ['whenResourceUpdated'] (N, P) {
          this['on'](O['EventTypes']['resUpdated'] + ':' + N, M => {
            P(M['msg']['oldResource'], M['msg']['newResource']);
          }
          );
        }
        ['whenResourceLoaded'] (N, P) {
          this['on'](O['EventTypes']['resLoaded'] + ':' + N, M => {
            P(M['msg']);
          }
          );
        }
        ['whenResourceRemoved'] (N, P) {
          this['on'](O['EventTypes']['resRemoved'] + ':' + N, M => {
            P(M['msg']);
          }
          );
        }
      }
      O['creators'] = {},
        O['EventTypes'] = {
          'resAdd': 'res:add',
          'resRemoved': 'res:remove',
          'resUpdated': 'res:update',
          'resLoaded': 'res:load'
        },
        O['registerCreator'](V['images'], Z),
        O['registerCreator'](V['stopRules'], q),
        O['registerCreator'](V['featureStyles'], J),
        O['registerCreator'](V['gridStyles'], C),
        O['registerCreator'](V['jsonFiles'], S),
        O['registerCreator'](V['rawFiles'], U),
        O['registerCreator'](V['colorScales'], Z);
      const G = new O();
    }
    ,
    0x95: (K, H, F) => {
      'use strict';
      F['d'](H, {
        'Ao': () => G,
        'H$': () => Q,
        'Tz': () => v2,
        'fV': () => M,
        'jr': () => L,
        'lS': () => v3,
        'sU': () => v4,
        'tq': () => R
      });
      var Y = F(0x39b)
        , T = F(0x1)
        , X = function (v5, v6, v7, v8) {
          return new (v7 || (v7 = Promise))(function (v9, vv) {
            function vA (vl) {
              try {
                vk(v8['next'](vl));
              } catch (vK) {
                vv(vK);
              }
            }
            function vn (vl) {
              try {
                vk(v8['throw'](vl));
              } catch (vK) {
                vv(vK);
              }
            }
            function vk (vl) {
              var vK;
              vl['done'] ? v9(vl['value']) : (vK = vl['value'],
                vK instanceof v7 ? vK : new v7(function (vi) {
                  vi(vK);
                }
                ))['then'](vA, vn);
            }
            vk((v8 = v8['apply'](v5, v6 || []))['next']());
          }
          );
        };
      let W = undefined !== window['orientation']
        , j = false;
      class D {
        constructor(v5, v6, v7) {
          this['name'] = v5,
            this['version'] = v6,
            this['os'] = v7,
            this['type'] = 'browser';
        }
      }
      class V {
        constructor(v5) {
          this['version'] = v5,
            this['type'] = 'node',
            this['name'] = 'node',
            this['os'] = process['platform'];
        }
      }
      class Z {
        constructor(v5, v6, v7, v8) {
          this['name'] = v5,
            this['version'] = v6,
            this['os'] = v7,
            this['bot'] = v8,
            this['type'] = 'bot-device';
        }
      }
      class B {
        constructor() {
          this['type'] = 'bot',
            this['bot'] = true,
            this['name'] = 'bot',
            this['version'] = null,
            this['os'] = null;
        }
      }
      class U {
        constructor() {
          this['type'] = 'react-native',
            this['name'] = 'react-native',
            this['version'] = null,
            this['os'] = null;
        }
      }
      const q = /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/
        , J = 0x3
        , C = [['aol', /AOLShield\/([0-9\._]+)/], ['edge', /Edge\/([0-9\._]+)/], ['edge-ios', /EdgiOS\/([0-9\._]+)/], ['yandexbrowser', /YaBrowser\/([0-9\._]+)/], ['kakaotalk', /KAKAOTALK\s([0-9\.]+)/], ['samsung', /SamsungBrowser\/([0-9\.]+)/], ['silk', /\bSilk\/([0-9._-]+)\b/], ['miui', /MiuiBrowser\/([0-9\.]+)$/], ['beaker', /BeakerBrowser\/([0-9\.]+)/], ['edge-chromium', /Edg\/([0-9\.]+)/], ['chromium-webview', /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/], ['chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/], ['phantomjs', /PhantomJS\/([0-9\.]+)(:?\s|$)/], ['crios', /CriOS\/([0-9\.]+)(:?\s|$)/], ['firefox', /Firefox\/([0-9\.]+)(?:\s|$)/], ['fxios', /FxiOS\/([0-9\.]+)/], ['opera-mini', /Opera Mini.*Version\/([0-9\.]+)/], ['opera', /Opera\/([0-9\.]+)(?:\s|$)/], ['opera', /OPR\/([0-9\.]+)(:?\s|$)/], ['ie', /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/], ['ie', /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/], ['ie', /MSIE\s(7\.0)/], ['bb10', /BB10;\sTouch.*Version\/([0-9\.]+)/], ['android', /Android\s([0-9\.]+)/], ['ios', /Version\/([0-9\._]+).*Mobile.*Safari.*/], ['safari', /Version\/([0-9\._]+).*Safari/], ['facebook', /FBAV\/([0-9\.]+)/], ['instagram', /Instagram\s([0-9\.]+)/], ['ios-webview', /AppleWebKit\/([0-9\.]+).*Mobile/], ['ios-webview', /AppleWebKit\/([0-9\.]+).*Gecko\)$/], ['searchbot', /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/]]
        , O = [['iOS', /iP(hone|od|ad)/], ['Android\x20OS', /Android/], ['BlackBerry\x20OS', /BlackBerry|BB10/], ['Windows\x20Mobile', /IEMobile/], ['Amazon\x20OS', /Kindle/], ['Windows\x203.11', /Win16/], ['Windows\x2095', /(Windows 95)|(Win95)|(Windows_95)/], ['Windows\x2098', /(Windows 98)|(Win98)/], ['Windows\x202000', /(Windows NT 5.0)|(Windows 2000)/], ['Windows\x20XP', /(Windows NT 5.1)|(Windows XP)/], ['Windows\x20Server\x202003', /(Windows NT 5.2)/], ['Windows\x20Vista', /(Windows NT 6.0)/], ['Windows\x207', /(Windows NT 6.1)/], ['Windows\x208', /(Windows NT 6.2)/], ['Windows\x208.1', /(Windows NT 6.3)/], ['Windows\x2010', /(Windows NT 10.0)/], ['Windows\x2011', /(Windows NT 11.0)/], ['Windows\x20ME', /Windows ME/], ['Open\x20BSD', /OpenBSD/], ['Sun\x20OS', /SunOS/], ['Chrome\x20OS', /CrOS/], ['Linux', /(Linux)|(X11)/], ['Mac\x20OS', /(Mac_PowerPC)|(Macintosh)/], ['QNX', /QNX/], ['BeOS', /BeOS/], ['OS/2', /OS\/2/]];
      function G (v5) {
        return v5 ? N(v5) : 'undefined' == typeof document && 'undefined' != typeof navigator && 'ReactNative' === navigator['product'] ? new U() : 'undefined' != typeof navigator ? N(navigator['userAgent']) : 'undefined' != typeof process && process['version'] ? new V(process['version']['slice'](0x1)) : null;
      }
      function N (v5) {
        const v6 = function (vk) {
          return '' !== vk && C['reduce']((vl, [vK, vi]) => {
            if (vl)
              return vl;
            const vb = vi['exec'](vk);
            return !!vb && [vK, vb];
          }
            , false);
        }(v5);
        if (!v6)
          return null;
        const [v7, v8] = v6;
        if ('searchbot' === v7)
          return new B();
        let v9 = v8[0x1] && v8[0x1]['split'](/[._]/)['slice'](0x0, 0x3);
        v9 ? v9['length'] < J && (v9 = [...v9, ...z(J - v9['length'])]) : v9 = [];
        const vv = v9['join']('.')
          , vA = M(v5)
          , vn = q['exec'](v5);
        return vn && vn[0x1] ? new Z(v7, vv, vA, vn[0x1]) : new D(v7, v9['join']('.'), vA);
      }
      function M (v5) {
        for (let v6 = 0x0, v7 = O['length']; v6 < v7; v6++) {
          const [v8, v9] = O[v6];
          if (v9['exec'](v5))
            return v8;
        }
        return null;
      }
      function z (v5) {
        const v6 = [];
        for (let v7 = 0x0; v7 < v5; v7++)
          v6['push']('0');
        return v6;
      }
      function Q () {
        const v5 = G()
          , v6 = v5['name'] && v5['name']['toLowerCase']();
        let v7 = v5['version'] || '00';
        const v8 = parseFloat(v7['slice'](0x0, 0x2));
        return !!(v6 && (v6['indexOf']('chrome') >= 0x0 || v6['indexOf']('chromium') >= 0x0) && v8 > 0x3c);
      }
      function L (v5) {
        var v6, v7 = document['createElement']('img');
        Object['defineProperty'](v7, 'id', {
          'get': function () {
            v6 = 'on';
          }
        }),
          requestAnimationFrame(function v8 () {
            v6 = 'off',
              requestAnimationFrame(v8),
              'on' === v6 && (location['href'] = v5 || 'http://www.mlogcn.com');
          });
      }
      const R = v2;
      let v0, v1;
      function v2 (v5 = true) {
        if (j)
          return true;
        const v6 = function () {
          var v7 = new Object()
            , v8 = location['search']['substring'](0x1);
          if (!v8 || 0x0 === v8['trim']()['length']) {
            const vl = location['hash']['indexOf']('?');
            v8 = location['hash']['substring'](vl + 0x1);
          }
          for (var v9 = v8['split']('&'), vv = 0x0; vv < v9['length']; vv++) {
            var vA = v9[vv]['indexOf']('=');
            if (-0x1 != vA) {
              var vn = v9[vv]['substring'](0x0, vA)
                , vk = v9[vv]['substring'](vA + 0x1);
              v7[vn] = unescape(vk);
            }
          }
          return v7;
        }();
        return !(!window['force_mobile'] && 'true' != v6['mobile']) || (v5 ? ((0x0,
          T['ri'])(v0) || (v0 = function () {
            var v7;
            let v8 = false;
            var v9;
            return v9 = navigator['userAgent'] || navigator['vendor'] || window['opera'],
              (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i['test'](v9) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|FeatureDataProviderBase|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i['test'](v9['substr'](0x0, 0x4))) && (v8 = true),
              v8 || (null === (v7 = navigator['userAgent']) || undefined === v7 ? undefined : v7['toLowerCase']()['indexOf']('mobile')) >= 0x0;
          }()),
          v0) : W);
      }
      function v3 () {
        try {
          const v5 = document['createElement']('canvas');
          if ((0x0,
            T['ri'])(v5['getContext']('webgl2')))
            return 0x2;
          const v6 = v5['getContext']('webgl');
          return (0x0,
            T['ri'])(v6) || Y['kg']['error']('当前系统不支持WebGL！'),
            v6['getExtension']('OES_texture_float') || Y['kg']['warn']('当前系统不支持WebGL1的float扩展，将无法渲染非byte类型数据！'),
            0x1;
        } catch (v7) {
          Y['kg']['error']('当前系统不支持WebGL，无法使用本渲染引擎！');
        }
      }
      function v4 () {
        return X(this, undefined, undefined, function* () {
          return (0x0,
            T['ri'])(v1) ? v1 : new Promise((v5, v6) => {
              const v7 = new Image();
              v7['src'] = 'data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA',
                v7['onload'] = v7['onerror'] = () => {
                  v1 = 0x2 === v7['height'],
                    v5(v1);
                }
                ;
            }
            );
        });
      }
    }
    ,
    0xfb: (K, b, H) => {
      'use strict';
      H['d'](b, {
        'EO': () => W,
        'OE': () => V,
        'Qs': () => I,
        'c0': () => Z,
        'ke': () => j,
        'nA': () => B,
        'y$': () => E
      });
      var x = H(0x35a)
        , F = H(0x313)
        , y = H(0x260)
        , w = H(0x133)
        , Y = H(0x39b)
        , T = H(0x13c)
        , X = H(0x1);
      function E (S) {
        if (undefined !== (S = parseFloat(S)) && S < 0x270f) {
          ++S;
          let U = Math['floor'](S / 0x14)
            , q = Math['floor']((S - 0x14 * U) / 0x4)
            , J = 0xa * U + 0x2 * q + Math['floor']((S - 0x14 * U - 0x4 * q) / 0x2);
          if (0x0 === J)
            return;
          let C = J + 0x20;
          return C > 0x3d && (C = 0x3d),
            String['fromCharCode'](C);
        }
      }
      function W (S) {
        return undefined === (S = parseFloat(S)) || S < 0x270f && (S >= 0x64 && (S -= 0x64),
          S < 0x4 ? S = undefined : S += S < 0x42 ? 0x3d : S < 0x4e ? 0x5f : 0x60),
          S;
      }
      function I (S) {
        return undefined === (S = parseFloat(S)) ? S : S < 0x270f ? S * Math['PI'] / 0xb4 : undefined;
      }
      const j = {
        'wind': 'wind',
        'weather': 'weather',
        'degree2arc': 'degree2arc',
        'res': 'res',
        'anaVals': 'anaVals',
        'decimal': 'decimal',
        'subImage': 'subImage',
        'transform': 'transform',
        'cs': 'cs',
        'all': 'all'
      }
        , D = {
          'wind': E,
          'weather': W,
          'degree2arc': I,
          'res': (S, U) => {
            const q = T['Zc']['getResource'](S)['instance'];
            if (q && q['stops'] && U) {
              const J = Object['assign']({}, q);
              return U['field'] && (J['fieldName'] = U['field']),
                U['action'] && (J['action'] = U['action']),
                J;
            }
            return q;
          }
          ,
          'anaVals': (S, U) => {
            var q;
            const J = T['Zc']['getResource'](S)['instance'];
            if (J) {
              const C = new y['NB'](J)['getVals']();
              if (U) {
                const O = null !== (q = U['start']) && undefined !== q ? q : 0x0
                  , G = U['end'];
                return C['slice'](O, G);
              }
              return C;
            }
            return Y['kg']['warn']('资源' + S + '没有找到！'),
              [];
          }
          ,
          'decimal': (S, U) => {
            const q = U && U['len'] || 0x1;
            return parseFloat(S)['toFixed'](parseInt(q));
          }
          ,
          'subImage': (S, U) => {
            const q = S + '_sub_' + U['x'] + '_' + U['y'] + '_' + U['w'] + '_' + U['h'];
            if (T['Zc']['hasResource'](q))
              return T['Zc']['getResource'](q)['instance'];
            const J = T['Zc']['getResource'](S)['instance'];
            if (J && (J instanceof HTMLImageElement || J instanceof HTMLCanvasElement || J instanceof HTMLVideoElement)) {
              const C = document['createElement']('canvas');
              return C['width'] = U['w'],
                C['height'] = U['h'],
                C['getContext']('2d')['drawImage'](J, U['x'], U['y'], U['w'], U['h'], 0x0, 0x0, U['w'], U['h']),
                T['Zc']['addResource'](q, {
                  'resourceType': T['MM']['images'],
                  'instance': C
                }, false),
                C;
            }
            return Y['kg']['warn']('当前资源不存在或者不是图片类型！' + S),
              J;
          }
          ,
          'transform': (S, U) => {
            var q, J;
            const C = null !== (q = U['scale']) && undefined !== q ? q : 0x1
              , O = null !== (J = U['offset']) && undefined !== J ? J : 0x0;
            return 0x0 == U['scaleFirst'] ? (S + O) * C : S * C + O;
          }
          ,
          'cs': (S, U) => ('string' == typeof S && (S = F['xS'][S] ? (0x0,
            F['dO'])(F['xS'][S], U['min'], U['max'], 'false' !== U['gradient']) : (0x0,
              w['it'])(S)),
            (0x0,
              X['ri'])(S['min']) && (0x0,
                X['ri'])(S['max']) && (0x0,
                  X['ri'])(S['colorScale']) ? S : S['width'] && S['height'] ? new x['Xm']({
                    'colorScale': S,
                    'min': (0x0,
                      X['ri'])(U['min']) ? parseFloat(U['min']) : undefined,
                    'max': (0x0,
                      X['ri'])(U['max']) ? parseFloat(U['max']) : undefined
                  }) : (Y['kg']['warn']('当前类型无法转换为colorsacle!'),
                    S)),
          'all': (S, U) => {
            const q = U['__order']
              , J = {
                'initial': S
              };
            return q['reduce']((C, O) => {
              if ('all' === (O = O['trim']()))
                return Y['kg']['warn']('all\x20loader不支持嵌套！'),
                  C;
              const G = B(O);
              if (!(0x0,
                X['ri'])(G))
                return Y['kg']['warn']('loader\x20' + O + '不存在！'),
                  C;
              const N = U[O];
              if (!(0x0,
                X['ri'])(N) || !N['trim']()['length'])
                return G(C, J);
              const P = (0x0,
                w['vl'])(N, ',', ':')
                , M = G(C, Object['assign'](Object['assign']({}, J), P));
              return J[O] = M,
                M;
            }
              , S);
          }
        };
      function V (S, U) {
        D[S] = U;
      }
      function Z (S, U) {
        for (const q of S)
          V(q, U);
      }
      function B (S) {
        return D[S];
      }
    }
    ,
    0x1: (v0, v1, v2) => {
      'use strict';
      v2['d'](v1, {
        'BR': () => vd,
        'f0': () => vM,
        'VS': () => An,
        'pj': () => A1,
        'U2': () => A3,
        'ZS': () => A4,
        'Ef': () => Al,
        'cM': () => A7,
        'f8': () => vp,
        'En': () => vt,
        'ri': () => vB,
        'GN': () => vm,
        'l7': () => vf,
        'vY': () => va,
        'p6': () => A0,
        'K0': () => vY,
        'j$': () => vu,
        'BG': () => A2,
        'tr': () => vD,
        'xA': () => vw,
        'lC': () => vh,
        'vi': () => vZ,
        'Fp': () => vV,
        'oT': () => vT,
        'C8': () => vy,
        'Q': () => vs,
        'Hn': () => vr,
        '$k': () => vj,
        'kJ': () => vP,
        'eP': () => vC,
        'J_': () => vo,
        'xb': () => vg,
        'mf': () => vq,
        'Ft': () => vN,
        'hj': () => vG,
        'Kn': () => vJ,
        'HD': () => vO,
        'JY': () => vz,
        'EX': () => A8,
        'd$': () => A6,
        've': () => AK,
        'Wd': () => vQ,
        'Tc': () => Ak,
        'ft': () => vR,
        'TN': () => vX,
        'wO': () => Av,
        'r_': () => AA,
        'Zu': () => A9,
        'XG': () => A5,
        'Ov': () => vx,
        'uw': () => vF,
        'nf': () => vI,
        'Rc': () => vW,
        'LG': () => vH,
        'hQ': () => vc,
        'Rf': () => Quadtree,
        '_6': () => vL
      });
      var v3 = v2(0x17a)
        , v4 = v2['n'](v3)
        , v5 = v2(0x338)
        , v6 = v2(0x240)
        , v7 = v2(0x1de)
        , v8 = v2(0x60)
        , v9 = v2(0x1ca)
        , vv = v2(0x39b)
        , vA = v2(0xcc)
        , vn = v2(0x4b);
      const vk = function (Ai, Ab, Ae) {
        undefined === Ae && (Ae = {});
        for (var Ac = Ae['steps'] || 0x40, AH = Ae['properties'] ? Ae['properties'] : !Array['isArray'](Ai) && 'Feature' === Ai['type'] && Ai['properties'] ? Ai['properties'] : {}, At = [], Ax = 0x0; Ax < Ac; Ax++)
          At['push']((0x0,
            vA['Z'])(Ai, Ab, -0x168 * Ax / Ac, Ae)['geometry']['coordinates']);
        return At['push'](At[0x0]),
          (0x0,
            vn['yu'])([At], AH);
      };
      function vl (Ai, Ab, Ae, Ac, AH) {
        undefined === AH && (AH = {});
        var At = AH['steps'] || 0x40
          , Ax = vK(Ae)
          , Ap = vK(Ac)
          , AF = Array['isArray'](Ai) || 'Feature' !== Ai['type'] ? {} : Ai['properties'];
        if (Ax === Ap)
          return (0x0,
            vn['Tu'])(vk(Ai, Ab, AH)['geometry']['coordinates'][0x0], AF);
        for (var Ay = Ax, Ar = Ax < Ap ? Ap : Ap + 0x168, Aw = Ay, As = [], Ah = 0x0; Aw < Ar;)
          As['push']((0x0,
            vA['Z'])(Ai, Ab, Aw, AH)['geometry']['coordinates']),
            Aw = Ay + 0x168 * ++Ah / At;
        return Aw > Ar && As['push']((0x0,
          vA['Z'])(Ai, Ab, Ar, AH)['geometry']['coordinates']),
          (0x0,
            vn['Tu'])(As, AF);
      }
      function vK (Ai) {
        var Ab = Ai % 0x168;
        return Ab < 0x0 && (Ab += 0x168),
          Ab;
      }
      var vi = function (Ai, Ab, Ae, Ac) {
        return new (Ae || (Ae = Promise))(function (AH, At) {
          function Ax (Ay) {
            try {
              AF(Ac['next'](Ay));
            } catch (Ar) {
              At(Ar);
            }
          }
          function Ap (Ay) {
            try {
              AF(Ac['throw'](Ay));
            } catch (Ar) {
              At(Ar);
            }
          }
          function AF (Ay) {
            var Ar;
            Ay['done'] ? AH(Ay['value']) : (Ar = Ay['value'],
              Ar instanceof Ae ? Ar : new Ae(function (Aw) {
                Aw(Ar);
              }
              ))['then'](Ax, Ap);
          }
          AF((Ac = Ac['apply'](Ai, Ab || []))['next']());
        }
        );
      };
      let vb = 0x0;
      function vc () {
        return 'qe_uid_' + vb++;
      }
      function vH (Ai) {
        let Ab = [];
        for (let Ae of Ai)
          for (let Ac of Ae)
            Ab['push'](Ac);
        return Ab;
      }
      function vt (Ai, Ab) {
        return null == Ai ? Ab : Ai;
      }
      function vx (Ai, Ab, Ae) {
        if (Ai = Ai || {},
          Ae) {
          for (let Ac in Ae)
            Ai[Ac] = Ae[Ac];
        }
        if (Ab) {
          for (let AH in Ab)
            Ai[AH] = Ab[AH];
        }
        return Ai;
      }
      function vp (Ai, Ab) {
        const Ae = (Ax, Ap, AF) => {
          const Ay = Ax[AF];
          Ay instanceof Array ? (vB(Ap[AF]) || (Ap[AF] = []),
            AH(Ay, Ap[AF])) : 'object' == typeof Ay ? (vB(Ap[AF]) || (Ap[AF] = {}),
              Ac(Ay, Ap[AF])) : Ap[AF] = Ay;
        }
          , Ac = (Ax, Ap) => {
            const AF = Object['keys'](Ax);
            for (const Ay of AF)
              Ae(Ax, Ap, Ay);
          }
          , AH = (Ax, Ap) => {
            for (let AF = 0x0; AF < Ax['length']; AF++)
              Ae(Ax, Ap, AF);
          }
          ;
        let At = Ab;
        return Ai instanceof Array ? (!At || At instanceof Array ? vB(At) || (At = []) : (vv['kg']['warn']('提供的拷贝目标和拷贝源（数组）不是一个类型，将生成新的拷贝目标返回！'),
          At = []),
          AH(Ai, At)) : 'object' == typeof Ai ? (At && 'object' != typeof At ? (vv['kg']['warn']('提供的拷贝目标和拷贝源（Object）不是一个类型，将生成新的拷贝目标返回！'),
            At = {}) : vB(At) || (At = {}),
            Ac(Ai, At)) : (At = Ai,
              vv['kg']['debug']('拷贝源非数组和对象，将直接返回拷贝源！')),
          At;
      }
      function vF (Ai, Ab, Ae) {
        return Ai = Ai || {},
          Ae && (Ai = vp(Ae)),
          Ab && (Ai = vp(Ab, Ai)),
          Ai;
      }
      function vy (Ai) {
        let Ab = Math['sqrt'](Ai[0x0] * Ai[0x0] + Ai[0x1] * Ai[0x1])
          , Ae = 0x10e - 0xb4 * Math['atan2'](Ai[0x1], Ai[0x0]) / Math['PI'];
        return Ae %= 0x168,
          [Ab, Ae];
      }
      function vr (Ai) {
        let Ab = (0x10e - Ai[0x1]) * Math['PI'] / 0xb4;
        return [Ai[0x0] * Math['cos'](Ab), Ai[0x0] * Math['sin'](Ab)];
      }
      function vw (Ai) {
        return vi(this, undefined, undefined, function* () {
          return vX(Ai)['then'](Ab => Ab['json']())['catch'](vv['kg']['debug']);
        });
      }
      function vs (Ai, Ab = false) {
        return vi(this, undefined, undefined, function* () {
          let Ae;
          if (Ai['endsWith']('zip') || Ab)
            Ae = (yield vu(Ai, undefined, 'text', true))[0x0];
          else {
            const Ac = yield vX(Ai);
            Ae = yield Ac['text']();
          }
          return Ae;
        });
      }
      function vh (Ai) {
        return vi(this, undefined, undefined, function* () {
          return vu(Ai, undefined, 'text', true)['then'](Ab => JSON['parse'](Ab[0x0]))['catch'](vv['kg']['debug']);
        });
      }
      function vu (Ai, Ab, Ae = 'arraybuffer', Ac = false, AH) {
        return vi(this, undefined, undefined, function* () {
          let At;
          return At = 'function' == typeof Ae ? Ae : Ax => Ae,
            vT(Ai)['then'](Ax => {
              if (!Ai['endsWith']('zip') && !Ac)
                return [Ax];
              const Ap = [];
              let AF = performance['now']();
              return new (v4())()['loadAsync'](Ax)['then'](Ay => vi(this, undefined, undefined, function* () {
                const Ar = Object['keys'](Ay['files'])['length'];
                for (let Aw in Ay['files']) {
                  let As = Aw;
                  if (As['indexOf']('MACOSX') >= 0x0)
                    continue;
                  let Ah = Ay['files'][As];
                  Ab && !Ab(Ah) || (yield Ah['async'](At(Ah))['then'](Au => {
                    vv['kg']['debug']('unzip\x20' + As + '\x20costs\x20' + (performance['now']() - AF) + 'ms'),
                      AF = performance['now'](),
                      AH && AH(Au, Ah, Ar),
                      Ap['push'](Au);
                  }
                  )['catch'](vv['kg']['debug']));
                }
                return Ap;
              }))['catch'](vv['kg']['debug']);
            }
            )['catch'](vv['kg']['debug']);
        });
      }
      function vY (Ai, Ab, Ae, Ac = 'arraybuffer', AH = false) {
        return vi(this, undefined, undefined, function* () {
          const At = [];
          for (const Ax of Ai) {
            const Ap = yield vu(Ax, Ae, Ac, AH)['catch'](vv['kg']['debug']);
            Ab && Ab(Ap),
              At['push'](...Ap);
          }
          return At;
        });
      }
      function vT (Ai) {
        return vi(this, undefined, undefined, function* () {
          return qeFetch(Ai)['then'](Ab => Ab['arrayBuffer']())['catch'](vv['kg']['debug']);
        });
      }

      let vX = qeFetch;

      function Quadtree (Ai, Ab, Ae) {
        return null == Ai ? Ab : Ae ? Ae(Ai) : Ai;
      }
      function vf (Ai, ...Ab) {
        var Ae, Ac, AH, At;
        for (Ac = 0x1,
          AH = arguments['length']; Ac < AH; Ac++)
          for (Ae in At = arguments[Ac])
            Ai[Ae] = At[Ae];
        return Ai;
      }
      function vW (Ai) {
        return Ai['_qe_id'] = Ai['_leaflet_id'] || vc(),
          Ai['_qe_id'];
      }
      function vI (Ai) {
        return Ai['trim']()['split'](/\s+/);
      }
      function vj (Ai, Ab, Ae) {
        var Ac = ((0x2 * Ae - 0x1) / 0x1 + 0x1) / 0x2
          , AH = 0x1 - Ac
          , At = vt(Ai['a'], 0x1)
          , Ax = vt(Ab['a'], 0x1);
        return 0x0 === At && (At = 0.001),
          0x0 === Ax && (Ax = 0.001),
        {
          'r': Math['round'](Ai['r'] * Ac + Ab['r'] * AH),
          'g': Math['round'](Ai['g'] * Ac + Ab['g'] * AH),
          'b': Math['round'](Ai['b'] * Ac + Ab['b'] * AH),
          'a': At * Ac + Ax * AH
        };
      }
      function vD (Ai, Ab, Ae) {
        return Math['floor']((Ae - Ai) / Ab);
      }
      function vV (Ai, Ab) {
        return {
          'x': Ai % Ab,
          'y': Math['floor'](Ai / Ab)
        };
      }
      function vZ (Ai, Ab, Ae) {
        return Ab * Ae + Ai;
      }
      function vB (Ai) {
        return null != Ai && ('number' != typeof Ai || !isNaN(Ai));
      }
      Array['isArray'] || (Array['isArray'] = function (Ai) {
        return '[object\x20Array]' === Object['prototype']['toString']['call'](Ai);
      }
      ),
        'function' != typeof Object['assign'] && Object['defineProperty'](Object, 'assign', {
          'value': function (Ai, Ab) {
            if (null == Ai)
              throw new TypeError('Cannot\x20convert\x20undefined\x20or\x20null\x20to\x20object');
            let Ae = Object(Ai);
            for (let Ac = 0x1; Ac < arguments['length']; Ac++) {
              const AH = arguments[Ac];
              if (null != AH) {
                for (let At in AH)
                  Object['prototype']['hasOwnProperty']['call'](AH, At) && (Ae[At] = AH[At]);
              }
            }
            return Ae;
          },
          'writable': true,
          'configurable': true
        });
      const vS = Object['prototype']['hasOwnProperty']
        , vU = 'undefined' != typeof Symbol ? Symbol['toStringTag'] : undefined;
      function vd (Ai) {
        return Object['prototype']['toString']['call'](Ai)['slice'](0x8, -0x1)['toLowerCase']();
      }
      function vq (Ai) {
        if (!vJ(Ai))
          return false;
        const Ab = function (Ae) {
          if (null === Ae)
            return undefined === Ae ? '[object\x20Undefined]' : '[object\x20Null]';
          if (!vU || !(vU in Object(Ae)))
            return toString['call'](Ae);
          const Ac = vS['call'](Ae, vU)
            , AH = Ae[vU];
          let At = false;
          try {
            Ae[vU] = undefined,
              At = true;
          } catch (Ap) { }
          const Ax = Object['prototype']['toString']['call'](Ae);
          return At && (Ac ? Ae[vU] = AH : delete Ae[vU]),
            Ax;
        }(Ai);
        return '[object\x20Function]' === Ab || '[object\x20AsyncFunction]' === Ab || '[object\x20GeneratorFunction]' === Ab || '[object\x20Proxy]' === Ab;
      }
      function vJ (Ai) {
        const Ab = typeof Ai;
        return null !== Ai && ('object' === Ab || 'function' === Ab);
      }
      function vo (Ai) {
        return '[object\x20Date]' === Object['prototype']['toString']['call'](Ai);
      }
      function vC (Ai) {
        return '[object\x20ArrayBuffer]' === Object['prototype']['toString']['call'](Ai);
      }
      function vO (Ai) {
        return null != Ai && ('string' == typeof Ai || null !== Ai['constructor'] && Ai['constructor'] === String);
      }
      function vG (Ai) {
        return '[object\x20Number]' === Object['prototype']['toString']['call'](Ai) && !isNaN(Ai);
      }
      function vg (Ai) {
        let Ab;
        for (Ab in Ai)
          return false;
        return !Ab;
      }
      function vN (Ai) {
        return null == Ai;
      }
      function vP (Ai) {
        return Array['isArray'](Ai);
      }
      function vM (Ai, ...Ab) {
        return Object['assign'](Ai, ...Ab);
      }
      function va (Ai, Ab) {
        return Ai - Ab * Math['floor'](Ai / Ab);
      }
      function vz (Ai) {
        return null != Ai && ('number' != typeof Ai || !isNaN(Ai));
      }
      function vQ (Ai, Ab, Ae) {
        let Ac;
        const AH = At => {
          Ab && Ab(),
            Ac ? clearTimeout(Ac) : Ae && Ae(),
            Ac = setTimeout(() => {
              Ai(),
                Ac = undefined;
            }
              , 0x12c);
        }
          ;
        return window['addEventListener']('resize', AH),
        {
          'remove': () => window['removeEventListener']('resize', AH)
        };
      }
      function vm (Ai, Ab) {
        var Ae = document['createElement']('a');
        Ae['setAttribute']('href', Ai),
          Ae['setAttribute']('download', Ab),
          Ae['click']();
      }
      function vL (Ai) {
        return Ai < 0x0 ? Ai + 0x168 : Ai;
      }
      function vR (Ai, Ab, Ae, Ac) {
        if (0x0 === Ab['alpha']())
          return Ai;
        var AH = ((0x2 * Ae - 0x1) / 0x1 + 0x1) / 0x2
          , At = 0x1 - AH;
        return new v7['t']({
          'r': Math['round'](Ai['red']() * AH + Ab['red']() * At),
          'g': Math['round'](Ai['green']() * AH + Ab['green']() * At),
          'b': Math['round'](Ai['blue']() * AH + Ab['blue']() * At),
          'a': Ac
        });
      }
      const A0 = (Ai, Ab) => Ab['replace'](/\\?{.*?}/g, Ae => {
        if (Ae['startsWith']('\x5c'))
          return Ae['slice'](0x1);
        switch (Ae) {
          case '{yyyy}':
            return '' + Ai['getFullYear']();
          case '{yy}':
            return ('' + Ai['getFullYear']())['slice'](-0x2);
          case '{MM}':
            return ('' + (Ai['getMonth']() + 0x1))['padStart'](0x2, '0');
          case '{dd}':
            return ('' + Ai['getDate']())['padStart'](0x2, '0');
          case '{HH}':
            return ('' + Ai['getHours']())['padStart'](0x2, '0');
          case '{mm}':
            return ('' + Ai['getMinutes']())['padStart'](0x2, '0');
          case '{ss}':
            return ('' + Ai['getSeconds']())['padStart'](0x2, '0');
          case '{SSS}':
            return ('' + Ai['getMilliseconds']())['padStart'](0x3, '0');
          default:
            return '';
        }
      }
      );
      function A1 (Ai) {
        const Ab = performance['now']();
        let Ae = 0x1 / 0x0
          , Ac = -0x1 / 0x0;
        return Ai['forEachYx'](AH => {
          Ai['isUndef'](AH) || (AH < Ae && (Ae = AH),
            AH > Ac && (Ac = AH));
        }
        ),
          vv['kg']['debug']('calc\x20max\x20min\x20costs\x20' + (performance['now']() - Ab) + 'ms'),
        {
          'min': Ae,
          'max': Ac
        };
      }
      function A2 (Ai, Ab, Ae = true, Ac = true, AH) {
        let At = Ai['getGrid']()
          , Ax = -0xf423f
          , Ap = 0x0;
        const AF = (As, Ah) => {
          let Au = new v5['P'](At['dataType'], At['xSize'], At['ySize']);
          Au['undef'] = At['undef'];
          let AY = Ai['allGrids']()[AH || 0x0];
          for (let AT = As; AT < Ah; AT++) {
            let AX = AY[AT];
            for (let AE = 0x0; AE < AX['raw']['length']; AE++) {
              const Af = AX['read1D'](AE);
              Af !== Au['undef'] && Au['raw'][AE] < Af && (Au['raw'][AE] = Af),
                Ax < Af && (Ax = Af,
                  Ap = AE);
            }
          }
          return -0xf423f === Ax && (Ax = Au['undef']),
            new v9['o']([[Au]], {
              'gridOptions': Ai['gridOptions']
            });
        }
          , Ay = Ai['allGrids']()[0x0]['length'];
        let Ar, Aw;
        return Ae && (Ar = AF(Ab, Ay)),
          Ac && (Aw = AF(0x0, Ab + 0x1)),
        {
          'upper': Ar,
          'lower': Aw,
          'maxPos': Ap,
          'maxVal': Ax
        };
      }
      function A3 (Ai, Ab, Ae, Ac, AH) {
        const At = Ae - Ab + 0x1
          , Ax = AH - Ac + 0x1
          , Ap = new v5['P'](Ai['dataType'], At, Ax, undefined, Ai['undef'], Ai['algo'], Ai['dataScale'], Ai['dataOffset'])
          , AF = [];
        for (let Ay = Ac; Ay <= AH; Ay++) {
          const Ar = Ay * Ai['xSize'];
          for (let Aw = Ab; Aw <= Ae; Aw++) {
            const As = Ar + Aw
              , Ah = Ai['raw'][As];
            AF['push'](Ah);
          }
        }
        return Ap['update'](AF),
          Ap;
      }
      function A4 (Ai, Ab) {
        const Ae = (0x0,
          v6['Z'])(Ai['gridOptions']);
        if (Ab['maxLat'] > Ae['maxLat'] || Ab['minLat'] < Ae['minLat'] || Ab['maxLon'] > Ae['maxLon'] || Ab['minLon'] < Ae['minLon'])
          return vv['kg']['warn']('提供的裁切范围不在格点范围之内！'),
            Ai;
        const Ac = Ai['gridOptions']['xDelta'] > 0x0 ? Ab['minLon'] : Ab['maxLon']
          , AH = Ai['gridOptions']['yDelta'] > 0x0 ? Ab['minLat'] : Ab['maxLat']
          , At = Ai['gridOptions']['xDelta'] > 0x0 ? Ab['maxLon'] : Ab['minLon']
          , Ax = Ai['gridOptions']['yDelta'] > 0x0 ? Ab['maxLat'] : Ab['minLat']
          , Ap = vD(Ai['gridOptions']['xStart'], Ai['gridOptions']['xDelta'], Ac)
          , AF = vD(Ai['gridOptions']['yStart'], Ai['gridOptions']['yDelta'], AH)
          , Ay = vD(Ai['gridOptions']['xStart'], Ai['gridOptions']['xDelta'], At)
          , Ar = vD(Ai['gridOptions']['yStart'], Ai['gridOptions']['yDelta'], Ax)
          , Aw = Ay - Ap + 0x1
          , As = Ar - AF + 0x1
          , Ah = {
            'xStart': Ai['gridOptions']['xStart'] + Ap * Ai['gridOptions']['xDelta'],
            'yStart': Ai['gridOptions']['yStart'] + AF * Ai['gridOptions']['yDelta'],
            'xSize': Aw,
            'ySize': As,
            'xDelta': Ai['gridOptions']['xDelta'],
            'yDelta': Ai['gridOptions']['yDelta']
          };
        (0x0,
          v6['T'])(Ah);
        const Au = Ai['allGrids']()
          , AY = Au['length'];
        if (0x0 === AY)
          return console['warn']('格点中没有数据！'),
            Ai;
        const AT = Au[0x0]['length']
          , AX = [];
        for (let AE = 0x0; AE < AY; AE++) {
          const Af = [];
          for (let AW = 0x0; AW < AT; AW++) {
            const AI = A3(Ai['getGrid'](AE, AW), Ap, Ay, AF, Ar);
            Af['push'](AI);
          }
          AX['push'](Af);
        }
        return new v9['o'](AX, {
          'gridOptions': Ah
        });
      }
      function A5 (Ai, Ab = 'grid.mesh') {
        const Ae = performance['now']()
          , Ac = new Float32Array(Ai['xSize'] * Ai['ySize']);
        for (let AF = 0x0; AF < Ac['length']; AF++)
          Ac[AF] = AF;
        let AH = 0x0;
        const At = (Ai['xSize'] - 0x1) * (Ai['ySize'] - 0x1) * 0x6
          , Ax = new Uint32Array(At);
        for (let Ay = 0x0; Ay < Ai['xSize'] * Ai['ySize'] - Ai['xSize']; Ay++) {
          if ((Ay + 0x1) % Ai['xSize'] == 0x0)
            continue;
          const Ar = Ay
            , Aw = Ay + Ai['xSize']
            , As = Aw + 0x1
            , Ah = Ar + 0x1;
          Ax[AH++] = Ar,
            Ax[AH++] = Aw,
            Ax[AH++] = As,
            Ax[AH++] = Ar,
            Ax[AH++] = As,
            Ax[AH++] = Ah;
        }
        const Ap = new Blob([Ac, Ax]);
        vm(window['URL']['createObjectURL'](Ap), Ab),
          vv['kg']['debug']('cache\x20mesh\x20costs\x20' + (performance['now']() - Ae) + 'ms');
      }
      function A6 (Ai, Ab) {
        return vi(this, undefined, undefined, function* () {
          const Ae = yield (yield vX(Ab))['arrayBuffer']()
            , Ac = Ai['xSize'] * Ai['ySize'] * 0x4;
          return {
            'ids': new Float32Array(Ae, 0x0, Ac),
            'indices': new Uint32Array(Ae, Ac)
          };
        });
      }
      function A7 (Ai, Ab) {
        switch (Ai) {
          case v8['U']['UInt8']:
            return new Uint8Array(Ab);
          case v8['U']['Int8']:
            return new Int8Array(Ab);
          case v8['U']['UInt16']:
            return new Uint16Array(Ab);
          case v8['U']['Int16']:
            return new Int16Array(Ab);
          case v8['U']['UInt32']:
            return new Uint32Array(Ab);
          case v8['U']['Int32']:
            return new Int32Array(Ab);
          case v8['U']['Float32']:
            return new Float32Array(Ab);
          case v8['U']['Float64']:
            return new Float64Array(Ab);
          default:
            throw new Error('not\x20supported\x20grid\x20data\x20type\x20' + Ai);
        }
      }
      function A8 (Ai) {
        return vi(this, undefined, undefined, function* () {
          return new Promise((Ab, Ae) => {
            const Ac = Ai['length'];
            let AH = 0x0;
            const At = {}
              , Ax = () => {
                AH++,
                  AH === Ac && Ab(At);
              }
              ;
            for (const Ap of Ai) {
              const AF = new Image();
              AF['onerror'] = () => {
                At[Ap] = undefined,
                  Ax();
              }
                ,
                AF['onload'] = () => {
                  At[Ap] = AF,
                    Ax();
                }
                ,
                AF['src'] = Ap;
            }
          }
          );
        });
      }
      function A9 (Ai, Ab) {
        return Ai + Math['random']() * (Ab - Ai);
      }
      function Av (Ai, Ab = true) {
        const Ae = A9(Ai['minLon'], Ai['maxLon'])
          , Ac = A9(Ai['minLat'], Ai['maxLat']);
        return Ab ? vB(Ai['minHeight']) && vB(Ai['maxHeight']) ? [Ae, Ac, A9(Ai['minHeight'], Ai['maxHeight'])] : [Ae, Ac, 0x0] : [Ae, Ac];
      }
      function AA (Ai, Ab = true) {
        const Ae = Math['min'](Ai['xStart'], Ai['xEnd'])
          , Ac = Math['max'](Ai['xStart'], Ai['xEnd'])
          , AH = Math['min'](Ai['yStart'], Ai['yEnd'])
          , At = Math['max'](Ai['yStart'], Ai['yEnd'])
          , Ax = A9(Ae, Ac)
          , Ap = A9(AH, At);
        return Ab ? Ai['zValues']['length'] > 0x1 ? [Ax, Ap, A9(Ai['zValues'][0x0], Ai['zValues'][Ai['zValues']['length'] - 0x1])] : [Ax, Ap, 0x0] : [Ax, Ap];
      }
      function An (Ai, Ab, Ae, Ac) {
        const AH = Ac / 0x2
          , At = Ae / 0x2;
        return {
          'minLat': Ai - AH,
          'maxLat': Ai + AH,
          'minLon': Ab - At,
          'maxLon': Ab + At
        };
      }
      function Ak (Ai, Ab = 1013.225) {
        return 0xad2b * (0x1 - Math['pow'](Ai / 1013.225, 0.1903));
      }
      function Al (Ai, Ab, Ae = [0x0, 0x2d, 0x5a, 0x87], Ac = undefined, AH = 0x5a) {
        Ac || (Ac = Ab['map'](AF => ({
          'distance': AF,
          'angle': 0x5a,
          'value': AF['toString']()
        }))),
          Ab = Ab['sort']((AF, Ay) => AF - Ay),
          AH = Math['max'](AH, 0xa);
        const At = [];
        Ab['forEach'](AF => {
          const Ay = vk(Ai, AF, {
            'units': 'kilometers',
            'steps': AH
          });
          Ay['properties']['value'] = AF,
            At['push'](Ay);
        }
        );
        const Ax = [];
        Ae['forEach'](AF => {
          const Ay = vl(Ai, Ab[Ab['length'] - 0x1], AF, AF + 0xa, {
            'steps': AH,
            'units': 'kilometers'
          })
            , Ar = vl(Ai, Ab[Ab['length'] - 0x1], AF + 0xb4, AF + 0xb4 + 0xa, {
              'steps': AH,
              'units': 'kilometers'
            });
          Ax['push']({
            'type': 'Feature',
            'geometry': {
              'type': 'LineString',
              'coordinates': [Ay['geometry']['coordinates'][0x0], Ar['geometry']['coordinates'][0x0]]
            },
            'properties': {
              'value': AF
            }
          });
        }
        );
        const Ap = [];
        return Ac['forEach'](AF => {
          var Ay;
          const Ar = vl(Ai, AF['distance'], AF['angle'], AF['angle'] + 0xa, {
            'steps': AH,
            'units': 'kilometers'
          });
          Ap['push']({
            'type': 'Feature',
            'geometry': {
              'type': 'Point',
              'coordinates': Ar['geometry']['coordinates'][0x0]
            },
            'properties': {
              'value': null !== (Ay = AF['value']) && undefined !== Ay ? Ay : AF['distance'],
              'distance': AF['distance'],
              'angle': AF['angle']
            }
          });
        }
        ),
        {
          'type': 'FeatureCollection',
          'features': [...At, ...Ax, ...Ap]
        };
      }
      const AK = (Ai, Ab, Ae) => vi(undefined, undefined, undefined, function* () {
        return new Promise((Ac, AH) => {
          try {
            if (document['getElementById'](Ab)) {
              if (window[Ae])
                return Ac(null);
              let At = 0x0;
              const Ax = setInterval(() => {
                if (window[Ae] || !(At < 0x5))
                  return At++,
                    clearInterval(Ax),
                    Ac(null);
              }
                , 0x1f4);
            } else {
              const Ap = document['createElement']('script');
              Ap['setAttribute']('type', 'text/javascript'),
                Ap['setAttribute']('id', Ab),
                Ap['onload'] = Ac,
                Ap['onerror'] = AH,
                Ap['src'] = Ai,
                Ap['async'] = true,
                document['body']['appendChild'](Ap);
            }
          } catch (AF) {
            AH(AF);
          }
        }
        );
      });
    }
    ,
    0xcc: (l, K, b) => {
      'use strict';
      b['d'](K, {
        'Z': () => x
      });
      var c = b(0x4b)
        , H = b(0x32b);
      function x (F, y, w, Y) {
        undefined === Y && (Y = {});
        var T = (0x0,
          H['c9'])(F)
          , X = (0x0,
            c['Ht'])(T[0x0])
          , E = (0x0,
            c['Ht'])(T[0x1])
          , W = (0x0,
            c['Ht'])(w)
          , I = (0x0,
            c['lF'])(y, Y['units'])
          , j = Math['asin'](Math['sin'](E) * Math['cos'](I) + Math['cos'](E) * Math['sin'](I) * Math['cos'](W))
          , D = X + Math['atan2'](Math['sin'](W) * Math['sin'](I) * Math['cos'](E), Math['cos'](I) - Math['sin'](E) * Math['sin'](j))
          , V = (0x0,
            c['vi'])(D)
          , Z = (0x0,
            c['vi'])(j);
        return (0x0,
          c['xm'])([V, Z], Y['properties']);
      }
    }
    ,
    0x4b: (K, b, H) => {
      'use strict';
      H['d'](b, {
        'DL': () => T,
        'Ht': () => W,
        'Tu': () => Y,
        'lF': () => X,
        'vi': () => E,
        'xm': () => y,
        'yu': () => w,
        'zL': () => F
      });
      var x = 6371008.8
        , p = {
          'centimeters': 0x25f96350,
          'centimetres': 0x25f96350,
          'degrees': 57.22891354143274,
          'feet': 20902260.511392,
          'inches': 39.37 * x,
          'kilometers': 6371.0088,
          'kilometres': 6371.0088,
          'meters': x,
          'metres': x,
          'miles': 3958.761333810546,
          'millimeters': 0x17bbde120,
          'millimetres': 0x17bbde120,
          'nauticalmiles': x / 0x73c,
          'radians': 0x1,
          'yards': 6967335.223679999
        };
      function F (j, D, V) {
        undefined === V && (V = {});
        var Z = {
          'type': 'Feature'
        };
        return (0x0 === V['id'] || V['id']) && (Z['id'] = V['id']),
          V['bbox'] && (Z['bbox'] = V['bbox']),
          Z['properties'] = D || {},
          Z['geometry'] = j,
          Z;
      }
      function y (j, D, V) {
        if (undefined === V && (V = {}),
          !j)
          throw new Error('coordinates\x20is\x20required');
        if (!Array['isArray'](j))
          throw new Error('coordinates\x20must\x20be\x20an\x20Array');
        if (j['length'] < 0x2)
          throw new Error('coordinates\x20must\x20be\x20at\x20least\x202\x20numbers\x20long');
        if (!I(j[0x0]) || !I(j[0x1]))
          throw new Error('coordinates\x20must\x20contain\x20numbers');
        return F({
          'type': 'Point',
          'coordinates': j
        }, D, V);
      }
      function w (j, D, V) {
        undefined === V && (V = {});
        for (var Z = 0x0, B = j; Z < B['length']; Z++) {
          var S = B[Z];
          if (S['length'] < 0x4)
            throw new Error('Each\x20LinearRing\x20of\x20a\x20Polygon\x20must\x20have\x204\x20or\x20more\x20Positions.');
          for (var U = 0x0; U < S[S['length'] - 0x1]['length']; U++)
            if (S[S['length'] - 0x1][U] !== S[0x0][U])
              throw new Error('First\x20and\x20last\x20Position\x20are\x20not\x20equivalent.');
        }
        return F({
          'type': 'Polygon',
          'coordinates': j
        }, D, V);
      }
      function Y (j, D, V) {
        if (undefined === V && (V = {}),
          j['length'] < 0x2)
          throw new Error('coordinates\x20must\x20be\x20an\x20array\x20of\x20two\x20or\x20more\x20positions');
        return F({
          'type': 'LineString',
          'coordinates': j
        }, D, V);
      }
      function T (j, D) {
        undefined === D && (D = 'kilometers');
        var V = p[D];
        if (!V)
          throw new Error(D + '\x20units\x20is\x20invalid');
        return j * V;
      }
      function X (j, D) {
        undefined === D && (D = 'kilometers');
        var V = p[D];
        if (!V)
          throw new Error(D + '\x20units\x20is\x20invalid');
        return j / V;
      }
      function E (j) {
        return j % (0x2 * Math['PI']) * 0xb4 / Math['PI'];
      }
      function W (j) {
        return j % 0x168 * Math['PI'] / 0xb4;
      }
      function I (j) {
        return !isNaN(j) && null !== j && !Array['isArray'](j);
      }
    }
    ,
    0x32b: (l, K, b) => {
      'use strict';
      function c (x) {
        if (!x)
          throw new Error('coord\x20is\x20required');
        if (!Array['isArray'](x)) {
          if ('Feature' === x['type'] && null !== x['geometry'] && 'Point' === x['geometry']['type'])
            return x['geometry']['coordinates'];
          if ('Point' === x['type'])
            return x['coordinates'];
        }
        if (Array['isArray'](x) && x['length'] >= 0x2 && !Array['isArray'](x[0x0]) && !Array['isArray'](x[0x1]))
          return x;
        throw new Error('coord\x20must\x20be\x20GeoJSON\x20Point\x20or\x20an\x20Array\x20of\x20numbers');
      }
      function H (x) {
        return 'Feature' === x['type'] ? x['geometry'] : x;
      }
      b['d'](K, {
        'c9': () => c,
        'wA': () => H
      }),
        b(0x4b);
    }
  }
    , A = {};
  function n (l) {
    var K = A[l];
    if (undefined !== K)
      return K['exports'];
    var i = A[l] = {
      'exports': {}
    };
    return v[l](i, i['exports'], n),
      i['exports'];
  }
  n['n'] = l => {
    var K = l && l['__esModule'] ? () => l['default'] : () => l;
    return n['d'](K, {
      'a': K
    }),
      K;
  }
    ,
    n['d'] = (l, K) => {
      for (var i in K)
        n['o'](K, i) && !n['o'](l, i) && Object['defineProperty'](l, i, {
          'enumerable': true,
          'get': K[i]
        });
    }
    ,
    n['o'] = (l, K) => Object['prototype']['hasOwnProperty']['call'](l, K),
    n['r'] = l => {
      'undefined' != typeof Symbol && Symbol['toStringTag'] && Object['defineProperty'](l, Symbol['toStringTag'], {
        'value': 'Module'
      }),
        Object['defineProperty'](l, '__esModule', {
          'value': true
        });
    }
    ;
  var k = {};
  return (() => {
    'use strict';
    n['r'](k),
      n['d'](k, {
        'Array2DGridDataProvider': () => Array2DGridDataProvider,
        'BinaryGridDataProvider': () => BinaryGridDataProvider,
        'BinaryReader': () => BinaryReader,
        'BitmapColorScaleGL': () => iS['Xm'],
        'CSStyle': () => iB['NX'],
        'CSStyle3D': () => CSStyle3D,
        'CimissGridDataProvider': () => CimissGridDataProvider,
        'CimissStationFeatureProvider': () => CimissStationFeatureProvider,
        'CollisionDetectMode': () => CollisionDetectMode,
        'CollisonDetector': () => CollisonDetector,
        'DAPParserType': () => e1['ko'],
        'DAPService': () => DAPService,
        'DASParser': () => e1['Bn'],
        'DDSParser': () => e1['cF'],
        'DODSUnpacker': () => DODSUnpacker,
        'DataAnimationService': () => DataAnimationService,
        'DataAnimationType': () => DataAnimationType,
        'Evented': () => iT['c'],
        'FeatureBaseClass': () => iB['rJ'],
        'FeatureBooleanField2FeatureBooleanFunc': () => iB['pd'],
        'FeatureColorField2FeatureColorFunc': () => iB['Jf'],
        'FeatureDataProviderBase': () => FeatureDataProviderBase,
        'FeatureImageField2FeatureImageFunc': () => iB['cQ'],
        'FeatureImageStyle': () => iB['Tw'],
        'FeatureLabelStyle': () => iB['PE'],
        'FeatureLabelStyle3D': () => FeatureLabelStyle3D,
        'FeatureNumberArrayField2FeatureNumberArrayFunc': () => iB['q$'],
        'FeatureNumberField2FeatureNumberFunc': () => iB['JW'],
        'FeatureStringField2FeatureStringFunc': () => iB['Fj'],
        'FeatureStyle': () => iB['sC'],
        'FeatureStyle3D': () => FeatureStyle3D,
        'FeatureTextStyle': () => iB['oL'],
        'FeatureVolumeStyle': () => FeatureVolumeStyle,
        'FrameDrawService': () => FrameDrawService,
        'GeoJSONFeatureProvider': () => GeoJSONFeatureProvider,
        'Geometry3DLayerStyle': () => iS['Yv'],
        'Geometry3DSectionMode': () => iS['vS'],
        'GeometryStyle': () => iB['CI'],
        'GrayImageGridData': () => KN['K'],
        'GrayImageGridDataProvider': () => GrayImageGridDataProvider,
        'GridBaseStyle': () => iU['W6'],
        'GridBooleanField2GridBooleanFunc': () => iU['se'],
        'GridColorField2GridColorFunc': () => iU['vX'],
        'GridData': () => KN['P'],
        'GridDataGLFillMode': () => iS['sW'],
        'GridDataProviderBase': () => Km['r'],
        'GridDataType': () => KP['U'],
        'GridGLBaseStyle': () => iS['$n'],
        'GridImageField2GridImageFunc': () => iU['CN'],
        'GridImageFieldGL2TexImage': () => iS['Rd'],
        'GridImageStyle': () => iU['$f'],
        'GridLabelStyle': () => iU['dl'],
        'GridNumberArrayField2GridNumberArrayFunc': () => iU['UZ'],
        'GridNumberArrayFieldGL2GridNumberArray': () => iS['ce'],
        'GridNumberField2GridNumberFunc': () => iU['Dg'],
        'GridStringField2GridStringFunc': () => iU['no'],
        'GridTextStyle': () => iU['x1'],
        'IDWScatterInterpolator': () => IDWScatterInterpolator,
        'LayerCreator': () => LayerCreator,
        'LegendService': () => LegendService,
        'LogService': () => v0['$V'],
        'MCBDefaults': () => MCBDefaults,
        'MapToolService': () => MapToolService,
        'MemoryGridDataProvider': () => iu['o'],
        'MemoryWindDataProvider': () => MemoryWindDataProvider,
        'MicapsDiamond131GridDataProvider': () => MicapsDiamond131GridDataProvider,
        'JsonGridDataProvider': () => JsonGridDataProvider,
        'MicapsDiamond14FeatureProvider': () => MicapsDiamond14FeatureProvider,
        'MicapsDiamond2WindGridProvider': () => MicapsDiamond2WindGridProvider,
        'MicapsDiamond4GridDataProvider': () => MicapsDiamond4GridDataProvider,
        'PixelLayerStyle': () => iS['lj'],
        'PixelLayerStyle3D': () => iS['_E'],
        'PlainNumberArrayField2PlainNumberArrayFunc': () => iB['M'],
        'PlotConstants': () => PlotConstants,
        'PlotLineBase': () => PlotLineBase,
        'PlotPointBase': () => PlotPointBase,
        'PlotPolygonBase': () => PlotPolygonBase,
        'PlotShapeBase': () => eA,
        'PlotTypes': () => eH,
        'PointArrayFeatureProvider': () => b4,
        'PointImageStyle3D': () => iP,
        'PointStyle': () => iB['SC'],
        'PointStyle3D': () => iO,
        'PolygonStyle': () => iB['_7'],
        'PolygonStyle3D': () => ig,
        'PolylineStyle': () => iB['Xx'],
        'PolylineStyle3D': () => PolylineStyle3D,
        'QEGridDataProvider': () => QEGridDataProvider,
        'Quadtree': () => Quadtree,
        'RandomFeatureProvider': () => bH,
        'ResourceService': () => iz['zc'],
        'SimpleDapInfoParser': () => e1['b_'],
        'Spectra': () => id['t'],
        'StopRuleActionMode': () => iR['Mg'],
        'StopRuleItemFilterMode': () => iR['DY'],
        'StopRules': () => iR['NB'],
        'StyleBaseClass': () => iq['Uw'],
        'TifGridDataProvider': () => bb,
        'TracingService': () => bL,
        'TypeOf': () => Kz['BR'],
        'VectorMapTool': () => VectorMapTool,
        'VectorMapToolPointerButtonType': () => c9,
        'VolumeLayerStyle': () => iS['IW'],
        'Wind3DLayerStyle': () => iS['we'],
        'WindArrowLayerStyle': () => iS['S2'],
        'WindInterpMethodType': () => iS['Lh'],
        'WindLayerStyle': () => iS['SR'],
        'addCustomImageTileRules': () => cX,
        'antiDebug': () => KL['jr'],
        'array2Spectra': () => iq['LH'],
        'assign': () => Kz['f0'],
        'auth': () => cB,
        'authInfo': () => cf,
        'bitmapColorScaleFieldGL2BitmapColorScaleGL': () => iS['sC'],
        'bufferExtent': () => Kz['VS'],
        'calcMaxMin': () => Kz['pj'],
        'clipGridData': () => Kz['U2'],
        'clipGridProvider': () => Kz['ZS'],
        'colorStopRuleItemConverter': () => iq['$k'],
        'consts': () => Kg['v'],
        'createBoxGeometry': () => cK,
        'createDrawPlot': () => createDrawPlot,
        'createGLTypedArray': () => createGLTypedArray,
        'createRadarRangeRingGeoJSON': () => Kz['Ef'],
        'createTypeArr': () => Kz['cM'],
        'deepCopyLiteral': () => Kz['f8'],
        'defaultLoaderNames': () => cF['ke'],
        'defaultVal': () => Kz['En'],
        'defined': () => Kz['ri'],
        'degreeToArc': () => cF['Qs'],
        'detectBrowser': () => KL['Ao'],
        'detectOS': () => KL['fV'],
        'downloadImage': () => Kz['GN'],
        'drawCustomGridSection': () => cx,
        'drawGridSection': () => cp,
        'drawRoundRect': () => cH,
        'earcut': () => v1,
        'earcutFlatten': () => vX,
        'ensureFloatString': () => ik,
        'ensureGridDataOptions': () => KM['T'],
        'extend': () => Kz['l7'],
        'featureStyleResourceCreator': () => iz['gD'],
        'floorMod': () => Kz['vY'],
        'formatDate': () => Kz['p6'],
        'getAlgoConstsAndUniforms': () => i7,
        'getBinaries': () => Kz['K0'],
        'getBinary': () => Kz['j$'],
        'getCR': () => Kz['BG'],
        'getFieldLoader': () => cF['nA'],
        'getGridPosIndex': () => Kz['tr'],
        'getHeightAlgoConstsAndUniforms': () => i6,
        'getHeightUniforms': () => iA,
        'getImageTileUrls': () => cE,
        'getJSON': () => Kz['xA'],
        'getJSONZip': () => Kz['lC'],
        'getPos1DFrom2D': () => Kz['vi'],
        'getPos2DFrom1D': () => Kz['Fp'],
        'getPredefinedBitmapScale': () => b0['K9'],
        'getPredefinedBitmapScaleSync': () => b0['dO'],
        'getPredefinedStopRules': () => b0['uD'],
        'getProperlyWebGLVersion': () => KL['lS'],
        'getQueryParams': () => iq['vl'],
        'getRGBA2FloatConsts': () => iK,
        'getRaw': () => Kz['oT'],
        'getSDFromUV': () => Kz['C8'],
        'getText': () => Kz['Q'],
        'getTiltPathOfGridDatas': () => cc,
        'getUVFromSD': () => Kz['Hn'],
        'glNames': () => ic,
        'gridColorFieldGL2StopRules': () => iS['m_'],
        'gridNumberFieldGL2GridNumberStopRules': () => iS['m3'],
        'gridOptionsToExtent': () => KM['Z'],
        'gridStaticColorFieldGL2NumberArray': () => iS['hM'],
        'gridStaticColorFieldGL2Spectra': () => iS['uI'],
        'gridStyleResourceCreator': () => iz['xR'],
        'imageResourceCreator': () => iz['Xf'],
        'init': () => cV,
        'injectBuiltInShaderFunctions': () => i5,
        'interpColor': () => Kz['$k'],
        'isArray': () => Kz['kJ'],
        'isArrayBuffer': () => Kz['eP'],
        'isDate': () => Kz['J_'],
        'isEmpty': () => Kz['xb'],
        'isFunction': () => Kz['mf'],
        'isMobile': () => KL['tq'],
        'isMoblie': () => KL['Tz'],
        'isNull': () => Kz['Ft'],
        'isNumber': () => Kz['hj'],
        'isObject': () => Kz['Kn'],
        'isString': () => Kz['HD'],
        'isSupportedBrowser': () => KL['H$'],
        'isValid': () => Kz['JY'],
        'jsonFileResourceCreator': () => iz['I$'],
        'layerCreator': () => iL,
        'loadAllImages': () => Kz['EX'],
        'loadGridMesh': () => Kz['d$'],
        'loadResourcesAndLayers': () => im,
        'loadScript': () => Kz['ve'],
        'logger': () => v0['kg'],
        'mcb': () => ij,
        'mergeShaderLib': () => iF,
        'number2Spectra': () => iq['lW'],
        'onWindowSizeChanged': () => Kz['Wd'],
        'p2h': () => Kz['Tc'],
        'pickColor': () => Kz['ft'],
        'preDeinfedImageTileTokens': () => cu,
        'predefinedColorNames': () => id['m'],
        'predefinedImageTiles': () => cY,
        'predefinedLegendNames': () => b0['xS'],
        'processFieldWithLoaders': () => iq['it'],
        'qeFetch': () => Kz['TN'],
        'qeGLFuncs': () => iy,
        'randomPointInExtent': () => Kz['wO'],
        'randomPointInGrid': () => Kz['r_'],
        'randomValueInRange': () => Kz['Zu'],
        'rawFileResourceCreator': () => iz['GB'],
        'registerDrawPlotCreator': () => c7,
        'registerFieldLoader': () => cF['OE'],
        'registerFieldLoaders': () => cF['c0'],
        'resourceCreatorBase': () => iz['pQ'],
        'resourceService': () => iz['Zc'],
        'resourceTypePreDefined': () => iz['MM'],
        'saveGridMesh': () => Kz['XG'],
        'scaleGridProvider': () => ix,
        'setAlgoUniforms': () => iv,
        'setDirectAlgoUniforms': () => i8,
        'setGLNames': () => iH,
        'setHeightAlgoUniforms': () => i9,
        'setOptions': () => Kz['Ov'],
        'setOptionsDeep': () => Kz['uw'],
        'setShaders': () => ih,
        'shaderLib': () => ip,
        'splitWords': () => Kz['nf'],
        'stamp': () => Kz['Rc'],
        'stopRuleResouceCreator': () => iz['qg'],
        'string2Spectra': () => iq['$P'],
        'supportWebP': () => KL['sU'],
        'toOneDim': () => Kz['LG'],
        'uid': () => Kz['hQ'],
        'updateLoggerDebugMode': () => v0['qr'],
        'whenValid': () => Kz['Rf'],
        'windSpeed2ttf': () => cF['y$'],
        'wrapLon': () => Kz['_6'],
        'ww2ttf': () => cF['EO']
      });
    var v0 = n(0x39b);
    function v1 (cS, cU, cd) {
      cd = cd || 0x2;
      var cq, cJ, cC, cO, cG, cg, cN, cP = cU && cU['length'], cM = cP ? cU[0x0] * cd : cS['length'], cz = v2(cS, 0x0, cM, cd, true), cQ = [];
      if (!cz || cz['next'] === cz['prev'])
        return cQ;
      if (cP && (cz = function (cL, cR, H0, H1) {
        var H2, H3, H4, H5 = [];
        for (H2 = 0x0,
          H3 = cR['length']; H2 < H3; H2++)
          (H4 = v2(cL, cR[H2] * H1, H2 < H3 - 0x1 ? cR[H2 + 0x1] * H1 : cL['length'], H1, false)) === H4['next'] && (H4['steiner'] = true),
            H5['push'](vK(H4));
        for (H5['sort'](v9),
          H2 = 0x0; H2 < H5['length']; H2++)
          vv(H5[H2], H0),
            H0 = v3(H0, H0['next']);
        return H0;
      }(cS, cU, cz, cd)),
        cS['length'] > 0x50 * cd) {
        cq = cC = cS[0x0],
          cJ = cO = cS[0x1];
        for (var cm = cd; cm < cM; cm += cd)
          (cG = cS[cm]) < cq && (cq = cG),
            (cg = cS[cm + 0x1]) < cJ && (cJ = cg),
            cG > cC && (cC = cG),
            cg > cO && (cO = cg);
        cN = 0x0 !== (cN = Math['max'](cC - cq, cO - cJ)) ? 0x1 / cN : 0x0;
      }
      return v4(cz, cQ, cd, cq, cJ, cN),
        cQ;
    }
    function v2 (cS, cU, cd, cq, cJ) {
      var cC, cO;
      if (cJ === function (cG, cg, cN, cP) {
        for (var cM = 0x0, cz = cg, cQ = cN - cP; cz < cN; cz += cP)
          cM += (cG[cQ] - cG[cz]) * (cG[cz + 0x1] + cG[cQ + 0x1]),
            cQ = cz;
        return cM;
      }(cS, cU, cd, cq) > 0x0) {
        for (cC = cU; cC < cd; cC += cq)
          cO = vu(cC, cS[cC], cS[cC + 0x1], cO);
      } else {
        for (cC = cd - cq; cC >= cU; cC -= cq)
          cO = vu(cC, cS[cC], cS[cC + 0x1], cO);
      }
      return cO && vx(cO, cO['next']) && (vY(cO),
        cO = cO['next']),
        cO;
    }
    function v3 (cS, cU) {
      if (!cS)
        return cS;
      cU || (cU = cS);
      var cd, cq = cS;
      do {
        if (cd = false,
          cq['steiner'] || !vx(cq, cq['next']) && 0x0 !== vH(cq['prev'], cq, cq['next']))
          cq = cq['next'];
        else {
          if (vY(cq),
            (cq = cU = cq['prev']) === cq['next'])
            break;
          cd = true;
        }
      } while (cd || cq !== cU);
      return cU;
    }
    function v4 (cS, cU, cd, cq, cJ, cC, cO) {
      if (cS) {
        !cO && cC && function (cP, cM, cz, cQ) {
          var cm = cP;
          do {
            null === cm['z'] && (cm['z'] = vk(cm['x'], cm['y'], cM, cz, cQ)),
              cm['prevZ'] = cm['prev'],
              cm['nextZ'] = cm['next'],
              cm = cm['next'];
          } while (cm !== cP);
          cm['prevZ']['nextZ'] = null,
            cm['prevZ'] = null,
            function (cL) {
              var cR, H0, H1, H2, H3, H4, H5, H6, H7 = 0x1;
              do {
                for (H0 = cL,
                  cL = null,
                  H3 = null,
                  H4 = 0x0; H0;) {
                  for (H4++,
                    H1 = H0,
                    H5 = 0x0,
                    cR = 0x0; cR < H7 && (H5++,
                      H1 = H1['nextZ']); cR++)
                    ;
                  for (H6 = H7; H5 > 0x0 || H6 > 0x0 && H1;)
                    0x0 !== H5 && (0x0 === H6 || !H1 || H0['z'] <= H1['z']) ? (H2 = H0,
                      H0 = H0['nextZ'],
                      H5--) : (H2 = H1,
                        H1 = H1['nextZ'],
                        H6--),
                      H3 ? H3['nextZ'] = H2 : cL = H2,
                      H2['prevZ'] = H3,
                      H3 = H2;
                  H0 = H1;
                }
                H3['nextZ'] = null,
                  H7 *= 0x2;
              } while (H4 > 0x1);
            }(cm);
        }(cS, cq, cJ, cC);
        for (var cG, cg, cN = cS; cS['prev'] !== cS['next'];)
          if (cG = cS['prev'],
            cg = cS['next'],
            cC ? v6(cS, cq, cJ, cC) : v5(cS))
            cU['push'](cG['i'] / cd),
              cU['push'](cS['i'] / cd),
              cU['push'](cg['i'] / cd),
              vY(cS),
              cS = cg['next'],
              cN = cg['next'];
          else {
            if ((cS = cg) === cN) {
              cO ? 0x1 === cO ? v4(cS = v7(v3(cS), cU, cd), cU, cd, cq, cJ, cC, 0x2) : 0x2 === cO && v8(cS, cU, cd, cq, cJ, cC) : v4(v3(cS), cU, cd, cq, cJ, cC, 0x1);
              break;
            }
          }
      }
    }
    function v5 (cS) {
      var cU = cS['prev']
        , cd = cS
        , cq = cS['next'];
      if (vH(cU, cd, cq) >= 0x0)
        return false;
      for (var cJ = cS['next']['next']; cJ !== cS['prev'];) {
        if (vb(cU['x'], cU['y'], cd['x'], cd['y'], cq['x'], cq['y'], cJ['x'], cJ['y']) && vH(cJ['prev'], cJ, cJ['next']) >= 0x0)
          return false;
        cJ = cJ['next'];
      }
      return true;
    }
    function v6 (cS, cU, cd, cq) {
      var cJ = cS['prev']
        , cC = cS
        , cO = cS['next'];
      if (vH(cJ, cC, cO) >= 0x0)
        return false;
      for (var cG = cJ['x'] < cC['x'] ? cJ['x'] < cO['x'] ? cJ['x'] : cO['x'] : cC['x'] < cO['x'] ? cC['x'] : cO['x'], cg = cJ['y'] < cC['y'] ? cJ['y'] < cO['y'] ? cJ['y'] : cO['y'] : cC['y'] < cO['y'] ? cC['y'] : cO['y'], cN = cJ['x'] > cC['x'] ? cJ['x'] > cO['x'] ? cJ['x'] : cO['x'] : cC['x'] > cO['x'] ? cC['x'] : cO['x'], cP = cJ['y'] > cC['y'] ? cJ['y'] > cO['y'] ? cJ['y'] : cO['y'] : cC['y'] > cO['y'] ? cC['y'] : cO['y'], cM = vk(cG, cg, cU, cd, cq), cz = vk(cN, cP, cU, cd, cq), cQ = cS['prevZ'], cm = cS['nextZ']; cQ && cQ['z'] >= cM && cm && cm['z'] <= cz;) {
        if (cQ !== cS['prev'] && cQ !== cS['next'] && vb(cJ['x'], cJ['y'], cC['x'], cC['y'], cO['x'], cO['y'], cQ['x'], cQ['y']) && vH(cQ['prev'], cQ, cQ['next']) >= 0x0)
          return false;
        if (cQ = cQ['prevZ'],
          cm !== cS['prev'] && cm !== cS['next'] && vb(cJ['x'], cJ['y'], cC['x'], cC['y'], cO['x'], cO['y'], cm['x'], cm['y']) && vH(cm['prev'], cm, cm['next']) >= 0x0)
          return false;
        cm = cm['nextZ'];
      }
      for (; cQ && cQ['z'] >= cM;) {
        if (cQ !== cS['prev'] && cQ !== cS['next'] && vb(cJ['x'], cJ['y'], cC['x'], cC['y'], cO['x'], cO['y'], cQ['x'], cQ['y']) && vH(cQ['prev'], cQ, cQ['next']) >= 0x0)
          return false;
        cQ = cQ['prevZ'];
      }
      for (; cm && cm['z'] <= cz;) {
        if (cm !== cS['prev'] && cm !== cS['next'] && vb(cJ['x'], cJ['y'], cC['x'], cC['y'], cO['x'], cO['y'], cm['x'], cm['y']) && vH(cm['prev'], cm, cm['next']) >= 0x0)
          return false;
        cm = cm['nextZ'];
      }
      return true;
    }
    function v7 (cS, cU, cd) {
      var cq = cS;
      do {
        var cJ = cq['prev']
          , cC = cq['next']['next'];
        !vx(cJ, cC) && vp(cJ, cq, cq['next'], cC) && vw(cJ, cC) && vw(cC, cJ) && (cU['push'](cJ['i'] / cd),
          cU['push'](cq['i'] / cd),
          cU['push'](cC['i'] / cd),
          vY(cq),
          vY(cq['next']),
          cq = cS = cC),
          cq = cq['next'];
      } while (cq !== cS);
      return v3(cq);
    }
    function v8 (cS, cU, cd, cq, cJ, cC) {
      var cO = cS;
      do {
        for (var cG = cO['next']['next']; cG !== cO['prev'];) {
          if (cO['i'] !== cG['i'] && vc(cO, cG)) {
            var cg = vh(cO, cG);
            return cO = v3(cO, cO['next']),
              cg = v3(cg, cg['next']),
              v4(cO, cU, cd, cq, cJ, cC),
              void v4(cg, cU, cd, cq, cJ, cC);
          }
          cG = cG['next'];
        }
        cO = cO['next'];
      } while (cO !== cS);
    }
    function v9 (cS, cU) {
      return cS['x'] - cU['x'];
    }
    function vv (cS, cU) {
      if (cU = function (cq, cJ) {
        var cC, cO = cJ, cG = cq['x'], cg = cq['y'], cN = -0x1 / 0x0;
        do {
          if (cg <= cO['y'] && cg >= cO['next']['y'] && cO['next']['y'] !== cO['y']) {
            var cP = cO['x'] + (cg - cO['y']) * (cO['next']['x'] - cO['x']) / (cO['next']['y'] - cO['y']);
            if (cP <= cG && cP > cN) {
              if (cN = cP,
                cP === cG) {
                if (cg === cO['y'])
                  return cO;
                if (cg === cO['next']['y'])
                  return cO['next'];
              }
              cC = cO['x'] < cO['next']['x'] ? cO : cO['next'];
            }
          }
          cO = cO['next'];
        } while (cO !== cJ);
        if (!cC)
          return null;
        if (cG === cN)
          return cC;
        var cM, cz = cC, cQ = cC['x'], cm = cC['y'], cL = 0x1 / 0x0;
        cO = cC;
        do {
          cG >= cO['x'] && cO['x'] >= cQ && cG !== cO['x'] && vb(cg < cm ? cG : cN, cg, cQ, cm, cg < cm ? cN : cG, cg, cO['x'], cO['y']) && (cM = Math['abs'](cg - cO['y']) / (cG - cO['x']),
            vw(cO, cq) && (cM < cL || cM === cL && (cO['x'] > cC['x'] || cO['x'] === cC['x'] && vA(cC, cO))) && (cC = cO,
              cL = cM)),
            cO = cO['next'];
        } while (cO !== cz);
        return cC;
      }(cS, cU),
        cU) {
        var cd = vh(cU, cS);
        v3(cU, cU['next']),
          v3(cd, cd['next']);
      }
    }
    function vA (cS, cU) {
      return vH(cS['prev'], cS, cU['prev']) < 0x0 && vH(cU['next'], cS, cS['next']) < 0x0;
    }
    function vk (cS, cU, cd, cq, cJ) {
      return (cS = 0x55555555 & ((cS = 0x33333333 & ((cS = 0xf0f0f0f & ((cS = 0xff00ff & ((cS = 0x7fff * (cS - cd) * cJ) | cS << 0x8)) | cS << 0x4)) | cS << 0x2)) | cS << 0x1)) | (cU = 0x55555555 & ((cU = 0x33333333 & ((cU = 0xf0f0f0f & ((cU = 0xff00ff & ((cU = 0x7fff * (cU - cq) * cJ) | cU << 0x8)) | cU << 0x4)) | cU << 0x2)) | cU << 0x1)) << 0x1;
    }
    function vK (cS) {
      var cU = cS
        , cd = cS;
      do {
        (cU['x'] < cd['x'] || cU['x'] === cd['x'] && cU['y'] < cd['y']) && (cd = cU),
          cU = cU['next'];
      } while (cU !== cS);
      return cd;
    }
    function vb (cS, cU, cd, cq, cJ, cC, cO, cG) {
      return (cJ - cO) * (cU - cG) - (cS - cO) * (cC - cG) >= 0x0 && (cS - cO) * (cq - cG) - (cd - cO) * (cU - cG) >= 0x0 && (cd - cO) * (cC - cG) - (cJ - cO) * (cq - cG) >= 0x0;
    }
    function vc (cS, cU) {
      return cS['next']['i'] !== cU['i'] && cS['prev']['i'] !== cU['i'] && !function (cd, cq) {
        var cJ = cd;
        do {
          if (cJ['i'] !== cd['i'] && cJ['next']['i'] !== cd['i'] && cJ['i'] !== cq['i'] && cJ['next']['i'] !== cq['i'] && vp(cJ, cJ['next'], cd, cq))
            return true;
          cJ = cJ['next'];
        } while (cJ !== cd);
        return false;
      }(cS, cU) && (vw(cS, cU) && vw(cU, cS) && function (cd, cq) {
        var cJ = cd
          , cC = false
          , cO = (cd['x'] + cq['x']) / 0x2
          , cG = (cd['y'] + cq['y']) / 0x2;
        do {
          cJ['y'] > cG != cJ['next']['y'] > cG && cJ['next']['y'] !== cJ['y'] && cO < (cJ['next']['x'] - cJ['x']) * (cG - cJ['y']) / (cJ['next']['y'] - cJ['y']) + cJ['x'] && (cC = !cC),
            cJ = cJ['next'];
        } while (cJ !== cd);
        return cC;
      }(cS, cU) && (vH(cS['prev'], cS, cU['prev']) || vH(cS, cU['prev'], cU)) || vx(cS, cU) && vH(cS['prev'], cS, cS['next']) > 0x0 && vH(cU['prev'], cU, cU['next']) > 0x0);
    }
    function vH (cS, cU, cd) {
      return (cU['y'] - cS['y']) * (cd['x'] - cU['x']) - (cU['x'] - cS['x']) * (cd['y'] - cU['y']);
    }
    function vx (cS, cU) {
      return cS['x'] === cU['x'] && cS['y'] === cU['y'];
    }
    function vp (cS, cU, cd, cq) {
      var cJ = vy(vH(cS, cU, cd))
        , cC = vy(vH(cS, cU, cq))
        , cO = vy(vH(cd, cq, cS))
        , cG = vy(vH(cd, cq, cU));
      return cJ !== cC && cO !== cG || !(0x0 !== cJ || !vF(cS, cd, cU)) || !(0x0 !== cC || !vF(cS, cq, cU)) || !(0x0 !== cO || !vF(cd, cS, cq)) || !(0x0 !== cG || !vF(cd, cU, cq));
    }
    function vF (cS, cU, cd) {
      return cU['x'] <= Math['max'](cS['x'], cd['x']) && cU['x'] >= Math['min'](cS['x'], cd['x']) && cU['y'] <= Math['max'](cS['y'], cd['y']) && cU['y'] >= Math['min'](cS['y'], cd['y']);
    }
    function vy (cS) {
      return cS > 0x0 ? 0x1 : cS < 0x0 ? -0x1 : 0x0;
    }
    function vw (cS, cU) {
      return vH(cS['prev'], cS, cS['next']) < 0x0 ? vH(cS, cU, cS['next']) >= 0x0 && vH(cS, cS['prev'], cU) >= 0x0 : vH(cS, cU, cS['prev']) < 0x0 || vH(cS, cS['next'], cU) < 0x0;
    }
    function vh (cS, cU) {
      var cd = new vT(cS['i'], cS['x'], cS['y'])
        , cq = new vT(cU['i'], cU['x'], cU['y'])
        , cJ = cS['next']
        , cC = cU['prev'];
      return cS['next'] = cU,
        cU['prev'] = cS,
        cd['next'] = cJ,
        cJ['prev'] = cd,
        cq['next'] = cd,
        cd['prev'] = cq,
        cC['next'] = cq,
        cq['prev'] = cC,
        cq;
    }
    function vu (cS, cU, cd, cq) {
      var cJ = new vT(cS, cU, cd);
      return cq ? (cJ['next'] = cq['next'],
        cJ['prev'] = cq,
        cq['next']['prev'] = cJ,
        cq['next'] = cJ) : (cJ['prev'] = cJ,
          cJ['next'] = cJ),
        cJ;
    }
    function vY (cS) {
      cS['next']['prev'] = cS['prev'],
        cS['prev']['next'] = cS['next'],
        cS['prevZ'] && (cS['prevZ']['nextZ'] = cS['nextZ']),
        cS['nextZ'] && (cS['nextZ']['prevZ'] = cS['prevZ']);
    }
    function vT (cS, cU, cd) {
      this['i'] = cS,
        this['x'] = cU,
        this['y'] = cd,
        this['prev'] = null,
        this['next'] = null,
        this['z'] = null,
        this['prevZ'] = null,
        this['nextZ'] = null,
        this['steiner'] = false;
    }
    function vX (cS) {
      for (var cU = cS[0x0][0x0]['length'], cd = {
        'vertices': [],
        'holes': [],
        'dimensions': cU
      }, cq = 0x0, cJ = 0x0; cJ < cS['length']; cJ++) {
        for (var cC = 0x0; cC < cS[cJ]['length']; cC++)
          for (var cO = 0x0; cO < cU; cO++)
            cd['vertices']['push'](cS[cJ][cC][cO]);
        cJ > 0x0 && (cq += cS[cJ - 0x1]['length'],
          cd['holes']['push'](cq));
      }
      return cd;
    }
    class Quadtree {
      constructor(cS, cU, cd, cq) {
        this['max_objects'] = cU || 0xa,
          this['max_levels'] = cd || 0x4,
          this['level'] = cq || 0x0,
          this['bounds'] = cS,
          this['objects'] = [],
          this['nodes'] = [];
      }
      ['split'] () {
        var cS = this['level'] + 0x1
          , cU = this['bounds']['width'] / 0x2
          , cd = this['bounds']['height'] / 0x2
          , cq = this['bounds']['x']
          , cJ = this['bounds']['y'];
        this['nodes'][0x0] = new Quadtree({
          'x': cq + cU,
          'y': cJ,
          'width': cU,
          'height': cd
        }, this['max_objects'], this['max_levels'], cS),
          this['nodes'][0x1] = new Quadtree({
            'x': cq,
            'y': cJ,
            'width': cU,
            'height': cd
          }, this['max_objects'], this['max_levels'], cS),
          this['nodes'][0x2] = new Quadtree({
            'x': cq,
            'y': cJ + cd,
            'width': cU,
            'height': cd
          }, this['max_objects'], this['max_levels'], cS),
          this['nodes'][0x3] = new Quadtree({
            'x': cq + cU,
            'y': cJ + cd,
            'width': cU,
            'height': cd
          }, this['max_objects'], this['max_levels'], cS);
      }
      ['getIndex'] (cS) {
        var cU = []
          , cd = this['bounds']['x'] + this['bounds']['width'] / 0x2
          , cq = this['bounds']['y'] + this['bounds']['height'] / 0x2
          , cJ = cS['y'] < cq
          , cC = cS['x'] < cd
          , cO = cS['x'] + cS['width'] > cd
          , cG = cS['y'] + cS['height'] > cq;
        return cJ && cO && cU['push'](0x0),
          cC && cJ && cU['push'](0x1),
          cC && cG && cU['push'](0x2),
          cO && cG && cU['push'](0x3),
          cU;
      }
      ['insert'] (cS) {
        var cU, cd = 0x0;
        if (this['nodes']['length']) {
          for (cU = this['getIndex'](cS),
            cd = 0x0; cd < cU['length']; cd++)
            this['nodes'][cU[cd]]['insert'](cS);
        } else {
          if (this['objects']['push'](cS),
            this['objects']['length'] > this['max_objects'] && this['level'] < this['max_levels']) {
            for (this['nodes']['length'] || this['split'](),
              cd = 0x0; cd < this['objects']['length']; cd++) {
              cU = this['getIndex'](this['objects'][cd]);
              for (var cq = 0x0; cq < cU['length']; cq++)
                this['nodes'][cU[cq]]['insert'](this['objects'][cd]);
            }
            this['objects'] = [];
          }
        }
      }
      ['retrieve'] (cS, cU = true) {
        var cd = this['getIndex'](cS)
          , cq = this['objects'];
        if (this['nodes']['length']) {
          for (var cJ = 0x0; cJ < cd['length']; cJ++)
            cq = cq['concat'](this['nodes'][cd[cJ]]['retrieve'](cS));
        }
        return cU || (cq = cq['filter'](function (cC, cO) {
          return cq['indexOf'](cC) >= cO;
        })),
          cq;
      }
      ['clear'] () {
        this['objects'] = [];
        for (var cS = 0x0; cS < this['nodes']['length']; cS++)
          this['nodes']['length'] && this['nodes'][cS]['clear']();
        this['nodes'] = [];
      }
    }
    let vf = Float32Array;
    function vW (cS, cU, cd) {
      const cq = new vf(0x3);
      return cS && (cq[0x0] = cS),
        cU && (cq[0x1] = cU),
        cd && (cq[0x2] = cd),
        cq;
    }
    function vI (cS, cU, cd) {
      return (cd = cd || new vf(0x3))[0x0] = cS[0x0] + cU[0x0],
        cd[0x1] = cS[0x1] + cU[0x1],
        cd[0x2] = cS[0x2] + cU[0x2],
        cd;
    }
    let vj = Float32Array;
    function vD (cS, cU, cd) {
      cd = cd || vW();
      const cq = cU[0x0]
        , cJ = cU[0x1]
        , cC = cU[0x2]
        , cO = cq * cS[0x3] + cJ * cS[0x7] + cC * cS[0xb] + cS[0xf];
      return cd[0x0] = (cq * cS[0x0] + cJ * cS[0x4] + cC * cS[0x8] + cS[0xc]) / cO,
        cd[0x1] = (cq * cS[0x1] + cJ * cS[0x5] + cC * cS[0x9] + cS[0xd]) / cO,
        cd[0x2] = (cq * cS[0x2] + cJ * cS[0x6] + cC * cS[0xa] + cS[0xe]) / cO,
        cd;
    }
    function vV (cS, cU, cd) {
      cd = cd || vW();
      const cq = cU[0x0]
        , cJ = cU[0x1]
        , cC = cU[0x2];
      return cd[0x0] = cq * cS[0x0] + cJ * cS[0x4] + cC * cS[0x8],
        cd[0x1] = cq * cS[0x1] + cJ * cS[0x5] + cC * cS[0x9],
        cd[0x2] = cq * cS[0x2] + cJ * cS[0x6] + cC * cS[0xa],
        cd;
    }
    const vZ = 0x1400
      , vB = 0x1401
      , vS = 0x1402
      , vU = 0x1403
      , vd = 0x1404
      , vq = 0x1405
      , vJ = 0x1406
      , vC = {};
    {
      const cS = vC;
      cS[vZ] = Int8Array,
        cS[vB] = Uint8Array,
        cS[vS] = Int16Array,
        cS[vU] = Uint16Array,
        cS[vd] = Int32Array,
        cS[vq] = Uint32Array,
        cS[vJ] = Float32Array,
        cS[0x8033] = Uint16Array,
        cS[0x8034] = Uint16Array,
        cS[0x8363] = Uint16Array,
        cS[0x140b] = Uint16Array,
        cS[0x8368] = Uint32Array,
        cS[0x8c3b] = Uint32Array,
        cS[0x8c3e] = Uint32Array,
        cS[0x8dad] = Uint32Array,
        cS[0x84fa] = Uint32Array;
    }
    function vO (cU) {
      if (cU instanceof Int8Array)
        return vZ;
      if (cU instanceof Uint8Array)
        return vB;
      if (cU instanceof Uint8ClampedArray)
        return vB;
      if (cU instanceof Int16Array)
        return vS;
      if (cU instanceof Uint16Array)
        return vU;
      if (cU instanceof Int32Array)
        return vd;
      if (cU instanceof Uint32Array)
        return vq;
      if (cU instanceof Float32Array)
        return vJ;
      throw new Error('unsupported\x20typed\x20array\x20type');
    }
    function vG (cU) {
      if (cU === Int8Array)
        return vZ;
      if (cU === Uint8Array)
        return vB;
      if (cU === Uint8ClampedArray)
        return vB;
      if (cU === Int16Array)
        return vS;
      if (cU === Uint16Array)
        return vU;
      if (cU === Int32Array)
        return vd;
      if (cU === Uint32Array)
        return vq;
      if (cU === Float32Array)
        return vJ;
      throw new Error('unsupported\x20typed\x20array\x20type');
    }
    function vg (cU) {
      const cd = vC[cU];
      if (!cd)
        throw new Error('unknown\x20gl\x20type');
      return cd;
    }
    const vN = 'undefined' != typeof SharedArrayBuffer ? function (cU) {
      return cU && cU['buffer'] && (cU['buffer'] instanceof ArrayBuffer || cU['buffer'] instanceof SharedArrayBuffer);
    }
      : function (cU) {
        return cU && cU['buffer'] && cU['buffer'] instanceof ArrayBuffer;
      }
      ;
    function vP (...cU) {
      console['error'](...cU);
    }
    function vM (...cU) {
      console['warn'](...cU);
    }
    const vz = new Map();
    function vQ (cU, cd) {
      if (!cU || 'object' != typeof cU)
        return false;
      let cq = vz['get'](cd);
      cq || (cq = new WeakMap(),
        vz['set'](cd, cq));
      let cJ = cq['get'](cU);
      if (undefined === cJ) {
        const cC = Object['prototype']['toString']['call'](cU);
        cJ = cC['substring'](0x8, cC['length'] - 0x1) === cd,
          cq['set'](cU, cJ);
      }
      return cJ;
    }
    function vm (cU, cd) {
      return 'undefined' != typeof WebGLTexture && vQ(cd, 'WebGLTexture');
    }
    const vL = 0x88e4
      , vR = 0x8892
      , A0 = 0x8893
      , A1 = 0x8764
      , A2 = 0x1400
      , A3 = 0x1401
      , A4 = 0x1402
      , A5 = 0x1403
      , A6 = 0x1404
      , A7 = 0x1405
      , A8 = 0x1406
      , A9 = {
        'attribPrefix': ''
      };
    function Av (cU, cd, cq, cJ) {
      if ('undefined' != typeof WebGLBuffer && vQ(cd, 'WebGLBuffer'))
        return cd;
      cq = cq || vR;
      const cC = cU['createBuffer']();
      return function (cO, cG, cg, cN, cP) {
        cO['bindBuffer'](cG, cg),
          cO['bufferData'](cG, cN, cP || vL);
      }(cU, cq, cC, cd, cJ),
        cC;
    }
    function AA (cU) {
      return 'indices' === cU;
    }
    function Ak (cU) {
      return cU['length'] ? cU : cU['data'];
    }
    const AK = /coord|texture/i
      , Ab = /color|colour/i;
    function Ac (cU, cd, cq) {
      return cU['numComponents'] || cU['size'] || function (cJ, cC) {
        let cO;
        if (cO = AK['test'](cJ) ? 0x2 : Ab['test'](cJ) ? 0x4 : 0x3,
          cC % cO > 0x0)
          throw new Error('Can\x20not\x20guess\x20numComponents\x20for\x20attribute\x20\x27' + cJ + '\x27.\x20Tried\x20' + cO + '\x20but\x20' + cC + '\x20values\x20is\x20not\x20evenly\x20divisible\x20by\x20' + cO + '.\x20You\x20should\x20specify\x20it.');
        return cO;
      }(cd, cq || Ak(cU)['length']);
    }
    function AH (cU, cd) {
      if (vN(cU))
        return cU;
      if (vN(cU['data']))
        return cU['data'];
      Array['isArray'](cU) && (cU = {
        'data': cU
      });
      let cq = cU['type'] ? Ax(cU['type']) : undefined;
      return cq || (cq = AA(cd) ? Uint16Array : Float32Array),
        new cq(cU['data']);
    }
    function Ax (cU) {
      return 'number' == typeof cU ? vg(cU) : cU || Float32Array;
    }
    function Ap (cU, cd) {
      return {
        'buffer': cd['buffer'],
        'numValues': 0x18,
        'type': (cq = cd['type'],
          'number' == typeof cq ? cq : cq ? vG(cq) : A8),
        'arrayType': Ax(cd['type'])
      };
      var cq;
    }
    function AF (cU, cd) {
      const cq = cd['data'] || cd
        , cJ = Ax(cd['type'])
        , cC = cq * cJ['BYTES_PER_ELEMENT']
        , cO = cU['createBuffer']();
      return cU['bindBuffer'](vR, cO),
        cU['bufferData'](vR, cC, cd['drawType'] || vL),
      {
        'buffer': cO,
        'numValues': cq,
        'type': vG(cJ),
        'arrayType': cJ
      };
    }
    function Ay (cU, cd, cq) {
      const cJ = AH(cd, cq);
      return {
        'arrayType': cJ['constructor'],
        'buffer': Av(cU, cJ, undefined, cd['drawType']),
        'type': vO(cJ),
        'numValues': 0x0
      };
    }
    const Aw = ['position', 'positions', 'a_position'];
    function Ah (cU, cd, cq) {
      const cJ = function (cG, cg) {
        const cN = {};
        return Object['keys'](cg)['forEach'](function (cP) {
          if (!AA(cP)) {
            const cz = cg[cP]
              , cQ = cz['attrib'] || cz['name'] || cz['attribName'] || A9['attribPrefix'] + cP;
            if (cz['value']) {
              if (!Array['isArray'](cz['value']) && !vN(cz['value']))
                throw new Error('array.value\x20is\x20not\x20array\x20or\x20typedarray');
              cN[cQ] = {
                'value': cz['value']
              };
            } else {
              let cm;
              cm = cz['buffer'] && cz['buffer'] instanceof WebGLBuffer ? Ap : 'number' == typeof cz || 'number' == typeof cz['data'] ? AF : Ay;
              const { buffer: cL, type: cR, numValues: H0, arrayType: H1 } = cm(cG, cz, cP)
                , H2 = undefined !== cz['normalize'] ? cz['normalize'] : (cM = H1) === Int8Array || cM === Uint8Array
                , H3 = Ac(cz, cP, H0);
              cN[cQ] = {
                'buffer': cL,
                'numComponents': H3,
                'type': cR,
                'normalize': H2,
                'stride': cz['stride'] || 0x0,
                'offset': cz['offset'] || 0x0,
                'divisor': undefined === cz['divisor'] ? undefined : cz['divisor'],
                'drawType': cz['drawType']
              };
            }
          }
          var cM;
        }),
          cG['bindBuffer'](vR, null),
          cN;
      }(cU, cd)
        , cC = Object['assign']({}, cq || {});
      cC['attribs'] = Object['assign']({}, cq ? cq['attribs'] : {}, cJ);
      const cO = cd['indices'];
      if (cO) {
        const cG = AH(cO, 'indices');
        cC['indices'] = Av(cU, cG, A0),
          cC['numElements'] = cG['length'],
          cC['elementType'] = vO(cG);
      } else
        cC['numElements'] || (cC['numElements'] = function (cg, cN) {
          let cP, cM;
          for (cM = 0x0; cM < Aw['length'] && (cP = Aw[cM],
            !(cP in cN)) && (cP = A9['attribPrefix'] + cP,
              !(cP in cN)); ++cM)
            ;
          cM === Aw['length'] && (cP = Object['keys'](cN)[0x0]);
          const cz = cN[cP];
          if (!cz['buffer'])
            return 0x1;
          cg['bindBuffer'](vR, cz['buffer']);
          const cQ = cg['getBufferParameter'](vR, A1);
          var cm;
          cg['bindBuffer'](vR, null);
          const cL = cQ / ((cm = cz['type']) === A2 || cm === A3 ? 0x1 : cm === A4 || cm === A5 ? 0x2 : cm === A6 || cm === A7 || cm === A8 ? 0x4 : 0x0)
            , cR = cz['numComponents'] || cz['size']
            , H0 = cL / cR;
          if (H0 % 0x1 != 0x0)
            throw new Error('numComponents\x20' + cR + '\x20not\x20correct\x20for\x20length\x20' + length);
          return H0;
        }(cU, cC['attribs']));
      return cC;
    }
    function Au (cU, cd) {
      const cq = {};
      return Object['keys'](cd)['forEach'](function (cJ) {
        cq[cJ] = function (cC, cO, cG) {
          const cg = 'indices' === cG ? A0 : vR;
          return Av(cC, AH(cO, cG), cg);
        }(cU, cd[cJ], cJ);
      }),
        cd['indices'] ? (cq['numElements'] = cd['indices']['length'],
          cq['elementType'] = vO(AH(cd['indices']))) : cq['numElements'] = function (cJ) {
            let cC, cO;
            for (cO = 0x0; cO < Aw['length'] && (cC = Aw[cO],
              !(cC in cJ)); ++cO)
              ;
            cO === Aw['length'] && (cC = Object['keys'](cJ)[0x0]);
            const cG = cJ[cC]
              , cg = Ak(cG)['length'];
            if (undefined === cg)
              return 0x1;
            const cN = Ac(cG, cC)
              , cP = cg / cN;
            if (cg % cN > 0x0)
              throw new Error('numComponents\x20' + cN + '\x20not\x20correct\x20for\x20length\x20' + cg);
            return cP;
          }(cd),
        cq;
    }
    function AY (cU, cd, cq) {
      return function (cJ, cC) {
        let cO = 0x0;
        return cJ['push'] = function () {
          for (let cG = 0x0; cG < arguments['length']; ++cG) {
            const cg = arguments[cG];
            if (cg instanceof Array || vN(cg)) {
              for (let cN = 0x0; cN < cg['length']; ++cN)
                cJ[cO++] = cg[cN];
            } else
              cJ[cO++] = cg;
          }
        }
          ,
          cJ['reset'] = function (cG) {
            cO = cG || 0x0;
          }
          ,
          cJ['numComponents'] = cC,
          Object['defineProperty'](cJ, 'numElements', {
            'get': function () {
              return this['length'] / this['numComponents'] | 0x0;
            }
          }),
          cJ;
      }(new (cq || Float32Array)(cU * cd), cU);
    }
    function AT (cU, cd, cq) {
      const cJ = cU['length']
        , cC = new Float32Array(0x3);
      for (let cO = 0x0; cO < cJ; cO += 0x3)
        cq(cd, [cU[cO], cU[cO + 0x1], cU[cO + 0x2]], cC),
          cU[cO] = cC[0x0],
          cU[cO + 0x1] = cC[0x1],
          cU[cO + 0x2] = cC[0x2];
    }
    function AX (cU, cd, cq) {
      cq = cq || vW();
      const cJ = cd[0x0]
        , cC = cd[0x1]
        , cO = cd[0x2];
      return cq[0x0] = cJ * cU[0x0] + cC * cU[0x1] + cO * cU[0x2],
        cq[0x1] = cJ * cU[0x4] + cC * cU[0x5] + cO * cU[0x6],
        cq[0x2] = cJ * cU[0x8] + cC * cU[0x9] + cO * cU[0xa],
        cq;
    }
    function AE (cU, cd) {
      return AT(cU, function (cq, cJ) {
        cJ = cJ || new vj(0x10);
        const cC = cq[0x0]
          , cO = cq[0x1]
          , cG = cq[0x2]
          , cg = cq[0x3]
          , cN = cq[0x4]
          , cP = cq[0x5]
          , cM = cq[0x6]
          , cz = cq[0x7]
          , cQ = cq[0x8]
          , cm = cq[0x9]
          , cL = cq[0xa]
          , cR = cq[0xb]
          , H0 = cq[0xc]
          , H1 = cq[0xd]
          , H2 = cq[0xe]
          , H3 = cq[0xf]
          , H4 = cL * H3
          , H5 = H2 * cR
          , H6 = cM * H3
          , H7 = H2 * cz
          , H8 = cM * cR
          , H9 = cL * cz
          , Hv = cG * H3
          , HA = H2 * cg
          , Hk = cG * cR
          , Hl = cL * cg
          , HK = cG * cz
          , Hb = cM * cg
          , Hc = cQ * H1
          , HH = H0 * cm
          , Hx = cN * H1
          , Hp = H0 * cP
          , HF = cN * cm
          , Hy = cQ * cP
          , Hw = cC * H1
          , Hh = H0 * cO
          , Hu = cC * cm
          , HY = cQ * cO
          , HT = cC * cP
          , HX = cN * cO
          , HE = H4 * cP + H7 * cm + H8 * H1 - (H5 * cP + H6 * cm + H9 * H1)
          , Hf = H5 * cO + Hv * cm + Hl * H1 - (H4 * cO + HA * cm + Hk * H1)
          , HW = H6 * cO + HA * cP + HK * H1 - (H7 * cO + Hv * cP + Hb * H1)
          , HI = H9 * cO + Hk * cP + Hb * cm - (H8 * cO + Hl * cP + HK * cm)
          , Hj = 0x1 / (cC * HE + cN * Hf + cQ * HW + H0 * HI);
        return cJ[0x0] = Hj * HE,
          cJ[0x1] = Hj * Hf,
          cJ[0x2] = Hj * HW,
          cJ[0x3] = Hj * HI,
          cJ[0x4] = Hj * (H5 * cN + H6 * cQ + H9 * H0 - (H4 * cN + H7 * cQ + H8 * H0)),
          cJ[0x5] = Hj * (H4 * cC + HA * cQ + Hk * H0 - (H5 * cC + Hv * cQ + Hl * H0)),
          cJ[0x6] = Hj * (H7 * cC + Hv * cN + Hb * H0 - (H6 * cC + HA * cN + HK * H0)),
          cJ[0x7] = Hj * (H8 * cC + Hl * cN + HK * cQ - (H9 * cC + Hk * cN + Hb * cQ)),
          cJ[0x8] = Hj * (Hc * cz + Hp * cR + HF * H3 - (HH * cz + Hx * cR + Hy * H3)),
          cJ[0x9] = Hj * (HH * cg + Hw * cR + HY * H3 - (Hc * cg + Hh * cR + Hu * H3)),
          cJ[0xa] = Hj * (Hx * cg + Hh * cz + HT * H3 - (Hp * cg + Hw * cz + HX * H3)),
          cJ[0xb] = Hj * (Hy * cg + Hu * cz + HX * cR - (HF * cg + HY * cz + HT * cR)),
          cJ[0xc] = Hj * (Hx * cL + Hy * H2 + HH * cM - (HF * H2 + Hc * cM + Hp * cL)),
          cJ[0xd] = Hj * (Hu * H2 + Hc * cG + Hh * cL - (Hw * cL + HY * H2 + HH * cG)),
          cJ[0xe] = Hj * (Hw * cM + HX * H2 + Hp * cG - (HT * H2 + Hx * cG + Hh * cM)),
          cJ[0xf] = Hj * (HT * cL + HF * cG + HY * cM - (Hu * cM + HX * cL + Hy * cG)),
          cJ;
      }(cd), AX),
        cU;
    }
    function Af (cU, cd) {
      return Object['keys'](cU)['forEach'](function (cq) {
        const cJ = cU[cq];
        cq['indexOf']('pos') >= 0x0 ? function (cC, cO) {
          AT(cC, cO, vD);
        }(cJ, cd) : cq['indexOf']('tan') >= 0x0 || cq['indexOf']('binorm') >= 0x0 ? function (cC, cO) {
          AT(cC, cO, vV);
        }(cJ, cd) : cq['indexOf']('norm') >= 0x0 && AE(cJ, cd);
      }),
        cU;
    }
    function AW (cU, cd, cq) {
      return cU = cU || 0x2,
      {
        'position': {
          'numComponents': 0x2,
          'data': [(cd = cd || 0x0) + -0x1 * (cU *= 0.5), (cq = cq || 0x0) + -0x1 * cU, cd + 0x1 * cU, cq + -0x1 * cU, cd + -0x1 * cU, cq + 0x1 * cU, cd + 0x1 * cU, cq + 0x1 * cU]
        },
        'normal': [0x0, 0x0, 0x1, 0x0, 0x0, 0x1, 0x0, 0x0, 0x1, 0x0, 0x0, 0x1],
        'texcoord': [0x0, 0x0, 0x1, 0x0, 0x0, 0x1, 0x1, 0x1],
        'indices': [0x0, 0x1, 0x2, 0x2, 0x1, 0x3]
      };
    }
    function AI (cU, cd, cq, cJ, cC) {
      var cO;
      cU = cU || 0x1,
        cd = cd || 0x1,
        cq = cq || 0x1,
        cJ = cJ || 0x1,
        cC = cC || ((cO = cO || new vj(0x10))[0x0] = 0x1,
          cO[0x1] = 0x0,
          cO[0x2] = 0x0,
          cO[0x3] = 0x0,
          cO[0x4] = 0x0,
          cO[0x5] = 0x1,
          cO[0x6] = 0x0,
          cO[0x7] = 0x0,
          cO[0x8] = 0x0,
          cO[0x9] = 0x0,
          cO[0xa] = 0x1,
          cO[0xb] = 0x0,
          cO[0xc] = 0x0,
          cO[0xd] = 0x0,
          cO[0xe] = 0x0,
          cO[0xf] = 0x1,
          cO);
      const cG = (cq + 0x1) * (cJ + 0x1)
        , cg = AY(0x3, cG)
        , cN = AY(0x3, cG)
        , cP = AY(0x2, cG);
      for (let cQ = 0x0; cQ <= cJ; cQ++)
        for (let cm = 0x0; cm <= cq; cm++) {
          const cL = cm / cq
            , cR = cQ / cJ;
          cg['push'](cU * cL - 0.5 * cU, 0x0, cd * cR - 0.5 * cd),
            cN['push'](0x0, 0x1, 0x0),
            cP['push'](cL, cR);
        }
      const cM = cq + 0x1
        , cz = AY(0x3, cq * cJ * 0x2, Uint16Array);
      for (let H0 = 0x0; H0 < cJ; H0++)
        for (let H1 = 0x0; H1 < cq; H1++)
          cz['push']((H0 + 0x0) * cM + H1, (H0 + 0x1) * cM + H1, (H0 + 0x0) * cM + H1 + 0x1),
            cz['push']((H0 + 0x1) * cM + H1, (H0 + 0x1) * cM + H1 + 0x1, (H0 + 0x0) * cM + H1 + 0x1);
      return Af({
        'position': cg,
        'normal': cN,
        'texcoord': cP,
        'indices': cz
      }, cC);
    }
    function Aj (cU, cd, cq, cJ, cC, cO, cG) {
      if (cd <= 0x0 || cq <= 0x0)
        throw new Error('subdivisionAxis\x20and\x20subdivisionHeight\x20must\x20be\x20>\x200');
      cJ = cJ || 0x0,
        cO = cO || 0x0;
      const cg = (cC = cC || Math['PI']) - cJ
        , cN = (cG = cG || 0x2 * Math['PI']) - cO
        , cP = (cd + 0x1) * (cq + 0x1)
        , cM = AY(0x3, cP)
        , cz = AY(0x3, cP)
        , cQ = AY(0x2, cP);
      for (let cR = 0x0; cR <= cq; cR++)
        for (let H0 = 0x0; H0 <= cd; H0++) {
          const H1 = H0 / cd
            , H2 = cR / cq
            , H3 = cN * H1 + cO
            , H4 = cg * H2 + cJ
            , H5 = Math['sin'](H3)
            , H6 = Math['cos'](H3)
            , H7 = Math['sin'](H4)
            , H8 = H6 * H7
            , H9 = Math['cos'](H4)
            , Hv = H5 * H7;
          cM['push'](cU * H8, cU * H9, cU * Hv),
            cz['push'](H8, H9, Hv),
            cQ['push'](0x1 - H1, H2);
        }
      const cm = cd + 0x1
        , cL = AY(0x3, cd * cq * 0x2, Uint16Array);
      for (let HA = 0x0; HA < cd; HA++)
        for (let Hk = 0x0; Hk < cq; Hk++)
          cL['push']((Hk + 0x0) * cm + HA, (Hk + 0x0) * cm + HA + 0x1, (Hk + 0x1) * cm + HA),
            cL['push']((Hk + 0x1) * cm + HA, (Hk + 0x0) * cm + HA + 0x1, (Hk + 0x1) * cm + HA + 0x1);
      return {
        'position': cM,
        'normal': cz,
        'texcoord': cQ,
        'indices': cL
      };
    }
    const AD = [[0x3, 0x7, 0x5, 0x1], [0x6, 0x2, 0x0, 0x4], [0x6, 0x7, 0x3, 0x2], [0x0, 0x1, 0x5, 0x4], [0x7, 0x6, 0x4, 0x5], [0x2, 0x3, 0x1, 0x0]];
    function AV (cU) {
      const cd = (cU = cU || 0x1) / 0x2
        , cq = [[-cd, -cd, -cd], [+cd, -cd, -cd], [-cd, +cd, -cd], [+cd, +cd, -cd], [-cd, -cd, +cd], [+cd, -cd, +cd], [-cd, +cd, +cd], [+cd, +cd, +cd]]
        , cJ = [[0x1, 0x0, 0x0], [-0x1, 0x0, 0x0], [0x0, 0x1, 0x0], [0x0, -0x1, 0x0], [0x0, 0x0, 0x1], [0x0, 0x0, -0x1]]
        , cC = [[0x1, 0x0], [0x0, 0x0], [0x0, 0x1], [0x1, 0x1]]
        , cO = AY(0x3, 0x18)
        , cG = AY(0x3, 0x18)
        , cg = AY(0x2, 0x18)
        , cN = AY(0x3, 0xc, Uint16Array);
      for (let cP = 0x0; cP < 0x6; ++cP) {
        const cM = AD[cP];
        for (let cQ = 0x0; cQ < 0x4; ++cQ) {
          const cm = cq[cM[cQ]]
            , cL = cJ[cP]
            , cR = cC[cQ];
          cO['push'](cm),
            cG['push'](cL),
            cg['push'](cR);
        }
        const cz = 0x4 * cP;
        cN['push'](cz + 0x0, cz + 0x1, cz + 0x2),
          cN['push'](cz + 0x0, cz + 0x2, cz + 0x3);
      }
      return {
        'position': cO,
        'normal': cG,
        'texcoord': cg,
        'indices': cN
      };
    }
    function AZ (cU, cd, cq, cJ, cC, cO, cG) {
      if (cJ < 0x3)
        throw new Error('radialSubdivisions\x20must\x20be\x203\x20or\x20greater');
      if (cC < 0x1)
        throw new Error('verticalSubdivisions\x20must\x20be\x201\x20or\x20greater');
      const cg = undefined === cO || cO
        , cN = undefined === cG || cG
        , cP = (cg ? 0x2 : 0x0) + (cN ? 0x2 : 0x0)
        , cM = (cJ + 0x1) * (cC + 0x1 + cP)
        , cz = AY(0x3, cM)
        , cQ = AY(0x3, cM)
        , cm = AY(0x2, cM)
        , cL = AY(0x3, cJ * (cC + cP / 0x2) * 0x2, Uint16Array)
        , cR = cJ + 0x1
        , H0 = Math['atan2'](cU - cd, cq)
        , H1 = Math['cos'](H0)
        , H2 = Math['sin'](H0)
        , H3 = cC + (cN ? 0x2 : 0x0);
      for (let H4 = cg ? -0x2 : 0x0; H4 <= H3; ++H4) {
        let H5, H6 = H4 / cC, H7 = cq * H6;
        H4 < 0x0 ? (H7 = 0x0,
          H6 = 0x1,
          H5 = cU) : H4 > cC ? (H7 = cq,
            H6 = 0x1,
            H5 = cd) : H5 = cU + H4 / cC * (cd - cU),
          -0x2 !== H4 && H4 !== cC + 0x2 || (H5 = 0x0,
            H6 = 0x0),
          H7 -= cq / 0x2;
        for (let H8 = 0x0; H8 < cR; ++H8) {
          const H9 = Math['sin'](H8 * Math['PI'] * 0x2 / cJ)
            , Hv = Math['cos'](H8 * Math['PI'] * 0x2 / cJ);
          cz['push'](H9 * H5, H7, Hv * H5),
            H4 < 0x0 ? cQ['push'](0x0, -0x1, 0x0) : H4 > cC ? cQ['push'](0x0, 0x1, 0x0) : 0x0 === H5 ? cQ['push'](0x0, 0x0, 0x0) : cQ['push'](H9 * H1, H2, Hv * H1),
            cm['push'](H8 / cJ, 0x1 - H6);
        }
      }
      for (let HA = 0x0; HA < cC + cP; ++HA)
        if (!(0x1 === HA && cg || HA === cC + cP - 0x2 && cN)) {
          for (let Hk = 0x0; Hk < cJ; ++Hk)
            cL['push'](cR * (HA + 0x0) + 0x0 + Hk, cR * (HA + 0x0) + 0x1 + Hk, cR * (HA + 0x1) + 0x1 + Hk),
              cL['push'](cR * (HA + 0x0) + 0x0 + Hk, cR * (HA + 0x1) + 0x1 + Hk, cR * (HA + 0x1) + 0x0 + Hk);
        }
      return {
        'position': cz,
        'normal': cQ,
        'texcoord': cm,
        'indices': cL
      };
    }
    function AB (cU, cd) {
      cd = cd || [];
      const cq = [];
      for (let cJ = 0x0; cJ < cU['length']; cJ += 0x4) {
        const cC = cU[cJ]
          , cO = cU['slice'](cJ + 0x1, cJ + 0x4);
        cO['push']['apply'](cO, cd);
        for (let cG = 0x0; cG < cC; ++cG)
          cq['push']['apply'](cq, cO);
      }
      return cq;
    }
    function AS () {
      const cU = [0x0, 0x0, 0x0, 0x0, 0x96, 0x0, 0x1e, 0x0, 0x0, 0x0, 0x96, 0x0, 0x1e, 0x96, 0x0, 0x1e, 0x0, 0x0, 0x1e, 0x0, 0x0, 0x1e, 0x1e, 0x0, 0x64, 0x0, 0x0, 0x1e, 0x1e, 0x0, 0x64, 0x1e, 0x0, 0x64, 0x0, 0x0, 0x1e, 0x3c, 0x0, 0x1e, 0x5a, 0x0, 0x43, 0x3c, 0x0, 0x1e, 0x5a, 0x0, 0x43, 0x5a, 0x0, 0x43, 0x3c, 0x0, 0x0, 0x0, 0x1e, 0x1e, 0x0, 0x1e, 0x0, 0x96, 0x1e, 0x0, 0x96, 0x1e, 0x1e, 0x0, 0x1e, 0x1e, 0x96, 0x1e, 0x1e, 0x0, 0x1e, 0x64, 0x0, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x64, 0x0, 0x1e, 0x64, 0x1e, 0x1e, 0x1e, 0x3c, 0x1e, 0x43, 0x3c, 0x1e, 0x1e, 0x5a, 0x1e, 0x1e, 0x5a, 0x1e, 0x43, 0x3c, 0x1e, 0x43, 0x5a, 0x1e, 0x0, 0x0, 0x0, 0x64, 0x0, 0x0, 0x64, 0x0, 0x1e, 0x0, 0x0, 0x0, 0x64, 0x0, 0x1e, 0x0, 0x0, 0x1e, 0x64, 0x0, 0x0, 0x64, 0x1e, 0x0, 0x64, 0x1e, 0x1e, 0x64, 0x0, 0x0, 0x64, 0x1e, 0x1e, 0x64, 0x0, 0x1e, 0x1e, 0x1e, 0x0, 0x1e, 0x1e, 0x1e, 0x64, 0x1e, 0x1e, 0x1e, 0x1e, 0x0, 0x64, 0x1e, 0x1e, 0x64, 0x1e, 0x0, 0x1e, 0x1e, 0x0, 0x1e, 0x3c, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x0, 0x1e, 0x3c, 0x0, 0x1e, 0x3c, 0x1e, 0x1e, 0x3c, 0x0, 0x43, 0x3c, 0x1e, 0x1e, 0x3c, 0x1e, 0x1e, 0x3c, 0x0, 0x43, 0x3c, 0x0, 0x43, 0x3c, 0x1e, 0x43, 0x3c, 0x0, 0x43, 0x5a, 0x1e, 0x43, 0x3c, 0x1e, 0x43, 0x3c, 0x0, 0x43, 0x5a, 0x0, 0x43, 0x5a, 0x1e, 0x1e, 0x5a, 0x0, 0x1e, 0x5a, 0x1e, 0x43, 0x5a, 0x1e, 0x1e, 0x5a, 0x0, 0x43, 0x5a, 0x1e, 0x43, 0x5a, 0x0, 0x1e, 0x5a, 0x0, 0x1e, 0x96, 0x1e, 0x1e, 0x5a, 0x1e, 0x1e, 0x5a, 0x0, 0x1e, 0x96, 0x0, 0x1e, 0x96, 0x1e, 0x0, 0x96, 0x0, 0x0, 0x96, 0x1e, 0x1e, 0x96, 0x1e, 0x0, 0x96, 0x0, 0x1e, 0x96, 0x1e, 0x1e, 0x96, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1e, 0x0, 0x96, 0x1e, 0x0, 0x0, 0x0, 0x0, 0x96, 0x1e, 0x0, 0x96, 0x0]
        , cd = AB([0x12, 0x0, 0x0, 0x1, 0x12, 0x0, 0x0, -0x1, 0x6, 0x0, 0x1, 0x0, 0x6, 0x1, 0x0, 0x0, 0x6, 0x0, -0x1, 0x0, 0x6, 0x1, 0x0, 0x0, 0x6, 0x0, 0x1, 0x0, 0x6, 0x1, 0x0, 0x0, 0x6, 0x0, -0x1, 0x0, 0x6, 0x1, 0x0, 0x0, 0x6, 0x0, -0x1, 0x0, 0x6, -0x1, 0x0, 0x0])
        , cq = AB([0x12, 0xc8, 0x46, 0x78, 0x12, 0x50, 0x46, 0xc8, 0x6, 0x46, 0xc8, 0xd2, 0x6, 0xc8, 0xc8, 0x46, 0x6, 0xd2, 0x64, 0x46, 0x6, 0xd2, 0xa0, 0x46, 0x6, 0x46, 0xb4, 0xd2, 0x6, 0x64, 0x46, 0xd2, 0x6, 0x4c, 0xd2, 0x64, 0x6, 0x8c, 0xd2, 0x50, 0x6, 0x5a, 0x82, 0x6e, 0x6, 0xa0, 0xa0, 0xdc], [0xff])
        , cJ = cU['length'] / 0x3
        , cC = {
          'position': AY(0x3, cJ),
          'texcoord': AY(0x2, cJ),
          'normal': AY(0x3, cJ),
          'color': AY(0x4, cJ, Uint8Array),
          'indices': AY(0x3, cJ / 0x3, Uint16Array)
        };
      cC['position']['push'](cU),
        cC['texcoord']['push']([0.22, 0.19, 0.22, 0.79, 0.34, 0.19, 0.22, 0.79, 0.34, 0.79, 0.34, 0.19, 0.34, 0.19, 0.34, 0.31, 0.62, 0.19, 0.34, 0.31, 0.62, 0.31, 0.62, 0.19, 0.34, 0.43, 0.34, 0.55, 0.49, 0.43, 0.34, 0.55, 0.49, 0.55, 0.49, 0.43, 0x0, 0x0, 0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x1, 0x0, 0x1, 0x1, 0x0, 0x0, 0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x1, 0x0, 0x1, 0x1, 0x0, 0x0, 0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x1, 0x0, 0x1, 0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x1, 0x0, 0x0, 0x1, 0x1, 0x0, 0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x1, 0x0, 0x0, 0x1, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x1, 0x1, 0x0, 0x0, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x1, 0x1, 0x0, 0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x1, 0x0, 0x0, 0x1, 0x1, 0x0, 0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x1, 0x0, 0x0, 0x1, 0x1, 0x0, 0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x1, 0x0, 0x0, 0x0, 0x1, 0x1, 0x1, 0x0, 0x0, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x1, 0x1, 0x0, 0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x1, 0x0, 0x0, 0x0, 0x1, 0x1, 0x1, 0x0, 0x0, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x1, 0x0, 0x0, 0x1, 0x1, 0x1, 0x0]),
        cC['normal']['push'](cd),
        cC['color']['push'](cq);
      for (let cO = 0x0; cO < cJ; ++cO)
        cC['indices']['push'](cO);
      return cC;
    }
    function AU (cU, cd, cq, cJ, cC, cO, cG) {
      if (cC <= 0x0)
        throw new Error('subdivisionDown\x20must\x20be\x20>\x200');
      const cg = (cG = cG || 0x1) - (cO = cO || 0x0)
        , cN = 0x2 * (cC + 0x1) * 0x4
        , cP = AY(0x3, cN)
        , cM = AY(0x3, cN)
        , cz = AY(0x2, cN);
      function cQ (H1, H2, H3) {
        return H1 + (H2 - H1) * H3;
      }
      function cm (H1, H2, H3, H4, H5, H6) {
        for (let Hv = 0x0; Hv <= cC; Hv++) {
          const HA = H2 / 0x1
            , Hk = Hv / cC
            , Hl = 0x2 * (HA - 0.5)
            , HK = (cO + Hk * cg) * Math['PI']
            , Hb = Math['sin'](HK)
            , Hc = Math['cos'](HK)
            , HH = cQ(cU, H1, Hb)
            , Hx = Hl * cJ
            , Hp = Hc * cU
            , HF = Hb * HH;
          cP['push'](Hx, Hp, HF);
          const Hy = vI((H7 = [0x0, Hb, Hc],
            H8 = H3,
            (H9 = (H9 = undefined) || new vf(0x3))[0x0] = H7[0x0] * H8[0x0],
            H9[0x1] = H7[0x1] * H8[0x1],
            H9[0x2] = H7[0x2] * H8[0x2],
            H9), H4);
          cM['push'](Hy),
            cz['push'](HA * H5 + H6, Hk);
        }
        var H7, H8, H9;
      }
      for (let H1 = 0x0; H1 < 0x2; H1++) {
        const H2 = 0x2 * (H1 / 0x1 - 0.5);
        cm(cd, H1, [0x1, 0x1, 0x1], [0x0, 0x0, 0x0], 0x1, 0x0),
          cm(cd, H1, [0x0, 0x0, 0x0], [H2, 0x0, 0x0], 0x0, 0x0),
          cm(cq, H1, [0x1, 0x1, 0x1], [0x0, 0x0, 0x0], 0x1, 0x0),
          cm(cq, H1, [0x0, 0x0, 0x0], [H2, 0x0, 0x0], 0x0, 0x1);
      }
      const cL = AY(0x3, 0x2 * cC * 0x4, Uint16Array);
      function cR (H3, H4) {
        for (let H5 = 0x0; H5 < cC; ++H5)
          cL['push'](H3 + H5 + 0x0, H3 + H5 + 0x1, H4 + H5 + 0x0),
            cL['push'](H3 + H5 + 0x1, H4 + H5 + 0x1, H4 + H5 + 0x0);
      }
      const H0 = cC + 0x1;
      return cR(0x0 * H0, 0x4 * H0),
        cR(0x5 * H0, 0x7 * H0),
        cR(0x6 * H0, 0x2 * H0),
        cR(0x3 * H0, 0x1 * H0),
      {
        'position': cP,
        'normal': cM,
        'texcoord': cz,
        'indices': cL
      };
    }
    function Ad (cU, cd, cq, cJ, cC, cO) {
      return AZ(cU, cU, cd, cq, cJ, cC, cO);
    }
    function Aq (cU, cd, cq, cJ, cC, cO) {
      if (cq < 0x3)
        throw new Error('radialSubdivisions\x20must\x20be\x203\x20or\x20greater');
      if (cJ < 0x3)
        throw new Error('verticalSubdivisions\x20must\x20be\x203\x20or\x20greater');
      cC = cC || 0x0;
      const cG = (cO = cO || 0x2 * Math['PI']) - cC
        , cg = cq + 0x1
        , cN = cJ + 0x1
        , cP = cg * cN
        , cM = AY(0x3, cP)
        , cz = AY(0x3, cP)
        , cQ = AY(0x2, cP)
        , cm = AY(0x3, cq * cJ * 0x2, Uint16Array);
      for (let cL = 0x0; cL < cN; ++cL) {
        const cR = cL / cJ
          , H0 = cR * Math['PI'] * 0x2
          , H1 = Math['sin'](H0)
          , H2 = cU + H1 * cd
          , H3 = Math['cos'](H0)
          , H4 = H3 * cd;
        for (let H5 = 0x0; H5 < cg; ++H5) {
          const H6 = H5 / cq
            , H7 = cC + H6 * cG
            , H8 = Math['sin'](H7)
            , H9 = Math['cos'](H7)
            , Hv = H8 * H2
            , HA = H9 * H2
            , Hk = H8 * H1
            , Hl = H9 * H1;
          cM['push'](Hv, H4, HA),
            cz['push'](Hk, H3, Hl),
            cQ['push'](H6, 0x1 - cR);
        }
      }
      for (let HK = 0x0; HK < cJ; ++HK)
        for (let Hb = 0x0; Hb < cq; ++Hb) {
          const Hc = 0x1 + Hb
            , HH = 0x1 + HK;
          cm['push'](cg * HK + Hb, cg * HH + Hb, cg * HK + Hc),
            cm['push'](cg * HH + Hb, cg * HH + Hc, cg * HK + Hc);
        }
      return {
        'position': cM,
        'normal': cz,
        'texcoord': cQ,
        'indices': cm
      };
    }
    function AJ (cU, cd, cq, cJ, cC) {
      if (cd < 0x3)
        throw new Error('divisions\x20must\x20be\x20at\x20least\x203');
      cC = cC || 0x1,
        cJ = cJ || 0x0;
      const cO = (cd + 0x1) * ((cq = cq || 0x1) + 0x1)
        , cG = AY(0x3, cO)
        , cg = AY(0x3, cO)
        , cN = AY(0x2, cO)
        , cP = AY(0x3, cq * cd * 0x2, Uint16Array);
      let cM = 0x0;
      const cz = cU - cJ
        , cQ = cd + 0x1;
      for (let cm = 0x0; cm <= cq; ++cm) {
        const cL = cJ + cz * Math['pow'](cm / cq, cC);
        for (let cR = 0x0; cR <= cd; ++cR) {
          const H0 = 0x2 * Math['PI'] * cR / cd
            , H1 = cL * Math['cos'](H0)
            , H2 = cL * Math['sin'](H0);
          if (cG['push'](H1, 0x0, H2),
            cg['push'](0x0, 0x1, 0x0),
            cN['push'](0x1 - cR / cd, cm / cq),
            cm > 0x0 && cR !== cd) {
            const H3 = cM + (cR + 0x1)
              , H4 = cM + cR
              , H5 = cM + cR - cQ
              , H6 = cM + (cR + 0x1) - cQ;
            cP['push'](H3, H4, H5),
              cP['push'](H3, H5, H6);
          }
        }
        cM += cd + 0x1;
      }
      return {
        'position': cG,
        'normal': cg,
        'texcoord': cN,
        'indices': cP
      };
    }
    function AC (cU) {
      return function (cd) {
        return Au(cd, cU['apply'](this, Array['prototype']['slice']['call'](arguments, 0x1)));
      }
        ;
    }
    function AO (cU) {
      return function (cd) {
        return Ah(cd, cU['apply'](null, Array['prototype']['slice']['call'](arguments, 0x1)));
      }
        ;
    }
    function AG (cU) {
      return !!cU['texStorage2D'];
    }
    AO(AS),
      AC(AS),
      AO(AV),
      AC(AV),
      AO(AI),
      AC(AI),
      AO(Aj),
      AC(Aj),
      AO(AZ),
      AC(AZ),
      AO(AW),
      AC(AW),
      AO(AU),
      AC(AU),
      AO(Ad),
      AC(Ad),
      AO(Aq),
      AC(Aq),
      AO(AJ),
      AC(AJ);
    const Ag = function () {
      const cU = {}
        , cd = {};
      return function (cq, cJ) {
        return function (cC) {
          const cO = cC['constructor']['name'];
          if (!cU[cO]) {
            for (const cG in cC)
              if ('number' == typeof cC[cG]) {
                const cg = cd[cC[cG]];
                cd[cC[cG]] = cg ? cg + '\x20|\x20' + cG : cG;
              }
            cU[cO] = true;
          }
        }(cq),
          cd[cJ] || ('number' == typeof cJ ? '0x' + cJ['toString'](0x10) : cJ);
      }
        ;
    }()
      , AN = {
        'textureColor': new Uint8Array([0x80, 0xc0, 0xff, 0xff]),
        'textureOptions': {},
        'crossOrigin': undefined
      }
      , AP = vN
      , AM = function () {
        let cU;
        return function () {
          return cU = cU || ('undefined' != typeof document && document['createElement'] ? document['createElement']('canvas')['getContext']('2d') : null),
            cU;
        }
          ;
      }()
      , Az = 0x1906
      , AQ = 0x1907
      , Am = 0x1908
      , AL = 0x1909
      , AR = 0x190a
      , n0 = 0x1902
      , n1 = 0x84f9
      , n2 = 0x812f
      , n3 = 0x2600
      , n4 = 0x2601
      , n5 = 0xde1
      , n6 = 0x8513
      , n7 = 0x806f
      , n8 = 0x8c1a
      , n9 = 0x8515
      , nv = 0x8516
      , nA = 0x8517
      , nk = 0x8518
      , nK = 0x8519
      , nb = 0x851a
      , nc = 0x2801
      , nH = 0x2800
      , nx = 0x2802
      , np = 0x2803
      , nF = 0x8072
      , ny = 0x813a
      , nw = 0x813b
      , nh = 0x813c
      , nu = 0x813d
      , nY = 0x884c
      , nT = 0x884d
      , nX = 0xcf5
      , nE = 0xcf2
      , nf = 0x806e
      , nW = 0xcf4
      , nI = 0xcf3
      , nj = 0x806d
      , nD = 0x9243
      , nV = 0x9241
      , nZ = 0x9240
      , nB = 0x8229
      , nS = 0x8f94
      , nU = 0x822d
      , nd = 0x822e
      , nq = 0x8232
      , nJ = 0x8231
      , nC = 0x823a
      , nO = 0x8239
      , nG = 0x823c
      , ng = 0x823b
      , nN = 0x822b
      , nP = 0x8f95
      , nM = 0x822f
      , nz = 0x8230
      , nQ = 0x8238
      , nm = 0x8237
      , nL = 0x8234
      , nR = 0x8233
      , k0 = 0x8236
      , k1 = 0x8235
      , k2 = 0x8051
      , k3 = 0x8c41
      , k4 = 0x8d62
      , k5 = 0x8f96
      , k6 = 0x8c3a
      , k7 = 0x8c3d
      , k8 = 0x881b
      , k9 = 0x8815
      , kv = 0x8d7d
      , kA = 0x8d8f
      , kk = 0x8d77
      , kK = 0x8d89
      , kb = 0x8d71
      , kc = 0x8d83
      , kH = 0x8058
      , kx = 0x8c43
      , kp = 0x8f97
      , kF = 0x8057
      , ky = 0x8056
      , kw = 0x8059
      , kh = 0x881a
      , ku = 0x8814
      , kY = 0x8d7c
      , kT = 0x8d8e
      , kX = 0x906f
      , kE = 0x8d76
      , kf = 0x8d88
      , kW = 0x8d82
      , kI = 0x8d70
      , kj = 0x81a5
      , kD = 0x81a6
      , kV = 0x8cac
      , kZ = 0x8cad
      , kB = 0x88f0
      , kS = 0x1400
      , kU = 0x1401
      , kd = 0x1402
      , kq = 0x1403
      , kJ = 0x1404
      , kC = 0x1405
      , kO = 0x1406
      , kG = 0x8033
      , kg = 0x8034
      , kN = 0x8363
      , kP = 0x140b
      , kM = 0x8d61
      , kz = 0x8368
      , kQ = 0x8c3b
      , km = 0x8c3e
      , kL = 0x8dad
      , kR = 0x84fa
      , l0 = 0x8227
      , l1 = 0x8228
      , l2 = 0x1903
      , l3 = 0x8d94
      , l4 = 0x8d98
      , l5 = 0x8d99;
    {
      const cU = {};
      cU[Az] = {
        'numColorComponents': 0x1
      },
        cU[AL] = {
          'numColorComponents': 0x1
        },
        cU[AR] = {
          'numColorComponents': 0x2
        },
        cU[AQ] = {
          'numColorComponents': 0x3
        },
        cU[Am] = {
          'numColorComponents': 0x4
        },
        cU[l2] = {
          'numColorComponents': 0x1
        },
        cU[l3] = {
          'numColorComponents': 0x1
        },
        cU[l0] = {
          'numColorComponents': 0x2
        },
        cU[l1] = {
          'numColorComponents': 0x2
        },
        cU[AQ] = {
          'numColorComponents': 0x3
        },
        cU[l4] = {
          'numColorComponents': 0x3
        },
        cU[Am] = {
          'numColorComponents': 0x4
        },
        cU[l5] = {
          'numColorComponents': 0x4
        },
        cU[n0] = {
          'numColorComponents': 0x1
        },
        cU[n1] = {
          'numColorComponents': 0x2
        };
    }
    let l6;
    function l7 (cd) {
      if (!l6) {
        const cq = {};
        cq[Az] = {
          'textureFormat': Az,
          'colorRenderable': true,
          'textureFilterable': true,
          'bytesPerElement': [0x1, 0x2, 0x2, 0x4],
          'type': [kU, kP, kM, kO]
        },
          cq[AL] = {
            'textureFormat': AL,
            'colorRenderable': true,
            'textureFilterable': true,
            'bytesPerElement': [0x1, 0x2, 0x2, 0x4],
            'type': [kU, kP, kM, kO]
          },
          cq[AR] = {
            'textureFormat': AR,
            'colorRenderable': true,
            'textureFilterable': true,
            'bytesPerElement': [0x2, 0x4, 0x4, 0x8],
            'type': [kU, kP, kM, kO]
          },
          cq[AQ] = {
            'textureFormat': AQ,
            'colorRenderable': true,
            'textureFilterable': true,
            'bytesPerElement': [0x3, 0x6, 0x6, 0xc, 0x2],
            'type': [kU, kP, kM, kO, kN]
          },
          cq[Am] = {
            'textureFormat': Am,
            'colorRenderable': true,
            'textureFilterable': true,
            'bytesPerElement': [0x4, 0x8, 0x8, 0x10, 0x2, 0x2],
            'type': [kU, kP, kM, kO, kG, kg]
          },
          cq[n0] = {
            'textureFormat': n0,
            'colorRenderable': true,
            'textureFilterable': false,
            'bytesPerElement': [0x2, 0x4],
            'type': [kC, kq]
          },
          cq[nB] = {
            'textureFormat': l2,
            'colorRenderable': true,
            'textureFilterable': true,
            'bytesPerElement': [0x1],
            'type': [kU]
          },
          cq[nS] = {
            'textureFormat': l2,
            'colorRenderable': false,
            'textureFilterable': true,
            'bytesPerElement': [0x1],
            'type': [kS]
          },
          cq[nU] = {
            'textureFormat': l2,
            'colorRenderable': false,
            'textureFilterable': true,
            'bytesPerElement': [0x4, 0x2],
            'type': [kO, kP]
          },
          cq[nd] = {
            'textureFormat': l2,
            'colorRenderable': false,
            'textureFilterable': false,
            'bytesPerElement': [0x4],
            'type': [kO]
          },
          cq[nq] = {
            'textureFormat': l3,
            'colorRenderable': true,
            'textureFilterable': false,
            'bytesPerElement': [0x1],
            'type': [kU]
          },
          cq[nJ] = {
            'textureFormat': l3,
            'colorRenderable': true,
            'textureFilterable': false,
            'bytesPerElement': [0x1],
            'type': [kS]
          },
          cq[nL] = {
            'textureFormat': l3,
            'colorRenderable': true,
            'textureFilterable': false,
            'bytesPerElement': [0x2],
            'type': [kq]
          },
          cq[nR] = {
            'textureFormat': l3,
            'colorRenderable': true,
            'textureFilterable': false,
            'bytesPerElement': [0x2],
            'type': [kd]
          },
          cq[k0] = {
            'textureFormat': l3,
            'colorRenderable': true,
            'textureFilterable': false,
            'bytesPerElement': [0x4],
            'type': [kC]
          },
          cq[k1] = {
            'textureFormat': l3,
            'colorRenderable': true,
            'textureFilterable': false,
            'bytesPerElement': [0x4],
            'type': [kJ]
          },
          cq[nN] = {
            'textureFormat': l0,
            'colorRenderable': true,
            'textureFilterable': true,
            'bytesPerElement': [0x2],
            'type': [kU]
          },
          cq[nP] = {
            'textureFormat': l0,
            'colorRenderable': false,
            'textureFilterable': true,
            'bytesPerElement': [0x2],
            'type': [kS]
          },
          cq[nM] = {
            'textureFormat': l0,
            'colorRenderable': false,
            'textureFilterable': true,
            'bytesPerElement': [0x8, 0x4],
            'type': [kO, kP]
          },
          cq[nz] = {
            'textureFormat': l0,
            'colorRenderable': false,
            'textureFilterable': false,
            'bytesPerElement': [0x8],
            'type': [kO]
          },
          cq[nQ] = {
            'textureFormat': l1,
            'colorRenderable': true,
            'textureFilterable': false,
            'bytesPerElement': [0x2],
            'type': [kU]
          },
          cq[nm] = {
            'textureFormat': l1,
            'colorRenderable': true,
            'textureFilterable': false,
            'bytesPerElement': [0x2],
            'type': [kS]
          },
          cq[nC] = {
            'textureFormat': l1,
            'colorRenderable': true,
            'textureFilterable': false,
            'bytesPerElement': [0x4],
            'type': [kq]
          },
          cq[nO] = {
            'textureFormat': l1,
            'colorRenderable': true,
            'textureFilterable': false,
            'bytesPerElement': [0x4],
            'type': [kd]
          },
          cq[nG] = {
            'textureFormat': l1,
            'colorRenderable': true,
            'textureFilterable': false,
            'bytesPerElement': [0x8],
            'type': [kC]
          },
          cq[ng] = {
            'textureFormat': l1,
            'colorRenderable': true,
            'textureFilterable': false,
            'bytesPerElement': [0x8],
            'type': [kJ]
          },
          cq[k2] = {
            'textureFormat': AQ,
            'colorRenderable': true,
            'textureFilterable': true,
            'bytesPerElement': [0x3],
            'type': [kU]
          },
          cq[k3] = {
            'textureFormat': AQ,
            'colorRenderable': false,
            'textureFilterable': true,
            'bytesPerElement': [0x3],
            'type': [kU]
          },
          cq[k4] = {
            'textureFormat': AQ,
            'colorRenderable': true,
            'textureFilterable': true,
            'bytesPerElement': [0x3, 0x2],
            'type': [kU, kN]
          },
          cq[k5] = {
            'textureFormat': AQ,
            'colorRenderable': false,
            'textureFilterable': true,
            'bytesPerElement': [0x3],
            'type': [kS]
          },
          cq[k6] = {
            'textureFormat': AQ,
            'colorRenderable': false,
            'textureFilterable': true,
            'bytesPerElement': [0xc, 0x6, 0x4],
            'type': [kO, kP, kQ]
          },
          cq[k7] = {
            'textureFormat': AQ,
            'colorRenderable': false,
            'textureFilterable': true,
            'bytesPerElement': [0xc, 0x6, 0x4],
            'type': [kO, kP, km]
          },
          cq[k8] = {
            'textureFormat': AQ,
            'colorRenderable': false,
            'textureFilterable': true,
            'bytesPerElement': [0xc, 0x6],
            'type': [kO, kP]
          },
          cq[k9] = {
            'textureFormat': AQ,
            'colorRenderable': false,
            'textureFilterable': false,
            'bytesPerElement': [0xc],
            'type': [kO]
          },
          cq[kv] = {
            'textureFormat': l4,
            'colorRenderable': false,
            'textureFilterable': false,
            'bytesPerElement': [0x3],
            'type': [kU]
          },
          cq[kA] = {
            'textureFormat': l4,
            'colorRenderable': false,
            'textureFilterable': false,
            'bytesPerElement': [0x3],
            'type': [kS]
          },
          cq[kk] = {
            'textureFormat': l4,
            'colorRenderable': false,
            'textureFilterable': false,
            'bytesPerElement': [0x6],
            'type': [kq]
          },
          cq[kK] = {
            'textureFormat': l4,
            'colorRenderable': false,
            'textureFilterable': false,
            'bytesPerElement': [0x6],
            'type': [kd]
          },
          cq[kb] = {
            'textureFormat': l4,
            'colorRenderable': false,
            'textureFilterable': false,
            'bytesPerElement': [0xc],
            'type': [kC]
          },
          cq[kc] = {
            'textureFormat': l4,
            'colorRenderable': false,
            'textureFilterable': false,
            'bytesPerElement': [0xc],
            'type': [kJ]
          },
          cq[kH] = {
            'textureFormat': Am,
            'colorRenderable': true,
            'textureFilterable': true,
            'bytesPerElement': [0x4],
            'type': [kU]
          },
          cq[kx] = {
            'textureFormat': Am,
            'colorRenderable': true,
            'textureFilterable': true,
            'bytesPerElement': [0x4],
            'type': [kU]
          },
          cq[kp] = {
            'textureFormat': Am,
            'colorRenderable': false,
            'textureFilterable': true,
            'bytesPerElement': [0x4],
            'type': [kS]
          },
          cq[kF] = {
            'textureFormat': Am,
            'colorRenderable': true,
            'textureFilterable': true,
            'bytesPerElement': [0x4, 0x2, 0x4],
            'type': [kU, kg, kz]
          },
          cq[ky] = {
            'textureFormat': Am,
            'colorRenderable': true,
            'textureFilterable': true,
            'bytesPerElement': [0x4, 0x2],
            'type': [kU, kG]
          },
          cq[kw] = {
            'textureFormat': Am,
            'colorRenderable': true,
            'textureFilterable': true,
            'bytesPerElement': [0x4],
            'type': [kz]
          },
          cq[kh] = {
            'textureFormat': Am,
            'colorRenderable': false,
            'textureFilterable': true,
            'bytesPerElement': [0x10, 0x8],
            'type': [kO, kP]
          },
          cq[ku] = {
            'textureFormat': Am,
            'colorRenderable': false,
            'textureFilterable': false,
            'bytesPerElement': [0x10],
            'type': [kO]
          },
          cq[kY] = {
            'textureFormat': l5,
            'colorRenderable': true,
            'textureFilterable': false,
            'bytesPerElement': [0x4],
            'type': [kU]
          },
          cq[kT] = {
            'textureFormat': l5,
            'colorRenderable': true,
            'textureFilterable': false,
            'bytesPerElement': [0x4],
            'type': [kS]
          },
          cq[kX] = {
            'textureFormat': l5,
            'colorRenderable': true,
            'textureFilterable': false,
            'bytesPerElement': [0x4],
            'type': [kz]
          },
          cq[kE] = {
            'textureFormat': l5,
            'colorRenderable': true,
            'textureFilterable': false,
            'bytesPerElement': [0x8],
            'type': [kq]
          },
          cq[kf] = {
            'textureFormat': l5,
            'colorRenderable': true,
            'textureFilterable': false,
            'bytesPerElement': [0x8],
            'type': [kd]
          },
          cq[kW] = {
            'textureFormat': l5,
            'colorRenderable': true,
            'textureFilterable': false,
            'bytesPerElement': [0x10],
            'type': [kJ]
          },
          cq[kI] = {
            'textureFormat': l5,
            'colorRenderable': true,
            'textureFilterable': false,
            'bytesPerElement': [0x10],
            'type': [kC]
          },
          cq[kj] = {
            'textureFormat': n0,
            'colorRenderable': true,
            'textureFilterable': false,
            'bytesPerElement': [0x2, 0x4],
            'type': [kq, kC]
          },
          cq[kD] = {
            'textureFormat': n0,
            'colorRenderable': true,
            'textureFilterable': false,
            'bytesPerElement': [0x4],
            'type': [kC]
          },
          cq[kV] = {
            'textureFormat': n0,
            'colorRenderable': true,
            'textureFilterable': false,
            'bytesPerElement': [0x4],
            'type': [kO]
          },
          cq[kB] = {
            'textureFormat': n1,
            'colorRenderable': true,
            'textureFilterable': false,
            'bytesPerElement': [0x4],
            'type': [kR]
          },
          cq[kZ] = {
            'textureFormat': n1,
            'colorRenderable': true,
            'textureFilterable': false,
            'bytesPerElement': [0x4],
            'type': [kL]
          },
          Object['keys'](cq)['forEach'](function (cJ) {
            const cC = cq[cJ];
            cC['bytesPerElementMap'] = {},
              cC['bytesPerElement']['forEach'](function (cO, cG) {
                const cg = cC['type'][cG];
                cC['bytesPerElementMap'][cg] = cO;
              });
          }),
          l6 = cq;
      }
      return l6[cd];
    }
    function l8 (cd) {
      const cq = l7(cd);
      if (!cq)
        throw 'unknown\x20internal\x20format';
      return {
        'format': cq['textureFormat'],
        'type': cq['type'][0x0]
      };
    }
    function l9 (cd) {
      return 0x0 == (cd & cd - 0x1);
    }
    function lv (cd, cq, cJ, cC, cO) {
      if (cO % 0x1 != 0x0)
        throw 'can\x27t\x20guess\x20dimensions';
      if (cJ || cC) {
        if (cC) {
          if (!cJ && (cJ = cO / cC) % 0x1)
            throw 'can\x27t\x20guess\x20dimensions';
        } else {
          if ((cC = cO / cJ) % 0x1)
            throw 'can\x27t\x20guess\x20dimensions';
        }
      } else {
        const cG = Math['sqrt'](cO / (cq === n6 ? 0x6 : 0x1));
        cG % 0x1 == 0x0 ? (cJ = cG,
          cC = cG) : (cJ = cO,
            cC = 0x1);
      }
      return {
        'width': cJ,
        'height': cC
      };
    }
    function lA (cd, cq) {
      undefined !== cq['colorspaceConversion'] && cd['pixelStorei'](nD, cq['colorspaceConversion']),
        undefined !== cq['premultiplyAlpha'] && cd['pixelStorei'](nV, cq['premultiplyAlpha']),
        undefined !== cq['flipY'] && cd['pixelStorei'](nZ, cq['flipY']);
    }
    function lk (cd) {
      cd['pixelStorei'](nX, 0x4),
        AG(cd) && (cd['pixelStorei'](nE, 0x0),
          cd['pixelStorei'](nf, 0x0),
          cd['pixelStorei'](nW, 0x0),
          cd['pixelStorei'](nI, 0x0),
          cd['pixelStorei'](nj, 0x0));
    }
    function lK (cd, cq, cJ) {
      const cC = cJ['target'] || n5;
      cd['bindTexture'](cC, cq),
        function (cO, cG, cg, cN) {
          cN['minMag'] && (cg['call'](cO, cG, nc, cN['minMag']),
            cg['call'](cO, cG, nH, cN['minMag'])),
            cN['min'] && cg['call'](cO, cG, nc, cN['min']),
            cN['mag'] && cg['call'](cO, cG, nH, cN['mag']),
            cN['wrap'] && (cg['call'](cO, cG, nx, cN['wrap']),
              cg['call'](cO, cG, np, cN['wrap']),
              (cG === n7 || 'undefined' != typeof WebGLSampler && vQ(cG, 'WebGLSampler')) && cg['call'](cO, cG, nF, cN['wrap'])),
            cN['wrapR'] && cg['call'](cO, cG, nF, cN['wrapR']),
            cN['wrapS'] && cg['call'](cO, cG, nx, cN['wrapS']),
            cN['wrapT'] && cg['call'](cO, cG, np, cN['wrapT']),
            undefined !== cN['minLod'] && cg['call'](cO, cG, ny, cN['minLod']),
            undefined !== cN['maxLod'] && cg['call'](cO, cG, nw, cN['maxLod']),
            undefined !== cN['baseLevel'] && cg['call'](cO, cG, nh, cN['baseLevel']),
            undefined !== cN['maxLevel'] && cg['call'](cO, cG, nu, cN['maxLevel']),
            undefined !== cN['compareFunc'] && cg['call'](cO, cG, nT, cN['compareFunc']),
            undefined !== cN['compareMode'] && cg['call'](cO, cG, nY, cN['compareMode']);
        }(cd, cC, cd['texParameteri'], cJ);
    }
    function lb (cd, cq, cJ, cC, cO, cG) {
      cJ = cJ || AN['textureOptions'],
        cG = cG || Am;
      const cg = cJ['target'] || n5;
      if (cC = cC || cJ['width'],
        cO = cO || cJ['height'],
        cd['bindTexture'](cg, cq),
        function (cN, cP, cM, cz) {
          if (!AG(cN))
            return l9(cP) && l9(cM);
          const cQ = l7(cz);
          if (!cQ)
            throw 'unknown\x20internal\x20format';
          return cQ['colorRenderable'] && cQ['textureFilterable'];
        }(cd, cC, cO, cG))
        cd['generateMipmap'](cg);
      else {
        const cN = function (cP) {
          const cM = l7(cP);
          if (!cM)
            throw 'unknown\x20internal\x20format';
          return cM['textureFilterable'];
        }(cG) ? n4 : n3;
        cd['texParameteri'](cg, nc, cN),
          cd['texParameteri'](cg, nH, cN),
          cd['texParameteri'](cg, nx, n2),
          cd['texParameteri'](cg, np, n2);
      }
    }
    function lc (cd) {
      return true === cd['auto'] || undefined === cd['auto'] && undefined === cd['level'];
    }
    function lH (cd, cq) {
      return (cq = cq || {})['cubeFaceOrder'] || [n9, nv, nA, nk, nK, nb];
    }
    function lx (cd, cq) {
      const cJ = lH(0x0, cq)['map'](function (cC, cO) {
        return {
          'face': cC,
          'ndx': cO
        };
      });
      return cJ['sort'](function (cC, cO) {
        return cC['face'] - cO['face'];
      }),
        cJ;
    }
    function lp (cd, cq, cJ, cC) {
      const cO = (cC = cC || AN['textureOptions'])['target'] || n5
        , cG = cC['level'] || 0x0;
      let cg = cJ['width']
        , cN = cJ['height'];
      const cP = cC['internalFormat'] || cC['format'] || Am
        , cM = l8(cP)
        , cz = cC['format'] || cM['format']
        , cQ = cC['type'] || cM['type'];
      if (lA(cd, cC),
        cd['bindTexture'](cO, cq),
        cO === n6) {
        const cm = cJ['width']
          , cL = cJ['height'];
        let cR, H0;
        if (cm / 0x6 === cL)
          cR = cL,
            H0 = [0x0, 0x0, 0x1, 0x0, 0x2, 0x0, 0x3, 0x0, 0x4, 0x0, 0x5, 0x0];
        else {
          if (cL / 0x6 === cm)
            cR = cm,
              H0 = [0x0, 0x0, 0x0, 0x1, 0x0, 0x2, 0x0, 0x3, 0x0, 0x4, 0x0, 0x5];
          else {
            if (cm / 0x3 == cL / 0x2)
              cR = cm / 0x3,
                H0 = [0x0, 0x0, 0x1, 0x0, 0x2, 0x0, 0x0, 0x1, 0x1, 0x1, 0x2, 0x1];
            else {
              if (cm / 0x2 != cL / 0x3)
                throw 'can\x27t\x20figure\x20out\x20cube\x20map\x20from\x20element:\x20' + (cJ['src'] ? cJ['src'] : cJ['nodeName']);
              cR = cm / 0x2,
                H0 = [0x0, 0x0, 0x1, 0x0, 0x0, 0x1, 0x1, 0x1, 0x0, 0x2, 0x1, 0x2];
            }
          }
        }
        const H1 = AM();
        H1 ? (H1['canvas']['width'] = cR,
          H1['canvas']['height'] = cR,
          cg = cR,
          cN = cR,
          lx(0x0, cC)['forEach'](function (H2) {
            const H3 = H0[0x2 * H2['ndx'] + 0x0] * cR
              , H4 = H0[0x2 * H2['ndx'] + 0x1] * cR;
            H1['drawImage'](cJ, H3, H4, cR, cR, 0x0, 0x0, cR, cR),
              cd['texImage2D'](H2['face'], cG, cP, cz, cQ, H1['canvas']);
          }),
          H1['canvas']['width'] = 0x1,
          H1['canvas']['height'] = 0x1) : 'undefined' != typeof createImageBitmap && (cg = cR,
            cN = cR,
            lx(0x0, cC)['forEach'](function (H2) {
              const H3 = H0[0x2 * H2['ndx'] + 0x0] * cR
                , H4 = H0[0x2 * H2['ndx'] + 0x1] * cR;
              cd['texImage2D'](H2['face'], cG, cP, cR, cR, 0x0, cz, cQ, null),
                createImageBitmap(cJ, H3, H4, cR, cR, {
                  'premultiplyAlpha': 'none',
                  'colorSpaceConversion': 'none'
                })['then'](function (H5) {
                  lA(cd, cC),
                    cd['bindTexture'](cO, cq),
                    cd['texImage2D'](H2['face'], cG, cP, cz, cQ, H5),
                    lc(cC) && lb(cd, cq, cC, cg, cN, cP);
                });
            }));
      } else {
        if (cO === n7 || cO === n8) {
          const H2 = Math['min'](cJ['width'], cJ['height'])
            , H3 = Math['max'](cJ['width'], cJ['height'])
            , H4 = H3 / H2;
          if (H4 % 0x1 != 0x0)
            throw 'can\x20not\x20compute\x203D\x20dimensions\x20of\x20element';
          const H5 = cJ['width'] === H3 ? 0x1 : 0x0
            , H6 = cJ['height'] === H3 ? 0x1 : 0x0;
          cd['pixelStorei'](nX, 0x1),
            cd['pixelStorei'](nE, cJ['width']),
            cd['pixelStorei'](nf, 0x0),
            cd['pixelStorei'](nj, 0x0),
            cd['texImage3D'](cO, cG, cP, H2, H2, H2, 0x0, cz, cQ, null);
          for (let H7 = 0x0; H7 < H4; ++H7) {
            const H8 = H7 * H2 * H5
              , H9 = H7 * H2 * H6;
            cd['pixelStorei'](nW, H8),
              cd['pixelStorei'](nI, H9),
              cd['texSubImage3D'](cO, cG, 0x0, 0x0, H7, H2, H2, 0x1, cz, cQ, cJ);
          }
          lk(cd);
        } else
          cd['texImage2D'](cO, cG, cP, cz, cQ, cJ);
      }
      lc(cC) && lb(cd, cq, cC, cg, cN, cP),
        lK(cd, cq, cC);
    }
    function lF () { }
    function ly (cd) {
      return 'undefined' != typeof ImageBitmap && cd instanceof ImageBitmap || 'undefined' != typeof ImageData && cd instanceof ImageData || 'undefined' != typeof HTMLElement && cd instanceof HTMLElement;
    }
    function lw (cd, cq, cJ) {
      return ly(cd) ? (setTimeout(function () {
        cJ(null, cd);
      }),
        cd) : function (cC, cO, cG) {
          let cg;
          if (cG = cG || lF,
            cO = undefined !== cO ? cO : AN['crossOrigin'],
            cO = function (cN, cP) {
              return undefined !== cP || function (cM) {
                if ('undefined' != typeof document) {
                  const cz = document['createElement']('a');
                  return cz['href'] = cM,
                    cz['hostname'] === location['hostname'] && cz['port'] === location['port'] && cz['protocol'] === location['protocol'];
                }
                {
                  const cQ = new URL(location['href'])['origin'];
                  return new URL(cM, location['href'])['origin'] === cQ;
                }
              }(cN) ? cP : 'anonymous';
            }(cC, cO),
            'undefined' != typeof Image) {
            cg = new Image(),
              undefined !== cO && (cg['crossOrigin'] = cO);
            const cN = function () {
              cg['removeEventListener']('error', cP),
                cg['removeEventListener']('load', cM),
                cg = null;
            }
              , cP = function () {
                const cz = 'couldn\x27t\x20load\x20image:\x20' + cC;
                vP(cz),
                  cG(cz, cg),
                  cN();
              }
              , cM = function () {
                cG(null, cg),
                  cN();
              };
            return cg['addEventListener']('error', cP),
              cg['addEventListener']('load', cM),
              cg['src'] = cC,
              cg;
          }
          if ('undefined' != typeof ImageBitmap) {
            let cz, cQ;
            const cm = function () {
              cG(cz, cQ);
            }
              , cL = {};
            cO && (cL['mode'] = 'cors'),
              qeFetch(cC, cL)['then'](function (cR) {
                if (!cR['ok'])
                  throw cR;
                return cR['blob']();
              })['then'](function (cR) {
                return createImageBitmap(cR, {
                  'premultiplyAlpha': 'none',
                  'colorSpaceConversion': 'none'
                });
              })['then'](function (cR) {
                cQ = cR,
                  setTimeout(cm);
              })['catch'](function (cR) {
                cz = cR,
                  setTimeout(cm);
              }),
              cg = null;
          }
          return cg;
        }(cd, cq, cJ);
    }
    function lh (cd, cq, cJ) {
      const cC = (cJ = cJ || AN['textureOptions'])['target'] || n5;
      if (cd['bindTexture'](cC, cq),
        false === cJ['color'])
        return;
      const cO = function (cG) {
        return cG = cG || AN['textureColor'],
          AP(cG) ? cG : new Uint8Array([0xff * cG[0x0], 0xff * cG[0x1], 0xff * cG[0x2], 0xff * cG[0x3]]);
      }(cJ['color']);
      if (cC === n6) {
        for (let cG = 0x0; cG < 0x6; ++cG)
          cd['texImage2D'](n9 + cG, 0x0, Am, 0x1, 0x1, 0x0, Am, kU, cO);
      } else
        cC === n7 || cC === n8 ? cd['texImage3D'](cC, 0x0, Am, 0x1, 0x1, 0x1, 0x0, Am, kU, cO) : cd['texImage2D'](cC, 0x0, Am, 0x1, 0x1, 0x0, Am, kU, cO);
    }
    function lu (cd, cq, cJ, cC) {
      const cO = (cC = cC || AN['textureOptions'])['target'] || n5;
      cd['bindTexture'](cO, cq);
      let cG = cC['width']
        , cg = cC['height']
        , cN = cC['depth'];
      const cP = cC['level'] || 0x0
        , cM = cC['internalFormat'] || cC['format'] || Am
        , cz = l8(cM)
        , cQ = cC['format'] || cz['format']
        , cm = cC['type'] || function (H1, H2, H3) {
          return AP(H2) ? vO(H2) : H3 || kU;
        }(0x0, cJ, cz['type']);
      if (AP(cJ))
        cJ instanceof Uint8ClampedArray && (cJ = new Uint8Array(cJ['buffer']));
      else {
        const H1 = vg(cm);
        cJ = new H1(cJ);
      }
      const cL = function (H2, H3) {
        const H4 = l7(H2);
        if (!H4)
          throw 'unknown\x20internal\x20format';
        const H5 = H4['bytesPerElementMap'][H3];
        if (undefined === H5)
          throw 'unknown\x20internal\x20format';
        return H5;
      }(cM, cm)
        , cR = cJ['byteLength'] / cL;
      if (cR % 0x1)
        throw 'length\x20wrong\x20size\x20for\x20format:\x20' + Ag(cd, cQ);
      let H0;
      if (cO === n7 || cO === n8) {
        if (cG || cg || cN)
          !cG || cg && cN ? !cg || cG && cN ? (H0 = lv(0x0, cO, cG, cg, cR / cN),
            cG = H0['width'],
            cg = H0['height']) : (H0 = lv(0x0, cO, cG, cN, cR / cg),
              cG = H0['width'],
              cN = H0['height']) : (H0 = lv(0x0, cO, cg, cN, cR / cG),
                cg = H0['width'],
                cN = H0['height']);
        else {
          const H2 = Math['cbrt'](cR);
          if (H2 % 0x1 != 0x0)
            throw 'can\x27t\x20guess\x20cube\x20size\x20of\x20array\x20of\x20numElements:\x20' + cR;
          cG = H2,
            cg = H2,
            cN = H2;
        }
      } else
        H0 = lv(0x0, cO, cG, cg, cR),
          cG = H0['width'],
          cg = H0['height'];
      if (lk(cd),
        cd['pixelStorei'](nX, cC['unpackAlignment'] || 0x1),
        lA(cd, cC),
        cO === n6) {
        const H3 = cR / 0x6 * (cL / cJ['BYTES_PER_ELEMENT']);
        lx(0x0, cC)['forEach'](H4 => {
          const H5 = H3 * H4['ndx']
            , H6 = cJ['subarray'](H5, H5 + H3);
          cd['texImage2D'](H4['face'], cP, cM, cG, cg, 0x0, cQ, cm, H6);
        }
        );
      } else
        cO === n7 || cO === n8 ? cd['texImage3D'](cO, cP, cM, cG, cg, cN, 0x0, cQ, cm, cJ) : cd['texImage2D'](cO, cP, cM, cG, cg, 0x0, cQ, cm, cJ);
      return {
        'width': cG,
        'height': cg,
        'depth': cN,
        'type': cm
      };
    }
    function lY (cd, cq, cJ) {
      cJ = cJ || lF,
        cq = cq || AN['textureOptions'];
      const cC = cd['createTexture']()
        , cO = cq['target'] || n5;
      let cG = cq['width'] || 0x1
        , cg = cq['height'] || 0x1;
      const cN = cq['internalFormat'] || Am;
      cd['bindTexture'](cO, cC),
        cO === n6 && (cd['texParameteri'](cO, nx, n2),
          cd['texParameteri'](cO, np, n2));
      let cP = cq['src'];
      if (cP) {
        if ('function' == typeof cP && (cP = cP(cd, cq)),
          'string' == typeof cP)
          !function (cM, cz, cQ, cm) {
            cm = cm || lF,
              cQ = cQ || AN['textureOptions'],
              lh(cM, cz, cQ),
              lw((cQ = Object['assign']({}, cQ))['src'], cQ['crossOrigin'], function (cL, cR) {
                cL ? cm(cL, cz, cR) : (lp(cM, cz, cR, cQ),
                  cm(null, cz, cR));
              });
          }(cd, cC, cq, cJ);
        else {
          if (AP(cP) || Array['isArray'](cP) && ('number' == typeof cP[0x0] || Array['isArray'](cP[0x0]) || AP(cP[0x0]))) {
            const cM = lu(cd, cC, cP, cq);
            cG = cM['width'],
              cg = cM['height'];
          } else
            Array['isArray'](cP) && ('string' == typeof cP[0x0] || ly(cP[0x0])) ? cO === n6 ? function (cz, cQ, cm, cL) {
              cL = cL || lF;
              const cR = cm['src'];
              if (0x6 !== cR['length'])
                throw 'there\x20must\x20be\x206\x20urls\x20for\x20a\x20cubemap';
              const H0 = cm['level'] || 0x0
                , H1 = cm['internalFormat'] || cm['format'] || Am
                , H2 = l8(H1)
                , H3 = cm['format'] || H2['format']
                , H4 = cm['type'] || kU
                , H5 = cm['target'] || n5;
              if (H5 !== n6)
                throw 'target\x20must\x20be\x20TEXTURE_CUBE_MAP';
              lh(cz, cQ, cm),
                cm = Object['assign']({}, cm);
              let H6 = 0x6;
              const H7 = []
                , H8 = lH(0x0, cm);
              let H9;
              H9 = cR['map'](function (Hv, HA) {
                return lw(Hv, cm['crossOrigin'], (Hk = H8[HA],
                  function (Hl, HK) {
                    --H6,
                      Hl ? H7['push'](Hl) : HK['width'] !== HK['height'] ? H7['push']('cubemap\x20face\x20img\x20is\x20not\x20a\x20square:\x20' + HK['src']) : (lA(cz, cm),
                        cz['bindTexture'](H5, cQ),
                        0x5 === H6 ? lH()['forEach'](function (Hb) {
                          cz['texImage2D'](Hb, H0, H1, H3, H4, HK);
                        }) : cz['texImage2D'](Hk, H0, H1, H3, H4, HK),
                        lc(cm) && cz['generateMipmap'](H5)),
                      0x0 === H6 && cL(H7['length'] ? H7 : undefined, cQ, H9);
                  }
                ));
                var Hk;
              });
            }(cd, cC, cq, cJ) : function (cz, cQ, cm, cL) {
              cL = cL || lF;
              const cR = cm['src']
                , H0 = cm['internalFormat'] || cm['format'] || Am
                , H1 = l8(H0)
                , H2 = cm['format'] || H1['format']
                , H3 = cm['type'] || kU
                , H4 = cm['target'] || n8;
              if (H4 !== n7 && H4 !== n8)
                throw 'target\x20must\x20be\x20TEXTURE_3D\x20or\x20TEXTURE_2D_ARRAY';
              lh(cz, cQ, cm),
                cm = Object['assign']({}, cm);
              let H5 = cR['length'];
              const H6 = [];
              let H7;
              const H8 = cm['level'] || 0x0;
              let H9 = cm['width']
                , Hv = cm['height'];
              const HA = cR['length'];
              let Hk = true;
              H7 = cR['map'](function (Hl, HK) {
                return lw(Hl, cm['crossOrigin'], (Hb = HK,
                  function (Hc, HH) {
                    if (--H5,
                      Hc)
                      H6['push'](Hc);
                    else {
                      if (lA(cz, cm),
                        cz['bindTexture'](H4, cQ),
                        Hk) {
                        Hk = false,
                          H9 = cm['width'] || HH['width'],
                          Hv = cm['height'] || HH['height'],
                          cz['texImage3D'](H4, H8, H0, H9, Hv, HA, 0x0, H2, H3, null);
                        for (let Hx = 0x0; Hx < HA; ++Hx)
                          cz['texSubImage3D'](H4, H8, 0x0, 0x0, Hx, H9, Hv, 0x1, H2, H3, HH);
                      } else {
                        let Hp, HF = HH;
                        HH['width'] === H9 && HH['height'] === Hv || (Hp = AM(),
                          HF = Hp['canvas'],
                          Hp['canvas']['width'] = H9,
                          Hp['canvas']['height'] = Hv,
                          Hp['drawImage'](HH, 0x0, 0x0, H9, Hv)),
                          cz['texSubImage3D'](H4, H8, 0x0, 0x0, Hb, H9, Hv, 0x1, H2, H3, HF),
                          Hp && HF === Hp['canvas'] && (Hp['canvas']['width'] = 0x0,
                            Hp['canvas']['height'] = 0x0);
                      }
                      lc(cm) && cz['generateMipmap'](H4);
                    }
                    0x0 === H5 && cL(H6['length'] ? H6 : undefined, cQ, H7);
                  }
                ));
                var Hb;
              });
            }(cd, cC, cq, cJ) : (lp(cd, cC, cP, cq),
              cG = cP['width'],
              cg = cP['height']);
        }
      } else
        !function (cz, cQ, cm) {
          const cL = cm['target'] || n5;
          cz['bindTexture'](cL, cQ);
          const cR = cm['level'] || 0x0
            , H0 = cm['internalFormat'] || cm['format'] || Am
            , H1 = l8(H0)
            , H2 = cm['format'] || H1['format']
            , H3 = cm['type'] || H1['type'];
          if (lA(cz, cm),
            cL === n6) {
            for (let H4 = 0x0; H4 < 0x6; ++H4)
              cz['texImage2D'](n9 + H4, cR, H0, cm['width'], cm['height'], 0x0, H2, H3, null);
          } else
            cL === n7 || cL === n8 ? cz['texImage3D'](cL, cR, H0, cm['width'], cm['height'], cm['depth'], 0x0, H2, H3, null) : cz['texImage2D'](cL, cR, H0, cm['width'], cm['height'], 0x0, H2, H3, null);
        }(cd, cC, cq);
      return lc(cq) && lb(cd, cC, cq, cG, cg, cN),
        lK(cd, cC, cq),
        cC;
    }
    const lT = vP;
    function lX (cd) {
      return 'undefined' != typeof document && document['getElementById'] ? document['getElementById'](cd) : null;
    }
    const lE = 0x84c0
      , lf = 0x8892
      , lW = 0x8b81
      , lI = 0x8b82
      , lj = 0x8b30
      , lD = 0x8b31
      , lV = 0x8c8d
      , lZ = 0x8b86
      , lB = 0x8b89
      , lS = 0x8c83
      , lU = 0x8a36
      , ld = 0x8a44
      , lq = 0x8a46
      , lJ = 0x8a40
      , lC = 0x8a43
      , lO = 0x1404
      , lG = 0xde1
      , lg = 0x8513
      , lN = 0x806f
      , lP = 0x8c1a
      , lM = {};
    function lz (cd, cq) {
      return lM[cq]['bindPoint'];
    }
    function lQ (cd, cq) {
      return function (cJ) {
        cd['uniform1i'](cq, cJ);
      }
        ;
    }
    function lm (cd, cq) {
      return function (cJ) {
        cd['uniform1iv'](cq, cJ);
      }
        ;
    }
    function lL (cd, cq) {
      return function (cJ) {
        cd['uniform2iv'](cq, cJ);
      }
        ;
    }
    function lR (cd, cq) {
      return function (cJ) {
        cd['uniform3iv'](cq, cJ);
      }
        ;
    }
    function K0 (cd, cq) {
      return function (cJ) {
        cd['uniform4iv'](cq, cJ);
      }
        ;
    }
    function K1 (cd, cq, cJ, cC) {
      const cO = lz(0x0, cq);
      return AG(cd) ? function (cG) {
        let cg, cN;
        !cG || vm(0x0, cG) ? (cg = cG,
          cN = null) : (cg = cG['texture'],
            cN = cG['sampler']),
          cd['uniform1i'](cC, cJ),
          cd['activeTexture'](lE + cJ),
          cd['bindTexture'](cO, cg),
          cd['bindSampler'](cJ, cN);
      }
        : function (cG) {
          cd['uniform1i'](cC, cJ),
            cd['activeTexture'](lE + cJ),
            cd['bindTexture'](cO, cG);
        }
        ;
    }
    function K2 (cd, cq, cJ, cC, cO) {
      const cG = lz(0x0, cq)
        , cg = new Int32Array(cO);
      for (let cN = 0x0; cN < cO; ++cN)
        cg[cN] = cJ + cN;
      return AG(cd) ? function (cP) {
        cd['uniform1iv'](cC, cg),
          cP['forEach'](function (cM, cz) {
            let cQ, cm;
            cd['activeTexture'](lE + cg[cz]),
              !cM || vm(0x0, cM) ? (cQ = cM,
                cm = null) : (cQ = cM['texture'],
                  cm = cM['sampler']),
              cd['bindSampler'](cJ, cm),
              cd['bindTexture'](cG, cQ);
          });
      }
        : function (cP) {
          cd['uniform1iv'](cC, cg),
            cP['forEach'](function (cM, cz) {
              cd['activeTexture'](lE + cg[cz]),
                cd['bindTexture'](cG, cM);
            });
        }
        ;
    }
    function K3 (cd, cq) {
      return function (cJ) {
        if (cJ['value'])
          switch (cd['disableVertexAttribArray'](cq),
          cJ['value']['length']) {
            case 0x4:
              cd['vertexAttrib4fv'](cq, cJ['value']);
              break;
            case 0x3:
              cd['vertexAttrib3fv'](cq, cJ['value']);
              break;
            case 0x2:
              cd['vertexAttrib2fv'](cq, cJ['value']);
              break;
            case 0x1:
              cd['vertexAttrib1fv'](cq, cJ['value']);
              break;
            default:
              throw new Error('the\x20length\x20of\x20a\x20float\x20constant\x20value\x20must\x20be\x20between\x201\x20and\x204!');
          }
        else
          cd['bindBuffer'](lf, cJ['buffer']),
            cd['enableVertexAttribArray'](cq),
            cd['vertexAttribPointer'](cq, cJ['numComponents'] || cJ['size'], cJ['type'] || 0x1406, cJ['normalize'] || false, cJ['stride'] || 0x0, cJ['offset'] || 0x0),
            cd['vertexAttribDivisor'] && cd['vertexAttribDivisor'](cq, cJ['divisor'] || 0x0);
      }
        ;
    }
    function K4 (cd, cq) {
      return function (cJ) {
        if (cJ['value']) {
          if (cd['disableVertexAttribArray'](cq),
            0x4 !== cJ['value']['length'])
            throw new Error('The\x20length\x20of\x20an\x20integer\x20constant\x20value\x20must\x20be\x204!');
          cd['vertexAttrib4iv'](cq, cJ['value']);
        } else
          cd['bindBuffer'](lf, cJ['buffer']),
            cd['enableVertexAttribArray'](cq),
            cd['vertexAttribIPointer'](cq, cJ['numComponents'] || cJ['size'], cJ['type'] || lO, cJ['stride'] || 0x0, cJ['offset'] || 0x0),
            cd['vertexAttribDivisor'] && cd['vertexAttribDivisor'](cq, cJ['divisor'] || 0x0);
      }
        ;
    }
    function K5 (cd, cq) {
      return function (cJ) {
        if (cJ['value']) {
          if (cd['disableVertexAttribArray'](cq),
            0x4 !== cJ['value']['length'])
            throw new Error('The\x20length\x20of\x20an\x20unsigned\x20integer\x20constant\x20value\x20must\x20be\x204!');
          cd['vertexAttrib4uiv'](cq, cJ['value']);
        } else
          cd['bindBuffer'](lf, cJ['buffer']),
            cd['enableVertexAttribArray'](cq),
            cd['vertexAttribIPointer'](cq, cJ['numComponents'] || cJ['size'], cJ['type'] || 0x1405, cJ['stride'] || 0x0, cJ['offset'] || 0x0),
            cd['vertexAttribDivisor'] && cd['vertexAttribDivisor'](cq, cJ['divisor'] || 0x0);
      }
        ;
    }
    function K6 (cd, cq, cJ) {
      const cC = cJ['size']
        , cO = cJ['count'];
      return function (cG) {
        cd['bindBuffer'](lf, cG['buffer']);
        const cg = cG['size'] || cG['numComponents'] || cC
          , cN = cg / cO
          , cP = cG['type'] || 0x1406
          , cM = lM[cP]['size'] * cg
          , cz = cG['normalize'] || false
          , cQ = cG['offset'] || 0x0
          , cm = cM / cO;
        for (let cL = 0x0; cL < cO; ++cL)
          cd['enableVertexAttribArray'](cq + cL),
            cd['vertexAttribPointer'](cq + cL, cN, cP, cz, cM, cQ + cm * cL),
            cd['vertexAttribDivisor'] && cd['vertexAttribDivisor'](cq + cL, cG['divisor'] || 0x0);
      }
        ;
    }
    lM[0x1406] = {
      'Type': Float32Array,
      'size': 0x4,
      'setter': function (cd, cq) {
        return function (cJ) {
          cd['uniform1f'](cq, cJ);
        }
          ;
      },
      'arraySetter': function (cd, cq) {
        return function (cJ) {
          cd['uniform1fv'](cq, cJ);
        }
          ;
      }
    },
      lM[0x8b50] = {
        'Type': Float32Array,
        'size': 0x8,
        'setter': function (cd, cq) {
          return function (cJ) {
            cd['uniform2fv'](cq, cJ);
          }
            ;
        },
        'cols': 0x2
      },
      lM[0x8b51] = {
        'Type': Float32Array,
        'size': 0xc,
        'setter': function (cd, cq) {
          return function (cJ) {
            cd['uniform3fv'](cq, cJ);
          }
            ;
        },
        'cols': 0x3
      },
      lM[0x8b52] = {
        'Type': Float32Array,
        'size': 0x10,
        'setter': function (cd, cq) {
          return function (cJ) {
            cd['uniform4fv'](cq, cJ);
          }
            ;
        },
        'cols': 0x4
      },
      lM[lO] = {
        'Type': Int32Array,
        'size': 0x4,
        'setter': lQ,
        'arraySetter': lm
      },
      lM[0x8b53] = {
        'Type': Int32Array,
        'size': 0x8,
        'setter': lL,
        'cols': 0x2
      },
      lM[0x8b54] = {
        'Type': Int32Array,
        'size': 0xc,
        'setter': lR,
        'cols': 0x3
      },
      lM[0x8b55] = {
        'Type': Int32Array,
        'size': 0x10,
        'setter': K0,
        'cols': 0x4
      },
      lM[0x1405] = {
        'Type': Uint32Array,
        'size': 0x4,
        'setter': function (cd, cq) {
          return function (cJ) {
            cd['uniform1ui'](cq, cJ);
          }
            ;
        },
        'arraySetter': function (cd, cq) {
          return function (cJ) {
            cd['uniform1uiv'](cq, cJ);
          }
            ;
        }
      },
      lM[0x8dc6] = {
        'Type': Uint32Array,
        'size': 0x8,
        'setter': function (cd, cq) {
          return function (cJ) {
            cd['uniform2uiv'](cq, cJ);
          }
            ;
        },
        'cols': 0x2
      },
      lM[0x8dc7] = {
        'Type': Uint32Array,
        'size': 0xc,
        'setter': function (cd, cq) {
          return function (cJ) {
            cd['uniform3uiv'](cq, cJ);
          }
            ;
        },
        'cols': 0x3
      },
      lM[0x8dc8] = {
        'Type': Uint32Array,
        'size': 0x10,
        'setter': function (cd, cq) {
          return function (cJ) {
            cd['uniform4uiv'](cq, cJ);
          }
            ;
        },
        'cols': 0x4
      },
      lM[0x8b56] = {
        'Type': Uint32Array,
        'size': 0x4,
        'setter': lQ,
        'arraySetter': lm
      },
      lM[0x8b57] = {
        'Type': Uint32Array,
        'size': 0x8,
        'setter': lL,
        'cols': 0x2
      },
      lM[0x8b58] = {
        'Type': Uint32Array,
        'size': 0xc,
        'setter': lR,
        'cols': 0x3
      },
      lM[0x8b59] = {
        'Type': Uint32Array,
        'size': 0x10,
        'setter': K0,
        'cols': 0x4
      },
      lM[0x8b5a] = {
        'Type': Float32Array,
        'size': 0x20,
        'setter': function (cd, cq) {
          return function (cJ) {
            cd['uniformMatrix2fv'](cq, false, cJ);
          }
            ;
        },
        'rows': 0x2,
        'cols': 0x2
      },
      lM[0x8b5b] = {
        'Type': Float32Array,
        'size': 0x30,
        'setter': function (cd, cq) {
          return function (cJ) {
            cd['uniformMatrix3fv'](cq, false, cJ);
          }
            ;
        },
        'rows': 0x3,
        'cols': 0x3
      },
      lM[0x8b5c] = {
        'Type': Float32Array,
        'size': 0x40,
        'setter': function (cd, cq) {
          return function (cJ) {
            cd['uniformMatrix4fv'](cq, false, cJ);
          }
            ;
        },
        'rows': 0x4,
        'cols': 0x4
      },
      lM[0x8b65] = {
        'Type': Float32Array,
        'size': 0x20,
        'setter': function (cd, cq) {
          return function (cJ) {
            cd['uniformMatrix2x3fv'](cq, false, cJ);
          }
            ;
        },
        'rows': 0x2,
        'cols': 0x3
      },
      lM[0x8b66] = {
        'Type': Float32Array,
        'size': 0x20,
        'setter': function (cd, cq) {
          return function (cJ) {
            cd['uniformMatrix2x4fv'](cq, false, cJ);
          }
            ;
        },
        'rows': 0x2,
        'cols': 0x4
      },
      lM[0x8b67] = {
        'Type': Float32Array,
        'size': 0x30,
        'setter': function (cd, cq) {
          return function (cJ) {
            cd['uniformMatrix3x2fv'](cq, false, cJ);
          }
            ;
        },
        'rows': 0x3,
        'cols': 0x2
      },
      lM[0x8b68] = {
        'Type': Float32Array,
        'size': 0x30,
        'setter': function (cd, cq) {
          return function (cJ) {
            cd['uniformMatrix3x4fv'](cq, false, cJ);
          }
            ;
        },
        'rows': 0x3,
        'cols': 0x4
      },
      lM[0x8b69] = {
        'Type': Float32Array,
        'size': 0x40,
        'setter': function (cd, cq) {
          return function (cJ) {
            cd['uniformMatrix4x2fv'](cq, false, cJ);
          }
            ;
        },
        'rows': 0x4,
        'cols': 0x2
      },
      lM[0x8b6a] = {
        'Type': Float32Array,
        'size': 0x40,
        'setter': function (cd, cq) {
          return function (cJ) {
            cd['uniformMatrix4x3fv'](cq, false, cJ);
          }
            ;
        },
        'rows': 0x4,
        'cols': 0x3
      },
      lM[0x8b5e] = {
        'Type': null,
        'size': 0x0,
        'setter': K1,
        'arraySetter': K2,
        'bindPoint': lG
      },
      lM[0x8b60] = {
        'Type': null,
        'size': 0x0,
        'setter': K1,
        'arraySetter': K2,
        'bindPoint': lg
      },
      lM[0x8b5f] = {
        'Type': null,
        'size': 0x0,
        'setter': K1,
        'arraySetter': K2,
        'bindPoint': lN
      },
      lM[0x8b62] = {
        'Type': null,
        'size': 0x0,
        'setter': K1,
        'arraySetter': K2,
        'bindPoint': lG
      },
      lM[0x8dc1] = {
        'Type': null,
        'size': 0x0,
        'setter': K1,
        'arraySetter': K2,
        'bindPoint': lP
      },
      lM[0x8dc4] = {
        'Type': null,
        'size': 0x0,
        'setter': K1,
        'arraySetter': K2,
        'bindPoint': lP
      },
      lM[0x8dc5] = {
        'Type': null,
        'size': 0x0,
        'setter': K1,
        'arraySetter': K2,
        'bindPoint': lg
      },
      lM[0x8dca] = {
        'Type': null,
        'size': 0x0,
        'setter': K1,
        'arraySetter': K2,
        'bindPoint': lG
      },
      lM[0x8dcb] = {
        'Type': null,
        'size': 0x0,
        'setter': K1,
        'arraySetter': K2,
        'bindPoint': lN
      },
      lM[0x8dcc] = {
        'Type': null,
        'size': 0x0,
        'setter': K1,
        'arraySetter': K2,
        'bindPoint': lg
      },
      lM[0x8dcf] = {
        'Type': null,
        'size': 0x0,
        'setter': K1,
        'arraySetter': K2,
        'bindPoint': lP
      },
      lM[0x8dd2] = {
        'Type': null,
        'size': 0x0,
        'setter': K1,
        'arraySetter': K2,
        'bindPoint': lG
      },
      lM[0x8dd3] = {
        'Type': null,
        'size': 0x0,
        'setter': K1,
        'arraySetter': K2,
        'bindPoint': lN
      },
      lM[0x8dd4] = {
        'Type': null,
        'size': 0x0,
        'setter': K1,
        'arraySetter': K2,
        'bindPoint': lg
      },
      lM[0x8dd7] = {
        'Type': null,
        'size': 0x0,
        'setter': K1,
        'arraySetter': K2,
        'bindPoint': lP
      };
    const K7 = {};
    K7[0x1406] = {
      'size': 0x4,
      'setter': K3
    },
      K7[0x8b50] = {
        'size': 0x8,
        'setter': K3
      },
      K7[0x8b51] = {
        'size': 0xc,
        'setter': K3
      },
      K7[0x8b52] = {
        'size': 0x10,
        'setter': K3
      },
      K7[lO] = {
        'size': 0x4,
        'setter': K4
      },
      K7[0x8b53] = {
        'size': 0x8,
        'setter': K4
      },
      K7[0x8b54] = {
        'size': 0xc,
        'setter': K4
      },
      K7[0x8b55] = {
        'size': 0x10,
        'setter': K4
      },
      K7[0x1405] = {
        'size': 0x4,
        'setter': K5
      },
      K7[0x8dc6] = {
        'size': 0x8,
        'setter': K5
      },
      K7[0x8dc7] = {
        'size': 0xc,
        'setter': K5
      },
      K7[0x8dc8] = {
        'size': 0x10,
        'setter': K5
      },
      K7[0x8b56] = {
        'size': 0x4,
        'setter': K4
      },
      K7[0x8b57] = {
        'size': 0x8,
        'setter': K4
      },
      K7[0x8b58] = {
        'size': 0xc,
        'setter': K4
      },
      K7[0x8b59] = {
        'size': 0x10,
        'setter': K4
      },
      K7[0x8b5a] = {
        'size': 0x4,
        'setter': K6,
        'count': 0x2
      },
      K7[0x8b5b] = {
        'size': 0x9,
        'setter': K6,
        'count': 0x3
      },
      K7[0x8b5c] = {
        'size': 0x10,
        'setter': K6,
        'count': 0x4
      };
    const K8 = /ERROR:\s*\d+:(\d+)/gi
      , K9 = /^[ \t]*\n/;
    function Kv (cd) {
      let cq = 0x0;
      return K9['test'](cd) && (cq = 0x1,
        cd = cd['replace'](K9, '')),
      {
        'lineOffset': cq,
        'shaderSource': cd
      };
    }
    function KA (cd, cq, cJ) {
      let cC, cO, cG;
      if ('function' == typeof cq && (cJ = cq,
        cq = undefined),
        'function' == typeof cd)
        cJ = cd,
          cd = undefined;
      else {
        if (cd && !Array['isArray'](cd)) {
          const cM = cd;
          cJ = cM['errorCallback'],
            cd = cM['attribLocations'],
            cC = cM['transformFeedbackVaryings'],
            cO = cM['transformFeedbackMode'],
            cG = cM['callback'];
        }
      }
      const cg = cJ || lT
        , cN = []
        , cP = {
          'errorCallback' (cz, ...cQ) {
            cN['push'](cz),
              cg(cz, ...cQ);
          },
          'transformFeedbackVaryings': cC,
          'transformFeedbackMode': cO,
          'callback': cG,
          'errors': cN
        };
      {
        let cz = {};
        Array['isArray'](cd) ? cd['forEach'](function (cQ, cm) {
          cz[cQ] = cq ? cq[cm] : cm;
        }) : cz = cd || {},
          cP['attribLocations'] = cz;
      }
      return cP;
    }
    const Kk = ['VERTEX_SHADER', 'FRAGMENT_SHADER']
      , Kl = (cd = 0x0) => new Promise(cq => setTimeout(cq, cd));
    function KK (cd, cq, cJ) {
      const cC = cd['createProgram']()
        , { attribLocations: cO, transformFeedbackVaryings: cG, transformFeedbackMode: cg } = KA(cJ);
      for (let cP = 0x0; cP < cq['length']; ++cP) {
        let cM = cq[cP];
        if ('string' == typeof cM) {
          const cz = lX(cM)
            , cQ = cz ? cz['text'] : cM;
          let cm = cd[Kk[cP]];
          cz && cz['type'] && (cm = ((cN = cz['type'])['indexOf']('frag') >= 0x0 ? lj : cN['indexOf']('vert') >= 0x0 ? lD : undefined) || cm),
            cM = cd['createShader'](cm),
            cd['shaderSource'](cM, Kv(cQ)['shaderSource']),
            cd['compileShader'](cM),
            cd['attachShader'](cC, cM);
        }
      }
      var cN;
      Object['entries'](cO)['forEach'](([cL, cR]) => cd['bindAttribLocation'](cC, cR, cL));
      {
        let cL = cG;
        cL && (cL['attribs'] && (cL = cL['attribs']),
          Array['isArray'](cL) || (cL = Object['keys'](cL)),
          cd['transformFeedbackVaryings'](cC, cL, cg || lV));
      }
      return cd['linkProgram'](cC),
        cC;
    }
    function Kb (cd, cq, cJ, cC, cO) {
      const cG = KA(cJ, cC, cO)
        , cg = new Set(cq)
        , cN = KK(cd, cq, cG);
      function cP (cM, cz) {
        const cQ = Kx(cM, cz, cG['errorCallback']);
        return cQ && function (cm, cL, cR) {
          const H0 = cm['getAttachedShaders'](cL);
          for (const H1 of H0)
            cR['has'](H1) && cm['deleteShader'](H1);
          cm['deleteProgram'](cL);
        }(cM, cz, cg),
          cQ;
      }
      if (!cG['callback'])
        return cP(cd, cN) ? undefined : cN;
      KH(cd, cN)['then'](() => {
        const cM = cP(cd, cN);
        cG['callback'](cM, cM ? undefined : cN);
      }
      );
    }
    function Kc (cd) {
      return function (cq, cJ, ...cC) {
        return new Promise((cO, cG) => {
          const cg = KA(...cC);
          cg['callback'] = (cN, cP) => {
            cN ? cG(cN) : cO(cP);
          }
            ,
            cd(cq, cJ, cg);
        }
        );
      }
        ;
    }
    async function KH (cd, cq) {
      const cJ = cd['getExtension']('KHR_parallel_shader_compile')
        , cC = cJ ? (cG, cg) => cG['getProgramParameter'](cg, cJ['COMPLETION_STATUS_KHR']) : () => true;
      let cO = 0x0;
      do {
        await Kl(cO),
          cO = 0x3e8 / 0x3c;
      } while (!cC(cd, cq));
    }
    function Kx (cd, cq, cJ) {
      if (cJ = cJ || lT,
        !cd['getProgramParameter'](cq, lI)) {
        const cC = cd['getProgramInfoLog'](cq);
        return cJ('Error\x20in\x20program\x20linking:\x20' + cC),
          cC + '\x0a' + cd['getAttachedShaders'](cq)['map'](cO => function (cG, cg, cN, cP) {
            if (cP = cP || lT,
              !cG['getShaderParameter'](cN, lW)) {
              const cM = cG['getShaderInfoLog'](cN)
                , { lineOffset: cz, shaderSource: cQ } = Kv(cG['getShaderSource'](cN))
                , cm = function (cL, cR = '', H0 = 0x0) {
                  const H1 = [...cR['matchAll'](K8)]
                    , H2 = new Map(H1['map']((H3, H4) => {
                      const H5 = parseInt(H3[0x1])
                        , H6 = H1[H4 + 0x1]
                        , H7 = H6 ? H6['index'] : cR['length'];
                      return [H5 - 0x1, cR['substring'](H3['index'], H7)];
                    }
                    ));
                  return cL['split']('\x0a')['map']((H3, H4) => {
                    const H5 = H2['get'](H4);
                    return H4 + 0x1 + H0 + ':\x20' + H3 + (H5 ? '\x0a\x0a^^^\x20' + H5 : '');
                  }
                  )['join']('\x0a');
                }(cQ, cM, cz) + '\x0aError\x20compiling\x20' + Ag(cG, cg) + ':\x20' + cM;
              return cP(cm),
                cm;
            }
            return '';
          }(cd, cd['getShaderParameter'](cO, cd['SHADER_TYPE']), cO, cJ))['filter'](cO => cO)['join']('\x0a');
      }
    }
    function Kp (cd) {
      const cq = cd['name'];
      return cq['startsWith']('gl_') || cq['startsWith']('webgl_');
    }
    Kc(Kb),
      Kc(Kf);
    const KF = /(\.|\[|]|\w+)/g
      , Ky = cd => cd >= '0' && cd <= '9';
    function Kw (cd, cq, cJ, cC) {
      const cO = cd['split'](KF)['filter'](cN => '' !== cN);
      let cG = 0x0
        , cg = '';
      for (; ;) {
        const cN = cO[cG++];
        cg += cN;
        const cP = Ky(cN[0x0])
          , cM = cP ? parseInt(cN) : cN;
        if (cP && (cg += cO[cG++]),
          cG === cO['length']) {
          cJ[cM] = cq;
          break;
        }
        {
          const cz = cO[cG++]
            , cQ = '[' === cz
            , cm = cJ[cM] || (cQ ? [] : {});
          cJ[cM] = cm,
            cJ = cm,
            cC[cg] = cC[cg] || function (cL) {
              return function (cR) {
                Ku(cL, cR);
              }
                ;
            }(cm),
            cg += cz;
        }
      }
    }
    function Kh (cd, cq) {
      let cJ = 0x0;
      function cC (cN, cP, cM) {
        const cz = cP['name']['endsWith']('[0]')
          , cQ = cP['type']
          , cm = lM[cQ];
        if (!cm)
          throw new Error('unknown\x20type:\x200x' + cQ['toString'](0x10));
        let cL;
        if (cm['bindPoint']) {
          const cR = cJ;
          cJ += cP['size'],
            cL = cz ? cm['arraySetter'](cd, cQ, cR, cM, cP['size']) : cm['setter'](cd, cQ, cR, cM, cP['size']);
        } else
          cL = cm['arraySetter'] && cz ? cm['arraySetter'](cd, cM) : cm['setter'](cd, cM);
        return cL['location'] = cM,
          cL;
      }
      const cO = {}
        , cG = {}
        , cg = cd['getProgramParameter'](cq, lZ);
      for (let cN = 0x0; cN < cg; ++cN) {
        const cP = cd['getActiveUniform'](cq, cN);
        if (Kp(cP))
          continue;
        let cM = cP['name'];
        cM['endsWith']('[0]') && (cM = cM['substr'](0x0, cM['length'] - 0x3));
        const cz = cd['getUniformLocation'](cq, cP['name']);
        if (cz) {
          const cQ = cC(0x0, cP, cz);
          cO[cM] = cQ,
            Kw(cM, cQ, cG, cO);
        }
      }
      return cO;
    }
    function Ku (cd, cq) {
      for (const cJ in cq) {
        const cC = cd[cJ];
        'function' == typeof cC ? cC(cq[cJ]) : Ku(cd[cJ], cq[cJ]);
      }
    }
    function KY (cd, ...cq) {
      const cJ = cd['uniformSetters'] || cd
        , cC = cq['length'];
      for (let cO = 0x0; cO < cC; ++cO) {
        const cG = cq[cO];
        if (Array['isArray'](cG)) {
          const cg = cG['length'];
          for (let cN = 0x0; cN < cg; ++cN)
            KY(cJ, cG[cN]);
        } else
          for (const cP in cG) {
            const cM = cJ[cP];
            cM && cM(cG[cP]);
          }
      }
    }
    function KT (cd, cq) {
      const cJ = {}
        , cC = cd['getProgramParameter'](cq, lB);
      for (let cO = 0x0; cO < cC; ++cO) {
        const cG = cd['getActiveAttrib'](cq, cO);
        if (Kp(cG))
          continue;
        const cg = cd['getAttribLocation'](cq, cG['name'])
          , cN = K7[cG['type']]
          , cP = cN['setter'](cd, cg, cN);
        cP['location'] = cg,
          cJ[cG['name']] = cP;
      }
      return cJ;
    }
    function KX (cd, cq) {
      const cJ = {
        'program': cq,
        'uniformSetters': Kh(cd, cq),
        'attribSetters': KT(cd, cq)
      };
      return AG(cd) && (cJ['uniformBlockSpec'] = function (cC, cO) {
        const cG = cC['getProgramParameter'](cO, lZ)
          , cg = []
          , cN = [];
        for (let cz = 0x0; cz < cG; ++cz) {
          cN['push'](cz),
            cg['push']({});
          const cQ = cC['getActiveUniform'](cO, cz);
          cg[cz]['name'] = cQ['name'];
        }
        [['UNIFORM_TYPE', 'type'], ['UNIFORM_SIZE', 'size'], ['UNIFORM_BLOCK_INDEX', 'blockNdx'], ['UNIFORM_OFFSET', 'offset']]['forEach'](function (cm) {
          const cL = cm[0x0]
            , cR = cm[0x1];
          cC['getActiveUniforms'](cO, cN, cC[cL])['forEach'](function (H0, H1) {
            cg[H1][cR] = H0;
          });
        });
        const cP = {}
          , cM = cC['getProgramParameter'](cO, lU);
        for (let cm = 0x0; cm < cM; ++cm) {
          const cL = cC['getActiveUniformBlockName'](cO, cm)
            , cR = {
              'index': cC['getUniformBlockIndex'](cO, cL),
              'usedByVertexShader': cC['getActiveUniformBlockParameter'](cO, cm, ld),
              'usedByFragmentShader': cC['getActiveUniformBlockParameter'](cO, cm, lq),
              'size': cC['getActiveUniformBlockParameter'](cO, cm, lJ),
              'uniformIndices': cC['getActiveUniformBlockParameter'](cO, cm, lC)
            };
          cR['used'] = cR['usedByVertexShader'] || cR['usedByFragmentShader'],
            cP[cL] = cR;
        }
        return {
          'blockSpecs': cP,
          'uniformData': cg
        };
      }(cd, cq),
        cJ['transformFeedbackInfo'] = function (cC, cO) {
          const cG = {}
            , cg = cC['getProgramParameter'](cO, lS);
          for (let cN = 0x0; cN < cg; ++cN) {
            const cP = cC['getTransformFeedbackVarying'](cO, cN);
            cG[cP['name']] = {
              'index': cN,
              'type': cP['type'],
              'size': cP['size']
            };
          }
          return cG;
        }(cd, cq)),
        cJ;
    }
    const KE = /\s|{|}|;/;
    function Kf (cd, cq, cJ, cC, cO) {
      const cG = KA(cJ, cC, cO)
        , cg = [];
      if (cq = cq['map'](function (cM) {
        if (!KE['test'](cM)) {
          const cz = lX(cM);
          if (cz)
            cM = cz['text'];
          else {
            const cQ = 'no\x20element\x20with\x20id:\x20' + cM;
            cG['errorCallback'](cQ),
              cg['push'](cQ);
          }
        }
        return cM;
      }),
        cg['length'])
        return function (cM, cz) {
          return cM['errorCallback'](cz),
            cM['callback'] && setTimeout(() => {
              cM['callback'](cz + '\x0a' + cM['errors']['join']('\x0a'));
            }
            ),
            null;
        }(cG, '');
      const cN = cG['callback'];
      cN && (cG['callback'] = (cM, cz) => {
        cN(cM, cM ? undefined : KX(cd, cz));
      }
      );
      const cP = function (cM, cz, cQ, cm, cL) {
        return Kb(cM, cz, cQ, cm, cL);
      }(cd, cq, cG);
      return cP ? KX(cd, cP) : null;
    }
    function KW (cd, cq, cJ, cC, cO) {
      for (const [cG, cg] of Object['entries'](cq)) {
        const cN = {
          ...cO
        }
          , cP = cJ[cG];
        Array['isArray'](cP) || Object['assign'](cN, cP);
        const cM = Kx(cd, cg, cN['errorCallback']);
        if (cM) {
          for (const cz of Object['values'](cq)) {
            const cQ = cd['getAttachedShaders'](cz);
            cd['deleteProgram'](cz);
            for (const cm of cQ)
              cC['has'](cm) || cd['deleteShader'](cm);
          }
          return cM;
        }
      }
    }
    function KI (cd, cq, cJ = {}) {
      const cC = new Set()
        , cO = Object['fromEntries'](Object['entries'](cq)['map'](([cG, cg]) => {
          const cN = {
            ...cJ
          }
            , cP = Array['isArray'](cg) ? cg : cg['shaders'];
          return Array['isArray'](cg) || Object['assign'](cN, cg),
            cP['forEach'](cC['add'], cC),
            [cG, KK(cd, cP, cN)];
        }
        ));
      if (!cJ['callback'])
        return KW(cd, cO, cq, cC, cJ) ? undefined : cO;
      (async function (cG, cg) {
        for (const cN of Object['values'](cg))
          await KH(cG, cN);
      }(cd, cO)['then'](() => {
        const cG = KW(cd, cO, cq, cC, cJ);
        cJ['callback'](cG, cG ? undefined : cO);
      }
      ));
    }
    Kc(KI),
      Kc(function (cd, cq, cJ) {
        function cC (cg, cN) {
          return Object['fromEntries'](Object['entries'](cN)['map'](([cP, cM]) => [cP, KX(cg, cM)]));
        }
        const cO = (cJ = KA(cJ))['callback'];
        cO && (cJ['callback'] = (cg, cN) => {
          cO(cg, cg ? undefined : cC(cd, cN));
        }
        );
        const cG = KI(cd, cq, cJ);
        if (!cO && cG)
          return cC(cd, cG);
      });
    const Kj = 0x8d41
      , KD = 0x8ce0
      , KV = 0x8d00
      , KZ = 0x821a
      , KB = 0x812f
      , KS = 0x2601
      , KU = [{
        'format': 0x1908,
        'type': 0x1401,
        'min': KS,
        'wrap': KB
      }, {
        'format': 0x84f9
      }]
      , Kd = {};
    Kd[0x84f9] = KZ,
      Kd[0x1901] = 0x8d20,
      Kd[0x8d48] = 0x8d20,
      Kd[0x1902] = KV,
      Kd[0x81a5] = KV,
      Kd[0x81a6] = KV,
      Kd[0x8cac] = KV,
      Kd[0x88f0] = KZ,
      Kd[0x8cad] = KZ;
    const Kq = {
      0x8056: true,
      0x8057: true,
      0x8d62: true,
      0x84f9: true,
      0x81a5: true,
      0x1901: true,
      0x8d48: true
    };
    function KJ (cd, cq, cJ, cC) {
      const cO = 0x8d40
        , cG = cd['createFramebuffer']();
      cd['bindFramebuffer'](cO, cG),
        cJ = cJ || cd['drawingBufferWidth'],
        cC = cC || cd['drawingBufferHeight'];
      const cg = []
        , cN = {
          'framebuffer': cG,
          'attachments': [],
          'width': cJ,
          'height': cC
        };
      return (cq = cq || KU)['forEach'](function (cP, cM) {
        let cz = cP['attachment'];
        const cQ = cP['samples']
          , cm = cP['format'];
        let cL = cP['attachmentPoint'] || function (H0, H1) {
          return Kd[H0] || Kd[H1];
        }(cm, cP['internalFormat']);
        if (cL || (cL = KD + cM),
          function (H0) {
            return H0 >= KD && H0 < 0x8d00;
          }(cL) && cg['push'](cL),
          !cz) {
          if (undefined !== cQ || function (H0) {
            return Kq[H0];
          }(cm))
            cz = cd['createRenderbuffer'](),
              cd['bindRenderbuffer'](Kj, cz),
              cQ > 0x1 ? cd['renderbufferStorageMultisample'](Kj, cQ, cm, cJ, cC) : cd['renderbufferStorage'](Kj, cm, cJ, cC);
          else {
            const H0 = Object['assign']({}, cP);
            H0['width'] = cJ,
              H0['height'] = cC,
              undefined === H0['auto'] && (H0['auto'] = false,
                H0['min'] = H0['min'] || H0['minMag'] || KS,
                H0['mag'] = H0['mag'] || H0['minMag'] || KS,
                H0['wrapS'] = H0['wrapS'] || H0['wrap'] || KB,
                H0['wrapT'] = H0['wrapT'] || H0['wrap'] || KB),
              cz = lY(cd, H0);
          }
        }
        if (cR = cz,
          'undefined' != typeof WebGLRenderbuffer && vQ(cR, 'WebGLRenderbuffer'))
          cd['framebufferRenderbuffer'](cO, cL, Kj, cz);
        else {
          if (!vm(0x0, cz))
            throw new Error('unknown\x20attachment\x20type');
          undefined !== cP['layer'] ? cd['framebufferTextureLayer'](cO, cL, cz, cP['level'] || 0x0, cP['layer']) : cd['framebufferTexture2D'](cO, cL, cP['target'] || 0xde1, cz, cP['level'] || 0x0);
        }
        var cR;
        cN['attachments']['push'](cz);
      }),
        cd['drawBuffers'] && cd['drawBuffers'](cg),
        cN;
    }
    const KC = /^(.*?)_/;
    function KO (cd, cq) {
      Ag(cd, 0x0);
      const cJ = cd['getExtension'](cq);
      if (cJ) {
        const cC = {}
          , cO = KC['exec'](cq)[0x1]
          , cG = '_' + cO;
        for (const cg in cJ) {
          const cN = cJ[cg]
            , cP = 'function' == typeof cN
            , cM = cP ? cO : cG;
          let cz = cg;
          cg['endsWith'](cM) && (cz = cg['substring'](0x0, cg['length'] - cM['length'])),
            undefined !== cd[cz] ? cP || cd[cz] === cN || vM(cz, cd[cz], cN, cg) : cP ? cd[cz] = function (cQ) {
              return function () {
                return cQ['apply'](cJ, arguments);
              }
                ;
            }(cN) : (cd[cz] = cN,
              cC[cz] = cN);
        }
        cC['constructor'] = {
          'name': cJ['constructor']['name']
        },
          Ag(cC, 0x0);
      }
      return cJ;
    }
    const KG = ['ANGLE_instanced_arrays', 'EXT_blend_minmax', 'EXT_color_buffer_float', 'EXT_color_buffer_half_float', 'EXT_disjoint_timer_query', 'EXT_disjoint_timer_query_webgl2', 'EXT_frag_depth', 'EXT_sRGB', 'EXT_shader_texture_lod', 'EXT_texture_filter_anisotropic', 'OES_element_index_uint', 'OES_standard_derivatives', 'OES_texture_float', 'OES_texture_float_linear', 'OES_texture_half_float', 'OES_texture_half_float_linear', 'OES_vertex_array_object', 'WEBGL_color_buffer_float', 'WEBGL_compressed_texture_atc', 'WEBGL_compressed_texture_etc1', 'WEBGL_compressed_texture_pvrtc', 'WEBGL_compressed_texture_s3tc', 'WEBGL_compressed_texture_s3tc_srgb', 'WEBGL_depth_texture', 'WEBGL_draw_buffers'];
    var Kg = n(0x346)
      , KN = n(0x338)
      , KP = n(0x60)
      , KM = n(0x240)
      , Kz = n(0x1);
    class BinaryReader {
      constructor(cd, cq = true) {
        this['_buffer'] = cd,
          this['littleEndian'] = cq,
          this['_view'] = new DataView(cd),
          this['_offset'] = 0x0;
      }
      get ['offset'] () {
        return this['_offset'];
      }
      get ['buffer'] () {
        return this['_buffer'];
      }
      get ['dataView'] () {
        return this['_view'];
      }
      ['reset'] () {
        this['_offset'] = 0x0;
      }
      ['seek'] (cd) {
        this['_offset'] = cd;
      }
      ['skip'] (cd) {
        this['_offset'] += cd;
      }
      ['readUint8'] () {
        const cd = this['_view']['getUint8'](this['_offset']);
        return this['_offset'] += 0x1,
          cd;
      }
      ['readUint16'] () {
        const cd = this['_view']['getUint16'](this['_offset'], this['littleEndian']);
        return this['_offset'] += 0x2,
          cd;
      }
      ['readUint32'] () {
        const cd = this['_view']['getUint32'](this['_offset'], this['littleEndian']);
        return this['_offset'] += 0x4,
          cd;
      }
      ['readInt8'] () {
        const cd = this['_view']['getInt8'](this['_offset']);
        return this['_offset'] += 0x1,
          cd;
      }
      ['readInt16'] () {
        const cd = this['_view']['getInt16'](this['_offset'], this['littleEndian']);
        return this['_offset'] += 0x2,
          cd;
      }
      ['readInt32'] () {
        const cd = this['_view']['getInt32'](this['_offset'], this['littleEndian']);
        return this['_offset'] += 0x4,
          cd;
      }
      ['readFloat32'] () {
        const cd = this['_view']['getFloat32'](this['_offset'], this['littleEndian']);
        return this['_offset'] += 0x4,
          cd;
      }
      ['readFloat64'] () {
        const cd = this['_view']['getFloat64'](this['_offset'], this['littleEndian']);
        return this['_offset'] += 0x8,
          cd;
      }
      ['readBuffer'] (cd) {
        const cq = this['_buffer']['slice'](this['_offset'], this['_offset'] + cd);
        return this['_offset'] += cd,
          cq;
      }
      ['readString'] (cd) {
        return String['fromCharCode']['apply'](null, new Uint8Array(this['readBuffer'](cd)));
      }
    }
    var Km = n(0x24d)
      , KL = n(0x95)
      , KR = function (cd, cq, cJ, cC) {
        return new (cJ || (cJ = Promise))(function (cO, cG) {
          function cg (cM) {
            try {
              cP(cC['next'](cM));
            } catch (cz) {
              cG(cz);
            }
          }
          function cN (cM) {
            try {
              cP(cC['throw'](cM));
            } catch (cz) {
              cG(cz);
            }
          }
          function cP (cM) {
            var cz;
            cM['done'] ? cO(cM['value']) : (cz = cM['value'],
              cz instanceof cJ ? cz : new cJ(function (cQ) {
                cQ(cz);
              }
              ))['then'](cg, cN);
          }
          cP((cC = cC['apply'](cd, cq || []))['next']());
        }
        );
      };
    class GrayImageGridDataProvider extends Km['r'] {
      constructor(cd, cq) {
        super(cq),
          this['options'] = {},
          this['options'] = (0x0,
            Kz['Ov'])(this['options'], cq),
          this['gridOptions'] = this['options']['gridOptions'],
          this['load'](cd);
      }
      ['load'] (cd) {
        this['grids']['push']([new KN['K'](this['gridOptions']['xSize'], this['gridOptions']['ySize'], cd, this['options']['undef'], this['options']['autoLoadToMemory'], this['options']['algo'], this['options']['scale'], this['options']['offset'], this['options']['dataType'])]);
      }
      static ['loadVideo'] (cd) {
        return KR(this, undefined, undefined, function* () {
          return new Promise((cq, cJ) => {
            const cC = document['createElement']('video');
            cC['autoplay'] = true,
              cC['loop'] = false,
              cC['crossOrigin'] = 'anonymous',
              cC['muted'] = true,
              cC['setAttribute']('playsinline', ''),
              cC['setAttribute']('webkit-playsinline', ''),
              cC['oncanplay'] = cO => {
                cC['play']()['then'](cG => {
                  cq(cC);
                }
                  , cG => {
                    cJ(cG);
                  }
                )['catch'](v0['kg']['debug']);
              }
              ,
              cC['addEventListener']('error', cO => {
                v0['kg']['debug'](cC['error']),
                  cJ(cO);
              }
              ),
              cC['src'] = cd;
          }
          );
        });
      }
      static ['loadImage'] (cd) {
        return KR(this, undefined, undefined, function* () {
          return new Promise((cq, cJ) => {
            const cC = new Image();
            cC['crossOrigin'] = 'anonymous',
              cC['onload'] = cO => {
                cq(cC);
              }
              ,
              cC['onerror'] = cO => {
                cJ(cO);
              }
              ,
              cC['src'] = cd;
          }
          );
        });
      }
      static ['extractHeaderFromBuffer'] (cd) {
        const cq = new BinaryReader(cd)
          , cJ = cq['readFloat32']()
          , cC = cq['readFloat32']()
          , cO = cq['readFloat32']()
          , cG = cq['readFloat32']()
          , cg = cq['readFloat32']()
          , cN = cq['readFloat32']()
          , cP = cq['readFloat32']()
          , cM = cq['readFloat32']()
          , cz = {
            'gridOptions': {
              'xStart': cC,
              'yStart': cJ,
              'xSize': cN,
              'ySize': cg,
              'xDelta': cG,
              'yDelta': cO,
              'tCount': 0x1,
              'zValues': [0x0]
            },
            'dataType': 0x0 === cq['readUint8']() ? KP['U']['UInt8'] : KP['U']['UInt16'],
            'scale': cP,
            'offset': cM,
            'algo': 0x1 === cP && 0x0 === cM ? 0x0 : 0x1,
            'undef': cq['readFloat32']()
          };
        return (0x0,
          KM['T'])(cz['gridOptions']),
        {
          'options': cz,
          'data': cq['readBuffer'](cd['byteLength'] - cq['offset'] + 0x1)
        };
      }
      static ['decodeWebp'] (cd) {
        return KR(this, undefined, undefined, function* () {
          return new Promise((cq, cJ) => KR(this, undefined, undefined, function* () {
            try {
              const cC = performance['now']();
              window['wasm_webp']({
                'onRuntimeInitialized' () { }
              })['then'](cO => {
                const cG = new Uint8Array(cd)
                  , cg = cO['decode'](cG, cG['length'], true);
                cO['free'](),
                  cq(cg),
                  v0['kg']['debug']('decode\x20webp\x20cost\x20' + (performance['now']() - cC) + 'ms');
              }
              );
            } catch (cO) {
              v0['kg']['error'](cO),
                cq(undefined);
            }
          }));
        });
      }
      static ['fromBuffer'] (cd, cq, cJ) {
        return KR(this, undefined, undefined, function* () {
          if (cJ['withHeader']) {
            const cG = this['extractHeaderFromBuffer'](cd);
            cJ['gridOptions'] && (cG['options']['gridOptions'] = Object['assign'](Object['assign']({}, cG['options']['gridOptions']), cJ['gridOptions'])),
              cJ = (0x0,
                Kz['Ov'])({}, cJ, cG['options']),
              cd = cG['data'],
              delete cJ['withHeader'];
          }
          if (cJ['compatibleOldDevice'] && !(yield (0x0,
            KL['sU'])())) {
            if (v0['kg']['debug']('原生不支持webp的设备，动态转换格式'),
              'function' != typeof window['wasm_webp'])
              try {
                yield (0x0,
                  Kz['ve'])(Kg['v']['resourcePath'] + '/libs/webp/wasm_webp.min.js', 'dynamic_script_webp', 'wasm_webp');
              } catch (cg) {
                v0['kg']['error']('加载webp_wasm失败！'),
                  v0['kg']['error'](cg);
              }
            if ('function' == typeof window['wasm_webp']) {
              let cN = yield GrayImageGridDataProvider['decodeWebp'](cd);
              if (cN) {
                const cP = Object['assign']({}, cJ['gridOptions']);
                if (cP['xSize'] > 0x400 || cP['ySize'] > 0x400) {
                  let cQ, cm;
                  cP['xSize'] > cP['ySize'] ? (cQ = 0x3f6,
                    cm = parseInt(cQ * (0x1 * cP['ySize'] / cP['xSize']))) : (cm = 0x3f6,
                      cQ = parseInt(cm * (0x1 * cP['xSize'] / cP['ySize'])));
                  const cL = Math['max'](parseInt(cP['xSize'] / cQ), 0x1)
                    , cR = Math['max'](parseInt(cP['ySize'] / cm), 0x1);
                  cP['xDelta'] = cP['xDelta'] * cL,
                    cP['yDelta'] = cP['yDelta'] * cR;
                  const H0 = [];
                  cQ = cm = 0x0;
                  for (let H1 = 0x0; H1 < cP['ySize']; H1 += cR) {
                    const H2 = H1 * cP['xSize'];
                    cm++,
                      cQ = 0x0;
                    for (let H3 = 0x0; H3 < cP['xSize']; H3 += cL) {
                      const H4 = 0x4 * (H2 + H3);
                      H0['push'](cN[H4], cN[H4 + 0x1], cN[H4 + 0x2], cN[H4 + 0x3]),
                        cQ++;
                    }
                  }
                  cP['xSize'] = cQ,
                    cP['ySize'] = cm,
                    cP['xEnd'] = cP['yEnd'] = undefined,
                    (0x0,
                      KM['T'])(cP),
                    cJ['gridOptions'] = cP,
                    cN = new Uint8Array(H0);
                }
                const cM = document['createElement']('canvas');
                cM['width'] = cJ['gridOptions']['xSize'],
                  cM['height'] = cJ['gridOptions']['ySize'];
                const cz = new ImageData(new Uint8ClampedArray(cN), cM['width'], cM['height']);
                return cM['getContext']('2d')['putImageData'](cz, 0x0, 0x0),
                  new GrayImageGridDataProvider(cM, cJ);
              }
            }
          } else
            (0x0,
              KL['sU'])() || v0['kg']['warn']('当前系统版本低于IOS14，且设置了不兼容旧版，可能造成数据无法渲染，您可以反馈给您的程序提供商！');
          const cC = new Blob([cd])
            , cO = URL['createObjectURL'](cC);
          return GrayImageGridDataProvider['fromURL'](cO, cq, cJ);
        });
      }
      static ['fromURL'] (cd, cq, cJ) {
        return KR(this, undefined, undefined, function* () {
          if (cJ['withHeader']) {
            const cO = yield (yield qeFetch(cd))['arrayBuffer']();
            return GrayImageGridDataProvider['fromBuffer'](cO, cq, cJ);
          }
          let cC = this['loadImage'];
          return cq && (cC = this['loadVideo']),
            cC(cd)['then'](cG => new GrayImageGridDataProvider(cG, cJ))['catch'](cG => { }
            );
        });
      }
    }
    function i1 (cd) {
      return (cd = cd['replace'](/\/\/.*/g, ''))['replace'](/\/\*\*[\s\S]*?\*\//gm, function (cq) {
        for (var cJ = cq['match'](/\n/gm)['length'], cC = '', cO = 0x0; cO < cJ; ++cO)
          cC += '\x0a';
        return cC;
      });
    }
    function i2 (cd, cq, cJ) {
      for (var cC, cO = 0x0; cO < cJ['length']; ++cO)
        cJ[cO]['name'] === cd && (cC = cJ[cO]);
      return (0x0,
        Kz['ri'])(cC) || (cC = {
          'name': cd,
          'glslSource': cq = i1(cq),
          'dependsOn': [],
          'requiredBy': [],
          'evaluated': false
        },
          cJ['push'](cC)),
        cC;
    }
    function i3 (cd, cq, cJ) {
      if (!cd['evaluated']) {
        cd['evaluated'] = true;
        var cC = cd['glslSource']['match'](/\bqe_[a-zA-Z0-9_]*/g);
        (0x0,
          Kz['ri'])(cC) && null !== cC && (cC = cC['filter'](function (cO, cG) {
            return cC['indexOf'](cO) === cG;
          }))['forEach'](function (cO) {
            if (cO !== cd['name'] && cJ['hasOwnProperty'](cO)) {
              var cG = i2(cO, cJ[cO], cq);
              cd['dependsOn']['push'](cG),
                cG['requiredBy']['push'](cd),
                i3(cG, cq, cJ);
            }
          });
      }
    }
    function i4 (cd, cq = 'main') {
      i1(cd);
      var cJ = []
        , cC = i2(cq, cd, cJ);
      i3(cC, cJ, ip),
        function (cg) {
          for (var cN = [], cP = []; cg['length'] > 0x0;) {
            var cM = cg['pop']();
            cP['push'](cM),
              0x0 === cM['requiredBy']['length'] && cN['push'](cM);
          }
          for (; cN['length'] > 0x0;) {
            var cz = cN['shift']();
            cg['push'](cz);
            for (var cQ = 0x0; cQ < cz['dependsOn']['length']; ++cQ) {
              var cm = cz['dependsOn'][cQ]
                , cL = cm['requiredBy']['indexOf'](cz);
              cm['requiredBy']['splice'](cL, 0x1),
                0x0 === cm['requiredBy']['length'] && cN['push'](cm);
            }
          }
          for (var cR = [], H0 = 0x0; H0 < cP['length']; ++H0)
            0x0 !== cP[H0]['requiredBy']['length'] && cR['push'](cP[H0]);
          if (0x0 !== cR['length']) {
            for (var H1 = 'A\x20circular\x20dependency\x20was\x20found\x20in\x20the\x20following\x20built-in\x20functions/structs/constants:\x20\x0a', H2 = 0x0; H2 < cR['length']; ++H2)
              H1 = H1 + cR[H2]['name'] + '\x0a';
            throw new Error(H1);
          }
        }(cJ);
      for (var cO = '', cG = cJ['length'] - 0x1; cG >= 0x0; --cG)
        cO = cO + cJ[cG]['glslSource'] + '\x0a';
      return cO['replace'](cC['glslSource'], '');
    }
    function i5 (cd, cq = '$inject') {
      let cJ = cd;
      if (cd['indexOf']('qe_') >= 0x0) {
        const cC = i4(cd, 'main');
        cJ = cd['indexOf'](cq) >= 0x0 ? cd['replace'](cq, cC) : cd['replace'](/void\s+main\s*\(\s*\)\s*{/gm, function (cO, cG) {
          return cC + '\x0a' + cO;
        });
      } else
        cJ = cd['replace'](cq, '');
      return cJ;
    }
    function i6 (cd, cq = false) {
      let cJ = '';
      switch (cd['dataType'] === KP['U']['UInt8'] ? cJ += 'const\x20float\x20baseScaleH=255.;' : cJ += 'const\x20float\x20baseScaleH=1.;',
      cJ += cq ? '\x0a\x20\x20\x20\x20\x20\x20\x20\x20const\x20float\x20undefH=' + ik(undefined === cd['undef'] ? Kg['v']['defaultUndef'] : cd['undef']) + ';\x0a\x20\x20\x20\x20\x20\x20\x20\x20' : 'uniform\x20float\x20undefH;',
      cd['algo']) {
        case undefined:
        case null:
        case 0x0:
        case 0x1:
        case 0x2:
          cJ += '\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20dataOffsetH;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20dataScaleH;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20mediump\x20int\x20dataAlgoH;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20';
          break;
        default:
          v0['kg']['error']('不能识别的算法类型！', true);
      }
      return cd instanceof KN['K'] && (cd['dataType'] === KP['U']['UInt8'] ? cJ += '\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#define\x20IMAGE_SOURCE_H\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20' : cd['dataType'] === KP['U']['Float32'] ? cJ += '\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#define\x20IMAGE_SOURCE_FLOAT_H\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20' : cJ += '\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#define\x20IMAGE_SOURCE_USHORT_H\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20'),
        cJ;
    }
    function i7 (cd, cq = false, cJ = true) {
      let cC = '';
      switch (cd['dataType'] === KP['U']['UInt8'] ? cC += 'const\x20float\x20baseScale=255.;' : cC += 'const\x20float\x20baseScale=1.;',
      cq && (cC += '\x0a\x20\x20\x20\x20\x20\x20\x20\x20const\x20float\x20undef=' + ik(undefined === cd['undef'] ? Kg['v']['defaultUndef'] : cd['undef']) + ';\x0a\x20\x20\x20\x20\x20\x20\x20\x20'),
      cd['algo']) {
        case undefined:
        case null:
        case 0x0:
        case 0x1:
        case 0x2:
          cC += '\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20dataOffset;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20dataScale;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20dataAlgo;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20';
          break;
        default:
          v0['kg']['error']('不能识别的算法类型！', true);
      }
      return cd instanceof KN['K'] && cJ && (cd['dataType'] === KP['U']['UInt8'] ? cC += '\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#define\x20IMAGE_SOURCE\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20' : cd['dataType'] === KP['U']['Float32'] ? cC += '\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#define\x20IMAGE_SOURCE_FLOAT\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20' : cC += '\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#define\x20IMAGE_SOURCE_USHORT\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20'),
        cC;
    }
    function i8 (cd, cq = {}) {
      const cJ = (0x0,
        Kz['En'])(cd['undef'], 0xf423f);
      cq['undef'] = cJ;
      let cC = cd['algo'];
      switch ((null == cC || isNaN(cC)) && (cC = 0x0),
      cC = parseInt(cC['toString']()),
      cC) {
        case 0x0:
        case 0x1:
        case 0x2:
          cq['dataOffset'] = cd['dataOffset'],
            cq['dataScale'] = cd['dataScale'],
            cq['dataAlgo'] = cC;
      }
      return cq;
    }
    function i9 (cd, cq = {}) {
      const cJ = (0x0,
        Kz['En'])(cd['undef'], 0xf423f);
      cq['undefH'] = () => cJ;
      let cC = cd['algo'];
      switch ((null == cC || isNaN(cC)) && (cC = 0x0),
      cC = parseInt(cC['toString']()),
      cC) {
        case 0x0:
        case 0x1:
        case 0x2:
          cq['dataOffsetH'] = () => cd['dataOffset'],
            cq['dataScaleH'] = () => cd['dataScale'],
            cq['dataAlgoH'] = () => cC;
      }
      return cq;
    }
    function iv (cd, cq = {}) {
      const cJ = (0x0,
        Kz['En'])(cd['undef'], 0xf423f);
      cq['undef'] = () => cJ;
      let cC = cd['algo'];
      switch ((null == cC || isNaN(cC)) && (cC = 0x0),
      cC = parseInt(cC['toString']()),
      cC) {
        case 0x0:
        case 0x1:
        case 0x2:
          cq['dataOffset'] = () => cd['dataOffset'],
            cq['dataScale'] = () => cd['dataScale'],
            cq['dataAlgo'] = () => cC;
      }
      return cq;
    }
    function iA () {
      return '\x0a\x20\x20\x20\x20uniform\x20float\x20currentHeight;\x0a\x20\x20\x20\x20uniform\x20float\x20preHeight;\x0a\x20\x20\x20\x20uniform\x20sampler2D\x20heightTexture;\x0a\x20\x20\x20\x20uniform\x20float\x20zScale;\x0a\x20\x20\x20\x20uniform\x20float\x20extrudeScale;\x0a\x20\x20\x20\x20uniform\x20float\x20extrudeOffset;\x0a\x20\x20\x20\x20uniform\x20bool\x20noHeight;\x0a\x20\x20\x20\x20';
    }
    function ik (cd) {
      return (cd = cd['toString'] && cd['toString']())['indexOf']('.') < 0x0 ? cd + '.' : cd;
    }
    function iK () {
      return '\x0a\x20\x20\x20\x20const\x20vec4\x20bitEnc\x20=\x20vec4(1.,255.,65025.,16581375.);\x0a\x20\x20\x20\x20const\x20vec4\x20bitDec\x20=\x201./bitEnc;\x0a\x20\x20\x20\x20';
    }
    function createGLTypedArray (cd, cq) {
      return cd === KP['U']['UInt8'] ? new Uint8Array(Uint8Array['BYTES_PER_ELEMENT'] * cq) : new Float32Array(Float32Array['BYTES_PER_ELEMENT'] * cq);
    }
    GrayImageGridDataProvider['qeName'] = 'g_gray';
    let ic = {
      'attrIn': 'in',
      'varIn': 'in',
      'varOut': 'out',
      'outColorDefine': 'out\x20vec4\x20qe_FragColor;',
      'outColorName': 'qe_FragColor',
      'textureFunc': 'texture',
      'header': '#version\x20300\x20es'
    };
    function iH () {
      Kg['v']['useWebGL2'] || (ic = {
        'attrIn': 'attribute',
        'varIn': 'varying',
        'varOut': 'varying',
        'outColorDefine': '',
        'outColorName': 'gl_FragColor',
        'textureFunc': 'texture2D',
        'header': ''
      });
    }
    function ix (cd, cq = 0x3, cJ = 0x1000) {
      if (cd['gridOptions']['xSize'] > cJ || cd['gridOptions']['ySize'] > cJ) {
        cd['gridOptions'] = Object['assign']({}, cd['gridOptions']);
        const cC = document['createElement']('canvas')
          , cO = cd['getGrid']()['imageSource'];
        cC['width'] = cO['width'] / cq,
          cC['height'] = cO['height'] / cq;
        const cG = {
          'xStart': cd['gridOptions']['xStart'],
          'xEnd': cd['gridOptions']['xEnd'],
          'xSize': parseInt(cd['gridOptions']['xSize'] / cq),
          'yStart': cd['gridOptions']['yStart'],
          'yEnd': cd['gridOptions']['yEnd'],
          'ySize': parseInt(cd['gridOptions']['ySize'] / cq)
        };
        return (0x0,
          KM['T'])(cG),
          cC['getContext']('2d')['drawImage'](cO, 0x0, 0x0, cO['width'], cO['height'], 0x0, 0x0, cC['width'], cC['height']),
          new GrayImageGridDataProvider(cC, Object['assign'](Object['assign']({}, cd['options']), {
            'gridOptions': cG
          }));
      }
      return cd;
    }
    const ip = {};
    function iF (cd) {
      for (const cq in cd)
        ip[cq] && v0['kg']['warn']('shaderLib中已经存在该key：' + cq + '\x0a\x20' + cd[cq]),
          ip[cq] = cd[cq];
    }
    const iy = {
      'qe_getGridOneDimPos': 'qe_getGridOneDimPos',
      'qe_getLonLatTexPos': 'qe_getLonLatTexPos',
      'qe_isUndef': 'qe_isUndef',
      'qe_readGrid2DRawVal': 'qe_readGrid2DRawVal',
      'qe_readHeight2DRawVal': 'qe_readHeight2DRawVal',
      'qe_readGrid3DRawVal': 'qe_readGrid3DRawVal',
      'qe_readGridValByUV': 'qe_readGridValByUV',
      'qe_readHeightValByUV': 'qe_readHeightValByUV',
      'qe_readGridVal3DByUV': 'qe_readGridVal3DByUV',
      'qe_interpGridValByUV': 'qe_interpGridValByUV',
      'qe_interpGridVal3DByUV': 'qe_interpGridVal3DByUV',
      'qe_geo2cartesian': 'qe_geo2cartesian',
      'qe_deg2cartesian': 'qe_deg2cartesian',
      'qe_deg2cartesianV2': 'qe_deg2cartesianV2',
      'qe_cartesian2deg': 'qe_cartesian2deg',
      'qe_getColor': 'qe_getColor',
      'qe_interpColor': 'qe_interpColor',
      'qe_getColorByScale': 'qe_getColorByScale',
      'qe_getHeightByPreAndCurrent': 'qe_getHeightByPreAndCurrent',
      'qe_texture2DFloat': 'qe_texture2DFloat',
      'qe_idx2LonLat': 'qe_idx2LonLat',
      'qe_idx2LonLatTexPos': 'qe_idx2LonLatTexPos',
      'qe_rgba2float': 'qe_rgba2float',
      'qe_float2rgba': 'qe_float2rgba',
      'qe_maskout': 'qe_maskout',
      'qe_encodeFloat': 'qe_encodeFloat',
      'qe_geoDistance': 'qe_geoDistance',
      'qe_decodeFloat': 'qe_decodeFloat'
    };
    let iw = false;
    function ih () {
      iw || (ip[iy['qe_texture2DFloat']] = '\x0a\x20\x20\x20\x20float\x20qe_texture2DFloat(sampler2D\x20tex,vec2\x20uv){\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20' + (Kg['v']['useWebGL2'] ? 'texture2D(tex,uv).r' : 'texture2D(tex,uv).w') + ';\x0a\x20\x20\x20\x20}\x0a',
        ip[iy['qe_rgba2float']] = '\x0a\x20\x20\x20\x20float\x20qe_rgba2float\x20(vec4\x20v)\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20dot(v,\x20bitDec);\x0a\x20\x20\x20\x20}\x0a',
        ip[iy['qe_float2rgba']] = '\x0a\x20\x20\x20\x20vec4\x20qe_float2rgba(float\x20v){\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20enc\x20=\x20bitEnc\x20*\x20v;\x0a\x20\x20\x20\x20\x20\x20\x20\x20enc\x20=\x20fract(enc);\x0a\x20\x20\x20\x20\x20\x20\x20\x20enc\x20-=\x20enc.yzww\x20*\x20vec2(1./255.,\x200.).xxxy;\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20enc;\x0a\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x0a',
        ip[iy['qe_decodeFloat']] = '\x0a\x20\x20\x20\x20\x0a\x20\x20\x20\x20ivec4\x20decodeFloat_floatsToBytes(vec4\x20inputFloats,\x20bool\x20littleEndian)\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20ivec4\x20bytes\x20=\x20ivec4(inputFloats\x20*\x20255.0);\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20(\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20littleEndian\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20?\x20bytes.abgr\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20:\x20bytes\x0a\x20\x20\x20\x20\x20\x20\x20\x20);\x0a\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20//\x20Break\x20the\x20four\x20bytes\x20down\x20into\x20an\x20array\x20of\x2032\x20bits.\x0a\x20\x20\x20\x20\x20\x20void\x20decodeFloat_bytesToBits(const\x20in\x20ivec4\x20bytes,\x20out\x20bool\x20bits[32])\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20for\x20(int\x20channelIndex\x20=\x200;\x20channelIndex\x20<\x204;\x20++channelIndex)\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20acc\x20=\x20float(bytes[channelIndex]);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20for\x20(int\x20indexInByte\x20=\x207;\x20indexInByte\x20>=\x200;\x20--indexInByte)\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20powerOfTwo\x20=\x20exp2(float(indexInByte));\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20bool\x20bit\x20=\x20acc\x20>=\x20powerOfTwo;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20bits[channelIndex\x20*\x208\x20+\x20(7\x20-\x20indexInByte)]\x20=\x20bit;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20acc\x20=\x20mod(acc,\x20powerOfTwo);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20//\x20Compute\x20the\x20exponent\x20of\x20the\x2032-bit\x20float.\x0a\x20\x20\x20\x20\x20\x20float\x20getExponent(bool\x20bits[32])\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20const\x20int\x20startIndex\x20=\x201;\x0a\x20\x20\x20\x20\x20\x20\x20\x20const\x20int\x20bitStringLength\x20=\x208;\x0a\x20\x20\x20\x20\x20\x20\x20\x20const\x20int\x20endBeforeIndex\x20=\x20startIndex\x20+\x20bitStringLength;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20acc\x20=\x200.0;\x0a\x20\x20\x20\x20\x20\x20\x20\x20int\x20pow2\x20=\x20bitStringLength\x20-\x201;\x0a\x20\x20\x20\x20\x20\x20\x20\x20for\x20(int\x20bitIndex\x20=\x20startIndex;\x20bitIndex\x20<\x20endBeforeIndex;\x20++bitIndex)\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20acc\x20+=\x20float(bits[bitIndex])\x20*\x20exp2(float(pow2--));\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20acc;\x0a\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20//\x20Compute\x20the\x20mantissa\x20of\x20the\x2032-bit\x20float.\x0a\x20\x20\x20\x20\x20\x20float\x20decodeFloat_getMantissa(bool\x20bits[32],\x20bool\x20subnormal)\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20const\x20int\x20startIndex\x20=\x209;\x0a\x20\x20\x20\x20\x20\x20\x20\x20const\x20int\x20bitStringLength\x20=\x2023;\x0a\x20\x20\x20\x20\x20\x20\x20\x20const\x20int\x20endBeforeIndex\x20=\x20startIndex\x20+\x20bitStringLength;\x0a\x20\x20\x20\x20\x20\x20\x20\x20//\x20Leading/implicit/hidden\x20bit\x20convention:\x0a\x20\x20\x20\x20\x20\x20\x20\x20//\x20If\x20the\x20number\x20is\x20not\x20subnormal\x20(with\x20exponent\x200),\x20we\x20add\x20a\x20leading\x201\x20digit.\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20acc\x20=\x20float(!subnormal)\x20*\x20exp2(float(bitStringLength));\x0a\x20\x20\x20\x20\x20\x20\x20\x20int\x20pow2\x20=\x20bitStringLength\x20-\x201;\x0a\x20\x20\x20\x20\x20\x20\x20\x20for\x20(int\x20bitIndex\x20=\x20startIndex;\x20bitIndex\x20<\x20endBeforeIndex;\x20++bitIndex)\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20acc\x20+=\x20float(bits[bitIndex])\x20*\x20exp2(float(pow2--));\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20acc;\x0a\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20//\x20Parse\x20the\x20float\x20from\x20its\x2032\x20bits.\x0a\x20\x20\x20\x20\x20\x20float\x20decodeFloat_bitsToFloat(bool\x20bits[32])\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20signBit\x20=\x20float(bits[0])\x20*\x20-2.0\x20+\x201.0;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20exponent\x20=\x20getExponent(bits);\x0a\x20\x20\x20\x20\x20\x20\x20\x20bool\x20subnormal\x20=\x20abs(exponent\x20-\x200.0)\x20<\x200.01;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20mantissa\x20=\x20decodeFloat_getMantissa(bits,\x20subnormal);\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20exponentBias\x20=\x20127.0;\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20signBit\x20*\x20mantissa\x20*\x20exp2(exponent\x20-\x20exponentBias\x20-\x2023.0);\x0a\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20//\x20Decode\x20a\x2032-bit\x20float\x20from\x20the\x20RGBA\x20color\x20channels\x20of\x20a\x20texel.\x0a\x20\x20\x20\x20\x20\x20float\x20qe_decodeFloat(vec4\x20texelRGBA,\x20bool\x20littleEndian)\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20ivec4\x20rgbaBytes\x20=\x20decodeFloat_floatsToBytes(texelRGBA,\x20littleEndian);\x0a\x20\x20\x20\x20\x20\x20\x20\x20bool\x20bits[32];\x0a\x20\x20\x20\x20\x20\x20\x20\x20decodeFloat_bytesToBits(rgbaBytes,\x20bits);\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20decodeFloat_bitsToFloat(bits);\x0a\x20\x20\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20',
        function () {
          const cd = ik(0x615299)
            , cq = 57.29577951308232;
          ip[iy['qe_geoDistance']] = '\x0a\x20\x20\x20\x20float\x20qe_geoDistance(vec2\x20pt1,vec2\x20pt2){\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20' + ik(cd) + '*acos(cos(pt1.y)*cos(pt2.y)*cos(pt1.x-pt2.x)+sin(pt1.y)*sin(pt2.y));\x0a\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20',
            ip[iy['qe_geo2cartesian']] = '\x0a\x20\x20\x20\x20vec3\x20' + iy['qe_geo2cartesian'] + '(vec3\x20geo){\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20cosLat=cos(geo.y);\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20snX=cosLat*cos(geo.x);\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20snY=cosLat*sin(geo.x);\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20snZ=sin(geo.y);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20sn=normalize(vec3(snX,snY,snZ));\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20radiiSquared=vec3(40680631.59076899*1000000.,40680631.59076899*1000000.,40408299.98466144*1000000.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20sk=radiiSquared*sn;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20gamma=sqrt(dot(sn,sk));\x0a\x20\x20\x20\x20\x20\x20\x20\x20sk=sk/gamma;\x0a\x20\x20\x20\x20\x20\x20\x20\x20sn=sn*geo.z;\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20sk+sn;\x0a\x20\x20\x20\x20}\x0a',
            ip[iy['qe_deg2cartesian']] = '\x0a\x20\x20\x20\x20vec3\x20' + iy['qe_deg2cartesian'] + '(vec3\x20deg){\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20radGeo=radians(deg.xy);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20geo=vec3(radGeo.xy,deg.z);\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20' + iy['qe_geo2cartesian'] + '(geo);\x0a\x20\x20\x20\x20}\x0a',
            ip[iy['qe_deg2cartesianV2']] = '\x0a\x20\x20\x20\x20vec3\x20' + iy['qe_deg2cartesianV2'] + '(vec3\x20pos){\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20g\x20=\x20' + cd + '\x20+pos.z;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20e\x20=\x20radians(pos.y);\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20b\x20=radians(pos.x);\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20a\x20=\x20cos(e);\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20x\x20=\x20cos(b)*a*g;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20y\x20=\x20sin(b)*a*g;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20z\x20=\x20sin(e)*g;\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec3(x,y,z);\x0a\x20\x20\x20\x20}\x0a',
            ip[iy['qe_cartesian2deg']] = '\x0a\x20\x20\x20\x20vec3\x20' + iy['qe_cartesian2deg'] + '(vec3\x20pos,bool\x20global)\x0a\x20\x20\x20\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(global){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20z\x20=\x20length(pos);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20h\x20=\x20z\x20-\x20' + cd + ';\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20latRad\x20=\x20asin(pos.z/z);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20lat\x20=\x20latRad\x20*\x20' + cq + ';\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20lon\x20=\x200.;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(pos.y>0.){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20lon\x20=\x20acos(pos.x/(cos(latRad)*z))\x20*\x20' + cq + ';\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20lon\x20=\x20-acos(pos.x/(cos(latRad)*z))\x20*\x20' + cq + ';\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec3(lon,lat,h);\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20}else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20lon=degrees(pos.x/' + cd + ');\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20lat=degrees(3.141592653589793/2.-2.*atan(exp(-1.*pos.y/' + cd + ')));\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec3(lon,lat,pos.z);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20}\x0a';
        }(),
        function () {
          ip[iy['qe_getGridOneDimPos']] = '\x0a\x20\x20\x20\x20float\x20' + iy['qe_getGridOneDimPos'] + '(float\x20pos,vec4\x20attr){\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20(pos-attr.x)/(attr.y-attr.x+attr.z);\x0a\x20\x20\x20\x20}\x0a',
            ip[iy['qe_getLonLatTexPos']] = '\x0a\x20\x20\x20\x20vec2\x20' + iy['qe_getLonLatTexPos'] + '(vec2\x20pos,vec4\x20xAttr,vec4\x20yAttr){\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20xPos=' + iy['qe_getGridOneDimPos'] + '(pos.x,xAttr);\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20yPos=' + iy['qe_getGridOneDimPos'] + '(pos.y,yAttr);\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(xPos,yPos);\x0a\x20\x20\x20\x20}\x0a',
            ip[iy['qe_isUndef']] = '\x0a\x20\x20\x20\x20bool\x20' + iy['qe_isUndef'] + '(float\x20val,float\x20undef){\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(undef<=0.){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20val<=undef;\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20val>=undef;\x0a\x20\x20\x20\x20}\x0a';
          let cd = '\x0a\x20\x20\x20\x20#ifdef\x20IMAGE_SOURCE\x0a\x20\x20\x20\x20\x20\x20\x20\x20val=texture2D(grid,uv).r*baseScale;\x0a\x20\x20\x20\x20#elif\x20defined(IMAGE_SOURCE_FLOAT)\x0a\x20\x20\x20\x20\x20\x20\x20\x20val=' + iy['qe_decodeFloat'] + '(texture2D(grid,uv),true);\x0a\x20\x20\x20\x20#elif\x20defined(IMAGE_SOURCE_USHORT)\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20r_c=texture2D(grid,uv);\x0a\x20\x20\x20\x20\x20\x20\x20\x20val=r_c.r*255.*255.+r_c.g*255.;\x0a\x20\x20\x20\x20#else\x0a\x20\x20\x20\x20\x20\x20\x20\x20val=texture2D(grid,uv).w*baseScale;\x0a\x20\x20\x20\x20#endif\x0a\x20\x20\x20\x20';
          Kg['v']['useWebGL2'] && (cd = '\x0a\x20\x20\x20\x20if(baseScale!=1.){\x0a\x20\x20\x20\x20\x20\x20\x20\x20//uint8\x0a\x20\x20\x20\x20\x20\x20\x20\x20#ifdef\x20IMAGE_SOURCE\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val=texture(grid,uv).r*baseScale;\x0a\x20\x20\x20\x20\x20\x20\x20\x20#else\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val=texture(grid,uv).w*baseScale;\x0a\x20\x20\x20\x20\x20\x20\x20\x20#endif\x0a\x20\x20\x20\x20}else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20#ifdef\x20IMAGE_SOURCE_FLOAT\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val=' + iy['qe_decodeFloat'] + '(texture(grid,uv),true);\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20#elif\x20defined(IMAGE_SOURCE_USHORT)\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20r_c=texture(grid,uv);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val=r_c.r*255.*255.+r_c.g*255.;\x0a\x20\x20\x20\x20\x20\x20\x20\x20#else\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val=texture(grid,uv).r;\x0a\x20\x20\x20\x20\x20\x20\x20\x20#endif\x0a\x20\x20\x20\x20}\x0a\x20\x20\x20\x20');
          let cq = '\x0a\x20\x20\x20\x20#ifdef\x20IMAGE_SOURCE_H\x0a\x20\x20\x20\x20\x20\x20\x20\x20val=texture2D(grid,uv).r*baseScaleH;\x0a\x20\x20\x20\x20#elif\x20defined(IMAGE_SOURCE_FLOAT_H)\x0a\x20\x20\x20\x20\x20\x20\x20\x20val=' + iy['qe_decodeFloat'] + '(texture2D(grid,uv),true);\x0a\x20\x20\x20\x20#elif\x20defined(IMAGE_SOURCE_USHORT_H)\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20r_c=texture2D(grid,uv);\x0a\x20\x20\x20\x20\x20\x20\x20\x20val=r_c.r*255.*255.+r_c.g*255.;\x0a\x20\x20\x20\x20#else\x0a\x20\x20\x20\x20\x20\x20\x20\x20val=texture2D(grid,uv).w*baseScaleH;\x0a\x20\x20\x20\x20#endif\x0a\x20\x20\x20\x20';
          Kg['v']['useWebGL2'] && (cq = '\x0a\x20\x20\x20\x20if(baseScaleH!=1.){\x0a\x20\x20\x20\x20\x20\x20\x20\x20//uint8\x0a\x20\x20\x20\x20\x20\x20\x20\x20#ifdef\x20IMAGE_SOURCE_H\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val=texture(grid,uv).r*baseScaleH;\x0a\x20\x20\x20\x20\x20\x20\x20\x20#else\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val=texture(grid,uv).w*baseScaleH;\x0a\x20\x20\x20\x20\x20\x20\x20\x20#endif\x0a\x20\x20\x20\x20}else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20#ifdef\x20IMAGE_SOURCE_FLOAT_H\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val=' + iy['qe_decodeFloat'] + '(texture(grid,uv),true);\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20#elif\x20defined(IMAGE_SOURCE_USHORT_H)\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20r_c=texture(grid,uv);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val=r_c.r*255.*255.+r_c.g*255.;\x0a\x20\x20\x20\x20\x20\x20\x20\x20#else\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val=texture(grid,uv).r;\x0a\x20\x20\x20\x20\x20\x20\x20\x20#endif\x0a\x20\x20\x20\x20}\x0a\x20\x20\x20\x20');
          let cJ = '\x0a\x20\x20\x20\x20#ifdef\x20IMAGE_SOURCE\x0a\x20\x20\x20\x20\x20\x20\x20\x20val=texture2D(grid,p).r*baseScale;\x0a\x20\x20\x20\x20#elif\x20defined(IMAGE_SOURCE_FLOAT)\x0a\x20\x20\x20\x20\x20\x20\x20\x20val=' + iy['qe_decodeFloat'] + '(texture2D(grid,p),true);\x0a\x20\x20\x20\x20#elif\x20defined(IMAGE_SOURCE_USHORT)\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20r_c=texture2D(grid,p);\x0a\x20\x20\x20\x20\x20\x20\x20\x20val=r_c.r*255.*255.+r_c.g*255.;\x0a\x20\x20\x20\x20#else\x0a\x20\x20\x20\x20\x20\x20\x20\x20val=texture2D(grid,p).w*baseScale;\x0a\x20\x20\x20\x20#endif\x0a\x20\x20\x20\x20\x0a\x20\x20\x20\x20';
          Kg['v']['useWebGL2'] && (cJ = '\x0a\x20\x20\x20\x20if(baseScale!=1.){\x0a\x20\x20\x20\x20\x20\x20\x20\x20//uint8\x0a\x20\x20\x20\x20\x20\x20\x20\x20#ifdef\x20IMAGE_SOURCE\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val=texture(grid,p).r*baseScale;\x0a\x20\x20\x20\x20\x20\x20\x20\x20#else\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val=texture(grid,p).w*baseScale;\x0a\x20\x20\x20\x20\x20\x20\x20\x20#endif\x0a\x20\x20\x20\x20}else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20#ifdef\x20IMAGE_SOURCE_FLOAT\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val=' + iy['qe_decodeFloat'] + '(texture(grid,p),true);\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20#elif\x20defined(IMAGE_SOURCE_USHORT)\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20r_c=texture(grid,p);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val=r_c.r*255.*255.+r_c.g*255.;\x0a\x20\x20\x20\x20\x20\x20\x20\x20#else\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val=texture(grid,p).r;\x0a\x20\x20\x20\x20\x20\x20\x20\x20#endif\x0a\x20\x20\x20\x20}\x0a\x20\x20\x20\x20'),
            ip[iy['qe_readHeight2DRawVal']] = '\x0a\x20\x20\x20\x20float\x20' + iy['qe_readHeight2DRawVal'] + '(sampler2D\x20grid,vec2\x20uv,float\x20undefH){\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20val;\x0a\x20\x20\x20\x20\x20\x20\x20\x20' + cq + '\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(val,undefH)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20undefH;\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(dataAlgoH==2){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val\x20=\x20(val+dataOffsetH)*dataScaleH;\x0a\x20\x20\x20\x20\x20\x20\x20\x20}else{\x20//current\x200\x201\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val\x20=\x20val*dataScaleH+dataOffsetH;\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20val;\x0a\x20\x20\x20\x20}\x0a',
            ip[iy['qe_readHeightValByUV']] = '\x0a\x0avec2\x20' + iy['qe_readHeightValByUV'] + '(sampler2D\x20grid,vec2\x20uv,vec4\x20xAttr,vec4\x20yAttr,float\x20undefH,int\x20interpMethod){\x0a\x20\x20\x20\x20float\x20rawVal=\x20' + iy['qe_readHeight2DRawVal'] + '(grid,uv,undefH);\x0a\x20\x20\x20\x20if(interpMethod==0\x20||\x20' + iy['qe_isUndef'] + '(rawVal,undefH)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal);\x0a\x20\x20\x20\x20}\x0a\x20\x20\x20\x20vec2\x20dataSize=vec2(xAttr.w,yAttr.w);\x0a\x20\x20\x20\x20vec2\x20pos=uv*dataSize;\x0a\x20\x20\x20\x20vec2\x20prePos\x20=\x20floor(pos);\x20//i,j\x20p22\x0a\x20\x20\x20\x20vec2\x20nextPos\x20=\x20ceil(pos);\x20//i+1,j+1\x20p33\x0a\x20\x20\x20\x20vec2\x20preUv\x20=\x20prePos\x20/dataSize;\x0a\x20\x20\x20\x20vec2\x20nextUv\x20=\x20nextPos\x20/dataSize;\x0a\x20\x20\x20\x20//weight\x0a\x20\x20\x20\x20vec2\x20weight\x20=\x20fract(pos);\x0a\x20\x20\x20\x20vec2\x20lbUv\x20=\x20preUv;\x0a\x20\x20\x20\x20vec2\x20ltUv\x20=\x20vec2(preUv.x,nextUv.y);\x0a\x20\x20\x20\x20vec2\x20rbUv\x20=\x20vec2(nextUv.x,preUv.y);\x0a\x20\x20\x20\x20vec2\x20rtUv\x20=\x20nextUv;\x0a\x20\x20\x20\x20float\x20lbVal\x20=\x20' + iy['qe_readHeight2DRawVal'] + '(grid,lbUv,undefH);\x20//p(i,j)\x20p22\x0a\x20\x20\x20\x20float\x20ltVal\x20=\x20' + iy['qe_readHeight2DRawVal'] + '(grid,ltUv,undefH);\x20//p(i,j+1)\x20p23\x0a\x20\x20\x20\x20float\x20rbVal\x20=\x20' + iy['qe_readHeight2DRawVal'] + '(grid,rbUv,undefH);\x20//p(i+1,j)\x20p32\x0a\x20\x20\x20\x20float\x20rtVal\x20=\x20' + iy['qe_readHeight2DRawVal'] + '(grid,rtUv,undefH);\x20//p(i+1,j+1)\x20p33\x0a\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(lbVal,undefH)\x20||\x20' + iy['qe_isUndef'] + '(ltVal,undefH)\x20||\x20' + iy['qe_isUndef'] + '(rbVal,undefH)\x20||\x20' + iy['qe_isUndef'] + '(rtVal,undefH)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal);\x0a\x20\x20\x20\x20}\x0a\x20\x20\x20\x20float\x20upVal=\x20ltVal\x20*\x20(1.-weight.x)\x20+\x20rtVal\x20*\x20weight.x;\x0a\x20\x20\x20\x20float\x20downVal\x20=\x20lbVal\x20*\x20(1.-weight.x)\x20+\x20rbVal\x20*\x20weight.x;\x0a\x20\x20\x20\x20float\x20interpVal=\x20downVal\x20*\x20(1.-weight.y)\x20+\x20upVal\x20*\x20weight.y;\x0a\x20\x20\x20\x20return\x20vec2(rawVal,interpVal);\x0a}\x0a',
            ip[iy['qe_readGrid2DRawVal']] = '\x0a\x20\x20\x20\x20float\x20' + iy['qe_readGrid2DRawVal'] + '(sampler2D\x20grid,vec2\x20uv,float\x20undef){\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20val;\x0a\x20\x20\x20\x20\x20\x20\x20\x20' + cd + '\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(val,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20undef;\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(dataAlgo==2.0){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val\x20=\x20(val+dataOffset)*dataScale;\x0a\x20\x20\x20\x20\x20\x20\x20\x20}else{\x20//current\x200\x201\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val\x20=\x20val*dataScale+dataOffset;\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20val;\x0a\x20\x20\x20\x20}\x0a',
            ip[iy['qe_readGrid3DRawVal']] = '\x0a\x20\x20\x20\x20float\x20' + iy['qe_readGrid3DRawVal'] + '(highp\x20sampler3D\x20grid,vec3\x20p,float\x20undef){\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20val;\x0a\x20\x20\x20\x20\x20\x20\x20\x20' + cJ + '\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(val,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20undef;\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(dataAlgo==2.0){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val\x20=\x20(val+dataOffset)*dataScale;\x0a\x20\x20\x20\x20\x20\x20\x20\x20}else{\x20//current\x200\x201\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val\x20=\x20val*dataScale+dataOffset;\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20val;\x0a\x20\x20\x20\x20}\x0a',
            ip[iy['qe_interpGridValByUV']] = '\x0a\x20\x20\x20\x20vec2\x20' + iy['qe_interpGridValByUV'] + '(sampler2D\x20grid,vec2\x20uv,vec4\x20xAttr,vec4\x20yAttr,float\x20undef,int\x20interpMethod,sampler2D\x20nextGrid,float\x20percent){\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20val=' + iy['qe_readGridValByUV'] + '(grid,uv,xAttr,yAttr,undef,interpMethod);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20nextVal=' + iy['qe_readGridValByUV'] + '(nextGrid,uv,xAttr,yAttr,undef,interpMethod);\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(val.y,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(percent<=0.5){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20val;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20nextVal;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20return\x20val;\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(nextVal.y,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(percent>0.5){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20nextVal;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20val;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20return\x20val;\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20mix(val,nextVal,percent);\x0a\x20\x20\x20\x20}\x0a',
            ip[iy['qe_interpGridVal3DByUV']] = '\x0a\x20\x20\x20\x20vec2\x20' + iy['qe_interpGridVal3DByUV'] + '(highp\x20sampler3D\x20grid,vec3\x20p,vec4\x20xAttr,vec4\x20yAttr,vec3\x20zAttr,float\x20undef,int\x20interpMethod,highp\x20sampler3D\x20nextGrid,float\x20percent){\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20val=' + iy['qe_readGridVal3DByUV'] + '(grid,p,xAttr,yAttr,zAttr,undef,interpMethod);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20nextVal=' + iy['qe_readGridVal3DByUV'] + '(nextGrid,p,xAttr,yAttr,zAttr,undef,interpMethod);\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(val.y,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(percent<=0.5){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20val;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20nextVal;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(nextVal.y,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(percent>0.5){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20nextVal;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20val;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20mix(val,nextVal,percent);\x0a\x20\x20\x20\x20}\x0a',
            ip[iy['qe_readGridValByUV']] = '\x0a\x20\x20\x20\x20float\x20cardinalSpline(vec4\x20colVal,vec4\x20uvec){\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20dot(uvec,cardinalSplineMat*colVal);\x0a\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20vec2\x20' + iy['qe_readGridValByUV'] + '(sampler2D\x20grid,vec2\x20uv,vec4\x20xAttr,vec4\x20yAttr,float\x20undef,int\x20interpMethod){\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20rawVal=\x20' + iy['qe_readGrid2DRawVal'] + '(grid,uv,undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(interpMethod==0\x20||\x20' + iy['qe_isUndef'] + '(rawVal,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20dataSize=vec2(xAttr.w,yAttr.w);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20pos=uv*dataSize;\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20prePos\x20=\x20floor(pos);\x20//i,j\x20p22\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20nextPos\x20=\x20ceil(pos);\x20//i+1,j+1\x20p33\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20preUv\x20=\x20prePos\x20/dataSize;\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20nextUv\x20=\x20nextPos\x20/dataSize;\x0a\x20\x20\x20\x20\x20\x20\x20\x20//weight\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20weight\x20=\x20fract(pos);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20lbUv\x20=\x20preUv;\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20ltUv\x20=\x20vec2(preUv.x,nextUv.y);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20rbUv\x20=\x20vec2(nextUv.x,preUv.y);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20rtUv\x20=\x20nextUv;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20lbVal\x20=\x20' + iy['qe_readGrid2DRawVal'] + '(grid,lbUv,undef);\x20//p(i,j)\x20p22\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20ltVal\x20=\x20' + iy['qe_readGrid2DRawVal'] + '(grid,ltUv,undef);\x20//p(i,j+1)\x20p23\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20rbVal\x20=\x20' + iy['qe_readGrid2DRawVal'] + '(grid,rbUv,undef);\x20//p(i+1,j)\x20p32\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20rtVal\x20=\x20' + iy['qe_readGrid2DRawVal'] + '(grid,rtUv,undef);\x20//p(i+1,j+1)\x20p33\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(lbVal,undef)\x20||\x20' + iy['qe_isUndef'] + '(ltVal,undef)\x20||\x20' + iy['qe_isUndef'] + '(rbVal,undef)\x20||\x20' + iy['qe_isUndef'] + '(rtVal,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20upVal=\x20ltVal\x20*\x20(1.-weight.x)\x20+\x20rtVal\x20*\x20weight.x;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20downVal\x20=\x20lbVal\x20*\x20(1.-weight.x)\x20+\x20rbVal\x20*\x20weight.x;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20interpVal=\x20downVal\x20*\x20(1.-weight.y)\x20+\x20upVal\x20*\x20weight.y;\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(interpMethod==1){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal,interpVal);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20xWeight=vec4(weight.x*weight.x*weight.x,weight.x*weight.x,weight.x,1.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20yWeight=vec4(weight.y*weight.y*weight.y,weight.y*weight.y,weight.y,1.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20//use\x20Cardinal\x20spline\x0a\x20\x20\x20\x20\x20\x20\x20\x20//col1->p(i-1,j-1)\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20p11=prePos+vec2(-1.,-1.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20uv11=p11/dataSize;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20v11=' + iy['qe_readGrid2DRawVal'] + '(grid,uv11,undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(v11,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20//p(i-1,j)\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20p12=prePos+vec2(-1.,0.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20uv12=p12/dataSize;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20v12=' + iy['qe_readGrid2DRawVal'] + '(grid,uv12,undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(v12,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20//p(i-1,j+1)\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20p13=prePos+vec2(-1.,1.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20uv13=p13/dataSize;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20v13=' + iy['qe_readGrid2DRawVal'] + '(grid,uv13,undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(v13,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20//p(i-1,j+2)\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20p14=prePos+vec2(-1.,2.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20uv14=p14/dataSize;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20v14=' + iy['qe_readGrid2DRawVal'] + '(grid,uv14,undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(v14,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20col1Val=cardinalSpline(vec4(v11,v12,v13,v14),yWeight);\x0a\x20\x20\x20\x20\x20\x20\x20\x20//col2->p(i,j-1)\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20p21=prePos+vec2(0.,-1.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20uv21=p21/dataSize;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20v21=' + iy['qe_readGrid2DRawVal'] + '(grid,uv21,undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(v21,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20//p(i,j)\x20p22\x20exist\x0a\x20\x20\x20\x20\x20\x20\x20\x20//p(i,j+1)\x20p23\x20exist\x0a\x20\x20\x20\x20\x20\x20\x20\x20//p(i,j+2)\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20p24=prePos+vec2(0.,2.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20uv24=p24/dataSize;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20v24=' + iy['qe_readGrid2DRawVal'] + '(grid,uv24,undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(v24,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20col2Val=cardinalSpline(vec4(v21,lbVal,ltVal,v24),yWeight);\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20//col3->p(i+1,j-1)\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20p31=prePos+vec2(1.,-1.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20uv31=p31/dataSize;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20v31=' + iy['qe_readGrid2DRawVal'] + '(grid,uv31,undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(v31,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20//p(i+1,j)\x20p32\x20exist\x0a\x20\x20\x20\x20\x20\x20\x20\x20//p(i+1,j+1)\x20p33\x20exist\x0a\x20\x20\x20\x20\x20\x20\x20\x20//p(i+1,j+2)\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20p34=prePos+vec2(1.,2.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20uv34=p34/dataSize;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20v34=' + iy['qe_readGrid2DRawVal'] + '(grid,uv34,undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(v34,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20col3Val=cardinalSpline(vec4(v31,rbVal,rtVal,v34),yWeight);\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20//col4->p(i+2,j-1)\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20p41=prePos+vec2(2.,-1.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20uv41=p41/dataSize;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20v41=' + iy['qe_readGrid2DRawVal'] + '(grid,uv41,undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(v41,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20//p(i+2,j)\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20p42=prePos+vec2(2.,0.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20uv42=p42/dataSize;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20v42=' + iy['qe_readGrid2DRawVal'] + '(grid,uv42,undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(v42,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20//p(i+2,j+1)\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20p43=prePos+vec2(2.,1.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20uv43=p43/dataSize;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20v43=' + iy['qe_readGrid2DRawVal'] + '(grid,uv43,undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(v43,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20//p(i+2,j+2)\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20p44=prePos+vec2(2.,2.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20uv44=p44/dataSize;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20v44=' + iy['qe_readGrid2DRawVal'] + '(grid,uv44,undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(v44,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20col4Val=cardinalSpline(vec4(v41,v42,v43,v44),yWeight);\x0a\x20\x20\x20\x20\x20\x20\x20\x20//calc\x20row\x20val\x0a\x20\x20\x20\x20\x20\x20\x20\x20interpVal=cardinalSpline(vec4(col1Val,col2Val,col3Val,col4Val),xWeight);\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal,interpVal);\x0a\x20\x20\x20\x20}\x0a',
            ip[iy['qe_readGridVal3DByUV']] = '\x0a\x0a\x20\x20\x20\x20float\x20readPlaneGridVal(highp\x20sampler3D\x20grid,vec2\x20preUv,vec2\x20nextUv,float\x20z,vec2\x20weight,float\x20undef){\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20lbUv\x20=\x20vec3(preUv,z);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20ltUv\x20=\x20vec3(preUv.x,nextUv.y,z);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20rbUv\x20=\x20vec3(nextUv.x,preUv.y,z);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20rtUv\x20=\x20vec3(nextUv,z);\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20lbVal\x20=\x20' + iy['qe_readGrid3DRawVal'] + '(grid,lbUv,undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20ltVal\x20=\x20' + iy['qe_readGrid3DRawVal'] + '(grid,ltUv,undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20rbVal\x20=\x20' + iy['qe_readGrid3DRawVal'] + '(grid,rbUv,undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20rtVal\x20=\x20' + iy['qe_readGrid3DRawVal'] + '(grid,rtUv,undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(lbVal,undef)\x20||\x20' + iy['qe_isUndef'] + '(ltVal,undef)\x20||' + iy['qe_isUndef'] + '(rbVal,undef)\x20||' + iy['qe_isUndef'] + '(rtVal,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20undef;\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20upVal=\x20ltVal\x20*\x20(1.-weight.x)\x20+\x20rtVal\x20*\x20weight.x;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20downVal\x20=\x20lbVal\x20*\x20(1.-weight.x)\x20+\x20rbVal\x20*\x20weight.x;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20interpVal=\x20downVal\x20*\x20(1.-weight.y)\x20+\x20upVal\x20*\x20weight.y;\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20interpVal;\x0a\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20vec2\x20' + iy['qe_readGridVal3DByUV'] + '(highp\x20sampler3D\x20grid,vec3\x20uv,vec4\x20xAttr,vec4\x20yAttr,vec3\x20zAttr,float\x20undef,int\x20interpMethod){\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20rawVal=\x20' + iy['qe_readGrid3DRawVal'] + '(grid,uv,undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(interpMethod==0\x20||\x20' + iy['qe_isUndef'] + '(rawVal,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20dataSize=vec3(xAttr.w,yAttr.w,zAttr.z);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20pos=uv*dataSize;\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20prePos\x20=\x20floor(pos);\x20//i,j\x20p22\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20nextPos\x20=\x20ceil(pos);\x20//i+1,j+1\x20p33\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20preUv\x20=\x20prePos\x20/dataSize;\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20nextUv\x20=\x20nextPos\x20/dataSize;\x0a\x20\x20\x20\x20\x20\x20\x20\x20//weight\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20weight\x20=\x20fract(pos);\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20downVal=readPlaneGridVal(grid,preUv.xy,nextUv.xy,preUv.z,weight.xy,undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(downVal,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal,rawVal);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20upVal=readPlaneGridVal(grid,preUv.xy,nextUv.xy,nextUv.z,weight.xy,undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(upVal,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal,rawVal);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal,mix(downVal,upVal,weight.z));\x0a\x20\x20\x20\x20}\x0a',
            ip[iy['qe_getColor']] = '\x0a\x20\x20\x20\x20vec4\x20qe_getColor(float\x20val){\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(val,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec4(0.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20col;\x0a\x20\x20\x20\x20\x20\x20\x20\x20for(int\x20i=0;i<stepCount;i++){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20col=colors[i];\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(val<=steps[i]){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20break;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20col;\x0a\x20\x20\x20\x20}\x0a',
            ip[iy['qe_interpColor']] = '\x0a\x20\x20\x20\x20vec4\x20qe_interpColor(float\x20val){\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(val,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec4(0.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20weight=0.;\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20col;\x0a\x20\x20\x20\x20\x20\x20\x20\x20for(int\x20i=0;i<stepCount;i++){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20col=colors[i];\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(val<=steps[i]){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(i==0||(i==stepCount-1)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20break;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20weight=(val-steps[i-1])/(steps[i]-steps[i-1]);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20colorPre=colors[i-1];\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20colorCur=colors[i];\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20col\x20=\x20mix(colorPre,colorCur,weight);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20break;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20col;\x0a\x20\x20\x20\x20}\x0a',
            ip[iy['qe_getHeightByPreAndCurrent']] = '\x0a\x20\x20\x20\x20float\x20qe_getHeightByPreAndCurrent(vec2\x20uv,bool\x20useTexture,float\x20percent){\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20height=0.;\x0a\x20\x20\x20\x20\x20\x20\x20\x20//\x20if(useTexture){\x0a\x20\x20\x20\x20\x20\x20\x20\x20//\x20\x20\x20\x20\x20height=' + iy['qe_texture2DFloat'] + '(heightTexture,uv);\x0a\x20\x20\x20\x20\x20\x20\x20\x20//\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20height=height+mix(preHeight,currentHeight,percent);\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20height*zScale;\x0a\x20\x20\x20\x20}\x0a',
            ip[iy['qe_idx2LonLat']] = '\x0a\x20\x20\x20\x20vec2\x20qe_idx2LonLat(float\x20idx,vec4\x20xAttr,vec4\x20yAttr){\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20rowIdx=floor(idx/xAttr.w);\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20colIdx=mod(idx,xAttr.w);\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20lon=xAttr.x+colIdx*xAttr.z;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20lat=yAttr.x+rowIdx*yAttr.z;\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(lon,lat);\x0a\x20\x20\x20\x20}\x0a',
            ip[iy['qe_idx2LonLatTexPos']] = '\x0a\x20\x20\x20\x20vec2\x20qe_idx2LonLatTexPos(float\x20idx,float\x20xSize,float\x20ySize){\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20pos1d=idx\x20/\x20xSize;\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20fract(pos1d),\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20floor(pos1d)/ySize\x0a\x20\x20\x20\x20\x20\x20\x20\x20);\x0a\x20\x20\x20\x20}\x0a',
            ip[iy['qe_maskout']] = '\x0a\x20\x20\x20\x20bool\x20qe_maskout(vec2\x20reso,sampler2D\x20maskTexture){\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20sUv=gl_FragCoord.xy/reso;\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20maskInfo=' + ic['textureFunc'] + '(maskTexture,vec2(sUv.x,sUv.y));\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(maskInfo.a<0.1){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20false;\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20true;\x0a\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20',
            ip[iy['qe_encodeFloat']] = '\x0a\x20\x20\x20\x20float\x20encodeFloat_shift_right\x20(float\x20v,\x20float\x20amt)\x20{\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20v\x20=\x20floor(v)\x20+\x200.5;\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20floor(v\x20/\x20exp2(amt));\x20\x0a\x20\x20\x20\x20}\x0a\x20\x20\x20\x20float\x20encodeFloat_shift_left\x20(float\x20v,\x20float\x20amt)\x20{\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20floor(v\x20*\x20exp2(amt)\x20+\x200.5);\x20\x0a\x20\x20\x20\x20}\x0a\x20\x20\x20\x20float\x20encodeFloat_mask_last\x20(float\x20v,\x20float\x20bits)\x20{\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20mod(v,\x20encodeFloat_shift_left(1.0,\x20bits));\x20\x0a\x20\x20\x20\x20}\x0a\x20\x20\x20\x20float\x20encodeFloat_extract_bits\x20(float\x20num,\x20float\x20from,\x20float\x20to)\x20{\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20from\x20=\x20floor(from\x20+\x200.5);\x20to\x20=\x20floor(to\x20+\x200.5);\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20encodeFloat_mask_last(encodeFloat_shift_right(num,\x20from),\x20to\x20-\x20from);\x20\x0a\x20\x20\x20\x20}\x0a\x20\x20\x20\x20vec4\x20qe_encodeFloat\x20(float\x20val)\x20{\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20if\x20(val\x20==\x200.0)\x20return\x20vec4(0,\x200,\x200,\x200);\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20sign\x20=\x20val\x20>\x200.0\x20?\x200.0\x20:\x201.0;\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20val\x20=\x20abs(val);\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20exponent\x20=\x20floor(log2(val));\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20biased_exponent\x20=\x20exponent\x20+\x20127.0;\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20fraction\x20=\x20((val\x20/\x20exp2(exponent))\x20-\x201.0)\x20*\x208388608.0;\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20t\x20=\x20biased_exponent\x20/\x202.0;\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20last_bit_of_biased_exponent\x20=\x20fract(t)\x20*\x202.0;\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20remaining_bits_of_biased_exponent\x20=\x20floor(t);\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20byte4\x20=\x20encodeFloat_extract_bits(fraction,\x200.0,\x208.0)\x20/\x20255.0;\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20byte3\x20=\x20encodeFloat_extract_bits(fraction,\x208.0,\x2016.0)\x20/\x20255.0;\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20byte2\x20=\x20(last_bit_of_biased_exponent\x20*\x20128.0\x20+\x20encodeFloat_extract_bits(fraction,\x2016.0,\x2023.0))\x20/\x20255.0;\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20byte1\x20=\x20(sign\x20*\x20128.0\x20+\x20remaining_bits_of_biased_exponent)\x20/\x20255.0;\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec4(byte4,\x20byte3,\x20byte2,\x20byte1);\x20\x0a\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x0a\x20\x20\x20\x20',
            ip[iy['qe_getColorByScale']] = '\x0a\x20\x20\x20\x20vec4\x20qe_getColorByScale(float\x20val){\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(val,undef)\x20||\x20val<csMin){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec4(0.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20u=(val-csMin)/(csMax-csMin);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20uv=vec2(u,0.5);\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20' + ic['textureFunc'] + '(csTexture,uv);\x0a\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20';
        }(),
        iw = true);
    }
    var iu = n(0x1ca);
    class IDWScatterInterpolator {
      constructor() {
        this['interpUniforms'] = {};
      }
      ['init'] (cd) {
        if (this['destroyShaders'](),
          this['options'] = (0x0,
            Kz['Ov'])({}, cd, IDWScatterInterpolator['DefaultOptions']),
          !this['gl']) {
          const cC = document['createElement']('canvas');
          this['gl'] = Kg['v']['useWebGL2'] ? cC['getContext']('webgl2') : cC['getContext']('webgl'),
            function (cO) {
              for (let cG = 0x0; cG < KG['length']; ++cG)
                KO(cO, KG[cG]);
            }(this['gl']);
        }
        this['gl']['canvas']['width'] = cd['gridOptions']['xSize'],
          this['gl']['canvas']['height'] = cd['gridOptions']['ySize'];
        const cq = ic['header'] + '\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20precision\x20highp\x20float;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20' + ic['attrIn'] + '\x20vec2\x20position;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20' + ic['attrIn'] + '\x20vec2\x20uv;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20' + ic['varOut'] + '\x20vec2\x20vUv;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20void\x20main(){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vUv=uv;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_Position=vec4(position,0.,1.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20'
          , cJ = ic['header'] + '\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20precision\x20highp\x20sampler2D;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20precision\x20highp\x20float;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20const\x20float\x20dataOffset=0.;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20const\x20float\x20dataScale=1.;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20const\x20int\x20maxCount=' + {} + ';\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20const\x20int\x20maxRadius=' + parseInt(this['options']['maxSearchGridSpan']) + ';\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20const\x20float\x20xi=' + ik(this['options']['gridOptions']['xDelta']) + ';\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//todo:使用xAttr和yAttr结合位置进行球面距离计算\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20const\x20vec4\x20xAttr=vec4(' + ik(this['options']['gridOptions']['xStart']) + ',' + ik(this['options']['gridOptions']['xEnd']) + ',' + ik(this['options']['gridOptions']['xDelta']) + ',' + ik(this['options']['gridOptions']['xSize']) + ');\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20const\x20vec4\x20yAttr=vec4(' + ik(this['options']['gridOptions']['yStart']) + ',' + ik(this['options']['gridOptions']['yEnd']) + ',' + ik(this['options']['gridOptions']['yDelta']) + ',' + ik(this['options']['gridOptions']['ySize']) + ');\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20const\x20float\x20uDelta=' + 0x1 / this['options']['gridOptions']['xSize'] + ';\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20const\x20float\x20vDelta=' + 0x1 / this['options']['gridOptions']['ySize'] + ';\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20const\x20mediump\x20int\x20dataAlgo=0;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20const\x20float\x20baseScale=1.;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20sampler2D\x20staTexture;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20undef;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20' + ic['varIn'] + '\x20vec2\x20vUv;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20' + ic['outColorDefine'] + '\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20$inject\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//todo:改遍历方式，现在一次性遍历的上下所有y点，导致y方向占比过高\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20idw(vec2\x20uv){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20wAll=0.;\x20//所有的距离幂指数的累加\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20vAll=0.;\x20//数据值乘以w的累加\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20int\x20ptCount=0;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20dataSize=vec2(xAttr.w,yAttr.w);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20pos=floor(uv*dataSize);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20center=vec2(xAttr.x+\x20uv.x*xAttr.w,yAttr.x+uv.y*yAttr.w);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20for(int\x20i=0;i<maxRadius;i++){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20fi=float(i);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20lu=(pos.x-fi)/(dataSize.x);\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20float\x20lu=uv.x-fi*uDelta;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(lu<0.){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20continue;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20ru=(pos.x+fi)/(dataSize.x);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20float\x20ru=uv.x+fi*uDelta;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(ru>1.){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20continue;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20cLon=center.x+xAttr.z;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20for(int\x20j=0;j<maxRadius;j++){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20fj=float(j);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20upV=(pos.y-fj)/(dataSize.y);\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20float\x20upV=uv.y-fj*vDelta;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(upV<0.){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20continue;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20downV=(pos.y+fj)/(dataSize.y);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20float\x20downV=uv.y+fj*vDelta;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(downV>1.){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20continue;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20cLat=center.y+yAttr.z;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20currentPos=vec2(cLon,cLat);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20h=' + iy['qe_geoDistance'] + '(center,currentPos);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20w=1./pow(h,' + ik(this['options']['p']) + ');\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//left\x20side,up\x20val\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20lUpVal=' + iy['qe_readGrid2DRawVal'] + '(staTexture,vec2(lu,upV),undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(!' + iy['qe_isUndef'] + '(lUpVal,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20wAll=wAll+w;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vAll=vAll+w*lUpVal;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20ptCount=ptCount+1;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20lDownVal=' + iy['qe_readGrid2DRawVal'] + '(staTexture,vec2(lu,downV),undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(!' + iy['qe_isUndef'] + '(lDownVal,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20wAll=wAll+w;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vAll=vAll+w*lDownVal;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20ptCount=ptCount+1;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20rUpVal=' + iy['qe_readGrid2DRawVal'] + '(staTexture,vec2(ru,upV),undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(!' + iy['qe_isUndef'] + '(rUpVal,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20wAll=wAll+w;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vAll=vAll+w*rUpVal;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20ptCount=ptCount+1;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20rDownVal=' + iy['qe_readGrid2DRawVal'] + '(staTexture,vec2(ru,downV),undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(!' + iy['qe_isUndef'] + '(rDownVal,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20wAll=wAll+w;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vAll=vAll+w*rDownVal;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20ptCount=ptCount+1;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20if(ptCount>=' + {} + '){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20\x20\x20\x20\x20return\x20vAll/wAll;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(ptCount==0){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20undef;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vAll/wAll;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20void\x20main(){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20uv=vec2(vUv.x,1.-vUv.y);\x20//vec2(gl_FragCoord.xy);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20val=' + iy['qe_readGrid2DRawVal'] + '(staTexture,uv,undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//if\x20not\x20undef,use\x20exact\x20value\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(val,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val=idw(uv);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20color=' + iy['qe_encodeFloat'] + '(val);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20' + ic['outColorName'] + '=color;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20';
        return this['interpProgram'] = Kf(this['gl'], [cq, i5(cJ)]),
          this['interpBuffer'] = Ah(this['gl'], {
            'position': {
              'numComponents': 0x2,
              'data': [-0x1, 0x1, -0x1, -0x1, 0x1, -0x1, -0x1, 0x1, 0x1, -0x1, 0x1, 0x1]
            },
            'uv': {
              'numComponents': 0x2,
              'data': [0x0, 0x0, 0x0, 0x1, 0x1, 0x1, 0x0, 0x0, 0x1, 0x1, 0x1, 0x0]
            }
          }),
          this['interpFramebuffer'] = KJ(this['gl'], [{
            'width': this['gl']['drawingBufferWidth'],
            'height': this['gl']['drawingBufferHeight'],
            'src': new Uint8Array(this['gl']['drawingBufferWidth'] * this['gl']['drawingBufferHeight'] * 0x4),
            'format': this['gl']['RGBA'],
            'type': this['gl']['UNSIGNED_BYTE'],
            'wrap': this['gl']['CLAMP_TO_EDGE'],
            'minMag': this['gl']['NEAREST']
          }]),
          this['gl']['bindFramebuffer'](this['gl']['FRAMEBUFFER'], null),
          this;
      }
      ['interpToProvider'] (cd, cq, cJ) {
        const cC = this['interp'](cd, cq, cJ);
        return new iu['o']([[cC]], {
          'gridOptions': this['options']['gridOptions']
        });
      }
      ['interp'] (cd, cq, cJ) {
        (this['options']['p'] < 0x0 || this['options']['maxSearchGridSpan'] <= 0x0) && v0['kg']['error']('p值不能小于0，maxSearchGridSpan需要大于0！'),
          v0['kg']['debug']('begin\x20interp');
        const cC = performance['now']();
        var cO, cG, cg;
        this['gl']['useProgram'](this['interpProgram']['program']),
          cO = this['gl'],
          cG = this['interpFramebuffer'],
          cg = cg || 0x8d40,
          cG ? (cO['bindFramebuffer'](cg, cG['framebuffer']),
            cO['viewport'](0x0, 0x0, cG['width'], cG['height'])) : (cO['bindFramebuffer'](cg, null),
              cO['viewport'](0x0, 0x0, cO['drawingBufferWidth'], cO['drawingBufferHeight'])),
          this['gl']['viewport'](0x0, 0x0, this['gl']['drawingBufferWidth'], this['gl']['drawingBufferHeight']),
          this['gl']['clear'](this['gl']['COLOR_BUFFER_BIT']),
          function (cz, cQ, cm) {
            cm['vertexArrayObject'] ? cz['bindVertexArray'](cm['vertexArrayObject']) : (function (cL, cR) {
              for (const H0 in cR) {
                const H1 = cL[H0];
                H1 && H1(cR[H0]);
              }
            }(cQ['attribSetters'] || cQ, cm['attribs']),
              cm['indices'] && cz['bindBuffer'](0x8893, cm['indices']));
          }(this['gl'], this['interpProgram'], this['interpBuffer']),
          this['interpUniforms']['staTexture'] = this['createStaTexture'](cd, cq, cJ),
          this['interpUniforms']['undef'] = cq,
          KY(this['interpProgram'], this['interpUniforms']),
          function (cz, cQ, cm, cL, cR, H0) {
            cm = undefined === cm ? 0x4 : cm;
            const H1 = cQ['indices']
              , H2 = cQ['elementType']
              , H3 = undefined === cL ? cQ['numElements'] : cL;
            cR = undefined === cR ? 0x0 : cR,
              H2 || H1 ? undefined !== H0 ? cz['drawElementsInstanced'](cm, H3, undefined === H2 ? 0x1403 : cQ['elementType'], cR, H0) : cz['drawElements'](cm, H3, undefined === H2 ? 0x1403 : cQ['elementType'], cR) : undefined !== H0 ? cz['drawArraysInstanced'](cm, cR, H3, H0) : cz['drawArrays'](cm, cR, H3);
          }(this['gl'], this['interpBuffer']),
          this['gl']['finish']();
        const cN = performance['now']()
          , cP = new Uint8Array(this['options']['gridOptions']['xSize'] * this['options']['gridOptions']['ySize'] * 0x4);
        this['gl']['readPixels'](0x0, 0x0, this['options']['gridOptions']['xSize'], this['options']['gridOptions']['ySize'], this['gl']['RGBA'], this['gl']['UNSIGNED_BYTE'], cP);
        const cM = new KN['P'](KP['U']['Float32'], this['options']['gridOptions']['xSize'], this['options']['gridOptions']['ySize'], cP['buffer'], cq);
        return v0['kg']['debug']('read\x20pixels\x20costs\x20' + (performance['now']() - cN) + 'ms'),
          this['gl']['bindFramebuffer'](this['gl']['FRAMEBUFFER'], null),
          v0['kg']['debug']('interp\x20total\x20costs\x20' + (performance['now']() - cC) + 'ms'),
          cM;
      }
      ['getGLDataInfo'] (cd) {
        const cq = cd['dataType'] !== KP['U']['UInt8'] && this['gl'] instanceof WebGL2RenderingContext ? this['gl']['RED'] : this['gl']['ALPHA'];
        let cJ = cd['dataType'] === KP['U']['UInt8'] ? this['gl']['UNSIGNED_BYTE'] : this['gl']['FLOAT']
          , cC = cq
          , cO = cd['dataType'] === KP['U']['UInt8'] || cd['dataType'] === KP['U']['Float32'] ? cd['raw'] : new Float32Array(cd['raw']);
        return cq === this['gl']['RED'] && (cC = this['gl']['R32F']),
        {
          'rawData': cO,
          'dataType': cJ,
          'innerFormat': cC,
          'pixelFormat': cq
        };
      }
      ['getValReplaceFunc'] () {
        return 'first' === this['options']['pointInSameGridStrategy'] ? (cd, cq) => cd : 'last' === this['options']['pointInSameGridStrategy'] ? (cd, cq) => cq : 'max' === this['options']['pointInSameGridStrategy'] ? (cd, cq) => Math['max'](cd, cq) : 'min' === this['options']['pointInSameGridStrategy'] ? (cd, cq) => Math['min'](cd, cq) : 'negMinPosMax' === this['options']['pointInSameGridStrategy'] ? (cd, cq) => cd < 0x0 ? Math['min'](cd, cq) : Math['max'](cd, cq) : (cd, cq) => (cd + cq) / 0x2;
      }
      ['createStaTexture'] (cd, cq, cJ) {
        var cC;
        const cO = performance['now']()
          , cG = new Float32Array(this['options']['gridOptions']['xSize'] * this['options']['gridOptions']['ySize']);
        cG['fill'](cq);
        const cg = new KN['P'](KP['U']['Float32'], this['options']['gridOptions']['xSize'], this['options']['gridOptions']['ySize'], cG['buffer'], cq)
          , cN = cd['getFeatures']()['features']
          , cP = this['getValReplaceFunc']();
        for (const cQ of cN) {
          const cm = cQ['geometry']['coordinates'];
          if (!(0x0,
            Kz['ri'])(cQ['properties'][cJ]))
            continue;
          const cL = (0x0,
            Kz['tr'])(this['options']['gridOptions']['xStart'], this['options']['gridOptions']['xDelta'], cm[0x0]);
          if (cL < 0x0 || cL >= this['options']['gridOptions']['xSize'])
            continue;
          const cR = (0x0,
            Kz['tr'])(this['options']['gridOptions']['yStart'], this['options']['gridOptions']['yDelta'], cm[0x1]);
          if (cR < 0x0 || cR >= this['options']['gridOptions']['ySize'])
            continue;
          let H0 = null !== (cC = parseFloat(cQ['properties'][cJ])) && undefined !== cC ? cC : cq;
          const H1 = cg['getPos'](cR, cL)
            , H2 = cg['read1D'](H1);
          H0 == cq ? H0 = H2 : H2 != cq && (H0 = cP(H2, H0)),
            cg['write2D'](cR, cL, H0);
        }
        const cM = this['getGLDataInfo'](cg)
          , cz = lY(this['gl'], {
            'width': cg['xSize'],
            'height': cg['ySize'],
            'min': this['gl']['NEAREST'],
            'mag': this['gl']['NEAREST'],
            'format': cM['pixelFormat'],
            'internalFormat': cM['innerFormat'],
            'type': cM['dataType'],
            'src': cM['rawData'],
            'wrapS': this['gl']['CLAMP_TO_EDGE'],
            'wrapT': this['gl']['CLAMP_TO_EDGE'],
            'flipY': 0x0
          });
        return v0['kg']['debug']('create\x20' + cN['length'] + '\x20station\x20texutre\x20costs\x20' + (performance['now']() - cO) + 'ms'),
          cz;
      }
      ['deleteBufferInfo'] (cd, cq) {
        if (cq) {
          for (const cJ of Object['values'](cq['attribs']))
            cd['deleteBuffer'](cJ['buffer']);
          cq['indices'] && cd['deleteBuffer'](cq['indices']);
        }
      }
      ['deleteFrameBufferInfo'] (cd, cq) {
        if (cq) {
          cd['deleteFramebuffer'](cq['framebuffer']);
          for (const cJ of cq['attachments'])
            cJ instanceof WebGLRenderbuffer ? cd['deleteRenderbuffer'](cJ) : cd['deleteTexture'](cJ);
        }
      }
      ['destroyShaders'] () {
        this['gl'] && (this['interpProgram'] && this['gl']['deleteProgram'](this['interpProgram']['program']),
          this['interpProgram'] = undefined,
          this['interpBuffer'] && this['deleteBufferInfo'](this['gl'], this['interpBuffer']),
          this['interpBuffer'] = undefined,
          this['interpFramebuffer'] && this['deleteFrameBufferInfo'](this['gl'], this['interpFramebuffer']),
          this['interpFramebuffer'] = undefined);
      }
      ['destroy'] () {
        if (this['destroyShaders'](),
          !this['gl'])
          return;
        const cd = this['gl']['getExtension']('WEBGL_lose_context');
        cd && cd['loseContext'](),
          this['gl'] = undefined;
      }
    }
    IDWScatterInterpolator['DefaultOptions'] = {
      'gridOptions': undefined,
      'p': 0x2,
      'maxSearchGridSpan': 0x5,
      'pointInSameGridStrategy': 'mean'
    };
    var iT = n(0x393);
    class iX extends iT['c'] {
      constructor(cd, cq, cJ = '', cC = undefined) {
        super(),
          this['workerPath'] = cd,
          this['maxWorkerNumber'] = cq,
          this['name'] = cJ,
          this['workerOptions'] = cC,
          this['workersCount'] = 0x0,
          this['startTime'] = undefined,
          this['taskPosted'] = 0x0,
          this['taskProcessed'] = 0x0,
          this['maxWorkerNumber'] = this['maxWorkerNumber'] || 0x4,
          this['exeQueues'] = [],
          this['workers'] = [];
      }
      ['push'] (cd) {
        this['exeQueues']['push'](cd),
          this['execNext']();
      }
      ['destroy'] () {
        this['workers']['forEach'](cd => cd['terminate']()),
          this['workers']['length'] = 0x0,
          this['workersCount'] = 0x0;
      }
      ['execNext'] () {
        if (0x0 === this['exeQueues']['length'])
          return void (this['taskPosted'] === this['taskProcessed'] && (v0['kg']['debug']('[' + this['name'] + ']\x20complete\x20' + this['taskPosted'] + '\x20task(s)\x20cost\x20' + (new Date()['getTime']() - this['startTime']['getTime']()) + 'ms'),
            this['startTime'] = undefined,
            this['taskPosted'] = 0x0,
            this['taskProcessed'] = 0x0,
            this['fire']('completed', {
              'firer': this,
              'msg': this
            })));
        if (this['workersCount'] >= this['maxWorkerNumber'] && 0x0 === this['workers']['length'])
          return;
        let cd;
        undefined === this['startTime'] && (this['startTime'] = new Date())
        // this['workers']['length'] > 0x0 ? cd = this['workers']['shift']() : (cd = new Worker(this['workerPath'],this['workerOptions']),

        if (this['workers']['length'] > 0x0) {
          cd = this['workers']['shift']()
        }
        else {
          cd = new Worker(this['workerPath'], this['workerOptions'])
          this['workersCount']++
        }
        var cq = this['exeQueues']['shift']();
        cq['beforeExec'] && cq['beforeExec'](cq),
          cd['onerror'] = cq['onError'],
          cd['onmessage'] = cJ => {
            this['workers']['push'](cd),
              this['taskProcessed']++,
              cq['onCompleted'](cJ['data']),
              this['execNext']();
          }
          ,
          cq['transffers'] && cq['transffers']['length'] > 0x0 ? cd['postMessage'](cq['data'], cq['transffers']) : cd['postMessage'](cq['data']),
          this['taskPosted']++;
      }
    }
    class iE extends iT['c'] {
      constructor(cd, cq) {
        super(),
          this['eventNames'] = {
            'tChanged': 'tChanged',
            'zChanged': 'zChanged',
            'tzChanged': 'tzChanged',
            'iTChanged': 'iTChanged',
            'iZChanged': 'iZChanged',
            'iTZChanged': 'iTZChanged',
            'activeTZDataUpated': 'activeTZDataUpated'
          },
          this['meta'] = {},
          this['_currentTIdx'] = 0x0,
          this['_currentZIdx'] = 0x0,
          this['mc'] = [],
          this['options'] = (0x0,
            Kz['Ov'])(this['options'], cq, {
              'maxTimeCount': 0x0
            }),
          this['mc'] = cd,
          this['meshOptions'] = {
            'tCount': cd['length'],
            'zValues': cd['length'] > 0x0 ? cd[0x0]['length'] : []
          },
          this['gridOptions'] = null == cq ? undefined : cq['gridOptions'];
      }
      ['allMeshes'] () {
        return this['mc'];
      }
      ['addMeshTo'] (cd, cq, cJ, cC, cO, cG) {
        cq = parseInt(cq),
          cJ = parseInt(cJ);
        const cg = this['getIntTIdx']()
          , cN = this['getIntZIdx']();
        return cG[cq] = cG[cq] || [],
          cG[cq][cJ] = cd,
          this['meshOptions']['tCount'] = cG['length'],
          (0x0,
            Kz['ri'])(cC) && this['meshOptions']['zValues'] && (this['meshOptions']['zValues'][cJ] = cC),
          cq === cg && cJ === cN ? this['fire'](this['eventNames']['activeTZDataUpated'], {
            'firer': this,
            'msg': this
          }) : cO && (this['lock'](),
            this['currentTIdx'] = cq,
            this['currentZIdx'] = cJ,
            this['unlock']()),
          this;
      }
      get ['currentTIdx'] () {
        return this['_currentTIdx'];
      }
      set ['currentTIdx'] (cd) {
        if (this['mc'] && cd >= this['mc']['length'])
          return;
        if (cd === this['currentTIdx'])
          return;
        const cq = this['getIntTIdx']();
        this['_currentTIdx'] = cd,
          cq !== this['getIntTIdx']() ? (this['fire'](this['eventNames']['iTChanged'], {
            'firer': this,
            'msg': this
          }),
            this['fire'](this['eventNames']['iTZChanged'], {
              'firer': this,
              'msg': this
            })) : (this['fire'](this['eventNames']['tChanged'], {
              'firer': this,
              'msg': this
            }),
              this['fire'](this['eventNames']['tzChanged'], {
                'firer': this,
                'msg': this
              }));
      }
      get ['currentZIdx'] () {
        return this['_currentZIdx'];
      }
      set ['currentZIdx'] (cd) {
        if (this['mc'] && cd >= this['mc'][this['getIntTIdx']()]['length'])
          return;
        if (cd === this['currentZIdx'])
          return;
        const cq = this['getIntZIdx']();
        this['_currentZIdx'] = cd,
          cq !== this['getIntZIdx']() ? (this['fire'](this['eventNames']['iZChanged'], {
            'firer': this,
            'msg': this
          }),
            this['fire'](this['eventNames']['iTZChanged'], {
              'firer': this,
              'msg': this
            })) : (this['fire'](this['eventNames']['zChanged'], {
              'firer': this,
              'msg': this
            }),
              this['fire'](this['eventNames']['tzChanged'], {
                'firer': this,
                'msg': this
              }));
      }
      ['getGrid'] (cd, cq) {
        return undefined === cd && (cd = this['getIntTIdx']()),
          undefined === cq && (cq = this['getIntZIdx']()),
          this['mc'][cd][cq];
      }
      ['allGrids'] () {
        return this['mc'];
      }
      ['updateMesh'] (cd, cq, cJ, cC, cO) {
        return this['addMeshTo'](cd, cq, cJ, cC, cO, this['allMeshes']());
      }
      ['getIntTIdx'] () {
        return parseInt(this['_currentTIdx']);
      }
      ['getIntZIdx'] () {
        return parseInt(this['_currentZIdx']);
      }
      ['onTChanged'] (cd) {
        return this['on'](this['eventNames']['tChanged'], cd),
          this;
      }
      ['onZChanged'] (cd) {
        return this['on'](this['eventNames']['zChanged'], cd),
          this;
      }
      ['onTZChanged'] (cd) {
        return this['on'](this['eventNames']['tzChanged'], cd),
          this;
      }
      ['onIntTChanged'] (cd) {
        return this['on'](this['eventNames']['iTChanged'], cd),
          this;
      }
      ['onIntZChanged'] (cd) {
        return this['on'](this['eventNames']['iZChanged'], cd),
          this;
      }
      ['onIntTZChanged'] (cd) {
        return this['on'](this['eventNames']['iTZChanged'], cd),
          this;
      }
      ['offTChanged'] (cd) {
        return this['off'](this['eventNames']['tChanged'], cd),
          this;
      }
      ['offZChanged'] (cd) {
        return this['off'](this['eventNames']['zChanged'], cd),
          this;
      }
      ['offTZChanged'] (cd) {
        return this['off'](this['eventNames']['tzChanged'], cd),
          this;
      }
      ['offIntTChanged'] (cd) {
        return this['off'](this['eventNames']['iTChanged'], cd),
          this;
      }
      ['offIntZChanged'] (cd) {
        return this['off'](this['eventNames']['iZChanged'], cd),
          this;
      }
      ['offIntTZChanged'] (cd) {
        return this['off'](this['eventNames']['iTZChanged'], cd),
          this;
      }
      ['onActiveGridUpdated'] (cd) {
        return this['on'](this['eventNames']['activeTZDataUpated'], cd),
          this;
      }
      ['offActiveGridUpdated'] (cd) {
        return this['off'](this['eventNames']['activeTZDataUpated'], cd),
          this;
      }
    }
    var iW = function (cd, cq, cJ, cC) {
      return new (cJ || (cJ = Promise))(function (cO, cG) {
        function cg (cM) {
          try {
            cP(cC['next'](cM));
          } catch (cz) {
            cG(cz);
          }
        }
        function cN (cM) {
          try {
            cP(cC['throw'](cM));
          } catch (cz) {
            cG(cz);
          }
        }
        function cP (cM) {
          var cz;
          cM['done'] ? cO(cM['value']) : (cz = cM['value'],
            cz instanceof cJ ? cz : new cJ(function (cQ) {
              cQ(cz);
            }
            ))['then'](cg, cN);
        }
        cP((cC = cC['apply'](cd, cq || []))['next']());
      }
      );
    };
    const MCBDefaults = {
      'threadCount': 0x4
    };
    function ij (cd) {
      var cq, cJ, cC;
      return iW(this, undefined, undefined, function* () {
        const cO = cd['wasm'] ? Kg['v']['wasmPath'] + '/mcb.js' : Kg['v']['workerPath'] + '/mcb.worker.js'
          , cG = new iX(cO, null !== (cq = cd['threadCount']) && undefined !== cq ? cq : MCBDefaults['threadCount'], 'mcb_' + (0x0,
            Kz['hQ'])(), {
            'type': 'module'
          });
        if (!(null == cd ? undefined : cd['analysisValues']['length']))
          return void v0['kg']['error']('未提供三维等值面分析值！');
        if (cd['dataSource']['gridOptions']['zValues']['length'] <= 0x1)
          return void v0['kg']['error']('单层数据无法分析三维等值面！');
        const cg = cd['dataSource'];
        let cN, cP = cg['gridOptions'];
        const cM = cg['getGrid']()
          , cz = null !== (cJ = cM['dataScale']) && undefined !== cJ ? cJ : 0x1
          , cQ = null !== (cC = cM['dataOffset']) && undefined !== cC ? cC : 0x0
          , cm = cM['undef']
          , cL = cM['dataType'];
        if (cd['visibleExtent']) {
          const H5 = Math['min'](cd['visibleExtent']['maxLon'], Math['max'](cP['xStart'], cP['xEnd']))
            , H6 = Math['max'](cd['visibleExtent']['minLon'], Math['min'](cP['xStart'], cP['xEnd']))
            , H7 = Math['min'](cd['visibleExtent']['maxLat'], Math['max'](cP['yStart'], cP['yEnd']))
            , H8 = Math['max'](cd['visibleExtent']['minLat'], Math['min'](cP['yStart'], cP['yEnd']))
            , H9 = cP['xDelta'] < 0x0 ? H5 : H6
            , Hv = cP['yDelta'] < 0x0 ? H7 : H8
            , HA = cP['xDelta'] < 0x0 ? H6 : H5
            , Hk = cP['yDelta'] < 0x0 ? H8 : H7
            , Hl = Math['floor']((HA - H9) / cP['xDelta']) + 0x1
            , HK = Math['floor']((Hk - Hv) / cP['yDelta']) + 0x1
            , Hb = HK * Hl
            , Hc = cP['zValues']['length'] * Hb;
          cN = new ArrayBuffer(Hc * cg['getGrid']()['raw']['BYTES_PER_ELEMENT']);
          const HH = (0x0,
            Kz['cM'])(cg['getGrid']()['dataType'], cN);
          let Hx = (0x0,
            Kz['tr'])(cP['xStart'], cP['xDelta'], H9)
            , Hp = (0x0,
              Kz['tr'])(cP['yStart'], cP['yDelta'], Hv)
            , HF = 0x0;
          const Hy = cg['allGrids']()[cg['getIntTIdx']()];
          for (let Hw = 0x0; Hw < cP['zValues']['length']; Hw++) {
            let Hh = Hy[Hw];
            for (let Hu = Hp; Hu < HK + Hp; Hu++) {
              let HY = Hu * cP['xSize'] + Hx
                , HT = Hh['raw']['subarray'](HY, HY + Hl);
              HH['set'](HT, HF * Hl),
                HF++;
            }
          }
          cP = {
            'xStart': H9,
            'xEnd': HA,
            'yStart': Hv,
            'yEnd': Hk,
            'xSize': Hl,
            'ySize': HK,
            'tCount': 0x1,
            'zValues': cP['zValues']
          },
            (0x0,
              KM['T'])(cP);
        } else {
          cN = new ArrayBuffer(cg['getGrid']()['raw']['byteLength'] * cg['gridOptions']['zValues']['length']);
          const HX = (0x0,
            Kz['cM'])(cg['getGrid']()['dataType'], cN);
          let HE = 0x0;
          cg['allGrids']()[cg['getIntTIdx']()]['forEach'](Hf => {
            HX['set'](Hf['raw'], HE),
              HE += Hf['raw']['length'];
          }
          );
        }
        const cR = []
          , H0 = []
          , H1 = cd['analysisValues']['map'](Hf => function (HW, HI, Hj, HD, HV, HZ, HB, HS, HU, Hd) {
            return iW(this, undefined, undefined, function* () {
              return new Promise((Hq, HJ) => {
                const HC = {
                  'data': {
                    'raw': undefined,
                    'dataType': HZ,
                    'algo': HU,
                    'gridOptions': Hj,
                    'levels': Hj['zValues']['length'],
                    'xSize': Hj['xSize'],
                    'ySize': Hj['ySize'],
                    'scale': null != HB ? HB : 0x1,
                    'offset': null != HS ? HS : 0x0,
                    'scaleFirst': 0x2 !== HU,
                    'outerScale': 0x1,
                    'outerOffset': 0x0,
                    'hasOuter': false,
                    'noShared': true,
                    'undef': Hd,
                    'undef_fill': 0x0,
                    'anaValue': HW,
                    'anaType': '>='
                  },
                  'beforeExec': () => {
                    let HO;
                    HO = 0x0 === HV['length'] ? HI['slice'](0x0) : HV['pop'](),
                      HC['data']['raw'] = HO,
                      HC['transffers'] = [HO];
                  }
                  ,
                  'onCompleted': HO => {
                    let HG = new Float32Array(HO['vertices']);
                    HV['push'](HO['source']),
                      Hq(new iE([[{
                        'meshes': [{
                          'vertices': HG,
                          'properties': {
                            'value': HW
                          },
                          'indices': HO['indices']
                        }]
                      }]], {
                        'gridOptions': Hj
                      }));
                  }
                };
                HD['push'](HC);
              }
              );
            });
          }(Hf, cN, cP, cG, cR, cL, cz, cQ, cM['algo'], cm)['then'](HW => {
            if (cd['completeOne']) {
              const HI = cd['layerCreator'](HW);
              cd['completeOne'](HI, HW),
                H0['push'](HI);
            }
            return HW;
          }
          ))
          , H2 = yield Promise['all'](H1)
          , H3 = {
            'meshes': []
          };
        H2['forEach'](Hf => {
          Hf['allMeshes']()[0x0][0x0]['meshes']['forEach'](HW => {
            H3['meshes']['push'](HW);
          }
          );
        }
        );
        const H4 = new iE([[H3]], {
          'gridOptions': cP
        });
        return cd['completeOne'] ? {
          'dataSource': H4,
          'layer': H0
        } : {
          'dataSource': H4,
          'layer': cd['layerCreator'](H4)
        };
      });
    }
    var CollisionDetectMode;
    !function (cd) {
      cd[cd['Hide_All_When_Any'] = 0x0] = 'Hide_All_When_Any',
        cd[cd['Hide_Only_Self'] = 0x1] = 'Hide_Only_Self';
    }(CollisionDetectMode || (CollisionDetectMode = {}));
    class iV {
      constructor(cd, cq, cJ, cC) {
        this['minX'] = cd,
          this['minY'] = cq,
          this['maxX'] = cJ,
          this['maxY'] = cC;
      }
      ['intersects'] (cd) {
        const cq = cd['maxX'] >= this['minX'] && cd['minX'] <= this['maxX']
          , cJ = cd['maxY'] >= this['minY'] && cd['minY'] <= this['maxY'];
        return cq && cJ;
      }
    }
    class CollisonDetector {
      constructor(cd) {
        cd['width'] && cd['height'] || v0['kg']['error']('碰撞检测类需要提供宽高属性！'),
          this['options'] = (0x0,
            Kz['Ov'])({}, cd, CollisonDetector['DefaultOptions']),
          this['collisionTree'] = new Quadtree({
            'x': this['options']['x'],
            'y': this['options']['y'],
            'width': this['options']['width'],
            'height': this['options']['height']
          }, this['options']['maxNodeItems']),
          this['batchInsert'](this['options']['objs']);
      }
      ['_collisionDetectByFeature'] (cd) {
        const cq = {};
        for (const cO of cd)
          cO['feature']['id'] = cO['feature']['id'] || (0x0,
            Kz['hQ'])(),
            cq[cO['feature']['id']] ? cq[cO['feature']['id']]['push'](cO) : cq[cO['feature']['id']] = [cO];
        const cJ = [];
        for (const cG in cq) {
          const cg = cq[cG];
          if (!cg['some'](cN => cN['hidden'])) {
            cJ['push'](cG);
            for (const cN of cg) {
              const cP = this['collisionTree']['retrieve'](cN);
              if (!cP || 0x0 === cP['length'])
                continue;
              let cM = cN['bounds'];
              cM || (cM = cN['bounds'] = new iV(cN['x'], cN['y'], cN['x'] + cN['width'], cN['y'] + cN['height']));
              let cz = 0x0;
              cP['forEach'](cQ => {
                if (cQ['hidden'] || cQ === cN || cQ['feature'] === cN['feature'])
                  return;
                let cm = cQ['bounds'];
                cm || (cm = cQ['bounds'] = new iV(cQ['x'], cQ['y'], cQ['x'] + cQ['width'], cQ['y'] + cQ['height'])),
                  cM['intersects'](cm) ? cQ['hidden'] = true : cz++;
              }
              );
            }
          }
        }
        const cC = [];
        for (const cQ of cJ)
          for (const cm of cq[cQ])
            cC['push'](cm);
        return cC;
      }
      ['insert'] (cd) {
        this['collisionTree']['insert'](cd);
      }
      ['batchInsert'] (cd) {
        cd && 0x0 !== cd['length'] && cd['forEach'](cq => {
          this['insert'](cq);
        }
        );
      }
      ['collisionDectect'] (cd) {
        if (!cd || 0x0 === cd['length'])
          return [];
        if (this['options']['collisonMode'] === CollisionDetectMode['Hide_All_When_Any'])
          return this['_collisionDetectByFeature'](cd);
        let cq = [];
        for (const cJ of cd) {
          if (cJ['hidden'])
            continue;
          cq['push'](cJ);
          const cC = this['collisionTree']['retrieve'](cJ);
          if (!cC || 0x0 === cC['length'])
            continue;
          let cO = cJ['bounds'];
          cO || (cO = cJ['bounds'] = new iV(cJ['x'], cJ['y'], cJ['x'] + cJ['width'], cJ['y'] + cJ['height']));
          let cG = 0x0;
          cC['forEach'](cg => {
            if (cg['hidden'] || cg === cJ || cg['feature'] === cJ['feature'])
              return;
            let cN = cg['bounds'];
            cN || (cN = cg['bounds'] = new iV(cg['x'], cg['y'], cg['x'] + cg['width'], cg['y'] + cg['height'])),
              cO['intersects'](cN) ? cg['hidden'] = true : cG++;
          }
          );
        }
        return cq;
      }
      ['clear'] () {
        this['collisionTree']['clear']();
      }
    }
    CollisonDetector['DefaultOptions'] = {
      'x': 0x0,
      'y': 0x0,
      'width': undefined,
      'height': undefined,
      'maxNodeItems': 0xa,
      'collisonMode': CollisionDetectMode['Hide_Only_Self']
    };
    var iB = n(0x19d)
      , iS = n(0x35a)
      , iU = n(0x219)
      , id = n(0x1de)
      , iq = n(0x133);
    class FeatureVolumeStyle extends iB['rJ'] {
      constructor(cd) {
        super(cd),
          (0x0,
            Kz['JY'])(cd['height']) || v0['kg']['error']('配置的点的高度值无效！'),
          this['_update'](cd, true);
      }
      ['_update'] (cd, cq) {
        cq ? (this['xDelta'] = (0x0,
          iB['JW'])((0x0,
            Kz['En'])(cd['xDelta'], FeatureVolumeStyle['DefaultOptions']['xDelta'])),
          this['yDelta'] = (0x0,
            iB['JW'])((0x0,
              Kz['En'])(cd['yDelta'], FeatureVolumeStyle['DefaultOptions']['yDelta'])),
          this['color'] = (0x0,
            iB['Jf'])((0x0,
              Kz['En'])(cd['color'], FeatureVolumeStyle['DefaultOptions']['color'])),
          this['visible'] = (0x0,
            iB['pd'])((0x0,
              Kz['En'])(cd['visible'], FeatureVolumeStyle['DefaultOptions']['visible']))) : (this['xDelta'] = (0x0,
                Kz['Rf'])(cd['xDelta'], this['xDelta'], iB['JW']),
                this['yDelta'] = (0x0,
                  Kz['Rf'])(cd['yDelta'], this['yDelta'], iB['JW']),
                this['color'] = (0x0,
                  Kz['Rf'])(cd['color'], this['color'], iB['Jf']),
                this['visible'] = (0x0,
                  Kz['Rf'])(cd['visible'], this['visible'], iB['pd'])),
          this['height'] = (0x0,
            Kz['Rf'])(cd['height'], this['height'], iB['JW']);
      }
    }
    FeatureVolumeStyle['DefaultOptions'] = {
      'xDelta': 0.1,
      'yDelta': 0.1,
      'color': id['m']['aliceblue'],
      'visible': true,
      'height': undefined
    };
    class FeatureLabelStyle3D extends iB['PE'] {
      ['_update'] (cd, cq) {
        super['_update'](cd, cq),
          cd['volume'] && (this['volume'] && !cq ? this['volume']['update'](cd['volume']) : this['volume'] = new FeatureVolumeStyle(cd['volume']));
      }
    }
    class iO extends iB['SC'] {
      constructor(cd) {
        super(cd);
      }
      ['updateLabels'] (cd) {
        const cq = [];
        if (cd['label'] && cd['label']['length'] > 0x0) {
          for (const cJ of cd['label'])
            cq['push'](new FeatureLabelStyle3D(cJ));
        }
        this['label'] = cq;
      }
    }
    class PolylineStyle3D extends iB['Xx'] {
      constructor(cd) {
        super(cd);
      }
      ['_update'] (cd, cq) {
        super['_update'](cd, cq),
          cq ? (this['simpleLine'] = (0x0,
            iB['pd'])((0x0,
              Kz['En'])(cd['simpleLine'], PolylineStyle3D['DefaultOptions']['simpleLine'])),
            this['glowPower'] = (0x0,
              iB['JW'])((0x0,
                Kz['En'])(cd['glowPower'], PolylineStyle3D['DefaultOptions']['glowPower'])),
            this['taperPower'] = (0x0,
              iB['JW'])((0x0,
                Kz['En'])(cd['taperPower'], PolylineStyle3D['DefaultOptions']['taperPower'])),
            this['strokeWidth'] = (0x0,
              iB['JW'])((0x0,
                Kz['En'])(cd['strokeWidth'], PolylineStyle3D['DefaultOptions']['strokeWidth']))) : (this['simpleLine'] = (0x0,
                  Kz['Rf'])(cd['simpleLine'], this['simpleLine'], iB['pd']),
                  this['glowPower'] = (0x0,
                    Kz['Rf'])(cd['glowPower'], this['glowPower'], iB['JW']),
                  this['taperPower'] = (0x0,
                    Kz['Rf'])(cd['taperPower'], this['taperPower'], iB['JW']),
                  this['strokeWidth'] = (0x0,
                    Kz['Rf'])(cd['strokeWidth'], this['strokeWidth'], iB['JW'])),
          this['glowColor'] = (0x0,
            Kz['Rf'])(cd['glowColor'], this['glowColor'], iB['Jf']),
          this['dashColor'] = (0x0,
            Kz['Rf'])(cd['dashColor'], this['dashColor'], iB['Jf']),
          this['strokeColor'] = (0x0,
            Kz['Rf'])(cd['strokeColor'], this['strokeColor'], iB['Jf']);
      }
    }
    PolylineStyle3D['DefaultOptions'] = Object['assign'](Object['assign']({}, iB['Xx']['DefaultOptions']), {
      'simpleLine': false,
      'glowPower': 0.5,
      'taperPower': 0.5,
      'strokeWidth': 0x2
    });
    class ig extends iB['_7'] {
      constructor(cd) {
        super(cd);
      }
      ['_update'] (cd, cq) {
        super['_update'](cd, cq),
          cq ? (this['closeTop'] = (0x0,
            iB['pd'])((0x0,
              Kz['En'])(cd['closeTop'], ig['DefaultOptions']['closeTop'])),
            this['closeBottom'] = (0x0,
              iB['pd'])((0x0,
                Kz['En'])(cd['closeBottom'], ig['DefaultOptions']['closeBottom']))) : (this['closeTop'] = (0x0,
                  Kz['Rf'])(cd['closeTop'], this['closeTop'], iB['pd']),
                  this['closeBottom'] = (0x0,
                    Kz['Rf'])(cd['closeBottom'], this['closeBottom'], iB['pd'])),
          this['extrudeHeight'] = (0x0,
            Kz['Rf'])(cd['extrudeHeight'], this['extrudeHeight'], iB['JW']),
          this['strokeColor'] = (0x0,
            Kz['Rf'])(cd['strokeColor'], this['strokeColor'], iB['Jf']);
      }
      ['updateLineStyle'] (cd) {
        this['lineStyle'] = cd['lineStyle'] && new PolylineStyle3D(cd['lineStyle']);
      }
      ['updateLabels'] (cd) {
        const cq = [];
        if (cd['label'] && cd['label']['length'] > 0x0) {
          for (const cJ of cd['label'])
            cq['push'](new FeatureLabelStyle3D(cJ));
        }
        this['label'] = cq;
      }
    }
    ig['DefaultOptions'] = Object['assign'](Object['assign']({}, iB['_7']['DefaultOptions']), {
      'closeTop': true,
      'closeBottom': true
    });
    class FeatureStyle3D extends iB['sC'] {
      constructor(cd) {
        super(cd);
      }
      ['_update'] (cd, cq) {
        cd && (cd['point'] && (this['point'] && !cq ? this['point']['update'](cd['point']) : this['point'] = new iO(cd['point'])),
          cd['polyline'] && (this['polyline'] && !cq ? this['polyline']['update'](cd['polyline']) : this['polyline'] = new PolylineStyle3D(cd['polyline'])),
          cd['polygon'] && (this['polygon'] && !cq ? this['polygon']['update'](cd['polygon']) : this['polygon'] = new ig(cd['polygon'])));
      }
    }
    class iP extends iq['Uw'] {
      constructor(cd) {
        super(cd),
          cd || v0['kg']['error']('PointImageStyle3D缺少构造参数！', true),
          this['_update'](cd, true);
      }
      ['_update'] (cd, cq) {
        cq ? (this['textureDim'] = (0x0,
          iS['ce'])((0x0,
            Kz['En'])(cd['textureDim'], iP['DefaultOptions']['textureDim'])),
          this['size'] = (0x0,
            Kz['En'])(cd['size'], iP['DefaultOptions']['size']),
          this['scaleMax'] = (0x0,
            Kz['En'])(cd['scaleMax'], iP['DefaultOptions']['scaleMax'])) : (this['textureDim'] = (0x0,
              Kz['Rf'])(cd['textureDim'], this['textureDim'], iS['ce']),
              this['size'] = (0x0,
                Kz['Rf'])(cd['size'], this['size'], iS['ce'])),
          this['texture'] = (0x0,
            Kz['Rf'])(cd['texture'], this['texture'], iS['Rd']);
      }
      ['_createCacheId'] (cd) {
        return '0';
      }
    }
    iP['DefaultOptions'] = {
      'textureDim': [0x1, 0x1],
      'texture': undefined,
      'size': 0x20,
      'scaleMax': 0x1
    };
    class CSStyle3D extends FeatureStyle3D {
      constructor(cd) {
        cd['analysisValues'] ? super(cd) : v0['kg']['error']('分析值analysisValues必须配置！', true);
      }
      ['_update'] (cd, cq) {
        cq ? (this['analysisValues'] = (0x0,
          iB['M'])(cd['analysisValues']),
          this['withShaded'] = (0x0,
            Kz['En'])(cd['withShaded'], CSStyle3D['DefaultOptions']['withShaded'])) : (this['analysisValues'] = (0x0,
              Kz['Rf'])(cd['analysisValues'], this['analysisValues'], iB['M']),
              this['withShaded'] = (0x0,
                Kz['Rf'])(cd['withShaded'], this['withShaded'])),
          this['interpField'] = (0x0,
            Kz['Rf'])(cd['interpField'], this['interpField']),
          this['interpGridOptions'] = (0x0,
            Kz['Rf'])(cd['interpGridOptions'], this['interpGridOptions']),
          this['interpGridOptions'] && (0x0,
            KM['T'])(this['interpGridOptions']),
          this['undef'] = (0x0,
            Kz['Rf'])(cd['undef'], this['undef']),
          super['_update'](cd, cq);
      }
    }
    CSStyle3D['DefaultOptions'] = Object['assign'](Object['assign']({}, iB['sC']['DefaultOptions']), {
      'withShaded': true,
      'analysisValues': undefined
    });
    var iz = n(0x13c);
    class LayerCreator {
      constructor() {
        this['creators'] = {},
          this['providerCreators'] = {};
      }
      ['create'] (cd) {
        const cq = new this['creators'][cd['type']](cd['options']);
        cq['setDrawOptions']((0x0,
          iq['it'])(cd['style']));
        const cJ = this['createProvider'](cd['data']);
        return cq['setDataSource'](cJ),
          cq['id'] = cd['name'] || (0x0,
            Kz['hQ'])(),
          cq;
      }
      ['createProvider'] (cd) {
        if (!cd || !cd['source'] || !cd['type'])
          return;
        let cq;
        if (cd['source2']) {
          const cJ = cd
            , cC = new (0x0,
              this['providerCreators'][cJ['source']['type']])((0x0,
                iq['it'])(cJ['source']['source']), cJ['source']['options'])
            , cO = new (0x0,
              this['providerCreators'][cJ['source2']['type']])((0x0,
                iq['it'])(cJ['source2']['source']), cJ['source2']['options']);
          cq = new (0x0,
            this['providerCreators'][cJ['type']])(cC, cO, cJ['options']);
        } else {
          const cG = (0x0,
            iq['it'])(cd['source']);
          cq = new (0x0,
            this['providerCreators'][cd['type']])(cG, cd['options']);
        }
        return cq;
      }
      ['registerProviderCreator'] (cd, cq) {
        (cq = cq || cd['qeName']) || v0['kg']['error']('注册的图层创建器没有指明类型！'),
          this['providerCreators'][cq] = cd;
      }
      ['register'] (cd, cq) {
        (cq = cq || cd['qeName']) || v0['kg']['error']('注册的图层创建器没有指明类型！'),
          this['creators'][cq] = cd;
      }
    }
    function im (cd, cq, cJ) {
      const cC = cG => {
        var cg;
        const cN = null !== (cg = cG['layerCreator']) && undefined !== cg ? cg : iL
          , cP = [];
        if (cG['layers'])
          for (const cM of cG['layers']) {
            const cz = cN['create'](cM);
            cz && (cq(cz),
              cP['push'](cz));
          }
        cJ && cJ(cP);
      }
        , cO = cG => {
          var cg;
          const cN = null !== (cg = cG['resourceService']) && undefined !== cg ? cg : iz['Zc'];
          cG['resources'] ? 'string' == typeof cG['resources'] || cG['resources'] instanceof Request ? cN['loadResourceFromConfigPath'](cG['resources'])['then'](cP => {
            cC(cG);
          }
          )['catch'](v0['kg']['debug']) : cN['loadResourceFromConfig'](cG['resources'])['then'](cP => {
            cC(cG);
          }
          )['catch'](v0['kg']['debug']) : cC(cG);
        }
        ;
      'string' == typeof cd ? (0x0,
        Kz['xA'])(cd)['then'](cG => {
          cO(cG);
        }
        )['catch'](v0['kg']['debug']) : cO(cd);
    }
    const iL = new LayerCreator();
    var iR = n(0x260)
      , b0 = n(0x313);
    class Array2DGridDataProvider extends Km['r'] {
      constructor(cd, cq) {
        super(cq),
          this['gridOptions'] = this['options']['gridOptions'],
          'function' == typeof cd && (cd = cd()),
          cd || v0['kg']['error']('数据源为空！');
        let cJ = 0x0;
        undefined === this['options']['dataScale'] && undefined === this['options']['dataOffset'] || (this['options']['dataScale'] = (0x0,
          Kz['En'])(this['options']['dataScale'], 0x1),
          this['options']['dataOffset'] = (0x0,
            Kz['En'])(this['options']['dataOffset'], 0x0),
          cJ = undefined === this['options']['scaleFirst'] || this['options']['scaleFirst'] ? 0x1 : 0x2);
        const cC = new KN['P'](KP['U']['Float32'], this['gridOptions']['xSize'], this['gridOptions']['ySize'], cd, this['options']['undef'], cJ, this['options']['dataScale'] || 0x1, this['options']['dataOffset'] || 0x0);
        this['grids'] = [[cC]];
      }
    }
    Array2DGridDataProvider['qeName'] = 'g_array2d',
      iL['registerProviderCreator'](Array2DGridDataProvider);
    class CimissGridDataProvider extends Array2DGridDataProvider {
      constructor(cd, cq) {
        'string' == typeof cd && (cd = JSON['parse'](cd)),
          super(cd['DS'], Object['assign']({
            'gridOptions': {
              'xStart': cd['startLon'],
              'yStart': cd['startLat'],
              'xDelta': cd['lonStep'],
              'yDelta': cd['latStep'],
              'xSize': cd['lonCount'],
              'ySize': cd['latCount'],
              'xEnd': cd['endLon'],
              'yEnd': cd['endLat'],
              'zValues': [0x0],
              'tCount': 0x1
            }
          }, cq || {}));
      }
    }
    CimissGridDataProvider['qeName'] = 'g_cimiss',
      iL['registerProviderCreator'](CimissGridDataProvider);
    class FeatureDataProviderBase extends iT['c'] {
      constructor() {
        super(...arguments),
          this['eventNames'] = {
            'dataUpdated': 'dataUpdated'
          },
          this['meta'] = {};
      }
      ['updateFeatures'] (cd) {
        this['_updateFeatures'](cd),
          this['fire'](this['eventNames']['dataUpdated'], {
            'firer': this,
            'msg': this
          });
      }
      ['onFeaturesUpdate'] (cd) {
        return this['on'](this['eventNames']['dataUpdated'], cd),
          this;
      }
      ['offFeaturesUpdate'] (cd) {
        return this['off'](this['eventNames']['dataUpdated'], cd),
          this;
      }
      ['getMaxMin'] (cd, cq, cJ = true) {
        cq = null != cq ? cq : Kg['v']['defaultUndef'];
        const cC = this['getFeatures']()['features'];
        if (!(null == cC ? undefined : cC['length']))
          return {
            'min': undefined,
            'max': undefined
          };
        let cO = 0x1 / 0x0
          , cG = -0x1 / 0x0
          , cg = cN => false;
        cJ && (cg = cq > 0x0 ? cN => cN >= cq : cN => cN <= cq);
        for (const cN of cC) {
          const cP = cN['properties'][cd];
          cg(cP) || (cP > cG && (cG = cP),
            cP < cO && (cO = cP));
        }
        return {
          'min': cO,
          'max': cG
        };
      }
    }
    class b4 extends FeatureDataProviderBase {
      constructor(cd, cq) {
        super(),
          this['featuresMap'] = {},
          cd || v0['kg']['error']('数据源为空！'),
          this['options'] = (0x0,
            Kz['Ov'])(this['options'], cq, b4['DefaultOptions']),
          'function' == typeof cd && (cd = cd()),
          this['parseFeatures'](cd);
      }
      ['_updateFeatures'] (cd) {
        this['features'] = undefined,
          this['featuresMap'] = {},
          this['parseFeatures'](cd);
      }
      ['parseFeatures'] (cd) {
        let cq = new Array();
        const cJ = this['options']['prefix'] && this['options']['prefix']['length'] > 0x0 || this['options']['suffix'] && this['options']['suffix']['length'] > 0x0 ? (cC, cO, cG) => {
          cC[cO] = this['options']['prefix'] + cG + this['options']['suffix'];
        }
          : (cC, cO, cG) => {
            cC[cO] = cG;
          }
          ;
        for (let cC of cd) {
          let cO, cG = cC[this['options']['idField']];
          if (undefined === cG && (cG = (0x0,
            Kz['hQ'])()),
            undefined !== this['featuresMap'][cG])
            cO = this['featuresMap'][cG];
          else {
            let cg;
            if (cC[this['options']['latField']] && cC[this['options']['lonField']])
              cg = {
                'type': 'Point',
                'coordinates': [parseFloat(cC[this['options']['lonField']]), parseFloat(cC[this['options']['latField']])]
              };
            else {
              if (!this['options']['stationInfoMap'])
                throw new Error('无法获取站点经纬度信息！请确保数据中存在经纬度字段且设置了正确的名称！');
              cg = {
                'type': 'Point',
                'coordinates': [this['options']['stationInfoMap'][cG][this['options']['lonField']], this['options']['stationInfoMap'][cG][this['options']['latField']]]
              };
            }
            cO = {
              'id': cG,
              'type': 'Feature',
              'geometry': cg,
              'properties': {}
            },
              cq['push'](cO);
          }
          for (let cN in cC)
            undefined !== cO['properties'][cN] && undefined !== this['options']['mergeFunc'] ? cO['properties'][cN] = this['options']['mergeFunc'](cN, cO['properties'][cN], cC[cN]) : cJ(cO['properties'], cN, cC[cN]);
          this['featuresMap'][cG] = cO;
        }
        this['features'] = {
          'type': 'FeatureCollection',
          'features': cq
        };
      }
      ['getFeatures'] () {
        return this['features'];
      }
      ['getFeature'] (cd) {
        return this['featuresMap'][cd];
      }
    }
    b4['DefaultOptions'] = {
      'lonField': 'Lon',
      'latField': 'Lat',
      'idField': 'Station_Id_C'
    },
      b4['qeName'] = 'v_array',
      iL['registerProviderCreator'](b4);
    class CimissStationFeatureProvider extends b4 {
      constructor(cd, cq) {
        super(() => ('string' == typeof cd && (cd = JSON['parse'](cd)),
          cd['DS']), cq),
          this['headers'] = {};
        for (const cJ in cd)
          'DS' !== cJ && (this['headers'][cJ] = cd[cJ]);
        this['meta'] = this['headers'];
      }
      ['_updateFeatures'] (cd) {
        'string' == typeof cd && (cd = JSON['parse'](cd));
        for (const cq in cd)
          'DS' !== cq && (this['headers'][cq] = cd[cq]);
        super['_updateFeatures'](cd['DS']);
      }
    }
    CimissStationFeatureProvider['qeName'] = 'v_cimiss',
      iL['registerProviderCreator'](CimissStationFeatureProvider);
    class QEGridDataProvider extends Km['r'] {
      constructor(cd, cq) {
        super(cq),
          this['load'](cd);
      }
      ['getDataType'] (cd, cq) {
        switch (cd) {
          case 'Int8':
            return cq ? KP['U']['UInt8'] : KP['U']['Int8'];
          case 'Int16':
            return cq ? KP['U']['UInt16'] : KP['U']['Int16'];
          case 'Int32':
            return cq ? KP['U']['UInt32'] : KP['U']['Int32'];
          case 'Int64':
            return console['log']('Int64\x20currently\x20not\x20supported,use\x20Int32\x20instead!'),
              cq ? KP['U']['UInt32'] : KP['U']['Int32'];
          case 'Float32':
            return KP['U']['Float32'];
          case 'Float64':
            return KP['U']['Float64'];
          default:
            throw new Error('不支持的数据类型：' + cd);
        }
      }
      ['load'] (cd) {
        const cq = new BinaryReader(cd, true)
          , cJ = cq['readInt32']()
          , cC = String['fromCharCode']['apply'](null, new Uint8Array(cq['readBuffer'](cJ)));
        this['meta'] = JSON['parse'](cC),
          this['options']['meta'] && (this['meta'] = Object['assign'](Object['assign']({}, this['meta']), this['options']['meta'])),
          this['meta']['times'] = (0x0,
            Kz['En'])(this['meta']['times'], 0x1),
          (undefined === this['meta']['undef'] || isNaN(this['meta']['undef']) || null === this['meta']['undef']) && (v0['kg']['warn']('当前数据和数据解析器中均没有提供缺测值信息，将使用默认缺测值consts.defaultUndef=' + Kg['v']['defaultUndef'] + '！'),
            this['meta']['undef'] = Kg['v']['defaultUndef']),
          this['grids'] = [],
          undefined !== this['meta']['algo'] && 0x1 === parseInt(this['meta']['algo']) ? this['loadByteGrid'](cq) : this['loadOriginalGrid'](cq),
          this['gridOptions'] = {
            'xStart': this['meta']['xStart'],
            'xSize': this['meta']['xSize'],
            'xEnd': this['meta']['xEnd'],
            'yStart': this['meta']['yStart'],
            'ySize': this['meta']['ySize'],
            'yEnd': this['meta']['yEnd'],
            'zValues': this['meta']['levelList'],
            'tCount': this['meta']['times']
          },
          (0x0,
            KM['T'])(this['gridOptions']);
      }
      ['loadOriginalGrid'] (cd) {
        const cq = (cd['buffer']['byteLength'] - cd['offset']) / (this['meta']['times'] * this['meta']['levels']);
        let cJ = 0x0;
        (this['meta']['dataScale'] || this['meta']['dataOffset']) && (cJ = 0x1);
        for (let cC = 0x0; cC < this['meta']['times']; cC++) {
          const cO = [];
          for (let cG = 0x0; cG < this['meta']['levels']; cG++) {
            const cg = cd['readBuffer'](cq)
              , cN = new KN['P'](this['getDataType'](this['meta']['dataType'], this['meta']['unsigned']), this['meta']['xSize'], this['meta']['ySize'], cg, 0x1 * this['meta']['undef'], cJ, this['meta']['dataScale'] || 0x1, this['meta']['dataOffset'] || 0x0);
            cO['push'](cN);
          }
          this['grids']['push'](cO);
        }
      }
      ['loadByteGrid'] (cd) {
        const cq = (cd['buffer']['byteLength'] - cd['offset']) / (this['meta']['times'] * this['meta']['levels'])
          , cJ = this['meta']['min'] || this['meta']['vmin']
          , cC = this['meta']['max'] || this['meta']['vmax'];
        for (let cO = 0x0; cO < this['meta']['times']; cO++) {
          const cG = [];
          for (let cg = 0x0; cg < this['meta']['levels']; cg++) {
            const cN = cC[cg] - cJ[cg]
              , cP = cd['readBuffer'](cq)
              , cM = new KN['P'](this['getDataType'](this['meta']['dataType'], this['meta']['unsigned']), this['meta']['xSize'], this['meta']['ySize'], cP, 0xff, 0x1, cN / 0xfe, cJ[cg]);
            cM['undef'] = 0xff,
              cG['push'](cM);
          }
          this['grids']['push'](cG);
        }
      }
    }
    QEGridDataProvider['qeName'] = 'g_qe',
      iL['registerProviderCreator'](QEGridDataProvider);
    class GeoJSONFeatureProvider extends FeatureDataProviderBase {
      constructor(cd) {
        super(),
          this['featuresMap'] = {},
          cd || v0['kg']['warn']('数据为空！'),
          this['_updateFeatures'](cd);
      }
      ['parseFeatures'] (cd) {
        if (!cd)
          return;
        let cq;
        switch (cd['type']) {
          case 'Point':
          case 'MultiPoint':
          case 'LineString':
          case 'MultiLineString':
          case 'Polygon':
          case 'MultiPolygon':
          case 'GeometryCollection':
            return this['parseFeatures']({
              'type': 'Feature',
              'geometry': cd,
              'properties': {}
            });
          case 'Feature':
            cq = {
              'type': 'FeatureCollection',
              'features': [cd]
            };
            break;
          case 'FeatureCollection':
            cq = cd;
        }
        return cq;
      }
      ['_updateFeatures'] (cd) {
        this['featuresMap'] = {},
          this['features'] = undefined,
          this['features'] = this['parseFeatures'](cd),
          this['features'] && this['features']['features'] && this['features']['features']['forEach'](cq => {
            cq['id'] || (cq['id'] = (0x0,
              Kz['hQ'])()),
              this['featuresMap'][cq['id']] = cq;
          }
          );
      }
      ['addFeature'] (cd) {
        cd['id'] = cd['id'] || (0x0,
          Kz['hQ'])(),
          this['features']['features']['push'](cd),
          this['featuresMap'][cd['id']] = cd;
      }
      ['removeFeature'] (cd) {
        const cq = this['getFeature'](cd);
        if (cq) {
          const cJ = this['features']['features']['indexOf'](cq);
          this['features']['features']['splice'](cJ, 0x1),
            delete this['featuresMap'][cd];
        }
      }
      ['getFeatures'] () {
        return this['features'];
      }
      ['getFeature'] (cd) {
        if (this['features'])
          return this['featuresMap'][cd];
      }
    }
    GeoJSONFeatureProvider['qeName'] = 'v_geojson',
      iL['registerProviderCreator'](GeoJSONFeatureProvider);
    class MemoryWindDataProvider extends Km['r'] {
      constructor(cd, cq, cJ) {
        var cC;
        super((0x0,
          Kz['Ov'])({}, cJ, MemoryWindDataProvider['DefaultOptions'])),
          this['gridOptions'] = (null == cd ? undefined : cd['gridOptions']) || cJ['gridOptions'],
          this['defaultGrid'] = null == cJ ? undefined : cJ['defaultGrid'],
          this['meta'] = Object['assign'](Object['assign'](Object['assign']({}, null !== (cC = this['meta']) && undefined !== cC ? cC : {}), (null == cd ? undefined : cd['meta']) || {}), (null == cq ? undefined : cq['meta']) || {}),
          this['options']['isUV'] ? (this['u'] = (null == cd ? undefined : cd['allGrids']()) || [],
            this['v'] = (null == cq ? undefined : cq['allGrids']()) || [],
            this['speed'] = [],
            this['dir'] = []) : (this['speed'] = (null == cd ? undefined : cd['allGrids']()) || [],
              this['dir'] = (null == cq ? undefined : cq['allGrids']()) || [],
              this['u'] = [],
              this['v'] = []),
          !this['options']['lazyCalc'] && cd && cq && (this['options']['isUV'] ? this['parseDataByUV']() : this['parseDataBySD']()),
          this['grids'] = this[this['options']['defaultGrid'] || 'speed'];
      }
      get ['wProvider'] () {
        return this['options']['wProvider'];
      }
      ['allU'] () {
        var cd;
        return (null === (cd = this['u']) || undefined === cd ? undefined : cd['length']) || this['parseDataBySD'](),
          this['u'];
      }
      ['allV'] () {
        var cd;
        return (null === (cd = this['v']) || undefined === cd ? undefined : cd['length']) || this['parseDataBySD'](),
          this['v'];
      }
      ['allW'] () {
        var cd;
        return null === (cd = this['options']['wProvider']) || undefined === cd ? undefined : cd['allGrids']();
      }
      ['allS'] () {
        var cd;
        return (null === (cd = this['speed']) || undefined === cd ? undefined : cd['length']) || this['parseDataByUV'](),
          this['speed'];
      }
      ['allD'] () {
        var cd;
        return (null === (cd = this['dir']) || undefined === cd ? undefined : cd['length']) || this['parseDataByUV'](),
          this['dir'];
      }
      ['addUV'] (cd, cq, cJ, cC, cO, cG) {
        if (this['lock'](),
          this['addGridTo'](cd, cJ, cC, cO, cG, this['u']),
          this['addGridTo'](cq, cJ, cC, cO, cG, this['v']),
          !this['options']['lazyCalc']) {
          const cg = this['parseSingleGridByUV'](cd, cq, cd['xSize'] * cd['ySize']);
          this['addGridTo'](cg[0x0], cJ, cC, cO, cG, this['speed']),
            this['addGridTo'](cg[0x1], cJ, cC, cO, cG, this['dir']);
        }
        return this['unlock'](),
          this;
      }
      ['addSD'] (cd, cq, cJ, cC, cO, cG) {
        if (!this['options']['lazyCalc']) {
          const cg = this['parseSingleGridBySD'](cd, cq, cd['xSize'] * cd['ySize']);
          this['addGridTo'](cg[0x0], cJ, cC, cO, cG, this['u']),
            this['addGridTo'](cg[0x1], cJ, cC, cO, cG, this['v']);
        }
        this['lock'](),
          this['addGridTo'](cd, cJ, cC, cO, cG, this['speed']),
          this['addGridTo'](cq, cJ, cC, cO, cG, this['dir']),
          this['unlock']();
      }
      ['parseSingleGridByUV'] (cd, cq, cJ) {
        const cC = new KN['P'](KP['U']['Float32'], this['gridOptions']['xSize'], this['gridOptions']['ySize'], undefined, cd['undef'])
          , cO = new KN['P'](KP['U']['Float32'], this['gridOptions']['xSize'], this['gridOptions']['ySize'], undefined, cd['undef']);
        for (let cG = 0x0; cG < cJ; cG++) {
          const cg = cd['read1D'](cG);
          if (cd['isUndef'](cg)) {
            cC['write1D'](cG, cd['undef']),
              cO['write1D'](cG, cd['undef']);
            continue;
          }
          const cN = cq['read1D'](cG);
          if (cq['isUndef'](cN)) {
            cC['write1D'](cG, cd['undef']),
              cO['write1D'](cG, cd['undef']);
            continue;
          }
          const cP = (0x0,
            Kz['C8'])([cd['read1D'](cG), cq['read1D'](cG)]);
          cC['write1D'](cG, cP[0x0]),
            cO['write1D'](cG, cP[0x1]);
        }
        return [cC, cO];
      }
      ['parseDataByUV'] () {
        const cd = []
          , cq = []
          , cJ = this['gridOptions']['ySize'] * this['gridOptions']['xSize'];
        for (let cC = 0x0; cC < this['u']['length']; cC++) {
          const cO = this['u'][cC]
            , cG = this['v'][cC]
            , cg = []
            , cN = [];
          for (let cP = 0x0; cP < cO['length']; cP++) {
            const cM = cO[cP]
              , cz = cG[cP]
              , cQ = this['parseSingleGridByUV'](cM, cz, cJ);
            cg['push'](cQ[0x0]),
              cN['push'](cQ[0x1]);
          }
          cd['push'](cg),
            cq['push'](cN);
        }
        this['speed'] = cd,
          this['dir'] = cq;
      }
      ['parseSingleGridBySD'] (cd, cq, cJ) {
        const cC = new KN['P'](KP['U']['Float32'], this['gridOptions']['xSize'], this['gridOptions']['ySize'], undefined, cd['undef'])
          , cO = new KN['P'](KP['U']['Float32'], this['gridOptions']['xSize'], this['gridOptions']['ySize'], undefined, cd['undef']);
        for (let cG = 0x0; cG < cJ; cG++) {
          const cg = cd['read1D'](cG);
          if (cd['isUndef'](cg)) {
            cC['write1D'](cG, cd['undef']),
              cO['write1D'](cG, cd['undef']);
            continue;
          }
          const cN = cq['read1D'](cG);
          if (cq['isUndef'](cN)) {
            cC['write1D'](cG, cd['undef']),
              cO['write1D'](cG, cd['undef']);
            continue;
          }
          const cP = (0x0,
            Kz['Hn'])([cd['read1D'](cG), cq['read1D'](cG)]);
          cC['write1D'](cG, cP[0x0]),
            cO['write1D'](cG, cP[0x1]);
        }
        return [cC, cO];
      }
      ['parseDataBySD'] () {
        const cd = []
          , cq = []
          , cJ = this['gridOptions']['ySize'] * this['gridOptions']['xSize'];
        for (let cC = 0x0; cC < this['speed']['length']; cC++) {
          const cO = this['speed'][cC]
            , cG = this['dir'][cC]
            , cg = []
            , cN = [];
          for (let cP = 0x0; cP < cO['length']; cP++) {
            const cM = cO[cP]
              , cz = cG[cP]
              , cQ = this['parseSingleGridBySD'](cM, cz, cJ);
            cg['push'](cQ[0x0]),
              cN['push'](cQ[0x1]);
          }
          cd['push'](cg),
            cq['push'](cN);
        }
        this['u'] = cd,
          this['v'] = cq;
      }
      ['getDimLevel'] (cd, cq) {
        return {
          'dim': undefined === cd ? this['getIntTIdx']() : parseInt(cd),
          'level': undefined === cq ? this['getIntZIdx']() : parseInt(cq)
        };
      }
      ['getUV'] (cd, cq, cJ, cC) {
        var cO;
        (null === (cO = this['u']) || undefined === cO ? undefined : cO['length']) || this['parseDataBySD']();
        const cG = this['getDimLevel'](cJ, cC)
          , cg = this['u'][cG['dim']][cG['level']]
          , cN = this['v'][cG['dim']][cG['level']];
        let cP = this['speed'][0x0][0x0]['getPos'](cd, cq);
        return [cg['read1D'](cP), cN['read1D'](cP)];
      }
      ['getSD'] (cd, cq, cJ, cC) {
        var cO;
        (null === (cO = this['speed']) || undefined === cO ? undefined : cO['length']) || this['parseDataByUV']();
        const cG = this['getDimLevel'](cJ, cC)
          , cg = this['speed'][cG['dim']][cG['level']]
          , cN = this['dir'][cG['dim']][cG['level']];
        let cP = this['speed'][0x0][0x0]['getPos'](cd, cq);
        return [cg['read1D'](cP), cN['read1D'](cP)];
      }
      ['getU'] (cd, cq) {
        var cJ;
        (null === (cJ = this['u']) || undefined === cJ ? undefined : cJ['length']) || this['parseDataBySD']();
        const cC = this['getDimLevel'](cd, cq);
        return this['u'][cC['dim']][cC['level']];
      }
      ['getV'] (cd, cq) {
        var cJ;
        (null === (cJ = this['v']) || undefined === cJ ? undefined : cJ['length']) || this['parseDataBySD']();
        const cC = this['getDimLevel'](cd, cq);
        return this['v'][cC['dim']][cC['level']];
      }
      ['getW'] (cd, cq) {
        if (!this['options']['wProvider'])
          throw new Error('当前未提供垂直速度分量！');
        const cJ = this['getDimLevel'](cd, cq);
        return this['options']['wProvider']['getGrid'](cJ['dim'], cJ['level']);
      }
      ['getS'] (cd, cq) {
        var cJ;
        (null === (cJ = this['speed']) || undefined === cJ ? undefined : cJ['length']) || this['parseDataByUV']();
        const cC = this['getDimLevel'](cd, cq);
        return this['speed'][cC['dim']][cC['level']];
      }
      ['getD'] (cd, cq) {
        var cJ;
        (null === (cJ = this['dir']) || undefined === cJ ? undefined : cJ['length']) || this['parseDataByUV']();
        const cC = this['getDimLevel'](cd, cq);
        return this['dir'][cC['dim']][cC['level']];
      }
      ['getGrid'] (cd, cq) {
        const cJ = this['getDimLevel'](cd, cq);
        return this['allGrids']()[cJ['dim']][cJ['level']];
      }
      ['allGrids'] () {
        var cd, cq, cJ, cC, cO;
        if (!(null === (cd = this['grids']) || undefined === cd ? undefined : cd['length'])) {
          let cG;
          'dir' === this['options']['defaultGrid'] ? ((null === (cq = this['dir']) || undefined === cq ? undefined : cq['length']) || this['parseDataByUV'](),
            cG = this['dir']) : 'speed' === this['options']['defaultGrid'] ? ((null === (cJ = this['speed']) || undefined === cJ ? undefined : cJ['length']) || this['parseDataByUV'](),
              cG = this['speed']) : 'u' === this['options']['defaultGrid'] ? ((null === (cC = this['u']) || undefined === cC ? undefined : cC['length']) || this['parseDataBySD'](),
                cG = this['u']) : ((null === (cO = this['v']) || undefined === cO ? undefined : cO['length']) || this['parseDataBySD'](),
                  cG = this['v']),
            this['grids'] = cG;
        }
        return this['grids'];
      }
    }
    MemoryWindDataProvider['DefaultOptions'] = {
      'isUV': true,
      'lazyCalc': false,
      'meta': {},
      'defaultGrid': 'speed'
    },
      MemoryWindDataProvider['qeName'] = 'g_wind',
      iL['registerProviderCreator'](MemoryWindDataProvider);
    class MicapsDiamond4GridDataProvider extends Array2DGridDataProvider {
      constructor(cd, cq) {
        const cJ = (cd = cd['replaceAll']('\x0a', '\x20')['replaceAll']('\x0d', '\x20'))['split'](/\s+/);
        for (; 0x0 === cJ[0x0]['trim']()['length'];)
          cJ['shift']();
        for (; 0x0 === cJ[cJ['length'] - 0x1]['trim']()['length'];)
          cJ['pop']();
        const cC = {
          'xStart': Number(cJ[0xb]),
          'xEnd': Number(cJ[0xc]),
          'yStart': Number(cJ[0xd]),
          'yEnd': Number(cJ[0xe]),
          'xDelta': Number(cJ[0x9]),
          'yDelta': Number(cJ[0xa]),
          'xSize': Number(cJ[0xf]),
          'ySize': Number(cJ[0x10])
        }
          , cO = cJ['splice'](0x0, 0x16);
        super(cJ, Object['assign']({
          'gridOptions': cC
        }, cq)),
          this['headers'] = cO,
          this['meta'] = this['headers'];
      }
    }

    class MicapsDiamond131GridDataProvider extends Km['r'] {
      constructor(cd, cq) {
        super((0x0,
          Kz['Ov'])({}, cq, MicapsDiamond131GridDataProvider['DefaultOptions'])),
          this['_decoder'] = new TextDecoder()

        this['_load'](cd);
      }
      ['_readString'] (cd, cq) {
        return this['_decoder']['decode'](cd['readBuffer'](cq))['replace'](/\0/g, '')['trim']();
      }
      ['_load'] (cd) {
        const cq = new BinaryReader(cd, true);
        this['meta'] = {},
          this['meta']['zoneName'] = this['_readString'](cq, 0xc),
          this['meta']['dataName'] = this['_readString'](cq, 0x26);
        let cJ = this['_readString'](cq, 0x8)['toLowerCase']()
          , cC = '1.5';
        'swan' !== cJ ? (cJ = 'old',
          cC = '1.0',
          cq['seek'](cq['offset'] - 0x8)) : cC = this['_readString'](cq, 0x8),
          this['meta']['version'] = cC,
          this['meta']['year'] = cq['readUint16'](),
          this['meta']['month'] = cq['readUint16'](),
          this['meta']['day'] = cq['readUint16'](),
          this['meta']['hour'] = cq['readUint16'](),
          this['meta']['minute'] = cq['readUint16'](),
          this['meta']['interval'] = cq['readUint16'](),
          this['meta']['xNumGrids'] = cq['readUint16'](),
          this['meta']['yNumGrids'] = cq['readUint16'](),
          this['meta']['zNumGrids'] = cq['readUint16'](),
          this['meta']['radarCount'] = cq['readInt32'](),
          this['meta']['startLon'] = Number(cq['readFloat32']()['toPrecision'](0x6)),
          this['meta']['startLat'] = Number(cq['readFloat32']()['toPrecision'](0x6)),
          this['meta']['centerLon'] = Number(cq['readFloat32']()['toPrecision'](0x6)),
          this['meta']['centerLat'] = Number(cq['readFloat32']()['toPrecision'](0x6)),
          this['meta']['xReso'] = Number(cq['readFloat32']()['toPrecision'](0x6)),
          this['meta']['yReso'] = Number(cq['readFloat32']()['toPrecision'](0x6));
        let cO = [];
        for (let cm = 0x0; cm < 0x28; cm++) {
          const cL = cq['readFloat32']();
          cL > 0x0 && cO['push'](cL);
        }
        0x0 === cO['length'] ? cO = [0x0] : this['options']['isZUnitKM'] && (cO = cO['map'](cR => 0x3e8 * cR));
        let cG = 0x0;
        'swan' === cJ && (cG = 0x2f0),
          cq['skip'](cG);
        const cg = this['meta']['xNumGrids'] * this['meta']['yNumGrids']
          , cN = cg * this['meta']['zNumGrids']
          , cP = cq['buffer']['byteLength'] - cN
          , cM = (cq['buffer']['byteLength'] - cP) / (cg * this['meta']['zNumGrids'])
          , cz = cg * cM;
        this['gridOptions'] = {
          'xStart': this['meta']['startLon'],
          'xSize': this['meta']['xNumGrids'],
          'xDelta': this['meta']['xReso'],
          'yStart': this['meta']['startLat'],
          'ySize': this['meta']['yNumGrids'],
          'yDelta': -this['meta']['yReso'],
          'zValues': cO,
          'tCount': 0x1
        },
          (0x0,
            KM['T'])(this['gridOptions']);
        const cQ = 0x1 === cM ? KP['U']['UInt8'] : KP['U']['Int16'];
        this['grids'] = [[]];
        for (let cR = 0x0; cR < cO['length']; cR++) {
          const H0 = cq['readBuffer'](cz)
          const H1 = new KN['P'](cQ, this['gridOptions']['xSize'], this['gridOptions']['ySize'], H0, 0x1 === cM ? 0xff : 0x270f, 0x2, 0x1 === cM ? 0.5 : 0x1, 0x1 === cM ? -0x42 : 0x0);
          this['grids'][0x0]['push'](H1);
        }
      }
      //mars3d 增加 2024-12-29
      toJSON () {
        let gridData = []
        for (let i = 0; i < this.grids[0].length; i++) {
          let grid = this.grids[0][i]
          gridData.push(Array.from(grid.raw))
        }
        return {
          grids: gridData,
          options: this.gridOptions
        }
      }
    }
    MicapsDiamond131GridDataProvider['DefaultOptions'] = {
      'isZUnitKM': true
    };
    function arrayToArrayBuffer (array) {
      const buffer = new ArrayBuffer(array.length);
      const view = new Uint8Array(buffer);
      for (let i = 0; i < array.length; i++) {
        view[i] = array[i];  // 遍历数组，并将每个元素的值复制到视图中
      }
      return buffer;
    }

    //mars3d 增加 2024-12-29
    class JsonGridDataProvider extends Km['r'] {
      constructor(cd, cq) {
        super((0x0, Kz['Ov'])({}, cq, JsonGridDataProvider['DefaultOptions']))
        this._load(cd);
      }
      _load (data) {
        this.gridOptions = data.options

        let cM = 1
        this.grids = [[]];
        for (let i = 0x0; i < data.grids.length; i++) {
          let grid = arrayToArrayBuffer(data.grids[i])

          const H1 = new KN['P'](
            cM,
            this.gridOptions.xSize,
            this.gridOptions.ySize,
            grid,
            0x1 === cM ? 0xff : 0x270f,
            0x2,
            0x1 === cM ? 0.5 : 0x1, 0x1 === cM ? -0x42 : 0x0
          );
          this.grids[0].push(H1);
        }
      }
    }
    JsonGridDataProvider['DefaultOptions'] = {
      'isZUnitKM': true
    };


    class BinaryGridDataProvider extends Km['r'] {
      constructor(cd, cq) {
        super(cq),
          this['load'](cd);
      }
      ['load'] (cd) {
        let cq = this['parseBinaryToGridDatas'](cd);
        this['gridOptions'] = this['getGridOptionsFromGridMetaInfo'](cq['metaInfo']),
          this['grids'] = cq['martixData'];
      }
      ['parseBinaryToGridDatas'] (cd) {
        if (undefined === cd)
          return;
        let cq = new Uint8Array(cd['slice'](0x0, 0xc))
          , cJ = String['fromCharCode']['apply'](null, cq)
          , cC = parseInt(String['fromCharCode']['apply'](null, new Uint8Array(cd['slice'](0xc, 0x14))))
          , cO = String['fromCharCode']['apply'](null, new Uint8Array(cd['slice'](0x14, cC)))['split'](',')
          , cG = {};
        for (let cQ of cO) {
          let cm = cQ['split']('=');
          cG[cm[0x0]] = cm[0x1];
        }
        let cg = {
          'productId': cG['ProductId'],
          'productTitle': cG['ProductTitle'],
          'year': parseInt(cG['Year']),
          'month': parseInt(cG['Month']),
          'day': parseInt(cG['Day']),
          'hour': parseInt(cG['Hour']),
          'minute': parseInt(cG['Minute']),
          'second': parseInt(cG['Second']),
          'forecast': cG['Forecast'],
          'width': parseInt(cG['Width']),
          'height': parseInt(cG['Height']),
          'dimension': parseInt(cG['Dimension']),
          'levels': parseInt(cG['Levels']),
          'left': parseFloat(cG['Left']),
          'right': parseFloat(cG['Right']),
          'top': parseFloat(cG['Top']),
          'bottom': parseFloat(cG['Bottom']),
          'resolutionX': parseFloat(cG['Resolution_x']),
          'resolutionY': parseFloat(cG['Resolution_y']),
          'resolutionCell': parseFloat(cG['ResolutionCell']),
          'dataType': parseInt(cG['DataType']),
          'levelValue': cG['LevelValue'] && cG['LevelValue']['split'](';'),
          'levelUnit': cG['LevelUnit'],
          'machine': cG['Machine'],
          'storage': cG['Storage'],
          'coordinateion': cG['Coordination'],
          'palette': cG['Palette'],
          'siteCode': cG['SiteCode'] && cG['SiteCode']['split'](';'),
          'invalid': parseFloat(cG['Invalid']),
          'offset': parseFloat(cG['Offset']),
          'ratio': parseFloat(cG['Ratio'])
        };
        this['meta'] = cg;
        let cN = this['getDataSizeFromBinaryType'](cg['dataType'])
          , cP = cg['width'] * cg['height'] * cN
          , cM = cC
          , cz = [];
        for (let cL = 0x0; cL < cg['dimension']; cL++) {
          cz[cL] = [];
          for (let cR = 0x0; cR < cg['levels']; cR++) {
            let H0 = cd['slice'](cM, cM + cP)
              , H1 = new KN['P'](this['getDataTypeFromBinaryType'](cg['dataType']), cg['width'], cg['height'], H0, cg['invalid'], 0x1, cg['ratio'], cg['offset']);
            H1['undef'] = cg['invalid'],
              cM += cP,
              cz[cL][cR] = H1;
          }
        }
        return {
          'fileId': cJ,
          'dataAddr': cC,
          'metaInfo': cg,
          'sourceMetaInfo': cG,
          'martixData': cz
        };
      }
      ['getDataSizeFromBinaryType'] (cd) {
        switch (cd) {
          case 0x0:
            return console['warn']('当前不支持char类型，会被当作uint8解析'),
              Uint8Array['BYTES_PER_ELEMENT'];
          case 0x3:
            return Uint8Array['BYTES_PER_ELEMENT'];
          case 0x1:
            return Int16Array['BYTES_PER_ELEMENT'];
          case 0x2:
            return Int32Array['BYTES_PER_ELEMENT'];
          case 0x4:
            return Uint16Array['BYTES_PER_ELEMENT'];
          case 0x5:
            return Uint32Array['BYTES_PER_ELEMENT'];
          case 0x6:
            return Float32Array['BYTES_PER_ELEMENT'];
          case 0x7:
            return Float64Array['BYTES_PER_ELEMENT'];
        }
      }
      ['getDataTypeFromBinaryType'] (cd) {
        switch (cd) {
          case 0x0:
            return console['warn']('当前不支持char类型，会被当作uint8解析'),
              KP['U']['UInt8'];
          case 0x3:
            return KP['U']['UInt8'];
          case 0x1:
            return KP['U']['Int16'];
          case 0x2:
            return KP['U']['Int32'];
          case 0x4:
            return KP['U']['UInt16'];
          case 0x5:
            return KP['U']['UInt32'];
          case 0x6:
            return KP['U']['Float32'];
          case 0x7:
            return KP['U']['Float64'];
        }
      }
      ['getGridOptionsFromGridMetaInfo'] (cd) {
        var cq;
        let cJ = [0x0];
        return cd['levelValue'] && (cJ = null === (cq = cd['levelValue']) || undefined === cq ? undefined : cq['map'](cC => parseFloat(cC))),
        {
          'xStart': cd['left'],
          'xEnd': cd['right'],
          'yStart': cd['top'],
          'yEnd': cd['bottom'],
          'xSize': cd['width'],
          'ySize': cd['height'],
          'xDelta': cd['left'] < cd['right'] ? Math['abs'](cd['resolutionX']) : -Math['abs'](cd['resolutionX']),
          'yDelta': cd['bottom'] > cd['top'] ? Math['abs'](cd['resolutionY']) : -Math['abs'](cd['resolutionY']),
          'tCount': this['grids']['length'],
          'zValues': cJ
        };
      }
    }
    var DataAnimationType, bK = function (cd, cq, cJ, cC) {
      return new (cJ || (cJ = Promise))(function (cO, cG) {
        function cg (cM) {
          try {
            cP(cC['next'](cM));
          } catch (cz) {
            cG(cz);
          }
        }
        function cN (cM) {
          try {
            cP(cC['throw'](cM));
          } catch (cz) {
            cG(cz);
          }
        }
        function cP (cM) {
          var cz;
          cM['done'] ? cO(cM['value']) : (cz = cM['value'],
            cz instanceof cJ ? cz : new cJ(function (cQ) {
              cQ(cz);
            }
            ))['then'](cg, cN);
        }
        cP((cC = cC['apply'](cd, cq || []))['next']());
      }
      );
    };
    window['GeoTIFF'] || (v0['kg']['debug']('未能找到GeoTIFF库，GeoTIFF数据解析器将不可用！'),
      window['GeoTIFF'] = {});
    class bb extends Km['r'] {
      constructor(cd, cq) {
        super(cq),
          this['getDataType'] = cJ => {
            switch (cJ['constructor']['name']) {
              case 'Int8Array':
                return KP['U']['Int8'];
              case 'Uint8Array':
                return KP['U']['UInt8'];
              case 'Int16Array':
                return KP['U']['Int16'];
              case 'Uint16Array':
                return KP['U']['UInt16'];
              case 'Int32Array':
                return KP['U']['Int32'];
              case 'Uint32Array':
                return KP['U']['UInt32'];
              case 'Float32Array':
                return KP['U']['Float32'];
              case 'Float64Array':
                return KP['U']['Float64'];
              default:
                throw new Error('不支持的数据类型：' + cJ['constructor']['name']);
            }
          }
          ,
          this['load'] = (cJ, cC) => {
            var cO;
            this['gridOptions'] = cC['gridOptions'],
              (0x0,
                KM['T'])(this['gridOptions']);
            let cG = [];
            const cg = this['getDataType'](cJ[0x0])
              , cN = cC['undef'] ? cC['undef'] : Kg['v']['defaultUndef']
              , cP = new KN['P'](cg, this['gridOptions']['xSize'], this['gridOptions']['ySize'], cJ[0x0], cN);
            cP['useAccurateUndef'] = null !== (cO = cC['useAccurateUndef']) && undefined !== cO && cO,
              cG['push'](cP),
              this['grids']['push'](cG);
          }
          ,
          this['load'](cd, cq);
      }
      static ['fromUrl'] (cd, cq = {}) {
        return bK(this, undefined, undefined, function* () {
          const cJ = yield (0x0,
            Kz['oT'])(cd);
          return bb['fromBuffer'](cJ, cq);
        });
      }
    }
    bb['readTifBuffer'] = cd => bK(undefined, undefined, undefined, function* () {
      const cq = yield window['GeoTIFF']['fromArrayBuffer'](cd)
        , cJ = yield cq['getImage']()
        , cC = cJ['getResolution']()
        , cO = cJ['getOrigin']()
        , cG = cJ['getWidth']()
        , cg = cJ['getHeight']();
      return {
        'options': {
          'xStart': cO[0x0],
          'yStart': cO[0x1],
          'xDelta': cC[0x0],
          'yDelta': cC[0x1],
          'xSize': cG,
          'ySize': cg
        },
        'data': yield cJ['readRasters']()
      };
    }),
      bb['fromBuffer'] = (cd, cq = {}) => bK(undefined, undefined, undefined, function* () {
        return bb['readTifBuffer'](cd)['then'](cJ => (cq['gridOptions'] = cq['gridOptions'] || cJ['options'],
          new bb(cJ['data'], cq)))['catch'](cJ => { }
          );
      }),
      bb['qeName'] = 'g_tif';
    class MicapsDiamond14FeatureProvider extends FeatureDataProviderBase {
      constructor(cd, cq) {
        super(),
          this['featuresMap'] = {},
          this['_parseFeatures'](cd);
      }
      ['_updateFeature'] (cd) {
        this['features']['features']['push'](cd),
          this['featuresMap'][cd['id']] = cd;
      }
      ['_parseClosedContours'] (cd) {
        let cq = cd['indexOf']('CLOSED_CONTOURS:');
        if (cq < 0x0)
          return;
        cq++;
        const cJ = parseInt(cd[cq++]);
        for (let cC = 0x0; cC < cJ; cC++) {
          const cO = cd[cq++]
            , cG = parseInt(cd[cq++]);
          if (0x0 === cG)
            continue;
          const cg = [];
          for (let cz = 0x0; cz < cG; cz++) {
            const cQ = parseFloat(cd[cq++])
              , cm = parseFloat(cd[cq++]);
            cg['push']([cQ, cm]),
              cq++;
          }
          const cN = cd[cq++]
            , cP = {
              'type': 'Feature',
              'geometry': {
                'type': 'Polygon',
                'coordinates': [cg]
              },
              'properties': {
                'value': cN,
                'width': cO
              },
              'id': (0x0,
                Kz['hQ'])()
            };
          this['_updateFeature'](cP);
          const cM = parseInt(cd[cq++]);
          if (cM > 0x0)
            for (let cL = 0x0; cL < cM; cL++) {
              const cR = parseFloat(cd[cq++])
                , H0 = parseFloat(cd[cq++]);
              cq++;
              const H1 = {
                'type': 'Feature',
                'geometry': {
                  'type': 'Point',
                  'coordinates': [cR, H0]
                },
                'properties': {
                  'value': cN
                },
                'id': (0x0,
                  Kz['hQ'])()
              };
              this['_updateFeature'](H1);
            }
        }
      }
      ['_parseFeatures'] (cd) {
        this['features'] = {
          'type': 'FeatureCollection',
          'features': []
        },
          this['featuresMap'] = {};
        const cq = (cd = cd['replaceAll']('\x0a', '\x20')['replaceAll']('\x0d', '\x20'))['split'](/\s+/);
        for (; 0x0 === cq[0x0]['trim']()['length'];)
          cq['shift']();
        for (; 0x0 === cq[cq['length'] - 0x1]['trim']()['length'];)
          cq['pop']();
        if (cq['length'] < 0x8 || 'diamond' !== cq[0x0] || '14' !== cq[0x1])
          throw new Error('当前文件不是Micaps\x2014类数据！');
        this['meta']['title'] = cq[0x2],
          this['meta']['year'] = 0x2 === cq[0x3]['length'] ? parseInt(cq[0x3]) + 0x7d0 : parseInt(cq[0x3]),
          this['meta']['mon'] = parseInt(cq[0x4]),
          this['meta']['day'] = parseInt(cq[0x5]),
          this['meta']['hour'] = parseInt(cq[0x6]),
          this['meta']['time'] = new Date(this['meta']['year'], this['meta']['mon'] - 0x1, this['meta']['day'], this['meta']['hour']),
          this['meta']['period'] = parseInt(cq[0x7]),
          this['_parseClosedContours'](cq);
      }
      ['_updateFeatures'] (cd) {
        this['_parseFeatures'](cd);
      }
      ['getFeatures'] () {
        return this['features'];
      }
      ['getFeature'] (cd) {
        return this['featuresMap'][cd];
      }
    }
    MicapsDiamond14FeatureProvider['qeName'] = 'v_diamond14';
    class bH extends FeatureDataProviderBase {
      constructor(cd) {
        super(),
          this['featuresMap'] = {},
          this['options'] = (0x0,
            Kz['Ov'])({}, cd, bH['DefaultOptions']),
          this['_generateFeatures']();
      }
      ['_generateFeatures'] () {
        const cd = this['options'];
        cd['extent'] || v0['kg']['error']('需要提供随机数的生成范围！', true);
        let cq = () => [(0x0,
          Kz['Zu'])(cd['extent']['minLon'], cd['extent']['maxLon']), (0x0,
            Kz['Zu'])(cd['extent']['minLat'], cd['extent']['maxLat'])];
        (0x0,
          Kz['ri'])(cd['extent']['minHeight']) && (0x0,
            Kz['ri'])(cd['extent']['maxHeight']) && (cq = () => [(0x0,
              Kz['Zu'])(cd['extent']['minLon'], cd['extent']['maxLon']), (0x0,
                Kz['Zu'])(cd['extent']['minLat'], cd['extent']['maxLat']), (0x0,
                  Kz['Zu'])(cd['extent']['minHeight'], cd['extent']['maxHeight'])]),
          this['featuresMap'] = {},
          this['features'] = {
            'type': 'FeatureCollection',
            'features': []
          },
          cd['fields'] && cd['fields']['forEach'](cJ => {
            var cC, cO, cG;
            cJ['randomMax'] = null !== (cC = cJ['randomMax']) && undefined !== cC ? cC : 0x64,
              cJ['randomMin'] = null !== (cO = cJ['randomMin']) && undefined !== cO ? cO : 0x0,
              cJ['valueMode'] = null !== (cG = cJ['valueMode']) && undefined !== cG ? cG : 'random';
          }
          );
        for (let cJ = 0x0; cJ < cd['count']; cJ++) {
          const cC = cq()
            , cO = {
              'fid': 'qe_' + cJ
            };
          if (cd['fields']) {
            for (let cg = 0x0; cg < cd['fields']['length']; cg++)
              this['_updateField'](cJ, cd['fields'][cg], cO);
          }
          const cG = {
            'type': 'Feature',
            'geometry': {
              'type': 'Point',
              'coordinates': cC
            },
            'properties': cO
          };
          this['featuresMap'][cO['fid']] = cG,
            this['features']['features']['push'](cG);
        }
      }
      ['_updateField'] (cd, cq, cJ) {
        var cC;
        let cO;
        if ('list' === cq['valueMode']) {
          (null === (cC = cq['valueList']) || undefined === cC ? undefined : cC['length']) || v0['kg']['error']('随时数生成模式为list时，需要提供valueList候选项！', true);
          const cG = parseInt(Math['random']() * cq['valueList']['length']);
          cO = cq['valueList'][cG];
        } else
          cO = (0x0,
            Kz['Zu'])(cq['randomMin'], cq['randomMax']);
        cq['postProcessor'] && (cO = cq['postProcessor'](cO, cd)),
          cJ[cq['name']] = cO;
      }
      ['_updateFeatures'] (cd) {
        this['options'] = (0x0,
          Kz['Ov'])({}, cd, bH['DefaultOptions']),
          this['_generateFeatures']();
      }
      ['getFeatures'] () {
        return this['features'];
      }
      ['getFeature'] (cd) {
        return this['featuresMap'][cd];
      }
    }
    bH['DefaultOptions'] = {
      'count': 0x3e8,
      'extent': undefined
    };
    class MicapsDiamond2WindGridProvider extends MemoryWindDataProvider {
      constructor(cd, cq) {
        if (!(null == cq ? undefined : cq['gridOptions']))
          throw new Error('该provider必须传入格点参数信息');
        (0x0,
          KM['T'])(cq['gridOptions']);
        const { s: cJ, d: cC } = MicapsDiamond2WindGridProvider['_getSDProvider'](cd, cq['gridOptions']);
        super(cJ, cC, Object['assign']({
          'isUV': false
        }, cq));
      }
      static ['_getSDProvider'] (cd, cq) {
        const cJ = cd['replaceAll']('\x0a', '\x20')['replaceAll']('\x0d', '\x20')['split'](/\s+/);
        for (; 0x0 === cJ[0x0]['trim']()['length'];)
          cJ['shift']();
        for (; 0x0 === cJ[cJ['length'] - 0x1]['trim']()['length'];)
          cJ['pop']();
        const cC = cJ['splice'](0x0, 0x9)
          , cO = new KN['P'](KP['U']['Float32'], cq['xSize'], cq['ySize'], undefined, 0x270f)
          , cG = new KN['P'](KP['U']['Float32'], cq['xSize'], cq['ySize'], undefined, 0x270f)
          , cg = Number(cC[cC['length'] - 0x1]);
        for (let cN = 0x0; cN < cg; cN++)
          cO['write1D'](cN, Number(cJ[0xa * cN + 0x9])),
            cG['write1D'](cN, Number(cJ[0xa * cN + 0x8]));
        return {
          's': new iu['o']([[cO]], {
            'gridOptions': cq
          }),
          'd': new iu['o']([[cG]], {
            'gridOptions': cq
          })
        };
      }
    }
    !function (cd) {
      cd[cd['Time'] = 0x0] = 'Time',
        cd[cd['Level'] = 0x1] = 'Level';
    }(DataAnimationType || (DataAnimationType = {}));
    class DataAnimationService extends iT['c'] {
      constructor(cd, cq) {
        super(),
          this['paused'] = 0x0,
          undefined === cq['all'] && v0['kg']['error']('动画的最大长度未设置！'),
          this['dataSources'] = cd instanceof Array ? cd : [cd],
          this['options'] = (0x0,
            Kz['Ov'])({}, cq, DataAnimationService['DefaultOptions']),
          !this['options']['layer'] || this['options']['layer'] instanceof Array || (this['options']['layer'] = [this['options']['layer']]),
          this['setAnimationFunc']();
      }
      ['setAnimationFunc'] () {
        this['options']['useTimer'] ? (this['startFunc'] = setInterval['bind'](window),
          this['stopFunc'] = clearInterval['bind'](window)) : (this['startFunc'] = requestAnimationFrame['bind'](window),
            this['stopFunc'] = cancelAnimationFrame['bind'](window));
      }
      ['setInterval'] (cd) {
        this['options']['useTimer'] ? this['animationId'] ? v0['kg']['warn']('当前正在动画中，无法设置动画间隔！') : this['options']['timerInterval'] = cd : v0['kg']['warn']('当前没有使用间隔方式渲染！');
      }
      ['setLoop'] (cd) {
        this['options']['loop'] = cd;
      }
      ['setDelta'] (cd) {
        this['options']['delta'] = cd;
      }
      ['start'] () {
        var cd;
        if (this['animationId'])
          return void v0['kg']['warn']('当前处于动画中，请先停止播放！');
        let cq = this['options']['all'] - this['options']['delta'];
        const cJ = Math['min'](Math['max'](null !== (cd = this['options']['fromIdx']) && undefined !== cd ? cd : 0x0, 0x0), this['options']['all'] - 0x2);
        (0x0,
          Kz['ri'])(this['options']['toIdx']) && (this['options']['toIdx'] <= cJ && v0['kg']['error']('暂不支持toIdx<=fromIdx的播放模式'),
            cq = Math['max'](Math['min'](this['options']['toIdx'] + 0x1, this['options']['all']), 0x2) - this['options']['delta']);
        const cC = this['options']['type'] === DataAnimationType['Level'] ? 'currentZIdx' : 'currentTIdx'
          , cO = () => {
            if (!(this['paused'] > 0x0)) {
              if (this['dataSources'][0x0][cC] < cJ && this['dataSources']['forEach'](cG => cG[cC] = cJ),
                this['dataSources'][0x0][cC] >= cq) {
                if (this['options']['loop'])
                  return this['dataSources']['forEach'](cG => {
                    cG[cC] = cJ;
                  }
                  ),
                    this['options']['layer'] && this['options']['layer']['forEach'](cG => cG['clearPreDataSource'] && cG['clearPreDataSource']()),
                    this['options']['clearPreSource'] && this['options']['clearPreSource'](),
                    void this['fire'](DataAnimationService['EventTypes']['backUpdate'], {
                      'firer': this,
                      'msg': 0x0
                    });
                this['stop']();
              }
              this['dataSources']['forEach'](cG => {
                cG[cC] += this['options']['delta'];
              }
              ),
                this['fire'](DataAnimationService['EventTypes']['idxUpdate'], {
                  'firer': this,
                  'msg': this['dataSources'][0x0][cC]
                });
            }
          }
          ;
        if (this['options']['useTimer'])
          this['animationId'] = this['startFunc'](cO, this['options']['timerInterval']);
        else {
          let cG = performance['now']();
          const cg = () => {
            if (!this['animationId'])
              return;
            const cN = performance['now']();
            cN - cG >= this['options']['timerInterval'] && (cO(),
              cG = cN),
              this['animationId'] = this['startFunc'](cg);
          }
            ;
          this['animationId'] = this['startFunc'](cg);
        }
        return this;
      }
      ['pause'] () {
        return this['paused']++,
          this;
      }
      ['resume'] () {
        return this['paused']--,
          this['paused'] < 0x0 && (this['paused'] = 0x0),
          this;
      }
      ['stop'] () {
        return this['animationId'] ? (this['stopFunc'](this['animationId']),
          this['animationId'] = undefined,
          this['paused'] = 0x0,
          this['fire'](DataAnimationService['EventTypes']['stopped'], {
            'firer': this,
            'msg': this
          }),
          this) : this;
      }
    }
    DataAnimationService['DefaultOptions'] = {
      'timerInterval': 0x1e,
      'loop': true,
      'autoStart': false,
      'useTimer': true,
      'all': undefined,
      'type': DataAnimationType['Time'],
      'layer': undefined,
      'delta': 0.05
    },
      DataAnimationService['EventTypes'] = {
        'idxUpdate': 'update:idx',
        'backUpdate': 'update:back',
        'stopped': 'stopped'
      };
    var bF = n(0x4b);
    function by (cd, cq, cJ) {
      if (null !== cd)
        for (var cC, cO, cG, cg, cN, cP, cM, cz, cQ = 0x0, cm = 0x0, cL = cd['type'], cR = 'FeatureCollection' === cL, H0 = 'Feature' === cL, H1 = cR ? cd['features']['length'] : 0x1, H2 = 0x0; H2 < H1; H2++) {
          cN = (cz = !!(cM = cR ? cd['features'][H2]['geometry'] : H0 ? cd['geometry'] : cd) && 'GeometryCollection' === cM['type']) ? cM['geometries']['length'] : 0x1;
          for (var H3 = 0x0; H3 < cN; H3++) {
            var H4 = 0x0
              , H5 = 0x0;
            if (null !== (cg = cz ? cM['geometries'][H3] : cM)) {
              cP = cg['coordinates'];
              var H6 = cg['type'];
              switch (cQ = !cJ || 'Polygon' !== H6 && 'MultiPolygon' !== H6 ? 0x0 : 0x1,
              H6) {
                case null:
                  break;
                case 'Point':
                  if (false === cq(cP, cm, H2, H4, H5))
                    return false;
                  cm++,
                    H4++;
                  break;
                case 'LineString':
                case 'MultiPoint':
                  for (cC = 0x0; cC < cP['length']; cC++) {
                    if (false === cq(cP[cC], cm, H2, H4, H5))
                      return false;
                    cm++,
                      'MultiPoint' === H6 && H4++;
                  }
                  'LineString' === H6 && H4++;
                  break;
                case 'Polygon':
                case 'MultiLineString':
                  for (cC = 0x0; cC < cP['length']; cC++) {
                    for (cO = 0x0; cO < cP[cC]['length'] - cQ; cO++) {
                      if (false === cq(cP[cC][cO], cm, H2, H4, H5))
                        return false;
                      cm++;
                    }
                    'MultiLineString' === H6 && H4++,
                      'Polygon' === H6 && H5++;
                  }
                  'Polygon' === H6 && H4++;
                  break;
                case 'MultiPolygon':
                  for (cC = 0x0; cC < cP['length']; cC++) {
                    for (H5 = 0x0,
                      cO = 0x0; cO < cP[cC]['length']; cO++) {
                      for (cG = 0x0; cG < cP[cC][cO]['length'] - cQ; cG++) {
                        if (false === cq(cP[cC][cO][cG], cm, H2, H4, H5))
                          return false;
                        cm++;
                      }
                      H5++;
                    }
                    H4++;
                  }
                  break;
                case 'GeometryCollection':
                  for (cC = 0x0; cC < cg['geometries']['length']; cC++)
                    if (false === by(cg['geometries'][cC], cq, cJ))
                      return false;
                  break;
                default:
                  throw new Error('Unknown\x20Geometry\x20Type');
              }
            }
          }
        }
    }
    function bw (cd, cq) {
      !function (cJ, cC) {
        var cO, cG, cg, cN, cP, cM, cz, cQ, cm, cL, cR = 0x0, H0 = 'FeatureCollection' === cJ['type'], H1 = 'Feature' === cJ['type'], H2 = H0 ? cJ['features']['length'] : 0x1;
        for (cO = 0x0; cO < H2; cO++) {
          for (cM = H0 ? cJ['features'][cO]['geometry'] : H1 ? cJ['geometry'] : cJ,
            cQ = H0 ? cJ['features'][cO]['properties'] : H1 ? cJ['properties'] : {},
            cm = H0 ? cJ['features'][cO]['bbox'] : H1 ? cJ['bbox'] : undefined,
            cL = H0 ? cJ['features'][cO]['id'] : H1 ? cJ['id'] : undefined,
            cP = (cz = !!cM && 'GeometryCollection' === cM['type']) ? cM['geometries']['length'] : 0x1,
            cg = 0x0; cg < cP; cg++)
            if (null !== (cN = cz ? cM['geometries'][cg] : cM))
              switch (cN['type']) {
                case 'Point':
                case 'LineString':
                case 'MultiPoint':
                case 'Polygon':
                case 'MultiLineString':
                case 'MultiPolygon':
                  if (false === cC(cN, cR, cQ, cm, cL))
                    return false;
                  break;
                case 'GeometryCollection':
                  for (cG = 0x0; cG < cN['geometries']['length']; cG++)
                    if (false === cC(cN['geometries'][cG], cR, cQ, cm, cL))
                      return false;
                  break;
                default:
                  throw new Error('Unknown\x20Geometry\x20Type');
              }
            else {
              if (false === cC(null, cR, cQ, cm, cL))
                return false;
            }
          cR++;
        }
      }(cd, function (cJ, cC, cO, cG, cg) {
        var cN, cP = null === cJ ? null : cJ['type'];
        switch (cP) {
          case null:
          case 'Point':
          case 'LineString':
          case 'Polygon':
            return false !== cq((0x0,
              bF['zL'])(cJ, cO, {
                'bbox': cG,
                'id': cg
              }), cC, 0x0) && undefined;
        }
        switch (cP) {
          case 'MultiPoint':
            cN = 'Point';
            break;
          case 'MultiLineString':
            cN = 'LineString';
            break;
          case 'MultiPolygon':
            cN = 'Polygon';
        }
        for (var cM = 0x0; cM < cJ['coordinates']['length']; cM++) {
          var cz = {
            'type': cN,
            'coordinates': cJ['coordinates'][cM]
          };
          if (false === cq((0x0,
            bF['zL'])(cz, cO), cC, cM))
            return false;
        }
      });
    }
    function bh (cd, cq, cJ) {
      var cC = cJ
        , cO = false;
      return function (cG, cg) {
        bw(cG, function (cN, cP, cM) {
          var cz = 0x0;
          if (cN['geometry']) {
            var cQ = cN['geometry']['type'];
            if ('Point' !== cQ && 'MultiPoint' !== cQ) {
              var cm, cL = 0x0, cR = 0x0, H0 = 0x0;
              return false !== by(cN, function (H1, H2, H3, H4, H5) {
                if (undefined === cm || cP > cL || H4 > cR || H5 > H0)
                  return cm = H1,
                    cL = cP,
                    cR = H4,
                    H0 = H5,
                    void (cz = 0x0);
                var H6 = (0x0,
                  bF['Tu'])([cm, H1], cN['properties']);
                if (false === cg(H6, cP, cM, H5, cz))
                  return false;
                cz++,
                  cm = H1;
              }) && undefined;
            }
          }
        });
      }(cd, function (cG, cg, cN, cP, cM) {
        cC = false === cO && undefined === cJ ? cG : cq(cC, cG, cg, cN, cP, cM),
          cO = true;
      }),
        cC;
    }
    class bu {
      static ['createGridXY_Delt'] (cd, cq, cJ, cC, cO, cG) {
        let cg, cN, cP;
        cN = (cJ - cd) / cO + 0x1,
          cP = (cC - cq) / cG + 0x1;
        let cM = []
          , cz = [];
        for (cg = 0x0; cg < cN; cg++)
          cM[cg] = cd + cg * cO;
        for (cg = 0x0; cg < cP; cg++)
          cz[cg] = cq + cg * cG;
        let cQ = [];
        return cQ['push'](cM),
          cQ['push'](cz),
          cQ;
      }
      static ['createGridXY_Num'] (cd, cq, cJ, cC, cO, cG) {
        let cg, cN, cP, cM = cO['length'], cz = cG['length'];
        for (cN = (cJ - cd) / cM,
          cP = (cC - cq) / cz,
          cg = 0x0; cg < cM; cg++)
          cO[cg] = cd + cg * cN;
        for (cg = 0x0; cg < cz; cg++)
          cG[cg] = cq + cg * cP;
      }
      static ['interpolation_IDW_Neighbor'] (cd, cq, cJ, cC) {
        let cO, cG, cg;
        cG = cq['length'],
          cO = cJ['length'],
          cg = cd['length'];
        let cN, cP, cM, cz, cQ, cm, cL, cR, H0, H1, H2 = [];
        H1 = cC;
        let H3 = [];
        for (H3[0x0] = [],
          H3[0x1] = [],
          cN = 0x0; cN < cO; cN++)
          for (H2[cN] = [],
            cP = 0x0; cP < cG; cP++) {
            for (H2[cN][cP] = -0x3e7,
              cL = 0x0,
              cR = 0x0,
              cM = 0x0; cM < H1; cM++) {
              if (cq[cP] == cd[cM][0x0] && cJ[cN] == cd[cM][0x1]) {
                H2[cN][cP] = cd[cM][0x2];
                break;
              }
              cm = 0x1 / (Math['pow'](cq[cP] - cd[cM][0x0], 0x2) + Math['pow'](cJ[cN] - cd[cM][0x1], 0x2)),
                H3[0x0][cM] = cm,
                H3[0x1][cM] = cM;
            }
            if (-0x3e7 == H2[cN][cP]) {
              for (cM = H1; cM < cg; cM++) {
                if (Math['pow'](cq[cP] - cd[cM][0x0], 0x2) + Math['pow'](cJ[cN] - cd[cM][0x1], 0x2) == 0x0) {
                  H2[cN][cP] = cd[cM][0x2];
                  break;
                }
                for (cm = 0x1 / (Math['pow'](cq[cP] - cd[cM][0x0], 0x2) + Math['pow'](cJ[cN] - cd[cM][0x1], 0x2)),
                  H0 = parseFloat(H3[0x0][0x0]),
                  cQ = 0x0,
                  cz = 0x1; cz < H1; cz++)
                  parseFloat(H3[0x0][cz]) < H0 && (H0 = parseFloat(H3[0x0][cz]),
                    cQ = cz);
                cm > H0 && (H3[0x0][cQ] = cm,
                  H3[0x1][cQ] = cM);
              }
              if (-0x3e7 == H2[cN][cP]) {
                for (cM = 0x0; cM < H1; cM++)
                  cL += parseFloat(H3[0x0][cM]) * cd[parseInt(H3[0x1][cM])][0x2],
                    cR += parseFloat(H3[0x0][cM]);
                H2[cN][cP] = cL / cR;
              }
            }
          }
        for (cN = 0x1; cN < cO - 0x1; cN++)
          for (cP = 0x1; cP < cG - 0x1; cP++)
            H2[cN][cP] = H2[cN][cP] + 0.125 * (H2[cN + 0x1][cP] + H2[cN - 0x1][cP] + H2[cN][cP + 0x1] + H2[cN][cP - 0x1] - 0x4 * H2[cN][cP]);
        return H2;
      }
      static ['interpolation_IDW_Neighbor_Undef'] (cd, cq, cJ, cC, cO) {
        let cG, cg, cN;
        cg = cq['length'],
          cG = cJ['length'],
          cN = cd['length'];
        let cP, cM, cz, cQ, cm, cL, cR, H0, H1, H2, H3 = [];
        H2 = cC;
        let H4, H5 = [], H6 = [];
        for (H6[0x0] = [],
          H6[0x1] = [],
          cP = 0x0; cP < cG; cP++)
          for (H3[cP] = [],
            cM = 0x0; cM < cg; cM++) {
            for (H3[cP][cM] = cO,
              cR = 0x0,
              H0 = 0x0,
              H4 = 0x0,
              cz = 0x0; cz < cN; cz++)
              if (cd[cz][0x2] != cO) {
                if (cq[cM] == cd[cz][0x0] && cJ[cP] == cd[cz][0x1]) {
                  H3[cP][cM] = cd[cz][0x2];
                  break;
                }
                cL = 0x1 / (Math['pow'](cq[cM] - cd[cz][0x0], 0x2) + Math['pow'](cJ[cP] - cd[cz][0x1], 0x2)),
                  H5[cz] = cL,
                  H4 < H2 && (H6[0x0][H4] = cL,
                    H6[0x1][H4] = cz),
                  H4 += 0x1;
              } else
                H5[cz] = -0x1;
            if (H3[cP][cM] == cO) {
              for (cz = 0x0; cz < cN; cz++)
                if (cL = H5[cz],
                  -0x1 != cL) {
                  for (H1 = H6[0x0][0x0],
                    cm = 0x0,
                    cQ = 0x1; cQ < H2; cQ++)
                    H6[0x0][cQ] < H1 && (H1 = H6[0x0][cQ],
                      cm = cQ);
                  cL > H1 && (H6[0x0][cm] = cL,
                    H6[0x1][cm] = cz);
                }
              for (cz = 0x0; cz < H2; cz++)
                cR += H6[0x0][cz] * cd[H6[0x1][cz]][0x2],
                  H0 += H6[0x0][cz];
              H3[cP][cM] = cR / H0;
            }
          }
        for (cP = 0x1; cP < cG - 0x1; cP++)
          for (cM = 0x1; cM < cg - 0x1; cM++)
            H3[cP][cM] = H3[cP][cM] + 0.125 * (H3[cP + 0x1][cM] + H3[cP - 0x1][cM] + H3[cP][cM + 0x1] + H3[cP][cM - 0x1] - 0x4 * H3[cP][cM]);
        return H3;
      }
      static ['interpolation_IDW_Radius'] (cd, cq, cJ, cC, cO, cG) {
        let cg, cN, cP;
        cN = cq['length'],
          cg = cJ['length'],
          cP = cd['length'];
        let cM, cz, cQ, cm, cL, cR, H0, H1, H2 = [];
        for (cM = 0x0; cM < cg; cM++)
          for (H2[cM] = [],
            cz = 0x0; cz < cN; cz++) {
            for (H2[cM][cz] = cG,
              H1 = false,
              cR = 0x0,
              H0 = 0x0,
              cm = 0x0,
              cQ = 0x0; cQ < cP; cQ++)
              if (cd[cQ][0x2] != cG && !(cd[cQ][0x0] < cq[cz] - cO || cd[cQ][0x0] > cq[cz] + cO || cd[cQ][0x1] < cJ[cM] - cO || cd[cQ][0x1] > cJ[cM] + cO)) {
                if (cq[cz] == cd[cQ][0x0] && cJ[cM] == cd[cQ][0x1]) {
                  H2[cM][cz] = cd[cQ][0x2],
                    H1 = true;
                  break;
                }
                Math['sqrt'](Math['pow'](cq[cz] - cd[cQ][0x0], 0x2) + Math['pow'](cJ[cM] - cd[cQ][0x1], 0x2)) <= cO && (cL = 0x1 / (Math['pow'](cq[cz] - cd[cQ][0x0], 0x2) + Math['pow'](cJ[cM] - cd[cQ][0x1], 0x2)),
                  H0 += cL,
                  cR += cd[cQ][0x2] * cL,
                  cm += 0x1);
              }
            H1 || cm >= cC && (H2[cM][cz] = cR / H0);
          }
        for (cM = 0x1; cM < cg - 0x1; cM++)
          for (cz = 0x1; cz < cN - 0x2; cz++)
            H2[cM][cz] != cG && H2[cM + 0x1][cz] != cG && H2[cM - 0x1][cz] != cG && H2[cM][cz + 0x1] != cG && H2[cM][cz - 0x1] != cG && (H2[cM][cz] = H2[cM][cz] + 0.125 * (H2[cM + 0x1][cz] + H2[cM - 0x1][cz] + H2[cM][cz + 0x1] + H2[cM][cz - 0x1] - 0x4 * H2[cM][cz]));
        return H2;
      }
      static ['interpolation_Grid'] (cd, cq, cJ, cC, cO, cG) {
        let cg = 0x2 * cq['length'] - 0x1
          , cN = 0x2 * cJ['length'] - 0x1;
        cO = [],
          cG = [];
        let cP, cM, cz, cQ, cm, cL, cR, H0 = [];
        for (cP = 0x0; cP < cg; cP++)
          cO[cP] = cP % 0x2 == 0x0 ? cq[cP / 0x2] : (cq[(cP - 0x1) / 0x2] + cq[(cP - 0x1) / 0x2 + 0x1]) / 0x2;
        for (cP = 0x0; cP < cN; cP++)
          for (cG[cP] = cP % 0x2 == 0x0 ? cJ[cP / 0x2] : (cJ[(cP - 0x1) / 0x2] + cJ[(cP - 0x1) / 0x2 + 0x1]) / 0x2,
            cM = 0x0; cM < cg; cM++)
            if (H0[cM] = [],
              cP % 0x2 == 0x0 && cM % 0x2 == 0x0)
              H0[cP][cM] = cd[cP / 0x2][cM / 0x2];
            else {
              if (cP % 0x2 == 0x0 && cM % 0x2 != 0x0)
                cz = cd[cP / 0x2][(cM - 0x1) / 0x2],
                  cQ = cd[cP / 0x2][(cM - 0x1) / 0x2 + 0x1],
                  cR = [],
                  cz != cC && cR['push'](cz),
                  cQ != cC && cR['push'](cQ),
                  0x0 === cR['length'] ? H0[cP][cM] = cC : 0x1 == cR['length'] ? H0[cP][cM] = cR[0x0] : H0[cP][cM] = (cz + cQ) / 0x2;
              else {
                if (cP % 0x2 != 0x0 && cM % 0x2 == 0x0)
                  cz = cd[(cP - 0x1) / 0x2][cM / 0x2],
                    cQ = cd[(cP - 0x1) / 0x2 + 0x1][cM / 0x2],
                    cR = [],
                    cz != cC && cR['push'](cz),
                    cQ != cC && cR['push'](cQ),
                    0x0 === cR['length'] ? H0[cP][cM] = cC : 0x1 == cR['length'] ? H0[cP][cM] = cR[0x0] : H0[cP][cM] = (cz + cQ) / 0x2;
                else {
                  if (cz = cd[(cP - 0x1) / 0x2][(cM - 0x1) / 0x2],
                    cQ = cd[(cP - 0x1) / 0x2][(cM - 0x1) / 0x2 + 0x1],
                    cm = cd[(cP - 0x1) / 0x2 + 0x1][(cM - 0x1) / 0x2 + 0x1],
                    cL = cd[(cP - 0x1) / 0x2 + 0x1][(cM - 0x1) / 0x2],
                    cR = [],
                    cz != cC && cR['push'](cz),
                    cQ != cC && cR['push'](cQ),
                    cm != cC && cR['push'](cm),
                    cL != cC && cR['push'](cL),
                    cR['length'])
                    H0[cP][cM] = cC;
                  else {
                    if (0x1 == cR['length'])
                      H0[cP][cM] = cR[0x0];
                    else {
                      let H1 = 0x0;
                      for (let H2 of cR)
                        H1 += H2;
                      H0[cP][cM] = H1 / cR['length'];
                    }
                  }
                }
              }
            }
        return H0;
      }
      static ['cressman'] (cd, cq, cJ, cC) {
        let cO = [];
        return cO['push'](0xa),
          cO['push'](0x7),
          cO['push'](0x4),
          cO['push'](0x2),
          cO['push'](0x1),
          bu['cressman_rad'](cd, cq, cJ, cC, cO);
      }
      static ['cressman_rad'] (cd, cq, cJ, cC, cO) {
        let cG, cg, cN, cP, cM = cq['length'], cz = cJ['length'], cQ = cd['length'], cm = [], cL = cO['length'], cR = cq[0x0], H0 = cq[cq['length'] - 0x1], H1 = cJ[0x0], H2 = cJ[cJ['length'] - 0x1], H3 = cq[0x1] - cq[0x0], H4 = cJ[0x1] - cJ[0x0], H5 = 0x0, H6 = 0x0, H7 = 0x0, H8 = [];
        for (cG = 0x0; cG < cQ; cG++)
          H8[cG] = [],
            cN = cd[cG][0x0],
            cP = cd[cG][0x1],
            H8[cG][0x0] = Math['floor']((cN - cR) / H3),
            H8[cG][0x1] = Math['floor']((cP - H1) / H4),
            H8[cG][0x2] = cd[cG][0x2],
            H8[cG][0x2] != cC && (H6 += H8[cG][0x2],
              H7 += 0x1);
        H6 /= H7;
        let H9, Hv = [], HA = [];
        for (cG = 0x0; cG < cz; cG++)
          for (Hv[cG] = [],
            HA[cG] = [],
            cg = 0x0; cg < cM; cg++)
            Hv[cG][cg] = -0x363466684d81160000,
              HA[cG][cg] = 0x363466684d81160000;
        for (H9 = cO['length'] > 0x0 ? cO[0x0] : 0x4,
          cG = 0x0; cG < cz; cG++)
          for (cP = cG,
            H1 = cP - H9,
            H2 = cP + H9,
            cm[cG] = [],
            cg = 0x0; cg < cM; cg++) {
            cN = cg,
              cR = cN - H9,
              H0 = cN + H9,
              H7 = 0x0,
              H5 = 0x0;
            for (let Hk = 0x0; Hk < cQ; Hk++) {
              let Hl = H8[Hk][0x2]
                , HK = H8[Hk][0x0]
                , Hb = H8[Hk][0x1];
              HK < 0x0 || HK >= cM - 0x1 || Hb < 0x0 || Hb >= cz - 0x1 || Hl == cC || HK < cR || HK > H0 || Hb < H1 || Hb > H2 || Math['sqrt'](Math['pow'](HK - cN, 0x2) + Math['pow'](Hb - cP, 0x2)) > H9 || (H5 += Hl,
                H7 += 0x1,
                Hv[cG][cg] < Hl && (Hv[cG][cg] = Hl),
                HA[cG][cg] > Hl && (HA[cG][cg] = Hl));
            }
            cm[cG][cg] = 0x0 == H7 ? cC : H5 / H7;
          }
        for (let Hc = 0x0; Hc < cL; Hc++)
          for (H9 = cO[Hc],
            cG = 0x0; cG < cz; cG++)
            for (cP = cG,
              H1 = cP - H9,
              H2 = cP + H9,
              cg = 0x0; cg < cM; cg++) {
              if (cm[cG][cg] == cC)
                continue;
              cN = cg,
                cR = cN - H9,
                H0 = cN + H9,
                H5 = 0x0;
              let HH = 0x0;
              for (let Hx = 0x0; Hx < cQ; Hx++) {
                let Hp = H8[Hx][0x2]
                  , HF = H8[Hx][0x0]
                  , Hy = H8[Hx][0x1];
                if (HF < 0x0 || HF >= cM - 0x1 || Hy < 0x0 || Hy >= cz - 0x1)
                  continue;
                if (Hp == cC || HF < cR || HF > H0 || Hy < H1 || Hy > H2)
                  continue;
                let Hw = Math['sqrt'](Math['pow'](HF - cN, 0x2) + Math['pow'](Hy - cP, 0x2));
                if (Hw > H9)
                  continue;
                let Hh, Hu = Hy, HY = HF, HT = Hu + 0x1, HX = HY + 0x1, HE = cm[Hu][HY], Hf = cm[Hu][HX], HW = cm[HT][HY], HI = cm[HT][HX], Hj = [];
                if (HE != cC && Hj['push'](HE),
                  Hf != cC && Hj['push'](Hf),
                  HW != cC && Hj['push'](HW),
                  HI != cC && Hj['push'](HI),
                  0x0 === Hj['length'])
                  continue;
                if (0x1 == Hj['length'])
                  Hh = Hj[0x0];
                else {
                  if (Hj['length'] <= 0x3) {
                    let HV = 0x0;
                    for (let HZ of Hj)
                      HV += HZ;
                    Hh = HV / Hj['length'];
                  } else {
                    let HB = HE + (HW - HE) * (Hy - Hu);
                    Hh = HB + (Hf + (HI - Hf) * (Hy - Hu) - HB) * (HF - HY);
                  }
                }
                let HD = (H9 * H9 - Hw * Hw) / (H9 * H9 + Hw * Hw);
                H5 += (Hp - Hh) * HD,
                  HH += HD;
              }
              if (HH < 0.000001)
                cm[cG][cg] = cC;
              else {
                let HS = cm[cG][cg] + H5 / HH;
                cm[cG][cg] = Math['max'](HA[cG][cg], Math['min'](Hv[cG][cg], HS));
              }
            }
        return cm;
      }
      static ['assignPointToGrid'] (cd, cq, cJ, cC) {
        let cO, cG, cg;
        cG = cq['length'],
          cO = cJ['length'],
          cg = cd['length'];
        let cN = []
          , cP = cq[0x1] - cq[0x0]
          , cM = cJ[0x1] - cJ[0x0]
          , cz = [];
        for (let cQ = 0x0; cQ < cO; cQ++) {
          cz[cQ] = [],
            cN[cQ] = [];
          for (let cm = 0x0; cm < cG; cm++)
            cz[cQ][cm] = 0x0,
              cN[cQ][cm] = 0x0;
        }
        for (let cL = 0x0; cL < cg; cL++) {
          if (bu['doubleEquals'](cd[cL][0x2], cC))
            continue;
          let cR = cd[cL][0x0]
            , H0 = cd[cL][0x1];
          if (cR < cq[0x0] || cR > cq[cG - 0x1])
            continue;
          if (H0 < cJ[0x0] || H0 > cJ[cO - 0x1])
            continue;
          let H1 = ((cR - cq[0x0]) / cP)['toFixed'](0x0)
            , H2 = ((H0 - cJ[0x0]) / cM)['toFixed'](0x0);
          cz[H2][H1] += 0x1,
            cN[H2][H1] += cd[cL][0x2];
        }
        for (let H3 = 0x0; H3 < cO; H3++)
          for (let H4 = 0x0; H4 < cG; H4++)
            0x0 == cz[H3][H4] ? cN[H3][H4] = cC : cN[H3][H4] = cN[H3][H4] / cz[H3][H4];
        return cN;
      }
      static ['doubleEquals'] (cd, cq) {
        return Math['abs'](cd / cq - 0x1) < 1e-11;
      }
    }
    class bY {
      constructor() {
        this['LineList'] = [];
      }
      ['getLineNum'] () {
        return this['LineList']['length'];
      }
    }
    class bT {
      constructor(cd, cq, cJ, cC) {
        this['xMin'] = cd,
          this['xMax'] = cq,
          this['yMin'] = cJ,
          this['yMax'] = cC;
      }
      ['Include'] (cd) {
        return this['xMin'] <= cd['xMin'] && this['xMax'] >= cd['xMax'] && this['yMin'] <= cd['yMin'] && this['yMax'] >= cd['yMax'];
      }
    }
    class bX {
      constructor() {
        this['extent'] = new bT(),
          this['pointList'] = [],
          this['ijPointList'] = [];
      }
    }
    class bE {
      constructor(cd, cq) {
        this['X'] = cd || 0x0,
          this['Y'] = cq || 0x0;
      }
      ['clone'] () {
        return new bE(this['X'], this['Y']);
      }
    }
    class bf {
      constructor() {
        this['Point'] = new bE();
      }
      ['clone'] () {
        let cd = new bf();
        return cd['Id'] = this['Id'],
          cd['BorderIdx'] = this['BorderIdx'],
          cd['BInnerIdx'] = this['BInnerIdx'],
          cd['Point'] = this['Point'],
          cd['Value'] = this['Value'],
          cd;
      }
    }
    class bW {
      constructor() {
        this['sPoint'] = new bE(),
          this['Point'] = new bE();
      }
    }
    class bI {
    }
    class bj {
    }
    class bD {
      constructor(cd, cq) {
        this['X'] = cd,
          this['Y'] = cq;
      }
    }
    class bV {
      constructor() {
        this['PointList'] = [];
      }
    }
    class bZ {
      constructor() {
        this['IsInnerBorder'] = false,
          this['Extent'] = new bT(),
          this['OutLine'] = new bV(),
          this['HoleLines'] = [];
      }
      ['Clone'] () {
        let cd = new bZ();
        cd['IsBorder'] = this['IsBorder'],
          cd['LowValue'] = this['LowValue'],
          cd['HighValue'] = this['HighValue'],
          cd['IsClockWise'] = this['IsClockWise'],
          cd['StartPointIdx'] = this['StartPointIdx'],
          cd['IsHighCenter'] = this['IsHighCenter'],
          cd['Extent'] = this['Extent'],
          cd['Area'] = this['Area'],
          cd['OutLine'] = this['OutLine'];
        for (let cq of this['HoleLines'])
          cd['HoleLines']['push'](cq);
        return cd['HoleIndex'] = this['HoleIndex'],
          cd;
      }
      ['HasHoles'] () {
        return this['HoleLines']['length'] > 0x0;
      }
      ['AddHole'] (cd) {
        if (cd instanceof bZ)
          this['HoleLines']['push'](cd['OutLine']);
        else {
          let cq = cd;
          bB['isClockwise'](cq) && (cq = cq['reverse']());
          let cJ = new bV();
          cJ['PointList'] = cq,
            this['HoleLines']['push'](cJ);
        }
      }
    }
    class bB {
      static ['tracingContourLines'] (cd, cq, cJ, cC, cO, cG, cg, cN) {
        return bB['createContourLines_UndefData'](cd, cq, cJ, cC, cO, cN, cG, cg);
      }
      static ['tracingBorders'] (cd, cq, cJ, cC, cO) {
        let cG, cg, cN, cP, cM, cz, cQ, cm, cL, cR, H0, H1, H2, H3 = [];
        for (cG = cd['length'],
          cg = cd[0x0]['length'],
          cN = 0x0; cN < cG; cN++)
          for (cC[cN] = [],
            cP = 0x0; cP < cg; cP++)
            bB['doubleEquals'](cd[cN][cP], cO) ? cC[cN][cP] = 0x0 : cC[cN][cP] = 0x1;
        for (cN = 0x1; cN < cG - 0x1; cN++)
          for (cP = 0x1; cP < cg - 0x1; cP++)
            0x1 === cC[cN][cP] && (cM = cC[cN][cP - 0x1],
              cz = cC[cN][cP + 0x1],
              cQ = cC[cN - 0x1][cP],
              cm = cC[cN + 0x1][cP],
              cL = cC[cN - 0x1][cP - 0x1],
              cR = cC[cN - 0x1][cP + 0x1],
              H0 = cC[cN + 0x1][cP - 0x1],
              H1 = cC[cN + 0x1][cP + 0x1],
              cM > 0x0 && cz > 0x0 && cQ > 0x0 && cm > 0x0 && cL > 0x0 && cR > 0x0 && H0 > 0x0 && H1 > 0x0 && (cC[cN][cP] = 0x2),
              cM + cz + cQ + cm + cL + cR + H0 + H1 <= 0x2 && (cC[cN][cP] = 0x0));
        for (; ;) {
          for (H2 = false,
            cN = 0x1; cN < cG - 0x1; cN++)
            for (cP = 0x1; cP < cg - 0x1; cP++)
              0x1 === cC[cN][cP] && (cM = cC[cN][cP - 0x1],
                cz = cC[cN][cP + 0x1],
                cQ = cC[cN - 0x1][cP],
                cm = cC[cN + 0x1][cP],
                cL = cC[cN - 0x1][cP - 0x1],
                cR = cC[cN - 0x1][cP + 0x1],
                H0 = cC[cN + 0x1][cP - 0x1],
                H1 = cC[cN + 0x1][cP + 0x1],
                (0x0 === cM && 0x0 === cz || 0x0 === cQ && 0x0 === cm) && (cC[cN][cP] = 0x0,
                  H2 = true),
                (0x0 === H0 && 0x0 === cz && 0x0 === cQ || 0x0 === H1 && 0x0 === cM && 0x0 === cQ || 0x0 === cL && 0x0 === cz && 0x0 === cm || 0x0 === cR && 0x0 === cM && 0x0 === cm) && (cC[cN][cP] = 0x0,
                  H2 = true));
          if (!H2)
            break;
        }
        for (cP = 0x0; cP < cg; cP++)
          0x1 === cC[0x0][cP] && (0x0 === cC[0x1][cP] ? cC[0x0][cP] = 0x0 : 0x0 === cP ? 0x0 === cC[0x0][cP + 0x1] && (cC[0x0][cP] = 0x0) : cP === cg - 0x1 ? 0x0 === cC[0x0][cg - 0x2] && (cC[0x0][cP] = 0x0) : 0x0 === cC[0x0][cP - 0x1] && 0x0 === cC[0x0][cP + 0x1] && (cC[0x0][cP] = 0x0)),
            0x1 === cC[cG - 0x1][cP] && (0x0 === cC[cG - 0x2][cP] ? cC[cG - 0x1][cP] = 0x0 : 0x0 === cP ? 0x0 === cC[cG - 0x1][cP + 0x1] && (cC[cG - 0x1][cP] = 0x0) : cP === cg - 0x1 ? 0x0 === cC[cG - 0x1][cg - 0x2] && (cC[cG - 0x1][cP] = 0x0) : 0x0 === cC[cG - 0x1][cP - 0x1] && 0x0 === cC[cG - 0x1][cP + 0x1] && (cC[cG - 0x1][cP] = 0x0));
        for (cN = 0x0; cN < cG; cN++)
          0x1 === cC[cN][0x0] && (0x0 === cC[cN][0x1] ? cC[cN][0x0] = 0x0 : 0x0 === cN ? 0x0 === cC[cN + 0x1][0x0] && (cC[cN][0x0] = 0x0) : cN === cG - 0x1 ? 0x0 === cC[cG - 0x2][0x0] && (cC[cN][0x0] = 0x0) : 0x0 === cC[cN - 0x1][0x0] && 0x0 === cC[cN + 0x1][0x0] && (cC[cN][0x0] = 0x0)),
            0x1 === cC[cN][cg - 0x1] && (0x0 === cC[cN][cg - 0x2] ? cC[cN][cg - 0x1] = 0x0 : 0x0 === cN ? 0x0 === cC[cN + 0x1][cg - 0x1] && (cC[cN][cg - 0x1] = 0x0) : cN === cG - 0x1 ? 0x0 === cC[cG - 0x2][cg - 0x1] && (cC[cN][cg - 0x1] = 0x0) : 0x0 === cC[cN - 0x1][cg - 0x1] && 0x0 === cC[cN + 0x1][cg - 0x1] && (cC[cN][cg - 0x1] = 0x0));
        let H4 = [];
        for (cN = 0x0; cN < cG + 0x2; cN++)
          for (H4[cN] = [],
            cP = 0x0; cP < cg + 0x2; cP++)
            H4[cN][cP] = 0x0 === cN || cN === cG + 0x1 || 0x0 === cP || cP === cg + 0x1 ? 0x0 : cC[cN - 0x1][cP - 0x1];
        let H5, H6, H7, H8, H9, Hv = [];
        for (cN = 0x0; cN < cG + 0x2; cN++)
          for (Hv[cN] = [],
            cP = 0x0; cP < cg + 0x2; cP++)
            0x1 === H4[cN][cP] ? (cM = H4[cN][cP - 0x1],
              cz = H4[cN][cP + 0x1],
              cQ = H4[cN - 0x1][cP],
              cm = H4[cN + 0x1][cP],
              cL = H4[cN - 0x1][cP - 0x1],
              cR = H4[cN - 0x1][cP + 0x1],
              H0 = H4[cN + 0x1][cP - 0x1],
              H1 = H4[cN + 0x1][cP + 0x1],
              Hv[cN][cP] = 0x1 === cM && 0x1 === cz && 0x1 === cQ && 0x1 === cm && (0x0 === cL && 0x0 === H1 || 0x0 === cR && 0x0 === H0) ? 0x2 : 0x1) : Hv[cN][cP] = 0x0;
        let HA, Hk, Hl, HK, Hb, Hc, HH = 0x0, Hx = 0x0;
        for (cN = 0x1; cN < cG + 0x1; cN++)
          for (cP = 0x1; cP < cg + 0x1; cP++)
            if (0x1 === H4[cN][cP]) {
              for (H8 = [],
                H9 = [],
                H5 = new bE(),
                H5['X'] = cq[cP - 0x1],
                H5['Y'] = cJ[cN - 0x1],
                H6 = new bI(),
                H6['I'] = cN - 0x1,
                H6['J'] = cP - 0x1,
                H8['push'](H5),
                H9['push'](H6),
                HA = cN,
                Hk = cP,
                Hb = cN,
                Hc = cP,
                Hl = Hb,
                HK = -0x1; ;) {
                let Hu = [];
                if (Hu[0x0] = HH,
                  Hu[0x1] = Hx,
                  !bB['traceBorder'](H4, Hl, Hb, HK, Hc, Hu))
                  break;
                if (HH = Hu[0x0],
                  Hx = Hu[0x1],
                  Hl = Hb,
                  HK = Hc,
                  Hb = HH,
                  Hc = Hx,
                  Hv[HH][Hx] = Hv[HH][Hx] - 0x1,
                  0x0 === Hv[HH][Hx] && (H4[HH][Hx] = 0x3),
                  H5 = new bE(),
                  H5['X'] = cq[Hx - 0x1],
                  H5['Y'] = cJ[HH - 0x1],
                  H6 = new bI(),
                  H6['I'] = HH - 0x1,
                  H6['J'] = Hx - 0x1,
                  H8['push'](H5),
                  H9['push'](H6),
                  HH === HA && Hx === Hk)
                  break;
              }
              Hv[cN][cP] = Hv[cN][cP] - 0x1,
                0x0 === Hv[cN][cP] && (H4[cN][cP] = 0x3),
                H8['length'] > 0x1 && (H7 = new bX(),
                  H7['area'] = bB['getExtentAndArea'](H8, H7['extent']),
                  H7['isOutLine'] = true,
                  H7['isClockwise'] = true,
                  H7['pointList'] = H8,
                  H7['ijPointList'] = H9,
                  H3['push'](H7));
            }
        let Hp, HF, Hy, Hw, Hh = [];
        for (cN = 0x1; cN < H3['length']; cN++)
          for (HF = H3[cN],
            cP = 0x0; cP < cN; cP++)
            if (Hy = H3[cN],
              HF['area'] > Hy['area']) {
              H3['splice'](cN, 0x1),
                H3['splice'](cP, 0x0, HF);
              break;
            }
        if (0x1 === H3['length'])
          HF = H3[0x0],
            bB['isClockwise'](HF['pointList']) || (HF['pointList'] = HF['pointList']['reverse'](),
              HF['ijPointList']['reverse']()),
            HF['isClockwise'] = true,
            Hw = [],
            Hw['push'](HF),
            Hp = new bY(),
            Hp['LineList'] = Hw,
            Hh['push'](Hp);
        else
          for (cN = 0x0; cN < H3['length'] && cN !== H3['length']; cN++) {
            for (HF = H3[cN],
              bB['isClockwise'](HF['pointList']) || (HF['pointList']['reverse'](),
                HF['ijPointList']['reverse']()),
              HF['isClockwise'] = true,
              Hw = [],
              Hw['push'](HF),
              cP = cN + 0x1; cP < H3['length'] && cP !== H3['length']; cP++)
              Hy = H3[cN],
                Hy['extent']['xMin'] > HF['extent']['xMin'] && Hy['extent']['xMax'] < HF['extent']['xMax'] && Hy['extent']['yMin'] > HF['extent']['yMin'] && Hy['extent']['yMax'] < HF['extent']['yMax'] && (H5 = Hy['pointList'][0x0],
                  bB['pointInPolygonByPList'](HF['pointList'], H5) && (Hy['isOutLine'] = false,
                    bB['isClockwise'](Hy['pointList']) && (Hy['pointList']['reverse'](),
                      Hy['ijPointList']['reverse']()),
                    Hy['isClockwise'] = false,
                    Hw['push'](Hy),
                    H3['splice'](cP, 0x1),
                    cP -= 0x1));
            Hp = new bY(),
              Hp['LineList'] = Hw,
              Hh['push'](Hp);
          }
        return Hh;
      }
      static ['createContourLines_UndefData'] (cd, cq, cJ, cC, cO, cG, cg, cN) {
        let cP, cM, cz, cQ, cm, cL, cR = [];
        for (cM = cd['length'],
          cz = cd[0x0]['length'],
          cL = 0.00001 * cO[0x0],
          0x0 === cL && (cL = 0.00001),
          cQ = 0x0; cQ < cM; cQ++)
          for (cm = 0x0; cm < cz; cm++)
            bB['doubleEquals'](cd[cQ][cm], cg) || (cd[cQ][cm] = cd[cQ][cm] + cL);
        let H0, H1, H2, H3, H4, H5, H6, H7, H8 = [], H9 = [];
        for (H8[0x0] = [],
          H8[0x1] = [],
          H9[0x0] = [],
          H9[0x1] = [],
          cQ = 0x0; cQ < cM; cQ++)
          for (H8[0x0][cQ] = [],
            H8[0x1][cQ] = [],
            H9[0x0][cQ] = [],
            H9[0x1][cQ] = [],
            cm = 0x0; cm < cz; cm++)
            cm < cz - 0x1 && (H8[0x0][cQ][cm] = -0x1,
              H8[0x1][cQ][cm] = -0x1),
              cQ < cM - 0x1 && (H9[0x0][cQ][cm] = -0x1,
                H9[0x1][cQ][cm] = -0x1);
        for (cQ = 0x0; cQ < cN['length']; cQ++)
          for (H0 = cN[cQ],
            cm = 0x0; cm < H0['getLineNum'](); cm++)
            for (H1 = H0['LineList'][cm],
              H2 = H1['ijPointList'],
              H3 = 0x0; H3 < H2['length'] - 0x1; H3++)
              H6 = H2[H3],
                H7 = H2[H3 + 0x1],
                H6['I'] === H7['I'] ? (H4 = H6['I'],
                  H5 = Math['min'](H6['J'], H7['J']),
                  H8[0x0][H4][H5] = cQ,
                  H7['J'] > H6['J'] ? H8[0x1][H4][H5] = 0x1 : H8[0x1][H4][H5] = 0x0) : (H5 = H6['J'],
                    H4 = Math['min'](H6['I'], H7['I']),
                    H9[0x0][H4][H5] = cQ,
                    H7['I'] > H6['I'] ? H9[0x1][H4][H5] = 0x0 : H9[0x1][H4][H5] = 0x1);
        let Hv, HA, Hk, Hl, HK = [], Hb = [];
        for (HA = 0x0; HA < cC; HA++) {
          for (Hv = cO[HA],
            cQ = 0x0; cQ < cM; cQ++)
            for (HK[cQ] = [],
              Hb[cQ] = [],
              cm = 0x0; cm < cz; cm++)
              cm < cz - 0x1 && (0x0 !== cG[cQ][cm] && 0x0 !== cG[cQ][cm + 0x1] && (cd[cQ][cm] - Hv) * (cd[cQ][cm + 0x1] - Hv) < 0x0 ? HK[cQ][cm] = (Hv - cd[cQ][cm]) / (cd[cQ][cm + 0x1] - cd[cQ][cm]) : HK[cQ][cm] = -0x2),
                cQ < cM - 0x1 && (0x0 !== cG[cQ][cm] && 0x0 !== cG[cQ + 0x1][cm] && (cd[cQ][cm] - Hv) * (cd[cQ + 0x1][cm] - Hv) < 0x0 ? Hb[cQ][cm] = (Hv - cd[cQ][cm]) / (cd[cQ + 0x1][cm] - cd[cQ][cm]) : Hb[cQ][cm] = -0x2);
          cP = bB['isoline_UndefData'](cd, cq, cJ, Hv, HK, Hb, H8, H9, cR['length']);
          for (let Hc of cP)
            cR['push'](Hc);
        }
        for (cQ = 0x0; cQ < cN['length']; cQ++)
          for (H0 = cN[cQ],
            H1 = H0['LineList'][0x0],
            cm = 0x0; cm < cR['length']; cm++)
            Hk = cR[cm],
              'Close' === Hk['Type'] && (Hl = Hk['PointList'][0x0],
                bB['pointInPolygonByPList'](H1['pointList'], Hl) && (Hk['BorderIdx'] = cQ)),
              cR['splice'](cm, 0x1),
              cR['splice'](cm, 0x0, Hk);
        return cR;
      }
      static ['createContourLines'] (cd, cq, cJ, cC, cO, cG, cg) {
        let cN, cP, cM, cz, cQ, cm, cL, cR, H0, H1 = [];
        cm = cd['length'],
          cL = cd[0x0]['length'];
        let H2, H3, H4, H5 = [], H6 = [];
        for (H2 = 0.00001 * cO[0x0],
          0x0 === H2 && (H2 = 0.00001),
          cR = 0x0; cR < cm; cR++)
          for (H0 = 0x0; H0 < cL; H0++)
            cd[cR][H0] = cd[cR][H0] + H2;
        for (H4 = 0x0; H4 < cC; H4++) {
          for (H3 = cO[H4],
            cR = 0x0; cR < cm; cR++)
            for (H0 = 0x0; H0 < cL; H0++)
              H0 < cL - 0x1 && ((cd[cR][H0] - H3) * (cd[cR][H0 + 0x1] - H3) < 0x0 ? H5[cR][H0] = (H3 - cd[cR][H0]) / (cd[cR][H0 + 0x1] - cd[cR][H0]) : H5[cR][H0] = -0x2),
                cR < cm - 0x1 && ((cd[cR][H0] - H3) * (cd[cR + 0x1][H0] - H3) < 0x0 ? H6[cR][H0] = (H3 - cd[cR][H0]) / (cd[cR + 0x1][H0] - cd[cR][H0]) : H6[cR][H0] = -0x2);
          cN = bB['isoline_Bottom'](cd, cq, cJ, H3, cG, cg, H5, H6),
            cP = bB['isoline_Left'](cd, cq, cJ, H3, cG, cg, H5, H6),
            cM = bB['isoline_Top'](cd, cq, cJ, H3, cG, cg, H5, H6),
            cz = bB['isoline_Right'](cd, cq, cJ, H3, cG, cg, H5, H6),
            cQ = bB['isoline_Close'](cd, cq, cJ, H3, cG, cg, H5, H6),
            bB['addAll'](cN, H1),
            bB['addAll'](cP, H1),
            bB['addAll'](cM, H1),
            bB['addAll'](cz, H1),
            bB['addAll'](cQ, H1);
        }
        return H1;
      }
      static ['addAll'] (cd, cq) {
        cq || console['log']('������������֮ǰ��Ҫ�ȳ�ʼ��Ŀ�����飡');
        for (let cJ of cd)
          cq['push'](cJ);
      }
      static ['cutContourWithPolygon'] (cd, cq) {
        let cJ, cC, cO, cG, cg, cN, cP, cM, cz, cQ, cm, cL, cR, H0, H1, H2 = [], H3 = new bV(), H4 = new bW();
        for (bB['_endPointList'] = [],
          bB['isClockwise'](cq) || cq['reverse'](),
          cJ = 0x0; cJ < cd['length']; cJ++) {
          cG = cd[cJ],
            cN = cG['Value'],
            cP = cG['Type'],
            cg = [],
            bB['addAll'](cG['PointList'], cg),
            cM = false;
          let H5 = [];
          if ('Close' === cP && bB['pointInPolygonByPList'](cq, cg[0x0])) {
            let H6 = true
              , H7 = 0x0;
            for (cC = 0x0; cC < cg['length']; cC++)
              if (!bB['pointInPolygonByPList'](cq, cg[cC])) {
                H7 = cC,
                  H6 = false;
                break;
              }
            if (!H6) {
              let H8 = [];
              for (cC = H7; cC < cg['length']; cC++)
                H8['push'](cg[0x0]);
              for (cC = 0x1; cC < H7; cC++)
                H8['push'](cg[0x0]);
              H8['push'](H8[0x0]),
                cg = H8;
            }
          }
          for (cm = new bE(),
            cC = 0x0; cC < cg['length']; cC++) {
            if (cL = cg[cC],
              bB['pointInPolygonByPList'](cq, cL)) {
              if (!cM && cC > 0x0) {
                for (H0 = new bj(),
                  H0['P1'] = cm,
                  H0['P2'] = cL,
                  cz = cq[cq['length'] - 0x1],
                  cR = new bE(),
                  cO = 0x0; cO < cq['length']; cO++) {
                  if (cQ = cq[cO],
                    H1 = new bj(),
                    H1['P1'] = cz,
                    H1['P2'] = cQ,
                    bB['isLineSegmentCross'](H0, H1)) {
                    cR = bB['getCrossPointD'](H0, H1),
                      H4['sPoint'] = cz,
                      H4['Point'] = cR,
                      H4['Index'] = H2['length'],
                      bB['_endPointList']['push'](H4);
                    break;
                  }
                  cz = cQ;
                }
                H5['push'](cR),
                  cP = 'Border';
              }
              H5['push'](cg[cC]),
                cM = true;
            } else {
              if (cM) {
                for (H0 = new bj(),
                  H0['P1'] = cm,
                  H0['P2'] = cL,
                  cz = cq[cq['length'] - 0x1],
                  cR = new bE(),
                  cO = 0x0; cO < cq['length']; cO++) {
                  if (cQ = cq[cO],
                    H1 = new bj(),
                    H1['P1'] = cz,
                    H1['P2'] = cQ,
                    bB['isLineSegmentCross'](H0, H1)) {
                    cR = bB['getCrossPointD'](H0, H1),
                      H4['sPoint'] = cz,
                      H4['Point'] = cR,
                      H4['Index'] = H2['length'],
                      bB['_endPointList']['push'](H4);
                    break;
                  }
                  cz = cQ;
                }
                H5['push'](cR),
                  H3['Value'] = cN,
                  H3['Type'] = cP,
                  H3['PointList'] = H5,
                  H2['push'](H3),
                  cM = false,
                  H5 = [],
                  cP = 'Border';
              }
            }
            cm = cL;
          }
          cM && H5['length'] > 0x1 && (H3['Value'] = cN,
            H3['Type'] = cP,
            H3['PointList'] = H5,
            H2['push'](H3));
        }
        return H2;
      }
      static ['cutContourLines'] (cd, cq) {
        let cJ, cC, cO, cG, cg, cN, cP, cM, cz, cQ, cm, cL, cR, H0, H1, H2, H3 = cq['LineList'][0x0]['pointList'], H4 = [], H5 = new bW();
        for (bB['_endPointList'] = [],
          bB['isClockwise'](H3) || H3['reverse'](),
          cJ = 0x0; cJ < cd['length']; cJ++) {
          cG = cd[cJ],
            cP = cG['Value'],
            cM = cG['Type'],
            cN = [],
            bB['addAll'](cG['PointList'], cN),
            cz = false;
          let H6 = [];
          if ('Close' === cM && bB['pointInPolygonByPList'](H3, cN[0x0])) {
            let H7 = true
              , H8 = 0x0;
            for (cC = 0x0; cC < cN['length']; cC++)
              if (!bB['pointInPolygonByPList'](H3, cN[cC])) {
                H8 = cC,
                  H7 = false;
                break;
              }
            if (!H7) {
              let H9 = [];
              for (cC = H8; cC < cN['length']; cC++)
                H9['push'](cN[cC]);
              for (cC = 0x1; cC < H8; cC++)
                H9['push'](cN[cC]);
              H9['push'](H9[0x0]),
                cN = H9;
            }
          }
          for (cL = new bE(),
            cC = 0x0; cC < cN['length']; cC++) {
            if (cR = cN[cC],
              bB['pointInPolygonByPList'](H3, cR)) {
              if (!cz && cC > 0x0) {
                for (H1 = new bj(),
                  H1['P1'] = cL,
                  H1['P2'] = cR,
                  cQ = H3[H3['length'] - 0x1],
                  H0 = new bE(),
                  cO = 0x0; cO < H3['length']; cO++) {
                  if (cm = H3[cO],
                    H2 = new bj(),
                    H2['P1'] = cQ,
                    H2['P2'] = cm,
                    bB['isLineSegmentCross'](H1, H2)) {
                    H0 = bB['getCrossPointD'](H1, H2),
                      H5['sPoint'] = cQ,
                      H5['Point'] = H0,
                      H5['Index'] = H4['length'],
                      bB['_endPointList']['push'](H5);
                    break;
                  }
                  cQ = cm;
                }
                H6['push'](H0),
                  cM = 'Border';
              }
              H6['push'](cN[cC]),
                cz = true;
            } else {
              if (cz) {
                for (H1 = new bj(),
                  H1['P1'] = cL,
                  H1['P2'] = cR,
                  cQ = H3[H3['length'] - 0x1],
                  H0 = new bE(),
                  cO = 0x0; cO < H3['length']; cO++) {
                  if (cm = H3[cO],
                    H2 = new bj(),
                    H2['P1'] = cQ,
                    H2['P2'] = cm,
                    bB['isLineSegmentCross'](H1, H2)) {
                    H0 = bB['getCrossPointD'](H1, H2),
                      H5['sPoint'] = cQ,
                      H5['Point'] = H0,
                      H5['Index'] = H4['length'],
                      bB['_endPointList']['push'](H5);
                    break;
                  }
                  cQ = cm;
                }
                H6['push'](H0),
                  cg = new bV(),
                  cg['Value'] = cP,
                  cg['Type'] = cM,
                  cg['PointList'] = H6,
                  H4['push'](cg),
                  cz = false,
                  H6 = [],
                  cM = 'Border';
              }
            }
            cL = cR;
          }
          cz && H6['length'] > 0x1 && (cg = new bV(),
            cg['Value'] = cP,
            cg['Type'] = cM,
            cg['PointList'] = H6,
            H4['push'](cg));
        }
        return H4;
      }
      static ['smoothLines'] (cd) {
        let cq, cJ, cC, cO = [];
        for (cq = 0x0; cq < cd['length']; cq++)
          if (cJ = cd[cq],
            cC = [],
            bB['addAll'](cJ['PointList'], cC),
            !(cC['length'] <= 0x1)) {
            if (0x2 === cC['length']) {
              let cG = new bE()
                , cg = cC[0x0]
                , cN = cC[0x1];
              cG['X'] = (cN['X'] - cg['X']) / 0x4 + cg['X'],
                cG['Y'] = (cN['Y'] - cg['Y']) / 0x4 + cg['Y'],
                cC['splice'](0x1, 0x0, cG),
                cG = new bE(),
                cG['X'] = (cN['X'] - cg['X']) / 0x4 * 0x3 + cg['X'],
                cG['Y'] = (cN['Y'] - cg['Y']) / 0x4 * 0x3 + cg['Y'],
                cC['splice'](0x2, 0x0, cG);
            }
            if (0x3 === cC['length']) {
              let cP = new bE()
                , cM = cC[0x0]
                , cz = cC[0x1];
              cP['X'] = (cz['X'] - cM['X']) / 0x2 + cM['X'],
                cP['Y'] = (cz['Y'] - cM['Y']) / 0x2 + cM['Y'],
                cC['splice'](0x1, 0x0, cP);
            }
            cC = bB['BSplineScanning'](cC, cC['length']),
              cJ['PointList'] = cC,
              cO['push'](cJ);
          }
        return cO;
      }
      static ['smoothPoints'] (cd) {
        return bB['BSplineScanning'](cd, cd['length']);
      }
      static ['tracingPolygons'] (cd, cq, cJ, cC) {
        let cO, cG, cg, cN, cP, cM, cz, cQ, cm, cL, cR, H0, H1 = [], H2 = [], H3 = [], H4 = [], H5 = [], H6 = 0x0;
        for (cz = 0x0; cz < cJ['length']; cz++) {
          if (H5 = [],
            H3 = [],
            H4 = [],
            H1 = [],
            cg = cJ[cz],
            cN = cg['LineList'][0x0],
            cG = cN['pointList'],
            bB['isClockwise'](cG) || cG['reverse'](),
            0x1 === cg['getLineNum']()) {
            for (cQ = 0x0; cQ < cG['length']; cQ++)
              cP = cG[cQ],
                cM = new bf(),
                cM['Id'] = -0x1,
                cM['Point'] = cP,
                cM['Value'] = cd[cN['ijPointList'][cQ]['I']][cN['ijPointList'][cQ]['J']],
                H5['push'](cM);
            for (cQ = 0x0; cQ < cq['length']; cQ++)
              cm = cq[cQ],
                cm['BorderIdx'] === cz && (H4['push'](cm),
                  'Border' === cm['Type'] && (cP = cm['PointList'][0x0],
                    cM = new bf(),
                    cM['Id'] = H4['length'] - 0x1,
                    cM['Point'] = cP,
                    cM['Value'] = cm['Value'],
                    H3['push'](cM),
                    cP = cm['PointList'][cm['PointList']['length'] - 0x1],
                    cM = new bf(),
                    cM['Id'] = H4['length'] - 0x1,
                    cM['Point'] = cP,
                    cM['Value'] = cm['Value'],
                    H3['push'](cM)));
            if (0x0 === H4['length']) {
              if (cR = cN['ijPointList'][0x0],
                cL = new bZ(),
                cd[cR['I']][cR['J']] < cC[0x0])
                H6 = cC[0x0],
                  cL['IsHighCenter'] = false;
              else {
                for (cQ = cC['length'] - 0x1; cQ >= 0x0; cQ--)
                  if (cd[cR['I']][cR['J']] > cC[cQ]) {
                    H6 = cC[cQ];
                    break;
                  }
                cL['IsHighCenter'] = true;
              }
              cG['length'] > 0x0 && (cL['IsBorder'] = true,
                cL['HighValue'] = H6,
                cL['LowValue'] = H6,
                cL['Extent'] = new bT(),
                cL['Area'] = bB['getExtentAndArea'](cG, cL['Extent']),
                cL['StartPointIdx'] = 0x0,
                cL['IsClockWise'] = true,
                cL['OutLine']['Type'] = 'Border',
                cL['OutLine']['Value'] = H6,
                cL['OutLine']['BorderIdx'] = cz,
                cL['OutLine']['PointList'] = cG,
                cL['HoleLines'] = [],
                H1['push'](cL));
            } else
              cO = H3['length'] > 0x0 ? bB['insertPoint2Border'](H3, H5) : H5,
                H1 = bB['tracingPolygons_Line_Border'](H4, cO);
            H1 = bB['addPolygonHoles'](H1);
          } else {
            for (cN = cg['LineList'][0x0],
              cQ = 0x0; cQ < cq['length']; cQ++)
              cm = cq[cQ],
                cm['BorderIdx'] === cz && (H4['push'](cm),
                  'Border' === cm['Type'] && (cP = cm['PointList'][0x0],
                    cM = new bf(),
                    cM['Id'] = H4['length'] - 0x1,
                    cM['Point'] = cP,
                    cM['Value'] = cm['Value'],
                    H3['push'](cM),
                    cP = cm['PointList'][cm['PointList']['length'] - 0x1],
                    cM = new bf(),
                    cM['Id'] = H4['length'] - 0x1,
                    cM['Point'] = cP,
                    cM['Value'] = cm['Value'],
                    H3['push'](cM)));
            if (0x0 === H4['length']) {
              if (cR = cN['ijPointList'][0x0],
                cL = new bZ(),
                cd[cR['I']][cR['J']] < cC[0x0])
                H6 = cC[0x0],
                  cL['IsHighCenter'] = false;
              else {
                for (cQ = cC['length'] - 0x1; cQ >= 0x0; cQ--)
                  if (cd[cR['I']][cR['J']] > cC[cQ]) {
                    H6 = cC[cQ];
                    break;
                  }
                cL['IsHighCenter'] = true;
              }
              cG['length'] > 0x0 && (cL['IsBorder'] = true,
                cL['HighValue'] = H6,
                cL['LowValue'] = H6,
                cL['Area'] = bB['getExtentAndArea'](cG, cL['Extent']),
                cL['StartPointIdx'] = 0x0,
                cL['IsClockWise'] = true,
                cL['OutLine']['Type'] = 'Border',
                cL['OutLine']['Value'] = H6,
                cL['OutLine']['BorderIdx'] = cz,
                cL['OutLine']['PointList'] = cG,
                cL['HoleLines'] = [],
                H1['push'](cL));
            } else {
              H0 = [],
                H0['length'] = cg['getLineNum'](),
                cO = bB['insertPoint2Border_Ring'](cd, H3, cg, H0),
                H1 = bB['tracingPolygons_Ring'](H4, cO, cg, cC, H0);
              let H8 = [];
              for (; H1['length'] > 0x0;) {
                let H9 = false;
                for (cQ = 0x0; cQ < H8['length']; cQ++)
                  if (H1[0x0]['Area'] > H8[cQ]['Area']) {
                    H8['push'](H1[0x0]),
                      H9 = true;
                    break;
                  }
                H9 || H8['push'](H1[0x0]),
                  H1['splice'](0x0, 0x1);
              }
              H1 = H8;
            }
            let H7 = [];
            for (cQ = 0x0; cQ < cg['getLineNum'](); cQ++)
              H7['push'](cg['LineList'][cQ]['pointList']);
            H7['length'] > 0x0 && bB['addHoles_Ring'](H1, H7),
              H1 = bB['addPolygonHoles_Ring'](H1);
          }
          bB['addAll'](H1, H2);
        }
        for (let Hv of H2)
          bB['isClockwise'](Hv['OutLine']['PointList']) || Hv['OutLine']['PointList']['reverse']();
        return H2;
      }
      static ['createContourPolygons'] (cd, cq, cJ) {
        let cC, cO;
        return cO = bB['insertPoint2RectangleBorder'](cd, cq),
          cC = bB['tracingPolygons_Extent'](cd, cO, cq, cJ),
          cC;
      }
      static ['createCutContourPolygons'] (cd, cq, cJ, cC) {
        let cO, cG, cg, cN, cP, cM = [];
        for (bB['isClockwise'](cq) || cq['reverse'](),
          cP = 0x0; cP < cq['length']; cP++)
          cg = cq[cP],
            cN = new bf(),
            cN['Id'] = -0x1,
            cN['Point'] = cg,
            cM['push'](cN);
        return cG = bB['insertEndPoint2Border'](bB['_endPointList'], cM),
          cO = bB['tracingPolygons_Extent'](cd, cG, cJ, cC),
          cO;
      }
      static ['createBorderContourPolygons'] (cd, cq, cJ, cC, cO) {
        let cG, cg, cN, cP, cM, cz, cQ, cm, cL, cR, H0, H1 = [], H2 = [], H3 = [], H4 = [], H5 = [], H6 = [], H7 = 0x0;
        for (cz = 0x0; cz < cJ['length']; cz++) {
          if (H6 = [],
            H3 = [],
            H5 = [],
            H1 = [],
            cg = cJ[cz],
            0x1 === cg['getLineNum']()) {
            for (cN = cg['LineList'][0x0],
              H4 = cN['pointList'],
              bB['isClockwise'](H4) || H4['reverse'](),
              cQ = 0x0; cQ < H4['length']; cQ++)
              cP = H4[cQ],
                cM = new bf(),
                cM['Id'] = -0x1,
                cM['Point'] = cP,
                cM['Value'] = cd[cN['ijPointList'][cQ]['I']][cN['ijPointList'][cQ]['J']],
                H6['push'](cM);
            for (cQ = 0x0; cQ < cq['length']; cQ++)
              cm = cq[cQ],
                cm['BorderIdx'] === cz && (H5['push'](cm),
                  'Border' === cm['Type'] && (cP = cm['PointList'][0x0],
                    cM = new bf(),
                    cM['Id'] = H5['length'] - 0x1,
                    cM['Point'] = cP,
                    cM['Value'] = cm['Value'],
                    H3['push'](cM),
                    cP = cm['PointList'][cm['PointList']['length'] - 0x1],
                    cM = new bf(),
                    cM['Id'] = H5['length'] - 0x1,
                    cM['Point'] = cP,
                    cM['Value'] = cm['Value'],
                    H3['push'](cM)));
            if (0x0 === H5['length']) {
              if (cR = cN['ijPointList'][0x0],
                cL = new bZ(),
                cd[cR['I']][cR['J']] < cO[0x0])
                H7 = cO[0x0],
                  cL['IsHighCenter'] = false;
              else {
                for (cQ = cO['length'] - 0x1; cQ >= 0x0; cQ--)
                  if (cd[cR['I']][cR['J']] > cO[cQ]) {
                    H7 = cO[cQ];
                    break;
                  }
                cL['IsHighCenter'] = true;
              }
              H4['length'] > 0x0 && (cL['HighValue'] = H7,
                cL['LowValue'] = H7,
                cL['Extent'] = new bT(),
                cL['Area'] = bB['getExtentAndArea'](H4, cL['Extent']),
                cL['StartPointIdx'] = 0x0,
                cL['IsClockWise'] = true,
                cL['OutLine']['Type'] = 'Border',
                cL['OutLine']['Value'] = H7,
                cL['OutLine']['BorderIdx'] = cz,
                cL['OutLine']['PointList'] = H4,
                H1['push'](cL));
            } else
              cG = bB['insertPoint2Border'](H3, H6),
                H1 = bB['tracingPolygons_Line_Border'](H5, cG);
          } else {
            for (cN = cg['LineList'][0x0],
              cQ = 0x0; cQ < cq['length']; cQ++)
              cm = cq[cQ],
                cm['BorderIdx'] === cz && (H5['push'](cm),
                  'Border' === cm['Type'] && (cP = cm['PointList'][0x0],
                    cM = new bf(),
                    cM['Id'] = H5['length'] - 0x1,
                    cM['Point'] = cP,
                    cM['Value'] = cm['Value'],
                    H3['push'](cM),
                    cP = cm['PointList'][cm['PointList']['length'] - 0x1],
                    cM = new bf(),
                    cM['Id'] = H5['length'] - 0x1,
                    cM['Point'] = cP,
                    cM['Value'] = cm['Value'],
                    H3['push'](cM)));
            if (0x0 === H5['length']) {
              if (cL = new bZ(),
                cR = cN['ijPointList'][0x0],
                cd[cR['I']][cR['J']] < cO[0x0])
                H7 = cO[0x0],
                  cL['IsHighCenter'] = false;
              else {
                for (cQ = cO['length'] - 0x1; cQ >= 0x0; cQ--)
                  if (cd[cR['I']][cR['J']] > cO[cQ]) {
                    H7 = cO[cQ];
                    break;
                  }
                cL['IsHighCenter'] = true;
              }
              H4['length'] > 0x0 && (cL['HighValue'] = H7,
                cL['LowValue'] = H7,
                cL['Area'] = bB['getExtentAndArea'](H4, cL['Extent']),
                cL['StartPointIdx'] = 0x0,
                cL['IsClockWise'] = true,
                cL['OutLine']['Type'] = 'Border',
                cL['OutLine']['Value'] = H7,
                cL['OutLine']['BorderIdx'] = cz,
                cL['OutLine']['PointList'] = H4,
                H1['push'](cL));
            } else
              H0 = [],
                cG = bB['insertPoint2Border_Ring'](cd, H3, cg, H0),
                H1 = bB['tracingPolygons_Ring'](H5, cG, cg, cO, H0);
          }
          bB['addAll'](H1, H2);
        }
        return H2;
      }
      static ['pointInPolygonByPList'] (cd, cq) {
        let cJ, cC, cO, cG, cg, cN, cP, cM, cz, cQ = false, cm = cd['length'];
        if (cm < 0x3)
          return false;
        for (cO = cd[cm - 0x1]['X'],
          cG = cd[cm - 0x1]['Y'],
          cz = 0x0; cz < cm; cz++)
          cJ = cd[cz]['X'],
            cC = cd[cz]['Y'],
            cJ > cO ? (cg = cO,
              cP = cJ,
              cN = cG,
              cM = cC) : (cg = cJ,
                cP = cO,
                cN = cC,
                cM = cG),
            cJ < cq['X'] == cq['X'] <= cO && (cq['Y'] - cN) * (cP - cg) < (cM - cN) * (cq['X'] - cg) && (cQ = !cQ),
            cO = cJ,
            cG = cC;
        return cQ;
      }
      static ['pointInPolygon'] (cd, cq) {
        if (cd['HasHoles']()) {
          let cJ = bB['pointInPolygonByPList'](cd['OutLine']['PointList'], cq);
          if (cJ) {
            for (let cC of cd['HoleLines'])
              if (bB['pointInPolygonByPList'](cC['PointList'], cq)) {
                cJ = false;
                break;
              }
          }
          return cJ;
        }
        return bB['pointInPolygonByPList'](cd['OutLine']['PointList'], cq);
      }
      static ['clipPolylines'] (cd, cq) {
        let cJ = [];
        for (let cC of cd)
          bB['addAll'](bB['cutPolyline'](cC, cq), cJ);
        return cJ;
      }
      static ['clipPolygons'] (cd, cq) {
        let cJ = [];
        for (let cG = 0x0; cG < cd['length']; cG++) {
          let cg = cd[cG];
          cg['HasHoles']() ? bB['addAll'](bB['cutPolygon_Hole'](cg, cq), cJ) : bB['addAll'](bB['cutPolygon'](cg, cq), cJ);
        }
        let cC, cO = [];
        for (let cN = 0x0; cN < cJ['length']; cN++) {
          let cP = cJ[cN];
          cC = false;
          for (let cM = 0x0; cM < cO['length']; cM++)
            if (cP['Area'] > cO[cM]['Area']) {
              cO['splice'](cM, 0x0, cP),
                cC = true;
              break;
            }
          cC || cO['push'](cP);
        }
        return cO;
      }
      static ['traceBorder'] (cd, cq, cJ, cC, cO, cG) {
        let cg, cN, cP, cM, cz = true;
        return cq < cJ ? 0x1 === cd[cJ][cO - 0x1] && 0x1 === cd[cJ][cO + 0x1] ? (cg = cd[cJ - 0x1][cO - 0x1],
          cN = cd[cJ + 0x1][cO],
          cP = cd[cJ + 0x1][cO - 0x1],
          0x0 !== cg && 0x0 === cN || 0x0 === cg && 0x0 !== cN && 0x0 !== cP ? (cG[0x0] = cJ,
            cG[0x1] = cO - 0x1) : (cG[0x0] = cJ,
              cG[0x1] = cO + 0x1)) : 0x1 === cd[cJ][cO - 0x1] && 0x1 === cd[cJ + 0x1][cO] ? (cg = cd[cJ + 0x1][cO - 0x1],
                cN = cd[cJ + 0x1][cO + 0x1],
                cP = cd[cJ][cO - 0x1],
                cM = cd[cJ][cO + 0x1],
                0x0 === cg || 0x0 === cN || 0x0 === cP || 0x0 === cM ? 0x0 === cg && 0x0 === cM || 0x0 === cN && 0x0 === cP ? (cG[0x0] = cJ,
                  cG[0x1] = cO - 0x1) : (cG[0x0] = cJ + 0x1,
                    cG[0x1] = cO) : (cG[0x0] = cJ,
                      cG[0x1] = cO - 0x1)) : 0x1 === cd[cJ][cO + 0x1] && 0x1 === cd[cJ + 0x1][cO] ? (cg = cd[cJ + 0x1][cO - 0x1],
                        cN = cd[cJ + 0x1][cO + 0x1],
                        cP = cd[cJ][cO - 0x1],
                        cM = cd[cJ][cO + 0x1],
                        0x0 === cg || 0x0 === cN || 0x0 === cP || 0x0 === cM ? 0x0 === cg && 0x0 === cM || 0x0 === cN && 0x0 === cP ? (cG[0x0] = cJ,
                          cG[0x1] = cO + 0x1) : (cG[0x0] = cJ + 0x1,
                            cG[0x1] = cO) : (cG[0x0] = cJ,
                              cG[0x1] = cO + 0x1)) : 0x1 === cd[cJ][cO - 0x1] ? (cG[0x0] = cJ,
                                cG[0x1] = cO - 0x1) : 0x1 === cd[cJ][cO + 0x1] ? (cG[0x0] = cJ,
                                  cG[0x1] = cO + 0x1) : 0x1 === cd[cJ + 0x1][cO] ? (cG[0x0] = cJ + 0x1,
                                    cG[0x1] = cO) : cz = false : cC < cO ? 0x1 === cd[cJ + 0x1][cO] && 0x1 === cd[cJ - 0x1][cO] ? (cg = cd[cJ + 0x1][cO - 0x1],
                                      cN = cd[cJ][cO + 0x1],
                                      cP = cd[cJ + 0x1][cO + 0x1],
                                      0x0 !== cg && 0x0 === cN || 0x0 === cg && 0x0 !== cN && 0x0 !== cP ? (cG[0x0] = cJ + 0x1,
                                        cG[0x1] = cO) : (cG[0x0] = cJ - 0x1,
                                          cG[0x1] = cO)) : 0x1 === cd[cJ + 0x1][cO] && 0x1 === cd[cJ][cO + 0x1] ? (cP = cd[cJ - 0x1][cO],
                                            cM = cd[cJ + 0x1][cO],
                                            cg = cd[cJ - 0x1][cO + 0x1],
                                            cN = cd[cJ + 0x1][cO + 0x1],
                                            0x0 === cg || 0x0 === cN || 0x0 === cP || 0x0 === cM ? 0x0 === cg && 0x0 === cM || 0x0 === cN && 0x0 === cP ? (cG[0x0] = cJ + 0x1,
                                              cG[0x1] = cO) : (cG[0x0] = cJ,
                                                cG[0x1] = cO + 0x1) : (cG[0x0] = cJ + 0x1,
                                                  cG[0x1] = cO)) : 0x1 === cd[cJ - 0x1][cO] && 0x1 === cd[cJ][cO + 0x1] ? (cP = cd[cJ - 0x1][cO],
                                                    cM = cd[cJ + 0x1][cO],
                                                    cg = cd[cJ - 0x1][cO + 0x1],
                                                    cN = cd[cJ + 0x1][cO + 0x1],
                                                    0x0 === cg || 0x0 === cN || 0x0 === cP || 0x0 === cM ? 0x0 === cg && 0x0 === cM || 0x0 === cN && 0x0 === cP ? (cG[0x0] = cJ - 0x1,
                                                      cG[0x1] = cO) : (cG[0x0] = cJ,
                                                        cG[0x1] = cO + 0x1) : (cG[0x0] = cJ - 0x1,
                                                          cG[0x1] = cO)) : 0x1 === cd[cJ + 0x1][cO] ? (cG[0x0] = cJ + 0x1,
                                                            cG[0x1] = cO) : 0x1 === cd[cJ - 0x1][cO] ? (cG[0x0] = cJ - 0x1,
                                                              cG[0x1] = cO) : 0x1 === cd[cJ][cO + 0x1] ? (cG[0x0] = cJ,
                                                                cG[0x1] = cO + 0x1) : cz = false : cq > cJ ? 0x1 === cd[cJ][cO - 0x1] && 0x1 === cd[cJ][cO + 0x1] ? (cg = cd[cJ + 0x1][cO - 0x1],
                                                                  cN = cd[cJ - 0x1][cO],
                                                                  cP = cd[cJ - 0x1][cO + 0x1],
                                                                  0x0 !== cg && 0x0 === cN || 0x0 === cg && 0x0 !== cN && 0x0 !== cP ? (cG[0x0] = cJ,
                                                                    cG[0x1] = cO - 0x1) : (cG[0x0] = cJ,
                                                                      cG[0x1] = cO + 0x1)) : 0x1 === cd[cJ][cO - 0x1] && 0x1 === cd[cJ - 0x1][cO] ? (cg = cd[cJ - 0x1][cO - 0x1],
                                                                        cN = cd[cJ - 0x1][cO + 0x1],
                                                                        cP = cd[cJ][cO - 0x1],
                                                                        cM = cd[cJ][cO + 0x1],
                                                                        0x0 === cg || 0x0 === cN || 0x0 === cP || 0x0 === cM ? 0x0 === cg && 0x0 === cM || 0x0 === cN && 0x0 === cP ? (cG[0x0] = cJ,
                                                                          cG[0x1] = cO - 0x1) : (cG[0x0] = cJ - 0x1,
                                                                            cG[0x1] = cO) : (cG[0x0] = cJ,
                                                                              cG[0x1] = cO - 0x1)) : 0x1 === cd[cJ][cO + 0x1] && 0x1 === cd[cJ - 0x1][cO] ? (cg = cd[cJ - 0x1][cO - 0x1],
                                                                                cN = cd[cJ - 0x1][cO + 0x1],
                                                                                cP = cd[cJ][cO - 0x1],
                                                                                cM = cd[cJ][cO + 0x1],
                                                                                0x0 === cg || 0x0 === cN || 0x0 === cP || 0x0 === cM ? 0x0 === cg && 0x0 === cM || 0x0 === cN && 0x0 === cP ? (cG[0x0] = cJ,
                                                                                  cG[0x1] = cO + 0x1) : (cG[0x0] = cJ - 0x1,
                                                                                    cG[0x1] = cO) : (cG[0x0] = cJ,
                                                                                      cG[0x1] = cO + 0x1)) : 0x1 === cd[cJ][cO - 0x1] ? (cG[0x0] = cJ,
                                                                                        cG[0x1] = cO - 0x1) : 0x1 === cd[cJ][cO + 0x1] ? (cG[0x0] = cJ,
                                                                                          cG[0x1] = cO + 0x1) : 0x1 === cd[cJ - 0x1][cO] ? (cG[0x0] = cJ - 0x1,
                                                                                            cG[0x1] = cO) : cz = false : cC > cO && (0x1 === cd[cJ + 0x1][cO] && 0x1 === cd[cJ - 0x1][cO] ? (cg = cd[cJ + 0x1][cO + 0x1],
                                                                                              cN = cd[cJ][cO - 0x1],
                                                                                              cP = cd[cJ - 0x1][cO - 0x1],
                                                                                              0x0 !== cg && 0x0 === cN || 0x0 === cg && 0x0 !== cN && 0x0 !== cP ? (cG[0x0] = cJ + 0x1,
                                                                                                cG[0x1] = cO) : (cG[0x0] = cJ - 0x1,
                                                                                                  cG[0x1] = cO)) : 0x1 === cd[cJ + 0x1][cO] && 0x1 === cd[cJ][cO - 0x1] ? (cP = cd[cJ - 0x1][cO],
                                                                                                    cM = cd[cJ + 0x1][cO],
                                                                                                    cg = cd[cJ - 0x1][cO - 0x1],
                                                                                                    cN = cd[cJ + 0x1][cO - 0x1],
                                                                                                    0x0 === cg || 0x0 === cN || 0x0 === cP || 0x0 === cM ? 0x0 === cg && 0x0 === cM || 0x0 === cN && 0x0 === cP ? (cG[0x0] = cJ + 0x1,
                                                                                                      cG[0x1] = cO) : (cG[0x0] = cJ,
                                                                                                        cG[0x1] = cO - 0x1) : (cG[0x0] = cJ + 0x1,
                                                                                                          cG[0x1] = cO)) : 0x1 === cd[cJ - 0x1][cO] && 0x1 === cd[cJ][cO - 0x1] ? (cP = cd[cJ - 0x1][cO],
                                                                                                            cM = cd[cJ + 0x1][cO],
                                                                                                            cg = cd[cJ - 0x1][cO - 0x1],
                                                                                                            cN = cd[cJ + 0x1][cO - 0x1],
                                                                                                            0x0 === cg || 0x0 === cN || 0x0 === cP || 0x0 === cM ? 0x0 === cg && 0x0 === cM || 0x0 === cN && 0x0 === cP ? (cG[0x0] = cJ - 0x1,
                                                                                                              cG[0x1] = cO) : (cG[0x0] = cJ,
                                                                                                                cG[0x1] = cO - 0x1) : (cG[0x0] = cJ - 0x1,
                                                                                                                  cG[0x1] = cO)) : 0x1 === cd[cJ + 0x1][cO] ? (cG[0x0] = cJ + 0x1,
                                                                                                                    cG[0x1] = cO) : 0x1 === cd[cJ - 0x1][cO] ? (cG[0x0] = cJ - 0x1,
                                                                                                                      cG[0x1] = cO) : 0x1 === cd[cJ][cO - 0x1] ? (cG[0x0] = cJ,
                                                                                                                        cG[0x1] = cO - 0x1) : cz = false),
          cz;
      }
      static ['traceIsoline_UndefData'] (cd, cq, cJ, cC, cO, cG, cg, cN, cP, cM, cz, cQ) {
        let cm = true
          , cL = 0x0
          , cR = 0x0
          , H0 = 0x0
          , H1 = 0x0
          , H2 = true;
        return cd < cq ? -0x2 !== cJ[cq][cG] && -0x2 !== cJ[cq][cG + 0x1] ? cJ[cq][cG] < cJ[cq][cG + 0x1] ? (cL = cg[cG],
          cR = cN[cq] + cJ[cq][cG] * (cN[cq + 0x1] - cN[cq]),
          H0 = cq,
          H1 = cG,
          cJ[H0][H1] = -0x2,
          H2 = false) : (cL = cg[cG + 0x1],
            cR = cN[cq] + cJ[cq][cG + 0x1] * (cN[cq + 0x1] - cN[cq]),
            H0 = cq,
            H1 = cG + 0x1,
            cJ[H0][H1] = -0x2,
            H2 = false) : -0x2 !== cJ[cq][cG] && -0x2 === cJ[cq][cG + 0x1] ? (cL = cg[cG],
              cR = cN[cq] + cJ[cq][cG] * (cN[cq + 0x1] - cN[cq]),
              H0 = cq,
              H1 = cG,
              cJ[H0][H1] = -0x2,
              H2 = false) : -0x2 === cJ[cq][cG] && -0x2 !== cJ[cq][cG + 0x1] ? (cL = cg[cG + 0x1],
                cR = cN[cq] + cJ[cq][cG + 0x1] * (cN[cq + 0x1] - cN[cq]),
                H0 = cq,
                H1 = cG + 0x1,
                cJ[H0][H1] = -0x2,
                H2 = false) : -0x2 !== cC[cq + 0x1][cG] ? (cL = cg[cG] + cC[cq + 0x1][cG] * (cg[cG + 0x1] - cg[cG]),
                  cR = cN[cq + 0x1],
                  H0 = cq + 0x1,
                  H1 = cG,
                  cC[H0][H1] = -0x2,
                  H2 = true) : cm = false : cO < cG ? -0x2 !== cC[cq][cG] && -0x2 !== cC[cq + 0x1][cG] ? cC[cq][cG] < cC[cq + 0x1][cG] ? (cL = cg[cG] + cC[cq][cG] * (cg[cG + 0x1] - cg[cG]),
                    cR = cN[cq],
                    H0 = cq,
                    H1 = cG,
                    cC[H0][H1] = -0x2,
                    H2 = true) : (cL = cg[cG] + cC[cq + 0x1][cG] * (cg[cG + 0x1] - cg[cG]),
                      cR = cN[cq + 0x1],
                      H0 = cq + 0x1,
                      H1 = cG,
                      cC[H0][H1] = -0x2,
                      H2 = true) : -0x2 !== cC[cq][cG] && -0x2 === cC[cq + 0x1][cG] ? (cL = cg[cG] + cC[cq][cG] * (cg[cG + 0x1] - cg[cG]),
                        cR = cN[cq],
                        H0 = cq,
                        H1 = cG,
                        cC[H0][H1] = -0x2,
                        H2 = true) : -0x2 === cC[cq][cG] && -0x2 !== cC[cq + 0x1][cG] ? (cL = cg[cG] + cC[cq + 0x1][cG] * (cg[cG + 0x1] - cg[cG]),
                          cR = cN[cq + 0x1],
                          H0 = cq + 0x1,
                          H1 = cG,
                          cC[H0][H1] = -0x2,
                          H2 = true) : -0x2 !== cJ[cq][cG + 0x1] ? (cL = cg[cG + 0x1],
                            cR = cN[cq] + cJ[cq][cG + 0x1] * (cN[cq + 0x1] - cN[cq]),
                            H0 = cq,
                            H1 = cG + 0x1,
                            cJ[H0][H1] = -0x2,
                            H2 = false) : cm = false : cg[cG] < cP ? -0x2 !== cJ[cq - 0x1][cG] && -0x2 !== cJ[cq - 0x1][cG + 0x1] ? cJ[cq - 0x1][cG] > cJ[cq - 0x1][cG + 0x1] ? (cL = cg[cG],
                              cR = cN[cq - 0x1] + cJ[cq - 0x1][cG] * (cN[cq] - cN[cq - 0x1]),
                              H0 = cq - 0x1,
                              H1 = cG,
                              cJ[H0][H1] = -0x2,
                              H2 = false) : (cL = cg[cG + 0x1],
                                cR = cN[cq - 0x1] + cJ[cq - 0x1][cG + 0x1] * (cN[cq] - cN[cq - 0x1]),
                                H0 = cq - 0x1,
                                H1 = cG + 0x1,
                                cJ[H0][H1] = -0x2,
                                H2 = false) : -0x2 !== cJ[cq - 0x1][cG] && -0x2 === cJ[cq - 0x1][cG + 0x1] ? (cL = cg[cG],
                                  cR = cN[cq - 0x1] + cJ[cq - 0x1][cG] * (cN[cq] - cN[cq - 0x1]),
                                  H0 = cq - 0x1,
                                  H1 = cG,
                                  cJ[H0][H1] = -0x2,
                                  H2 = false) : -0x2 === cJ[cq - 0x1][cG] && -0x2 !== cJ[cq - 0x1][cG + 0x1] ? (cL = cg[cG + 0x1],
                                    cR = cN[cq - 0x1] + cJ[cq - 0x1][cG + 0x1] * (cN[cq] - cN[cq - 0x1]),
                                    H0 = cq - 0x1,
                                    H1 = cG + 0x1,
                                    cJ[H0][H1] = -0x2,
                                    H2 = false) : -0x2 !== cC[cq - 0x1][cG] ? (cL = cg[cG] + cC[cq - 0x1][cG] * (cg[cG + 0x1] - cg[cG]),
                                      cR = cN[cq - 0x1],
                                      H0 = cq - 0x1,
                                      H1 = cG,
                                      cC[H0][H1] = -0x2,
                                      H2 = true) : cm = false : -0x2 !== cC[cq + 0x1][cG - 0x1] && -0x2 !== cC[cq][cG - 0x1] ? cC[cq + 0x1][cG - 0x1] > cC[cq][cG - 0x1] ? (cL = cg[cG - 0x1] + cC[cq + 0x1][cG - 0x1] * (cg[cG] - cg[cG - 0x1]),
                                        cR = cN[cq + 0x1],
                                        H0 = cq + 0x1,
                                        H1 = cG - 0x1,
                                        cC[H0][H1] = -0x2,
                                        H2 = true) : (cL = cg[cG - 0x1] + cC[cq][cG - 0x1] * (cg[cG] - cg[cG - 0x1]),
                                          cR = cN[cq],
                                          H0 = cq,
                                          H1 = cG - 0x1,
                                          cC[H0][H1] = -0x2,
                                          H2 = true) : -0x2 !== cC[cq + 0x1][cG - 0x1] && -0x2 === cC[cq][cG - 0x1] ? (cL = cg[cG - 0x1] + cC[cq + 0x1][cG - 0x1] * (cg[cG] - cg[cG - 0x1]),
                                            cR = cN[cq + 0x1],
                                            H0 = cq + 0x1,
                                            H1 = cG - 0x1,
                                            cC[H0][H1] = -0x2,
                                            H2 = true) : -0x2 === cC[cq + 0x1][cG - 0x1] && -0x2 !== cC[cq][cG - 0x1] ? (cL = cg[cG - 0x1] + cC[cq][cG - 0x1] * (cg[cG] - cg[cG - 0x1]),
                                              cR = cN[cq],
                                              H0 = cq,
                                              H1 = cG - 0x1,
                                              cC[H0][H1] = -0x2,
                                              H2 = true) : -0x2 !== cJ[cq][cG - 0x1] ? (cL = cg[cG - 0x1],
                                                cR = cN[cq] + cJ[cq][cG - 0x1] * (cN[cq + 0x1] - cN[cq]),
                                                H0 = cq,
                                                H1 = cG - 0x1,
                                                cJ[H0][H1] = -0x2,
                                                H2 = false) : cm = false,
          cM[0x0] = H0,
          cM[0x1] = H1,
          cz[0x0] = cL,
          cz[0x1] = cR,
          cQ[0x0] = H2,
          cm;
      }
      static ['isoline_UndefData'] (cd, cq, cJ, cC, cO, cG, cg, cN, cP) {
        let cM, cz, cQ, cm, cL = [];
        cM = cd['length'],
          cz = cd[0x0]['length'];
        let cR, H0, H1, H2, H3, H4, H5, H6, H7, H8, H9, Hv = 0x0, HA = 0x0, Hk = 0x0, Hl = 0x0, HK = true, Hb = new bW();
        for (cQ = 0x0; cQ < cM; cQ++)
          for (cm = 0x0; cm < cz; cm++) {
            if (cm < cz - 0x1 && cg[0x0][cQ][cm] > -0x1 && -0x2 !== cO[cQ][cm]) {
              for (H9 = [],
                H0 = cQ,
                H2 = cm,
                H3 = cq[H2] + cO[H0][H2] * (cq[H2 + 0x1] - cq[H2]),
                H4 = cJ[H0],
                0x0 === cg[0x1][cQ][cm] ? (cR = -0x1,
                  Hb['sPoint']['X'] = cq[cm + 0x1],
                  Hb['sPoint']['Y'] = cJ[cQ]) : (cR = H0,
                    Hb['sPoint']['X'] = cq[cm],
                    Hb['sPoint']['Y'] = cJ[cQ]),
                H1 = H2,
                H7 = new bE(),
                H7['X'] = H3,
                H7['Y'] = H4,
                H9['push'](H7),
                Hb['Index'] = cP + cL['length'],
                Hb['Point'] = H7,
                Hb['BorderIdx'] = cg[0x0][cQ][cm],
                bB['_endPointList']['push'](Hb),
                H8 = new bV(),
                H8['Type'] = 'Border',
                H8['BorderIdx'] = cg[0x0][cQ][cm]; ;) {
                let Hc = [Hv, HA]
                  , HH = [Hk, Hl]
                  , Hx = [HK];
                if (!bB['traceIsoline_UndefData'](cR, H0, cG, cO, H1, H2, cq, cJ, H3, Hc, HH, Hx)) {
                  H8['Type'] = 'Error';
                  break;
                }
                if (Hv = Hc[0x0],
                  HA = Hc[0x1],
                  Hk = HH[0x0],
                  Hl = HH[0x1],
                  HK = Hx[0x0],
                  H7 = new bE(),
                  H7['X'] = Hk,
                  H7['Y'] = Hl,
                  H9['push'](H7),
                  HK) {
                  if (cg[0x0][Hv][HA] > -0x1) {
                    0x0 === cg[0x1][Hv][HA] ? (Hb['sPoint']['X'] = cq[HA + 0x1],
                      Hb['sPoint']['Y'] = cJ[Hv]) : (Hb['sPoint']['X'] = cq[HA],
                        Hb['sPoint']['Y'] = cJ[Hv]);
                    break;
                  }
                } else {
                  if (cN[0x0][Hv][HA] > -0x1) {
                    0x0 === cN[0x1][Hv][HA] ? (Hb['sPoint']['X'] = cq[HA],
                      Hb['sPoint']['Y'] = cJ[Hv]) : (Hb['sPoint']['X'] = cq[HA],
                        Hb['sPoint']['Y'] = cJ[Hv + 0x1]);
                    break;
                  }
                }
                H3 = Hk,
                  cR = H0,
                  H1 = H2,
                  H0 = Hv,
                  H2 = HA;
              }
              cO[cQ][cm] = -0x2,
                H9['length'] > 0x1 && 'Error' !== H8['Type'] ? (Hb['Point'] = H7,
                  bB['_endPointList']['push'](Hb),
                  H8['Value'] = cC,
                  H8['PointList'] = H9,
                  cL['push'](H8)) : bB['_endPointList']['pop']();
            }
            if (cQ < cM - 0x1 && cN[0x0][cQ][cm] > -0x1 && -0x2 !== cG[cQ][cm]) {
              for (H9 = [],
                H0 = cQ,
                H2 = cm,
                H3 = cq[H2],
                H4 = cJ[H0] + cG[H0][H2] * (cJ[H0 + 0x1] - cJ[H0]),
                cR = H0,
                0x0 === cN[0x1][cQ][cm] ? (H1 = -0x1,
                  Hb['sPoint']['X'] = cq[cm],
                  Hb['sPoint']['Y'] = cJ[cQ]) : (H1 = H2,
                    Hb['sPoint']['X'] = cq[cm],
                    Hb['sPoint']['Y'] = cJ[cQ + 0x1]),
                H7 = new bE(),
                H7['X'] = H3,
                H7['Y'] = H4,
                H9['push'](H7),
                Hb['Index'] = cP + cL['length'],
                Hb['Point'] = H7,
                Hb['BorderIdx'] = cN[0x0][cQ][cm],
                bB['_endPointList']['push'](Hb),
                H8 = new bV(),
                H8['Type'] = 'Border',
                H8['BorderIdx'] = cN[0x0][cQ][cm]; ;) {
                let Hp = [Hv, HA]
                  , HF = [Hk, Hl]
                  , Hy = [HK];
                if (!bB['traceIsoline_UndefData'](cR, H0, cG, cO, H1, H2, cq, cJ, H3, Hp, HF, Hy)) {
                  H8['Type'] = 'Error';
                  break;
                }
                if (Hv = Hp[0x0],
                  HA = Hp[0x1],
                  Hk = HF[0x0],
                  Hl = HF[0x1],
                  HK = Hy[0x0],
                  H7 = new bE(),
                  H7['X'] = Hk,
                  H7['Y'] = Hl,
                  H9['push'](H7),
                  HK) {
                  if (cg[0x0][Hv][HA] > -0x1) {
                    0x0 === cg[0x1][Hv][HA] ? (Hb['sPoint']['X'] = cq[HA + 0x1],
                      Hb['sPoint']['Y'] = cJ[Hv]) : (Hb['sPoint']['X'] = cq[HA],
                        Hb['sPoint']['Y'] = cJ[Hv]);
                    break;
                  }
                } else {
                  if (cN[0x0][Hv][HA] > -0x1) {
                    0x0 === cN[0x1][Hv][HA] ? (Hb['sPoint']['X'] = cq[HA],
                      Hb['sPoint']['Y'] = cJ[Hv]) : (Hb['sPoint']['X'] = cq[HA],
                        Hb['sPoint']['Y'] = cJ[Hv + 0x1]);
                    break;
                  }
                }
                H3 = Hk,
                  cR = H0,
                  H1 = H2,
                  H0 = Hv,
                  H2 = HA;
              }
              cG[cQ][cm] = -0x2,
                H9['length'] > 0x1 && 'Error' !== H8['Type'] ? (Hb['Point'] = H7,
                  bB['_endPointList']['push'](Hb),
                  H8['Value'] = cC,
                  H8['PointList'] = H9,
                  cL['push'](H8)) : bB['_endPointList']['pop']();
            }
          }
        for (cm = 0x0; cm < cz - 0x1; cm++)
          -0x2 !== cO[0x0][cm] && (cO[0x0][cm] = -0x2),
            -0x2 !== cO[cM - 0x1][cm] && (cO[cM - 0x1][cm] = -0x2);
        for (cQ = 0x0; cQ < cM - 0x1; cQ++)
          -0x2 !== cG[cQ][0x0] && (cG[cQ][0x0] = -0x2),
            -0x2 !== cG[cQ][cz - 0x1] && (cG[cQ][cz - 0x1] = -0x2);
        for (cQ = 0x1; cQ < cM - 0x2; cQ++)
          for (cm = 0x1; cm < cz - 0x1; cm++)
            if (-0x2 !== cG[cQ][cm]) {
              let Hw = [];
              for (H0 = cQ,
                H2 = cm,
                H3 = cq[H2],
                H4 = cJ[cQ] + cG[cQ][H2] * (cJ[cQ + 0x1] - cJ[cQ]),
                H1 = -0x1,
                cR = H0,
                H5 = H3,
                H6 = H4,
                H7 = new bE(),
                H7['X'] = H3,
                H7['Y'] = H4,
                Hw['push'](H7),
                H8 = new bV(),
                H8['Type'] = 'Close'; ;) {
                let Hh = []
                  , Hu = []
                  , HY = [];
                if (!bB['traceIsoline_UndefData'](cR, H0, cG, cO, H1, H2, cq, cJ, H3, Hh, Hu, HY)) {
                  H8['Type'] = 'Error';
                  break;
                }
                if (Hv = Hh[0x0],
                  HA = Hh[0x1],
                  Hk = Hu[0x0],
                  Hl = Hu[0x1],
                  H7 = new bE(),
                  H7['X'] = Hk,
                  H7['Y'] = Hl,
                  Hw['push'](H7),
                  Math['abs'](Hl - H6) < 0.000001 && Math['abs'](Hk - H5) < 0.000001)
                  break;
                H3 = Hk,
                  cR = H0,
                  H1 = H2,
                  H0 = Hv,
                  H2 = HA;
              }
              cG[cQ][cm] = -0x2,
                Hw['length'] > 0x1 && 'Error' !== H8['Type'] && (H8['Value'] = cC,
                  H8['PointList'] = Hw,
                  cL['push'](H8));
            }
        for (cQ = 0x1; cQ < cM - 0x1; cQ++)
          for (cm = 0x1; cm < cz - 0x2; cm++)
            if (-0x2 !== cO[cQ][cm]) {
              let HT = [];
              for (H0 = cQ,
                H2 = cm,
                H3 = cq[H2] + cO[cQ][cm] * (cq[H2 + 0x1] - cq[H2]),
                H4 = cJ[cQ],
                H1 = H2,
                cR = -0x1,
                H5 = H3,
                H6 = H4,
                H7 = new bE(),
                H7['X'] = H3,
                H7['Y'] = H4,
                HT['push'](H7),
                H8 = new bV(),
                H8['Type'] = 'Close'; ;) {
                let HX = []
                  , HE = []
                  , Hf = [];
                if (!bB['traceIsoline_UndefData'](cR, H0, cG, cO, H1, H2, cq, cJ, H3, HX, HE, Hf)) {
                  H8['Type'] = 'Error';
                  break;
                }
                if (Hv = HX[0x0],
                  HA = HX[0x1],
                  Hk = HE[0x0],
                  Hl = HE[0x1],
                  H7 = new bE(),
                  H7['X'] = Hk,
                  H7['Y'] = Hl,
                  HT['push'](H7),
                  Math['abs'](Hl - H6) < 0.000001 && Math['abs'](Hk - H5) < 0.000001)
                  break;
                H3 = Hk,
                  cR = H0,
                  H1 = H2,
                  H0 = Hv,
                  H2 = HA;
              }
              cO[cQ][cm] = -0x2,
                HT['length'] > 0x1 && 'Error' !== H8['Type'] && (H8['Value'] = cC,
                  H8['PointList'] = HT,
                  cL['push'](H8));
            }
        return cL;
      }
      static ['traceIsoline'] (cd, cq, cJ, cC, cO, cG, cg, cN, cP, cM, cz) {
        let cQ, cm, cL, cR;
        return cd < cq ? -0x2 !== cJ[cq][cG] && -0x2 !== cJ[cq][cG + 0x1] ? cJ[cq][cG] < cJ[cq][cG + 0x1] ? (cL = cg[cG],
          cR = cN[cq] + cJ[cq][cG] * cM,
          cQ = cq,
          cm = cG,
          cJ[cQ][cm] = -0x2) : (cL = cg[cG + 0x1],
            cR = cN[cq] + cJ[cq][cG + 0x1] * cM,
            cQ = cq,
            cm = cG + 0x1,
            cJ[cQ][cm] = -0x2) : -0x2 !== cJ[cq][cG] && -0x2 === cJ[cq][cG + 0x1] ? (cL = cg[cG],
              cR = cN[cq] + cJ[cq][cG] * cM,
              cQ = cq,
              cm = cG,
              cJ[cQ][cm] = -0x2) : -0x2 === cJ[cq][cG] && -0x2 !== cJ[cq][cG + 0x1] ? (cL = cg[cG + 0x1],
                cR = cN[cq] + cJ[cq][cG + 0x1] * cM,
                cQ = cq,
                cm = cG + 0x1,
                cJ[cQ][cm] = -0x2) : (cL = cg[cG] + cC[cq + 0x1][cG] * cP,
                  cR = cN[cq + 0x1],
                  cQ = cq + 0x1,
                  cm = cG,
                  cC[cQ][cm] = -0x2) : cO < cG ? -0x2 !== cC[cq][cG] && -0x2 !== cC[cq + 0x1][cG] ? cC[cq][cG] < cC[cq + 0x1][cG] ? (cL = cg[cG] + cC[cq][cG] * cP,
                    cR = cN[cq],
                    cQ = cq,
                    cm = cG,
                    cC[cQ][cm] = -0x2) : (cL = cg[cG] + cC[cq + 0x1][cG] * cP,
                      cR = cN[cq + 0x1],
                      cQ = cq + 0x1,
                      cm = cG,
                      cC[cQ][cm] = -0x2) : -0x2 !== cC[cq][cG] && -0x2 === cC[cq + 0x1][cG] ? (cL = cg[cG] + cC[cq][cG] * cP,
                        cR = cN[cq],
                        cQ = cq,
                        cm = cG,
                        cC[cQ][cm] = -0x2) : -0x2 === cC[cq][cG] && -0x2 !== cC[cq + 0x1][cG] ? (cL = cg[cG] + cC[cq + 0x1][cG] * cP,
                          cR = cN[cq + 0x1],
                          cQ = cq + 0x1,
                          cm = cG,
                          cC[cQ][cm] = -0x2) : (cL = cg[cG + 0x1],
                            cR = cN[cq] + cJ[cq][cG + 0x1] * cM,
                            cQ = cq,
                            cm = cG + 0x1,
                            cJ[cQ][cm] = -0x2) : cg[cG] < cz ? -0x2 !== cJ[cq - 0x1][cG] && -0x2 !== cJ[cq - 0x1][cG + 0x1] ? cJ[cq - 0x1][cG] > cJ[cq - 0x1][cG + 0x1] ? (cL = cg[cG],
                              cR = cN[cq - 0x1] + cJ[cq - 0x1][cG] * cM,
                              cQ = cq - 0x1,
                              cm = cG,
                              cJ[cQ][cm] = -0x2) : (cL = cg[cG + 0x1],
                                cR = cN[cq - 0x1] + cJ[cq - 0x1][cG + 0x1] * cM,
                                cQ = cq - 0x1,
                                cm = cG + 0x1,
                                cJ[cQ][cm] = -0x2) : -0x2 !== cJ[cq - 0x1][cG] && -0x2 === cJ[cq - 0x1][cG + 0x1] ? (cL = cg[cG],
                                  cR = cN[cq - 0x1] + cJ[cq - 0x1][cG] * cM,
                                  cQ = cq - 0x1,
                                  cm = cG,
                                  cJ[cQ][cm] = -0x2) : -0x2 === cJ[cq - 0x1][cG] && -0x2 !== cJ[cq - 0x1][cG + 0x1] ? (cL = cg[cG + 0x1],
                                    cR = cN[cq - 0x1] + cJ[cq - 0x1][cG + 0x1] * cM,
                                    cQ = cq - 0x1,
                                    cm = cG + 0x1,
                                    cJ[cQ][cm] = -0x2) : (cL = cg[cG] + cC[cq - 0x1][cG] * cP,
                                      cR = cN[cq - 0x1],
                                      cQ = cq - 0x1,
                                      cm = cG,
                                      cC[cQ][cm] = -0x2) : -0x2 !== cC[cq + 0x1][cG - 0x1] && -0x2 !== cC[cq][cG - 0x1] ? cC[cq + 0x1][cG - 0x1] > cC[cq][cG - 0x1] ? (cL = cg[cG - 0x1] + cC[cq + 0x1][cG - 0x1] * cP,
                                        cR = cN[cq + 0x1],
                                        cQ = cq + 0x1,
                                        cm = cG - 0x1,
                                        cC[cQ][cm] = -0x2) : (cL = cg[cG - 0x1] + cC[cq][cG - 0x1] * cP,
                                          cR = cN[cq],
                                          cQ = cq,
                                          cm = cG - 0x1,
                                          cC[cQ][cm] = -0x2) : -0x2 !== cC[cq + 0x1][cG - 0x1] && -0x2 === cC[cq][cG - 0x1] ? (cL = cg[cG - 0x1] + cC[cq + 0x1][cG - 0x1] * cP,
                                            cR = cN[cq + 0x1],
                                            cQ = cq + 0x1,
                                            cm = cG - 0x1,
                                            cC[cQ][cm] = -0x2) : -0x2 === cC[cq + 0x1][cG - 0x1] && -0x2 !== cC[cq][cG - 0x1] ? (cL = cg[cG - 0x1] + cC[cq][cG - 0x1] * cP,
                                              cR = cN[cq],
                                              cQ = cq,
                                              cm = cG - 0x1,
                                              cC[cQ][cm] = -0x2) : (cL = cg[cG - 0x1],
                                                cR = cN[cq] + cJ[cq][cG - 0x1] * cM,
                                                cQ = cq,
                                                cm = cG - 0x1,
                                                cJ[cQ][cm] = -0x2),
          [cQ, cm, cL, cR];
      }
      static ['isoline_Bottom'] (cd, cq, cJ, cC, cO, cG, cg, cN) {
        let cP, cM, cz, cQ = [];
        cP = cd['length'],
          cM = cd[0x0]['length'];
        let cm, cL, cR, H0, H1, H2, H3, H4, H5, H6, H7 = 0x0, H8 = new bE(), H9 = new bV();
        for (cz = 0x0; cz < cM - 0x1; cz++)
          if (-0x2 !== cg[0x0][cz]) {
            let Hv = [];
            for (cL = 0x0,
              cR = cz,
              H2 = cq[cz] + cg[0x0][cz] * cO,
              H3 = cJ[0x0],
              cm = -0x1,
              H8['X'] = H2,
              H8['Y'] = H3,
              Hv['push'](H8); H6 = bB['traceIsoline'](cm, cL, cN, cg, H7, cR, cq, cJ, cO, cG, H2),
              H0 = parseInt(H6[0x0]),
              H1 = parseInt(H6[0x1]),
              H4 = parseFloat(H6[0x2]['toString']()),
              H5 = parseFloat(H6[0x3]['toString']()),
              H8['X'] = H4,
              H8['Y'] = H5,
              Hv['push'](H8),
              H0 !== cP - 0x1 && H1 !== cM - 0x1 && H5 !== cJ[0x0] && H4 !== cq[0x0];)
              H2 = H4,
                cm = cL,
                H7 = cR,
                cL = H0,
                cR = H1;
            cg[0x0][cz] = -0x2,
              Hv['length'] > 0x4 && (H9['Value'] = cC,
                H9['Type'] = 'Bottom',
                H9['PointList'] = [],
                bB['addAll'](Hv, H9['PointList']),
                cQ['push'](H9));
          }
        return cQ;
      }
      static ['isoline_Left'] (cd, cq, cJ, cC, cO, cG, cg, cN) {
        let cP, cM, cz, cQ, cm, cL, cR, H0, H1, H2, H3, H4, H5, H6, H7 = [];
        cP = cd['length'],
          cM = cd[0x0]['length'];
        let H8 = new bE()
          , H9 = new bV();
        for (cz = 0x0; cz < cP - 0x1; cz++)
          if (-0x2 !== cN[cz][0x0]) {
            let Hv = [];
            for (cm = cz,
              cR = 0x0,
              H2 = cq[0x0],
              H3 = cJ[cz] + cN[cz][0x0] * cG,
              cL = -0x1,
              cQ = cm,
              H8['X'] = H2,
              H8['Y'] = H3,
              Hv['push'](H8); H6 = bB['traceIsoline'](cQ, cm, cN, cg, cL, cR, cq, cJ, cO, cG, H2),
              H0 = parseInt(H6[0x0]),
              H1 = parseInt(H6[0x1]),
              H4 = parseFloat(H6[0x2]),
              H5 = parseFloat(H6[0x3]),
              H8['X'] = H4,
              H8['Y'] = H5,
              Hv['push'](H8),
              H0 !== cP - 0x1 && H1 !== cM - 0x1 && H5 !== cJ[0x0] && H4 !== cq[0x0];)
              H2 = H4,
                cQ = cm,
                cL = cR,
                cm = H0,
                cR = H1;
            Hv['length'] > 0x4 && (H9['Value'] = cC,
              H9['Type'] = 'Left',
              H9['PointList'] = [],
              bB['addAll'](Hv, H9['PointList']),
              H7['push'](H9));
          }
        return H7;
      }
      static ['isoline_Top'] (cd, cq, cJ, cC, cO, cG, cg, cN) {
        let cP, cM, cz, cQ, cm, cL, cR, H0, H1, H2, H3, H4, H5, H6, H7 = [];
        cP = cd['length'],
          cM = cd[0x0]['length'];
        let H8 = new bE()
          , H9 = new bV();
        for (cz = 0x0; cz < cM - 0x1; cz++)
          if (-0x2 !== cg[cP - 0x1][cz]) {
            let Hv = [];
            for (cm = cP - 0x1,
              cR = cz,
              H2 = cq[cz] + cg[cm][cz] * cO,
              H3 = cJ[cm],
              cQ = cm,
              cL = cR,
              H8['X'] = H2,
              H8['Y'] = H3,
              Hv['push'](H8); H6 = bB['traceIsoline'](cQ, cm, cN, cg, cL, cR, cq, cJ, cO, cG, H2),
              H0 = parseInt(H6[0x0]),
              H1 = parseInt(H6[0x1]),
              H4 = parseFloat(H6[0x2]),
              H5 = parseFloat(H6[0x3]),
              H8['X'] = H4,
              H8['Y'] = H5,
              Hv['push'](H8),
              H0 !== cP - 0x1 && H1 !== cM - 0x1 && H5 !== cJ[0x0] && H4 !== cq[0x0];)
              H2 = H4,
                cQ = cm,
                cL = cR,
                cm = H0,
                cR = H1;
            cg[cP - 0x1][cz] = -0x2,
              Hv['length'] > 0x4 && (H9['Value'] = cC,
                H9['Type'] = 'Top',
                H9['PointList'] = [],
                bB['addAll'](Hv, H9['PointList']),
                H7['push'](H9));
          }
        return H7;
      }
      static ['isoline_Right'] (cd, cq, cJ, cC, cO, cG, cg, cN) {
        let cP, cM, cz, cQ, cm, cL, cR, H0, H1, H2, H3, H4, H5, H6, H7 = [];
        cP = cd['length'],
          cM = cd[0x0]['length'];
        let H8 = new bE()
          , H9 = new bV();
        for (cz = 0x0; cz < cP - 0x1; cz++)
          if (-0x2 !== cN[cz][cM - 0x1]) {
            let Hv = [];
            for (cm = cz,
              cR = cM - 0x1,
              H2 = cq[cR],
              H3 = cJ[cz] + cN[cz][cR] * cG,
              cL = cR,
              cQ = cm,
              H8['X'] = H2,
              H8['Y'] = H3,
              Hv['push'](H8); H6 = bB['traceIsoline'](cQ, cm, cN, cg, cL, cR, cq, cJ, cO, cG, H2),
              H0 = parseInt(H6[0x0]),
              H1 = parseInt(H6[0x1]),
              H4 = parseFloat(H6[0x2]),
              H5 = parseFloat(H6[0x3]),
              H8['X'] = H4,
              H8['Y'] = H5,
              Hv['push'](H8),
              H0 !== cP - 0x1 && H1 !== cM - 0x1 && H5 !== cJ[0x0] && H4 !== cq[0x0];)
              H2 = H4,
                cQ = cm,
                cL = cR,
                cm = H0,
                cR = H1;
            Hv['length'] > 0x4 && (H9['Value'] = cC,
              H9['Type'] = 'Right',
              H9['PointList'] = [],
              bB['addAll'](Hv, H9['PointList']),
              H7['push'](H9));
          }
        return H7;
      }
      static ['isoline_Close'] (cd, cq, cJ, cC, cO, cG, cg, cN) {
        let cP, cM, cz, cQ, cm, cL, cR, H0, H1, H2, H3, H4, H5, H6, H7, H8, H9, Hv = [];
        cP = cd['length'],
          cM = cd[0x0]['length'];
        let HA = new bE()
          , Hk = new bV();
        for (cz = 0x1; cz < cP - 0x2; cz++)
          for (cQ = 0x1; cQ < cM - 0x1; cQ++)
            if (-0x2 !== cN[cz][cQ]) {
              let Hl = [];
              for (cL = cz,
                H0 = cQ,
                H3 = cq[H0],
                H4 = cJ[cz] + cN[cz][H0] * cG,
                cR = 0x0,
                cm = cL,
                H7 = H3,
                H8 = H4,
                HA['X'] = H3,
                HA['Y'] = H4,
                Hl['push'](HA); H9 = bB['traceIsoline'](cm, cL, cN, cg, cR, H0, cq, cJ, cO, cG, H3),
                H1 = parseInt(H9[0x0]),
                H2 = parseInt(H9[0x1]),
                H5 = parseFloat(H9[0x2]),
                H6 = parseFloat(H9[0x3]),
                !(0x0 === H1 && 0x0 === H2 || (HA['X'] = H5,
                  HA['Y'] = H6,
                  Hl['push'](HA),
                  Math['abs'](H6 - H8) < 0.000001 && Math['abs'](H5 - H7) < 0.000001) || (H3 = H5,
                    cm = cL,
                    cR = H0,
                    cL = H1,
                    H0 = H2,
                    cL === cP - 0x1 || H0 === cM - 0x1));)
                ;
              cN[cz][cQ] = -0x2,
                Hl['length'] > 0x4 && (Hk['Value'] = cC,
                  Hk['Type'] = 'Close',
                  Hk['PointList'] = [],
                  bB['addAll'](Hl, Hk['PointList']),
                  Hv['push'](Hk));
            }
        for (cz = 0x1; cz < cP - 0x1; cz++)
          for (cQ = 0x1; cQ < cM - 0x2; cQ++)
            if (-0x2 !== cg[cz][cQ]) {
              let HK = [];
              for (cL = cz,
                H0 = cQ,
                H3 = cq[H0] + cg[cz][cQ] * cO,
                H4 = cJ[cz],
                cR = H0,
                cm = 0x0,
                H7 = H3,
                H8 = H4,
                HA['X'] = H3,
                HA['Y'] = H4,
                HK['push'](HA); H9 = bB['traceIsoline'](cm, cL, cN, cg, cR, H0, cq, cJ, cO, cG, H3),
                H1 = parseInt(H9[0x0]),
                H2 = parseInt(H9[0x1]),
                H5 = parseFloat(H9[0x2]),
                H6 = parseFloat(H9[0x3]),
                HA['X'] = H5,
                HA['Y'] = H6,
                HK['push'](HA),
                !(Math['abs'](H6 - H8) < 0.000001 && Math['abs'](H5 - H7) < 0.000001 || (H3 = H5,
                  cm = cL,
                  cR = H0,
                  cL = H1,
                  H0 = H2,
                  cL === cP - 0x1 || H0 === cM - 0x1));)
                ;
              cg[cz][cQ] = -0x2,
                HK['length'] > 0x4 && (Hk['Value'] = cC,
                  Hk['Type'] = 'Close',
                  Hk['PointList'] = [],
                  bB['addAll'](HK, Hk['PointList']),
                  Hv['push'](Hk));
            }
        return Hv;
      }
      static ['tracingPolygons_Extent'] (cd, cq, cJ, cC) {
        if (0x0 === cd['length'])
          return [];
        let cO, cG, cg, cN, cP, cM, cz, cQ = [], cm = [];
        bB['addAll'](cd, cm);
        let cL, cR, H0, H1, H2 = [], H3 = [];
        for (H3['length'] = cq['length'] - 0x1,
          cP = 0x0; cP < H3['length']; cP++)
          H3[cP] = 0x0;
        let H4 = 0x0
          , H5 = 0x0
          , H6 = [];
        for (H0 = cq['length'] - 0x1,
          cP = 0x0; cP < H0; cP++)
          if (-0x1 !== cq[cP]['Id']) {
            if (cR = cP,
              cz = [],
              H6['push'](cq[cP]),
              H3[cR] < 0x2)
              for (cz['push'](cq[cR]['Point']),
                cR += 0x1,
                cR === H0 && (cR = 0x0),
                H1 = 0x0; ;) {
                if (cL = cq[cR],
                  -0x1 === cL['Id']) {
                  if (0x1 === H3[cR])
                    break;
                  cz['push'](cL['Point']),
                    H3[cR] += 0x1;
                } else {
                  if (0x2 === H3[cR])
                    break;
                  for (H3[cR] += 0x1,
                    cO = cm[cL['Id']],
                    0x0 === H1 ? (H4 = cO['Value'],
                      H5 = cO['Value'],
                      H1 += 0x1) : H4 === H5 && (cO['Value'] > H4 ? H5 = cO['Value'] : cO['Value'] < H4 && (H4 = cO['Value']),
                        H1 += 0x1),
                    H2 = [],
                    bB['addAll'](cO['PointList'], H2),
                    cG = H2[0x0],
                    cL['Point']['X'] === cG['X'] && cL['Point']['Y'] === cG['Y'] || H2['reverse'](),
                    bB['addAll'](H2, cz),
                    cM = 0x0; cM < cq['length'] - 0x1; cM++)
                    if (cM !== cR && cq[cM]['Id'] === cL['Id']) {
                      cR = cM,
                        H3[cR] += 0x1;
                      break;
                    }
                }
                if (cR === cP) {
                  cz['length'] > 0x0 && (cg = new bZ(),
                    cg['LowValue'] = H4,
                    cg['HighValue'] = H5,
                    cN = new bT(),
                    cg['Area'] = bB['getExtentAndArea'](cz, cN),
                    cg['IsClockWise'] = true,
                    cg['StartPointIdx'] = H6['length'] - 0x1,
                    cg['Extent'] = cN,
                    cg['OutLine']['PointList'] = cz,
                    cg['OutLine']['Value'] = H4,
                    cg['IsHighCenter'] = true,
                    cg['OutLine']['Type'] = 'Border',
                    cQ['push'](cg));
                  break;
                }
                cR += 0x1,
                  cR === H0 && (cR = 0x0);
              }
            if (cR = cP,
              H3[cR] < 0x2)
              for (cz = [],
                cz['push'](cq[cR]['Point']),
                cR += -0x1,
                -0x1 === cR && (cR = H0 - 0x1),
                H1 = 0x0; ;) {
                if (cL = cq[cR],
                  -0x1 === cL['Id']) {
                  if (0x1 === H3[cR])
                    break;
                  cz['push'](cL['Point']),
                    H3[cR] += 0x1;
                } else {
                  if (0x2 === H3[cR])
                    break;
                  for (H3[cR] += 0x1,
                    cO = cm[cL['Id']],
                    0x0 === H1 ? (H4 = cO['Value'],
                      H5 = cO['Value'],
                      H1 += 0x1) : H4 === H5 && (cO['Value'] > H4 ? H5 = cO['Value'] : cO['Value'] < H4 && (H4 = cO['Value']),
                        H1 += 0x1),
                    H2 = [],
                    bB['addAll'](cO['PointList'], H2),
                    cG = H2[0x0],
                    cL['Point']['X'] === cG['X'] && cL['Point']['Y'] === cG['Y'] || H2['reverse'](),
                    bB['addAll'](H2, cz),
                    cM = 0x0; cM < cq['length'] - 0x1; cM++)
                    if (cM !== cR && cq[cM]['Id'] === cL['Id']) {
                      cR = cM,
                        H3[cR] += 0x1;
                      break;
                    }
                }
                if (cR === cP) {
                  cz['length'] > 0x0 && (cg = new bZ(),
                    cg['LowValue'] = H4,
                    cg['HighValue'] = H5,
                    cN = new bT(),
                    cg['Area'] = bB['getExtentAndArea'](cz, cN),
                    cg['IsClockWise'] = false,
                    cg['StartPointIdx'] = H6['length'] - 0x1,
                    cg['Extent'] = cN,
                    cg['OutLine']['PointList'] = cz,
                    cg['OutLine']['Value'] = H4,
                    cg['IsHighCenter'] = true,
                    cg['OutLine']['Type'] = 'Border',
                    cQ['push'](cg));
                  break;
                }
                cR += -0x1,
                  -0x1 === cR && (cR = H0 - 0x1);
              }
          }
        let H7, H8, H9, Hv, HA = [];
        for (cP = 0x0; cP < cm['length']; cP++)
          if (cO = cm[cP],
            'Close' === cO['Type'] && cO['PointList']['length'] > 0x0) {
            for (cg = new bZ(),
              cg['LowValue'] = cO['Value'],
              cg['HighValue'] = cO['Value'],
              cN = new bT(),
              cg['Area'] = bB['getExtentAndArea'](cO['PointList'], cN),
              cg['IsClockWise'] = bB['isClockwise'](cO['PointList']),
              cg['Extent'] = cN,
              cg['OutLine'] = cO,
              cg['IsHighCenter'] = true,
              H7 = false,
              cM = 0x0; cM < HA['length']; cM++)
              if (cg['Area'] > HA[cM]['Area']) {
                HA['splice'](cM, 0x0, cg),
                  H7 = true;
                break;
              }
            H7 || HA['push'](cg);
          }
        if (cQ['length'] > 0x0) {
          let Hk, Hl, HK = false;
          if (cg = cQ[0x0],
            cg['LowValue'] === cg['HighValue'])
            for (Hk = cg['StartPointIdx']; ;) {
              if (cg['IsClockWise'] ? (Hk -= 0x1,
                -0x1 === Hk && (Hk = H6['length'] - 0x1)) : (Hk += 0x1,
                  Hk === H6['length'] && (Hk = 0x0)),
                cL = H6[Hk],
                cO = cm[cL['Id']],
                cO['Value'] !== cg['LowValue']) {
                HK = false;
                break;
              }
              if (Hk === cg['StartPointIdx']) {
                HK = true;
                break;
              }
            }
          if (HK) {
            if (HA['length'] > 0x0) {
              for (H8 = HA[0x0]['Extent'],
                cP = 0x0; cP < cQ['length']; cP++)
                cg = cQ[cP],
                  H9 = cg['Extent'],
                  H8['xMin'] > H9['xMin'] && H8['yMin'] > H9['yMin'] && H8['xMax'] < H9['xMax'] && H8['yMax'] < H9['yMax'] ? cg['IsHighCenter'] = false : cg['IsHighCenter'] = true;
            } else {
              let Hb = true;
              for (cP = 0x0; cP < cQ['length']; cP++)
                cg = cQ[cP],
                  Hb = !Hb,
                  cg['IsHighCenter'] = Hb;
            }
          } else {
            for (cP = 0x0; cP < cQ['length']; cP++)
              if (cg = cQ[cP],
                cg['LowValue'] === cg['HighValue'])
                for (Hl = false,
                  Hk = cg['StartPointIdx']; ;) {
                  if (cg['IsClockWise'] ? (Hk -= 0x1,
                    -0x1 === Hk && (Hk = H6['length'] - 0x1)) : (Hk += 0x1,
                      Hk === H6['length'] && (Hk = 0x0)),
                    cL = H6[Hk],
                    cO = cm[cL['Id']],
                    cO['Value'] !== cg['LowValue']) {
                    Hl ? cO['Value'] < cg['LowValue'] && (cg['IsHighCenter'] = false) : cO['Value'] > cg['LowValue'] && (cg['IsHighCenter'] = false);
                    break;
                  }
                  if (Hk === cg['StartPointIdx'])
                    break;
                  Hl = !Hl;
                }
          }
        } else {
          let Hc = cm[0x0]['Value']
            , HH = cm[0x0]['Value'];
          for (let Hx of cm)
            Hx['Value'] > Hc && (Hc = Hx['Value']),
              Hx['Value'] < HH && (HH = Hx['Value']);
          cg = new bZ(),
            cO = new bV(),
            cO['Type'] = 'Border',
            cO['Value'] = cC[0x0],
            cg['IsHighCenter'] = false,
            HA['length'] > 0x0 && HA[0x0]['LowValue'] === Hc && (cO['Value'] = cC[cC['length'] - 0x1],
              cg['IsHighCenter'] = true),
            H2 = [],
            cG = new bE(),
            cG['X'] = cJ['xMin'],
            cG['Y'] = cJ['yMin'],
            H2['push'](cG),
            cG = new bE(),
            cG['X'] = cJ['xMin'],
            cG['Y'] = cJ['yMax'],
            H2['push'](cG),
            cG = new bE(),
            cG['X'] = cJ['xMax'],
            cG['Y'] = cJ['yMax'],
            H2['push'](cG),
            cG = new bE(),
            cG['X'] = cJ['xMax'],
            cG['Y'] = cJ['yMin'],
            H2['push'](cG),
            H2['push'](H2[0x0]),
            cO['PointList'] = [],
            bB['addAll'](H2, cO['PointList']),
            cO['PointList']['length'] > 0x0 && (cg['LowValue'] = cO['Value'],
              cg['HighValue'] = cO['Value'],
              cN = new bT(),
              cg['Area'] = bB['getExtentAndArea'](cO['PointList'], cN),
              cg['IsClockWise'] = bB['isClockwise'](cO['PointList']),
              cg['Extent'] = cN,
              cg['OutLine'] = cO,
              cQ['push'](cg));
        }
        for (bB['addAll'](HA, cQ),
          cP = cQ['length'] - 0x1; cP >= 0x0; cP--)
          if (cg = cQ[cP],
            'Close' === cg['OutLine']['Type']) {
            for (H8 = cg['Extent'],
              H4 = cg['LowValue'],
              cG = cg['OutLine']['PointList'][0x0],
              cM = cP - 0x1; cM >= 0x0; cM--)
              if (Hv = cQ[cM],
                H9 = Hv['Extent'],
                H5 = Hv['LowValue'],
                H2 = [],
                bB['addAll'](Hv['OutLine']['PointList'], H2),
                bB['pointInPolygonByPList'](H2, cG) && H8['xMin'] > H9['xMin'] && H8['yMin'] > H9['yMin'] && H8['xMax'] < H9['xMax'] && H8['yMax'] < H9['yMax']) {
                (H4 < H5 || H4 === H5 && Hv['IsHighCenter']) && (cg['IsHighCenter'] = false);
                break;
              }
          }
        return cQ;
      }
      static ['tracingPolygons_Line_Border'] (cd, cq) {
        if (0x0 === cd['length'])
          return [];
        let cJ, cC, cO, cG, cg, cN, cP, cM, cz, cQ = [], cm = [];
        bB['addAll'](cd, cm);
        let cL, cR, H0, H1, H2 = [];
        for (H2['length'] = cq['length'] - 0x1,
          cg = 0x0; cg < H2['length']; cg++)
          H2[cg] = 0x0;
        let H3 = 0x0
          , H4 = 0x0
          , H5 = 0x0
          , H6 = [];
        for (cR = cq['length'] - 0x1,
          cg = 0x0; cg < cR; cg++)
          if (-0x1 !== cq[cg]['Id']) {
            if (cL = cg,
              cP = [],
              H6['push'](cq[cg]),
              H2[cL] < 0x2)
              for (cP['push'](cq[cL]['Point']),
                cL += 0x1,
                cL === cR && (cL = 0x0),
                H0 = 0x0,
                H1 = 0x0; ;) {
                if (cz = cq[cL],
                  -0x1 === cz['Id']) {
                  if (0x1 === H2[cL])
                    break;
                  H5 = cz['Value'],
                    H1 += 0x1,
                    cP['push'](cz['Point']),
                    H2[cL] += 0x1;
                } else {
                  if (0x2 === H2[cL])
                    break;
                  for (H2[cL] += 0x1,
                    cJ = cm[cz['Id']],
                    0x0 === H0 ? (H3 = cJ['Value'],
                      H4 = cJ['Value'],
                      H0 += 0x1) : (cJ['Value'] > H3 ? H4 = cJ['Value'] : cJ['Value'] < H3 && (H3 = cJ['Value']),
                        H0 += 0x1),
                    cM = [],
                    bB['addAll'](cJ['PointList'], cM),
                    cC = cM[0x0],
                    cz['Point']['X'] === cC['X'] && cz['Point']['Y'] === cC['Y'] || cM['reverse'](),
                    bB['addAll'](cM, cP),
                    cN = 0x0; cN < cq['length'] - 0x1; cN++)
                    if (cN !== cL && cq[cN]['Id'] === cz['Id']) {
                      cL = cN,
                        H2[cL] += 0x1;
                      break;
                    }
                }
                if (cL === cg) {
                  cP['length'] > 0x0 && (cO = new bZ(),
                    cO['IsBorder'] = true,
                    cO['LowValue'] = H3,
                    cO['HighValue'] = H4,
                    cG = new bT(),
                    cO['Area'] = bB['getExtentAndArea'](cP, cG),
                    cO['IsClockWise'] = true,
                    cO['StartPointIdx'] = H6['length'] - 0x1,
                    cO['Extent'] = cG,
                    cO['OutLine']['PointList'] = cP,
                    cO['OutLine']['Value'] = H3,
                    cO['IsHighCenter'] = true,
                    cO['HoleLines'] = [],
                    H1 > 0x0 && H5 < H3 && (cO['IsHighCenter'] = false,
                      cO['HighValue'] = H3),
                    cO['OutLine']['Type'] = 'Border',
                    cQ['push'](cO));
                  break;
                }
                cL += 0x1,
                  cL === cR && (cL = 0x0);
              }
            if (cL = cg,
              H2[cL] < 0x2)
              for (cP = [],
                cP['push'](cq[cL]['Point']),
                cL += -0x1,
                -0x1 === cL && (cL = cR - 0x1),
                H0 = 0x0,
                H1 = 0x0; ;) {
                if (cz = cq[cL],
                  -0x1 === cz['Id']) {
                  if (0x1 === H2[cL])
                    break;
                  H5 = cz['Value'],
                    H1 += 0x1,
                    cP['push'](cz['Point']),
                    H2[cL] += 0x1;
                } else {
                  if (0x2 === H2[cL])
                    break;
                  for (H2[cL] += 0x1,
                    cJ = cm[cz['Id']],
                    0x0 === H0 ? (H3 = cJ['Value'],
                      H4 = cJ['Value'],
                      H0 += 0x1) : (cJ['Value'] > H3 ? H4 = cJ['Value'] : cJ['Value'] < H3 && (H3 = cJ['Value']),
                        H0 += 0x1),
                    cM = [],
                    bB['addAll'](cJ['PointList'], cM),
                    cC = cM[0x0],
                    cz['Point']['X'] === cC['X'] && cz['Point']['Y'] === cC['Y'] || cM['reverse'](),
                    bB['addAll'](cM, cP),
                    cN = 0x0; cN < cq['length'] - 0x1; cN++)
                    if (cN !== cL && cq[cN]['Id'] === cz['Id']) {
                      cL = cN,
                        H2[cL] += 0x1;
                      break;
                    }
                }
                if (cL === cg) {
                  cP['length'] > 0x0 && (cO = new bZ(),
                    cO['IsBorder'] = true,
                    cO['LowValue'] = H3,
                    cO['HighValue'] = H4,
                    cG = new bT(),
                    cO['Area'] = bB['getExtentAndArea'](cP, cG),
                    cO['IsClockWise'] = false,
                    cO['StartPointIdx'] = H6['length'] - 0x1,
                    cO['Extent'] = cG,
                    cO['OutLine']['PointList'] = cP,
                    cO['OutLine']['Value'] = H3,
                    cO['IsHighCenter'] = true,
                    cO['HoleLines'] = [],
                    H1 > 0x0 && H5 < H3 && (cO['IsHighCenter'] = false,
                      cO['HighValue'] = H3),
                    cO['OutLine']['Type'] = 'Border',
                    cQ['push'](cO));
                  break;
                }
                cL += -0x1,
                  -0x1 === cL && (cL = cR - 0x1);
              }
          }
        let H7, H8 = [];
        for (cg = 0x0; cg < cm['length']; cg++)
          if (cJ = cm[cg],
            'Close' === cJ['Type'] && cJ['PointList']['length'] > 0x0) {
            for (cO = new bZ(),
              cO['IsBorder'] = false,
              cO['LowValue'] = cJ['Value'],
              cO['HighValue'] = cJ['Value'],
              cG = new bT(),
              cO['Area'] = bB['getExtentAndArea'](cJ['PointList'], cG),
              cO['IsClockWise'] = bB['isClockwise'](cJ['PointList']),
              cO['Extent'] = cG,
              cO['OutLine'] = cJ,
              cO['IsHighCenter'] = true,
              cO['HoleLines'] = [],
              H7 = false,
              cN = 0x0; cN < H8['length']; cN++)
              if (cO['Area'] > H8[cN]['Area']) {
                H8['splice'](cN, 0x0, cO),
                  H7 = true;
                break;
              }
            H7 || H8['push'](cO);
          }
        return cQ = bB['judgePolygonHighCenter'](cQ, H8, cm, cq),
          cQ;
      }
      static ['tracingClipPolygons'] (cd, cq, cJ) {
        if (0x0 === cq['length'])
          return [];
        let cC, cO, cG, cg, cN, cP, cM, cz = [], cQ = [];
        bB['addAll'](cq, cQ);
        let cm, cL, cR, H0 = [], H1 = [];
        for (H1['length'] = cJ['length'] - 0x1,
          cN = 0x0; cN < H1['length']; cN++)
          H1[cN] = 0x0;
        let H2, H3, H4 = [];
        for (cR = cJ['length'] - 0x1,
          cN = 0x0; cN < cR; cN++)
          if (-0x1 !== cJ[cN]['Id']) {
            if (cL = cN,
              H4['push'](cJ[cN]),
              H3 = cJ[cL]['Point'],
              H1[cL] < 0x1) {
              if (cM = [],
                cM['push'](cJ[cL]['Point']),
                cL += 0x1,
                cL === cR && (cL = 0x0),
                H2 = cJ[cL]['Point']['clone'](),
                -0x1 === cJ[cL]['Id']) {
                let H5 = cL + 0xa;
                for (let H6 = 0x1; H6 <= 0xa; H6++)
                  if (cJ[cL + H6]['Id'] > -0x1) {
                    H5 = cL + H6 - 0x1;
                    break;
                  }
                H2 = cJ[H5]['Point']['clone']();
              } else
                H2['X'] = (H2['X'] + H3['X']) / 0x2,
                  H2['Y'] = (H2['Y'] + H3['Y']) / 0x2;
              if (bB['pointInPolygon'](cd, H2))
                for (; ;) {
                  if (cm = cJ[cL],
                    -0x1 === cm['Id']) {
                    if (0x1 === H1[cL])
                      break;
                    cM['push'](cm['Point']),
                      H1[cL] += 0x1;
                  } else {
                    if (0x1 === H1[cL])
                      break;
                    for (H1[cL] += 0x1,
                      cC = cQ[cm['Id']],
                      H0 = [],
                      bB['addAll'](cC['PointList'], H0),
                      cO = H0[0x0],
                      bB['doubleEquals'](cm['Point']['X'], cO['X']) && bB['doubleEquals'](cm['Point']['Y'], cO['Y']) || H0['reverse'](),
                      bB['addAll'](H0, cM),
                      cP = 0x0; cP < cJ['length'] - 0x1; cP++)
                      if (cP !== cL && cJ[cP]['Id'] === cm['Id']) {
                        cL = cP,
                          H1[cL] += 0x1;
                        break;
                      }
                  }
                  if (cL === cN) {
                    cM['length'] > 0x0 && (cG = new bZ(),
                      cG['IsBorder'] = true,
                      cG['LowValue'] = cd['LowValue'],
                      cG['HighValue'] = cd['HighValue'],
                      cg = new bT(),
                      cG['Area'] = bB['getExtentAndArea'](cM, cg),
                      cG['IsClockWise'] = true,
                      cG['StartPointIdx'] = H4['length'] - 0x1,
                      cG['Extent'] = cg,
                      cG['OutLine']['PointList'] = cM,
                      cG['OutLine']['Value'] = cd['LowValue'],
                      cG['IsHighCenter'] = cd['IsHighCenter'],
                      cG['OutLine']['Type'] = 'Border',
                      cG['HoleLines'] = [],
                      cz['push'](cG));
                    break;
                  }
                  cL += 0x1,
                    cL === cR && (cL = 0x0);
                }
            }
            if (cL = cN,
              H1[cL] < 0x1) {
              if (cM = [],
                cM['push'](cJ[cL]['Point']),
                cL += -0x1,
                -0x1 === cL && (cL = cR - 0x1),
                H2 = cJ[cL]['Point']['clone'](),
                -0x1 === cJ[cL]['Id']) {
                let H7 = cL + 0xa;
                for (let H8 = 0x1; H8 <= 0xa; H8++)
                  if (cJ[cL + H8]['Id'] > -0x1) {
                    H7 = cL + H8 - 0x1;
                    break;
                  }
                H2 = cJ[H7]['Point']['clone']();
              } else
                H2['X'] = (H2['X'] + H3['X']) / 0x2,
                  H2['Y'] = (H2['Y'] + H3['Y']) / 0x2;
              if (bB['pointInPolygon'](cd, H2))
                for (; ;) {
                  if (cm = cJ[cL],
                    -0x1 === cm['Id']) {
                    if (0x1 === H1[cL])
                      break;
                    cM['push'](cm['Point']),
                      H1[cL] += 0x1;
                  } else {
                    if (0x1 === H1[cL])
                      break;
                    for (H1[cL] += 0x1,
                      cC = cQ[cm['Id']],
                      H0 = [],
                      bB['addAll'](cC['PointList'], H0),
                      cO = H0[0x0],
                      bB['doubleEquals'](cm['Point']['X'], cO['X']) && bB['doubleEquals'](cm['Point']['Y'], cO['Y']) || H0['reverse'](),
                      bB['addAll'](H0, cM),
                      cP = 0x0; cP < cJ['length'] - 0x1; cP++)
                      if (cP !== cL && cJ[cP]['Id'] === cm['Id']) {
                        cL = cP,
                          H1[cL] += 0x1;
                        break;
                      }
                  }
                  if (cL === cN) {
                    cM['length'] > 0x0 && (cG = new bZ(),
                      cG['IsBorder'] = true,
                      cG['LowValue'] = cd['LowValue'],
                      cG['HighValue'] = cd['HighValue'],
                      cg = new bT(),
                      cG['Area'] = bB['getExtentAndArea'](cM, cg),
                      cG['IsClockWise'] = false,
                      cG['StartPointIdx'] = H4['length'] - 0x1,
                      cG['Extent'] = cg,
                      cG['OutLine']['PointList'] = cM,
                      cG['OutLine']['Value'] = cd['LowValue'],
                      cG['IsHighCenter'] = cd['IsHighCenter'],
                      cG['OutLine']['Type'] = 'Border',
                      cG['HoleLines'] = [],
                      cz['push'](cG));
                    break;
                  }
                  cL += -0x1,
                    -0x1 === cL && (cL = cR - 0x1);
                }
            }
          }
        return cz;
      }
      static ['judgePolygonHighCenter'] (cd, cq, cJ, cC) {
        let cO, cG, cg, cN, cP, cM, cz, cQ, cm, cL = [];
        if (0x0 === cd['length']) {
          let H1 = cJ[0x0]['Value']
            , H2 = cJ[0x0]['Value'];
          for (let H3 of cJ)
            H3['Value'] > H1 && (H1 = H3['Value']),
              H3['Value'] < H2 && (H2 = H3['Value']);
          cg = new bZ(),
            cM = cC[0x0]['Value'],
            cM < H2 ? (H1 = H2,
              H2 = cM,
              cg['IsHighCenter'] = true) : cM > H1 && (H2 = H1,
                H1 = cM,
                cg['IsHighCenter'] = false),
            cN = new bV(),
            cN['Type'] = 'Border',
            cN['Value'] = cM,
            cL = [];
          for (let H4 of cC)
            cL['push'](H4['Point']);
          cN['PointList'] = [],
            bB['addAll'](cL, cN['PointList']),
            cN['PointList']['length'] > 0x0 && (cg['IsBorder'] = true,
              cg['LowValue'] = H2,
              cg['HighValue'] = H1,
              cP = new bT(),
              cg['Area'] = bB['getExtentAndArea'](cN['PointList'], cP),
              cg['IsClockWise'] = bB['isClockwise'](cN['PointList']),
              cg['Extent'] = cP,
              cg['OutLine'] = cN,
              cg['HoleLines'] = [],
              cd['push'](cg));
        }
        bB['addAll'](cq, cd);
        let cR, H0 = cd['length'];
        for (cO = 0x1; cO < H0; cO++)
          if (cg = cd[cO],
            'Close' === cg['OutLine']['Type']) {
            for (cQ = cg['Extent'],
              cz = cg['OutLine']['PointList'][0x0],
              cG = cO - 0x1; cG >= 0x0; cG--)
              if (cR = cd[cG],
                cm = cR['Extent'],
                cL = [],
                bB['addAll'](cR['OutLine']['PointList'], cL),
                bB['pointInPolygonByPList'](cL, cz) && cQ['xMin'] > cm['xMin'] && cQ['yMin'] > cm['yMin'] && cQ['xMax'] < cm['xMax'] && cQ['yMax'] < cm['yMax']) {
                cR['IsHighCenter'] ? cg['IsHighCenter'] = cg['HighValue'] !== cR['LowValue'] : cg['IsHighCenter'] = cg['LowValue'] === cR['HighValue'];
                break;
              }
          }
        return cd;
      }
      static ['judgePolygonHighCenter_old'] (cd, cq, cJ, cC) {
        let cO, cG, cg, cN, cP, cM, cz, cQ, cm, cL, cR = [];
        if (0x0 === cd['length']) {
          let H2 = cJ[0x0]['Value']
            , H3 = cJ[0x0]['Value'];
          for (let H4 of cJ)
            H4['Value'] > H2 && (H2 = H4['Value']),
              H4['Value'] < H3 && (H3 = H4['Value']);
          cg = new bZ(),
            cN = new bV(),
            cN['Type'] = 'Border',
            cN['Value'] = H3,
            cg['IsHighCenter'] = false,
            cq['length'] > 0x0 && cC[0x0]['Value'] >= cq[0x0]['LowValue'] && (cN['Value'] = H2,
              cg['IsHighCenter'] = true),
            cR = [];
          for (let H5 of cC)
            cR['push'](H5['Point']);
          cN['PointList'] = [],
            bB['addAll'](cR, cN['PointList']),
            cN['PointList']['length'] > 0x0 && (cg['IsBorder'] = true,
              cg['LowValue'] = cN['Value'],
              cg['HighValue'] = cN['Value'],
              cP = new bT(),
              cg['Area'] = bB['getExtentAndArea'](cN['PointList'], cP),
              cg['IsClockWise'] = bB['isClockwise'](cN['PointList']),
              cg['Extent'] = cP,
              cg['OutLine'] = cN,
              cg['HoleLines'] = [],
              cd['push'](cg));
        }
        bB['addAll'](cq, cd);
        let H0, H1 = cd['length'];
        for (cO = 0x1; cO < H1; cO++)
          if (cg = cd[cO],
            'Close' === cg['OutLine']['Type']) {
            for (cm = cg['Extent'],
              cM = cg['LowValue'],
              cQ = cg['OutLine']['PointList'][0x0],
              cG = cO - 0x1; cG >= 0x0; cG--)
              if (H0 = cd[cG],
                cL = H0['Extent'],
                cz = H0['LowValue'],
                cR = [],
                bB['addAll'](H0['OutLine']['PointList'], cR),
                bB['pointInPolygonByPList'](cR, cQ) && cm['xMin'] > cL['xMin'] && cm['yMin'] > cL['yMin'] && cm['xMax'] < cL['xMax'] && cm['yMax'] < cL['yMax']) {
                (cM < cz || cM === cz && H0['IsHighCenter']) && (cg['IsHighCenter'] = false);
                break;
              }
          }
        return cd;
      }
      static ['tracingPolygons_Ring'] (cd, cq, cJ, cC, cO) {
        let cG, cg, cN, cP, cM, cz, cQ, cm, cL, cR, H0, H1 = [];
        cG = [],
          bB['addAll'](cd, cG);
        let H2, H3, H4, H5 = [];
        for (H5['length'] = cq['length'] - 0x1,
          cz = 0x0; cz < H5['length']; cz++)
          H5[cz] = 0x0;
        let H6, H7, H8, H9 = 0x0, Hv = 0x0, HA = 0x0, Hk = [];
        for (H3 = cq['length'],
          cz = 0x0; cz < H3; cz++) {
          if (-0x1 === cq[cz]['Id'])
            continue;
          H2 = cz,
            Hk['push'](cq[cz]);
          let Hx = false;
          if (H5[H2] < 0x2) {
            cR = cq[H2],
              H8 = cR['BInnerIdx'],
              cm = [];
            let Hp = [];
            for (cm['push'](cR['Point']),
              Hp['push'](H2),
              H6 = cR['BorderIdx'],
              H7 = H6,
              H2 += 0x1,
              H8 += 0x1,
              H8 === cO[H6] - 0x1 && (H2 -= cO[H6] - 0x1),
              H4 = 0x0; ;) {
              if (cR = cq[H2],
                -0x1 === cR['Id']) {
                if (0x1 === H5[H2])
                  break;
                HA = cR['Value'],
                  cm['push'](cR['Point']),
                  H5[H2] += 0x1,
                  Hp['push'](H2);
              } else {
                if (0x2 === H5[H2])
                  break;
                for (H5[H2] += 0x1,
                  Hp['push'](H2),
                  cg = cG[cR['Id']],
                  0x0 === H4 ? (H9 = cg['Value'],
                    Hv = cg['Value'],
                    H4 += 0x1) : H9 === Hv && (cg['Value'] > H9 ? Hv = cg['Value'] : cg['Value'] < H9 && (H9 = cg['Value']),
                      H4 += 0x1),
                  cL = [],
                  bB['addAll'](cg['PointList'], cL),
                  cN = cL[0x0],
                  cR['Point']['X'] === cN['X'] && cR['Point']['Y'] === cN['Y'] || cL['reverse'](),
                  bB['addAll'](cL, cm),
                  cQ = 0x0; cQ < cq['length']; cQ++)
                  if (cQ !== H2 && (H0 = cq[cQ],
                    H0['Id'] === cR['Id'])) {
                    H2 = cQ,
                      H8 = H0['BInnerIdx'],
                      H5[H2] += 0x1,
                      Hp['push'](H2),
                      H7 = H0['BorderIdx'],
                      cR['BorderIdx'] > 0x0 && cR['BorderIdx'] === H0['BorderIdx'] && (Hx = true);
                    break;
                  }
              }
              if (H2 === cz) {
                if (cm['length'] > 0x0) {
                  if (Hx) {
                    let HF = false
                      , Hy = 0x0;
                    for (let HY = 0x0; HY < cR['BorderIdx']; HY++)
                      Hy += cO[HY];
                    let Hw = Hy
                      , Hh = Hy + cO[cR['BorderIdx']]
                      , Hu = Hw;
                    for (let HT = Hw; HT < Hh; HT++)
                      if (Hp['indexOf'](HT) < 0x0) {
                        Hu = HT;
                        break;
                      }
                    if (bB['pointInPolygonByPList'](cm, cq[Hu]['Point']) && (HF = true),
                      HF)
                      break;
                  }
                  cP = new bZ(),
                    cP['IsBorder'] = true,
                    cP['IsInnerBorder'] = Hx,
                    cP['LowValue'] = H9,
                    cP['HighValue'] = Hv,
                    cM = new bT(),
                    cP['Area'] = bB['getExtentAndArea'](cm, cM),
                    cP['IsClockWise'] = true,
                    cP['StartPointIdx'] = Hk['length'] - 0x1,
                    cP['Extent'] = cM,
                    cP['OutLine']['PointList'] = cm,
                    cP['OutLine']['Value'] = H9,
                    cP['IsHighCenter'] = true,
                    H9 === Hv && HA < H9 && (cP['IsHighCenter'] = false),
                    cP['OutLine']['Type'] = 'Border',
                    cP['HoleLines'] = [],
                    H1['push'](cP);
                }
                break;
              }
              H2 += 0x1,
                H8 += 0x1,
                H6 !== H7 && (H6 = H7),
                H8 === cO[H6] - 0x1 && (H2 -= cO[H6] - 0x1,
                  H8 = 0x0);
            }
          }
          if (Hx = false,
            H2 = cz,
            H5[H2] < 0x2) {
            cm = [];
            let HX = [];
            for (cR = cq[H2],
              H8 = cR['BInnerIdx'],
              cm['push'](cR['Point']),
              HX['push'](H2),
              H6 = cR['BorderIdx'],
              H7 = H6,
              H2 += -0x1,
              H8 += -0x1,
              -0x1 === H8 && (H2 += cO[H6] - 0x1),
              H4 = 0x0; ;) {
              if (cR = cq[H2],
                -0x1 === cR['Id']) {
                if (0x1 === H5[H2])
                  break;
                HA = cR['Value'],
                  cm['push'](cR['Point']),
                  HX['push'](H2),
                  H5[H2] += 0x1;
              } else {
                if (0x2 === H5[H2])
                  break;
                for (H5[H2] += 0x1,
                  HX['push'](H2),
                  cg = cG[cR['Id']],
                  0x0 === H4 ? (H9 = cg['Value'],
                    Hv = cg['Value'],
                    H4 += 0x1) : H9 === Hv && (cg['Value'] > H9 ? Hv = cg['Value'] : cg['Value'] < H9 && (H9 = cg['Value']),
                      H4 += 0x1),
                  cL = [],
                  bB['addAll'](cg['PointList'], cL),
                  cN = cL[0x0],
                  cR['Point']['X'] === cN['X'] && cR['Point']['Y'] === cN['Y'] || cL['reverse'](),
                  bB['addAll'](cL, cm),
                  cQ = 0x0; cQ < cq['length']; cQ++)
                  if (cQ !== H2 && (H0 = cq[cQ],
                    H0['Id'] === cR['Id'])) {
                    H2 = cQ,
                      H8 = H0['BInnerIdx'],
                      H5[H2] += 0x1,
                      HX['push'](H2),
                      H7 = H0['BorderIdx'],
                      cR['BorderIdx'] > 0x0 && cR['BorderIdx'] === H0['BorderIdx'] && (Hx = true);
                    break;
                  }
              }
              if (H2 === cz) {
                if (cm['length'] > 0x0) {
                  if (Hx) {
                    let HE = false
                      , Hf = 0x0;
                    for (let HD = 0x0; HD < cR['BorderIdx']; HD++)
                      Hf += cO[HD];
                    let HW = Hf
                      , HI = Hf + cO[cR['BorderIdx']]
                      , Hj = HW;
                    for (let HV = HW; HV < HI; HV++)
                      if (HX['indexOf'](HV) < 0x0) {
                        Hj = HV;
                        break;
                      }
                    if (bB['pointInPolygonByPList'](cm, cq[Hj]['Point']) && (HE = true),
                      HE)
                      break;
                  }
                  cP = new bZ(),
                    cP['IsBorder'] = true,
                    cP['IsInnerBorder'] = Hx,
                    cP['LowValue'] = H9,
                    cP['HighValue'] = Hv,
                    cM = new bT(),
                    cP['Area'] = bB['getExtentAndArea'](cm, cM),
                    cP['IsClockWise'] = false,
                    cP['StartPointIdx'] = Hk['length'] - 0x1,
                    cP['Extent'] = cM,
                    cP['OutLine']['PointList'] = cm,
                    cP['OutLine']['Value'] = H9,
                    cP['IsHighCenter'] = true,
                    H9 === Hv && HA < H9 && (cP['IsHighCenter'] = false),
                    cP['OutLine']['Type'] = 'Border',
                    cP['HoleLines'] = [],
                    H1['push'](cP);
                }
                break;
              }
              H2 += -0x1,
                H8 += -0x1,
                H6 !== H7 && (H6 = H7),
                -0x1 === H8 && (H2 += cO[H6],
                  H8 = cO[H6] - 0x1);
            }
          }
        }
        let Hl, HK, Hb, Hc, HH = [];
        for (cz = 0x0; cz < cG['length']; cz++)
          if (cg = cG[cz],
            'Close' === cg['Type']) {
            for (cP = new bZ(),
              cP['IsBorder'] = false,
              cP['LowValue'] = cg['Value'],
              cP['HighValue'] = cg['Value'],
              cM = new bT(),
              cP['Area'] = bB['getExtentAndArea'](cg['PointList'], cM),
              cP['IsClockWise'] = bB['isClockwise'](cg['PointList']),
              cP['Extent'] = cM,
              cP['OutLine'] = cg,
              cP['IsHighCenter'] = true,
              cP['HoleLines'] = [],
              Hl = false,
              cQ = 0x0; cQ < HH['length']; cQ++)
              if (cP['Area'] > HH[cQ]['Area']) {
                HH['splice'](cQ, 0x0, cP),
                  Hl = true;
                break;
              }
            Hl || HH['push'](cP);
          }
        for (0x0 === H1['length'] && (cg = new bV(),
          cg['Type'] = 'Border',
          cg['Value'] = cC[0x0],
          cg['PointList'] = [],
          bB['addAll'](cJ['LineList'][0x0]['pointList'], cg['PointList']),
          cg['PointList']['length'] > 0x0 && (cP = new bZ(),
            cP['LowValue'] = cg['Value'],
            cP['HighValue'] = cg['Value'],
            cM = new bT(),
            cP['Area'] = bB['getExtentAndArea'](cg['PointList'], cM),
            cP['IsClockWise'] = bB['isClockwise'](cg['PointList']),
            cP['Extent'] = cM,
            cP['OutLine'] = cg,
            cP['IsHighCenter'] = false,
            H1['push'](cP))),
          bB['addAll'](HH, H1),
          cz = H1['length'] - 0x1; cz >= 0x0; cz += -0x1)
          if (cP = H1[cz],
            'Close' === cP['OutLine']['Type']) {
            for (HK = cP['Extent'],
              H9 = cP['LowValue'],
              cN = cP['OutLine']['PointList'][0x0],
              cQ = cz - 0x1; cQ >= 0x0; cQ += -0x1)
              if (Hc = H1[cQ],
                Hb = Hc['Extent'],
                Hv = Hc['LowValue'],
                cL = [],
                bB['addAll'](Hc['OutLine']['PointList'], cL),
                bB['pointInPolygonByPList'](cL, cN) && HK['xMin'] > Hb['xMin'] && HK['yMin'] > Hb['yMin'] && HK['xMax'] < Hb['xMax'] && HK['yMax'] < Hb['yMax']) {
                (H9 < Hv || H9 === Hv && Hc['IsHighCenter']) && (cP['IsHighCenter'] = false);
                break;
              }
          }
        return H1;
      }
      static ['addPolygonHoles'] (cd) {
        let cq, cJ, cC = [];
        for (cq = 0x0; cq < cd['length']; cq++) {
          let cO = cd[cq];
          cO['IsBorder'] || (cO['HoleIndex'] = 0x1,
            cC['push'](cO));
        }
        if (0x0 === cC['length'])
          return cd;
        {
          let cG = [];
          for (cq = 0x1; cq < cC['length']; cq++) {
            let cN = cC[cq];
            for (cJ = cq - 0x1; cJ >= 0x0; cJ--) {
              let cP = cC[cJ];
              if (cP['Extent']['Include'](cN['Extent']) && bB['pointInPolygonByPList'](cP['OutLine']['PointList'], cN['OutLine']['PointList'][0x0])) {
                cN['HoleIndex'] = cP['HoleIndex'] + 0x1,
                  cP['AddHole'](cN);
                break;
              }
            }
          }
          let cg = [];
          for (cq = 0x0; cq < cC['length']; cq++)
            0x1 === cC[cq]['HoleIndex'] && cg['push'](cC[cq]);
          for (cq = 0x0; cq < cd['length']; cq++) {
            let cM = cd[cq];
            if (true === cM['IsBorder']) {
              for (cJ = 0x0; cJ < cg['length']; cJ++) {
                let cz = cg[cJ];
                cM['Extent']['Include'](cz['Extent']) && bB['pointInPolygonByPList'](cM['OutLine']['PointList'], cz['OutLine']['PointList'][0x0]) && cM['AddHole'](cz);
              }
              cG['push'](cM);
            }
          }
          return bB['addAll'](cC, cG),
            cG;
        }
      }
      static ['addPolygonHoles_Ring'] (cd) {
        let cq, cJ, cC = [];
        for (cq = 0x0; cq < cd['length']; cq++) {
          let cO = cd[cq];
          cO['IsBorder'] && !cO['IsInnerBorder'] || (cO['HoleIndex'] = 0x1,
            cC['push'](cO));
        }
        if (0x0 === cC['length'])
          return cd;
        {
          let cG = [];
          for (cq = 0x1; cq < cC['length']; cq++) {
            let cN = cC[cq];
            for (cJ = cq - 0x1; cJ >= 0x0; cJ--) {
              let cP = cC[cJ];
              if (cP['Extent']['Include'](cN['Extent']) && bB['pointInPolygonByPList'](cP['OutLine']['PointList'], cN['OutLine']['PointList'][0x0])) {
                cN['HoleIndex'] = cP['HoleIndex'] + 0x1,
                  cP['AddHole'](cN);
                break;
              }
            }
          }
          let cg = [];
          for (cq = 0x0; cq < cC['length']; cq++)
            0x1 === cC[cq]['HoleIndex'] && cg['push'](cC[cq]);
          for (cq = 0x0; cq < cd['length']; cq++) {
            let cM = cd[cq];
            if (cM['IsBorder'] && !cM['IsInnerBorder']) {
              for (cJ = 0x0; cJ < cg['length']; cJ++) {
                let cz = cg[cJ];
                cM['Extent']['Include'](cz['Extent']) && bB['pointInPolygonByPList'](cM['OutLine']['PointList'], cz['OutLine']['PointList'][0x0]) && cM['AddHole'](cz);
              }
              cG['push'](cM);
            }
          }
          return bB['addAll'](cC, cG),
            cG;
        }
      }
      static ['addHoles_Ring'] (cd, cq) {
        let cJ, cC;
        for (cJ = 0x0; cJ < cq['length']; cJ++) {
          let cO = cq[cJ]
            , cG = bB['getExtent'](cO);
          for (cC = cd['length'] - 0x1; cC >= 0x0; cC--) {
            let cg = cd[cC];
            if (cg['Extent']['Include'](cG)) {
              let cN = true;
              for (let cP of cO)
                if (!bB['pointInPolygonByPList'](cg['OutLine']['PointList'], cP)) {
                  cN = false;
                  break;
                }
              if (cN) {
                cg['AddHole'](cO);
                break;
              }
            }
          }
        }
      }
      static ['cutPolyline'] (cd, cq) {
        let cJ, cC, cO = [], cG = cd['PointList'], cg = bB['getExtent'](cG), cN = bB['getExtent'](cq);
        if (!bB['isExtentCross'](cg, cN))
          return cO;
        if (bB['isClockwise'](cq) || cq['reverse'](),
          bB['pointInPolygonByPList'](cq, cG[0x0])) {
          let H3 = true
            , H4 = 0x0;
          for (cJ = 0x0; cJ < cG['length']; cJ++)
            if (!bB['pointInPolygonByPList'](cq, cG[cJ])) {
              H4 = cJ,
                H3 = false;
              break;
            }
          if (H3)
            return cO['push'](cd),
              cO;
          if ('Close' === cd['Type']) {
            let H5 = [];
            for (cJ = H4; cJ < cG['length']; cJ++)
              H5['push'](cG[cJ]);
            for (cJ = 0x1; cJ < H4; cJ++)
              H5['push'](cG[cJ]);
            H5['push'](H5[0x0]),
              cG = [],
              bB['addAll'](H5, cG);
          } else
            cG['reverse']();
        }
        let cP, cM, cz, cQ, cm, cL, cR, H0, H1 = bB['pointInPolygonByPList'](cq, cG[0x0]), H2 = [];
        for (cz = cG[0x0],
          cJ = 0x1; cJ < cG['length']; cJ++) {
          if (cQ = cG[cJ],
            bB['pointInPolygonByPList'](cq, cQ)) {
            if (!H1) {
              for (cm = new bE(),
                cL = new bj(),
                cL['P1'] = cz,
                cL['P2'] = cQ,
                cP = cq[cq['length'] - 0x1],
                cC = 0x0; cC < cq['length']; cC++) {
                if (cM = cq[cC],
                  cR = new bj(),
                  cR['P1'] = cP,
                  cR['P2'] = cM,
                  bB['isLineSegmentCross'](cL, cR)) {
                  cm = bB['getCrossPointD'](cL, cR);
                  break;
                }
                cP = cM;
              }
              H2['push'](cm);
            }
            H2['push'](cG[cJ]),
              H1 = true;
          } else {
            if (H1) {
              for (cm = new bE(),
                cL = new bj(),
                cL['P1'] = cz,
                cL['P2'] = cQ,
                cP = cq[cq['length'] - 0x1],
                cC = 0x0; cC < cq['length']; cC++) {
                if (cM = cq[cC],
                  cR = new bj(),
                  cR['P1'] = cP,
                  cR['P2'] = cM,
                  bB['isLineSegmentCross'](cL, cR)) {
                  cm = bB['getCrossPointD'](cL, cR);
                  break;
                }
                cP = cM;
              }
              H2['push'](cm),
                H0 = new bV(),
                H0['Value'] = cd['Value'],
                H0['Type'] = cd['Type'],
                H0['PointList'] = H2,
                cO['push'](H0),
                H1 = false,
                H2 = [];
            }
          }
          cz = cQ;
        }
        return H1 && H2['length'] > 0x1 && (H0 = new bV(),
          H0['Value'] = cd['Value'],
          H0['Type'] = cd['Type'],
          H0['PointList'] = H2,
          cO['push'](H0)),
          cO;
      }
      static ['cutPolygon_Hole'] (cd, cq) {
        let cJ, cC, cO = [], cG = [], cg = cd['OutLine']['PointList'], cN = bB['getExtent'](cg), cP = bB['getExtent'](cq);
        if (!bB['isExtentCross'](cN, cP))
          return cO;
        bB['isClockwise'](cq) || cq['reverse']();
        let cM = [];
        if (bB['pointInPolygonByPList'](cq, cg[0x0])) {
          let cL = true
            , cR = 0x0;
          for (cJ = 0x0; cJ < cg['length']; cJ++)
            if (!bB['pointInPolygonByPList'](cq, cg[cJ])) {
              cR = cJ,
                cL = false;
              break;
            }
          if (cL)
            return cO['push'](cd),
              cO;
          {
            let H0 = [];
            for (cJ = cR; cJ < cg['length']; cJ++)
              H0['push'](cg[cJ]);
            for (cJ = 0x1; cJ < cR; cJ++)
              H0['push'](cg[cJ]);
            H0['push'](H0[0x0]),
              cM['push'](H0);
          }
        } else
          cM['push'](cg);
        let cz = [];
        for (let H1 = 0x0; H1 < cd['HoleLines']['length']; H1++) {
          let H2 = cd['HoleLines'][H1]['PointList'];
          if (cN = bB['getExtent'](H2),
            bB['isExtentCross'](cN, cP)) {
            if (bB['pointInPolygonByPList'](cq, H2[0x0])) {
              let H3 = true
                , H4 = 0x0;
              for (cJ = 0x0; cJ < H2['length']; cJ++)
                if (!bB['pointInPolygonByPList'](cq, H2[cJ])) {
                  H4 = cJ,
                    H3 = false;
                  break;
                }
              if (H3)
                cz['push'](H2);
              else {
                let H5 = [];
                for (cJ = H4; cJ < H2['length']; cJ++)
                  H5['push'](H2[cJ]);
                for (cJ = 0x1; cJ < H4; cJ++)
                  H5['push'](H2[cJ]);
                H5['push'](H5[0x0]),
                  cM['push'](H5);
              }
            } else
              cM['push'](H2);
          }
        }
        let cQ = []
          , cm = new bf();
        for (let H6 of cq)
          cm = new bf(),
            cm['Point'] = H6,
            cm['Id'] = -0x1,
            cQ['push'](cm);
        for (let H7 = 0x0; H7 < cM['length']; H7++) {
          cg = cM[H7];
          let H8, H9, Hv, HA, Hk, Hl, HK, Hb, Hc = false, HH = [];
          Hv = cg[0x0];
          let Hx = -0x1
            , Hp = -0x1
            , HF = true
            , Hy = 0x0;
          for (cJ = 0x1; cJ < cg['length']; cJ++) {
            if (HA = cg[cJ],
              bB['pointInPolygonByPList'](cq, HA)) {
              if (!Hc) {
                for (Hl = new bj(),
                  Hl['P1'] = Hv,
                  Hl['P2'] = HA,
                  H8 = cQ[cQ['length'] - 0x1]['Point'],
                  Hk = new bE(),
                  cC = 0x0; cC < cQ['length']; cC++) {
                  if (H9 = cQ[cC]['Point'],
                    HK = new bj(),
                    HK['P1'] = H8,
                    HK['P2'] = H9,
                    bB['isLineSegmentCross'](Hl, HK)) {
                    Hk = bB['getCrossPointD'](Hl, HK),
                      cm = new bf(),
                      cm['Id'] = cG['length'],
                      cm['Point'] = Hk,
                      cQ['splice'](cC, 0x0, cm),
                      Hx = cC;
                    break;
                  }
                  H8 = H9;
                }
                HH['push'](Hk);
              }
              HH['push'](cg[cJ]),
                Hc = true;
            } else {
              if (Hc) {
                for (Hl = new bj(),
                  Hl['P1'] = Hv,
                  Hl['P2'] = HA,
                  H8 = cQ[cQ['length'] - 0x1]['Point'],
                  Hk = new bE(),
                  cC = 0x0; cC < cQ['length']; cC++) {
                  if (H9 = cQ[cC]['Point'],
                    HK = new bj(),
                    HK['P1'] = H8,
                    HK['P2'] = H9,
                    bB['isLineSegmentCross'](Hl, HK)) {
                    HF || (Hx - Hp >= 0x1 && Hx - Hp <= 0xa ? bB['twoPointsInside'](Hy, Hp, Hx, cC) || (cQ['splice'](Hx, 0x1),
                      cQ['splice'](Hp, 0x0, cm)) : Hx - Hp <= -0x1 && Hx - Hp >= -0xa ? bB['twoPointsInside'](Hy, Hp, Hx, cC) || (cQ['splice'](Hx, 0x1),
                        cQ['splice'](Hp + 0x1, 0x0, cm)) : Hx === Hp && (bB['twoPointsInside'](Hy, Hp, Hx, cC) || (cQ['splice'](Hx, 0x1),
                          cQ['splice'](Hx + 0x1, 0x0, cm)))),
                      Hk = bB['getCrossPointD'](Hl, HK),
                      cm = new bf(),
                      cm['Id'] = cG['length'],
                      cm['Point'] = Hk,
                      cQ['splice'](cC, 0x0, cm),
                      Hp = cC,
                      Hy = Hx,
                      HF = false;
                    break;
                  }
                  H8 = H9;
                }
                HH['push'](Hk),
                  Hb = new bV(),
                  Hb['Value'] = cd['OutLine']['Value'],
                  Hb['Type'] = cd['OutLine']['Type'],
                  Hb['PointList'] = HH,
                  cG['push'](Hb),
                  Hc = false,
                  HH = [];
              }
            }
            Hv = HA;
          }
        }
        if (cG['length'] > 0x0)
          cO = bB['tracingClipPolygons'](cd, cG, cQ);
        else {
          if (bB['pointInPolygonByPList'](cg, cq[0x0])) {
            let Hw = new bT()
              , Hh = new bZ();
            Hh['IsBorder'] = true,
              Hh['LowValue'] = cd['LowValue'],
              Hh['HighValue'] = cd['HighValue'],
              Hh['Area'] = bB['getExtentAndArea'](cq, Hw),
              Hh['IsClockWise'] = true,
              Hh['Extent'] = Hw,
              Hh['OutLine']['PointList'] = cq,
              Hh['OutLine']['Value'] = cd['LowValue'],
              Hh['IsHighCenter'] = cd['IsHighCenter'],
              Hh['OutLine']['Type'] = 'Border',
              Hh['HoleLines'] = [],
              cO['push'](Hh);
          }
        }
        return cz['length'] > 0x0 && bB['addHoles_Ring'](cO, cz),
          cO;
      }
      static ['cutPolygon'] (cd, cq) {
        let cJ, cC, cO = [], cG = [], cg = cd['OutLine']['PointList'], cN = bB['getExtent'](cg), cP = bB['getExtent'](cq);
        if (!bB['isExtentCross'](cN, cP))
          return cO;
        if (bB['isClockwise'](cq) || cq['reverse'](),
          bB['pointInPolygonByPList'](cq, cg[0x0])) {
          let Hv = true
            , HA = 0x0;
          for (cJ = 0x0; cJ < cg['length']; cJ++)
            if (!bB['pointInPolygonByPList'](cq, cg[cJ])) {
              HA = cJ,
                Hv = false;
              break;
            }
          if (Hv)
            return cO['push'](cd),
              cO;
          {
            let Hk = [];
            for (cJ = HA; cJ < cg['length']; cJ++)
              Hk['push'](cg[cJ]);
            for (cJ = 0x1; cJ < HA; cJ++)
              Hk['push'](cg[cJ]);
            Hk['push'](Hk[0x0]),
              cg = [],
              bB['addAll'](Hk, cg);
          }
        }
        let cM = []
          , cz = new bf();
        for (let Hl of cq)
          cz = new bf(),
            cz['Point'] = Hl,
            cz['Id'] = -0x1,
            cM['push'](cz);
        let cQ, cm, cL, cR, H0, H1, H2, H3, H4 = false, H5 = [];
        cL = cg[0x0];
        let H6 = -0x1
          , H7 = -0x1
          , H8 = 0x0
          , H9 = true;
        for (cJ = 0x1; cJ < cg['length']; cJ++) {
          if (cR = cg[cJ],
            bB['pointInPolygonByPList'](cq, cR)) {
            if (!H4) {
              for (H1 = new bj(),
                H1['P1'] = cL,
                H1['P2'] = cR,
                cQ = cM[cM['length'] - 0x1]['Point'],
                H0 = new bE(),
                cC = 0x0; cC < cM['length']; cC++) {
                if (cm = cM[cC]['Point'],
                  H2 = new bj(),
                  H2['P1'] = cQ,
                  H2['P2'] = cm,
                  bB['isLineSegmentCross'](H1, H2)) {
                  H0 = bB['getCrossPointD'](H1, H2),
                    cz = new bf(),
                    cz['Id'] = cG['length'],
                    cz['Point'] = H0,
                    cM['splice'](cC, 0x0, cz),
                    H6 = cC;
                  break;
                }
                cQ = cm;
              }
              H5['push'](H0);
            }
            H5['push'](cg[cJ]),
              H4 = true;
          } else {
            if (H4) {
              for (H1 = new bj(),
                H1['P1'] = cL,
                H1['P2'] = cR,
                cQ = cM[cM['length'] - 0x1]['Point'],
                H0 = new bE(),
                cC = 0x0; cC < cM['length']; cC++) {
                if (cm = cM[cC]['Point'],
                  H2 = new bj(),
                  H2['P1'] = cQ,
                  H2['P2'] = cm,
                  bB['isLineSegmentCross'](H1, H2)) {
                  H9 || (H6 - H7 >= 0x1 && H6 - H7 <= 0xa ? bB['twoPointsInside'](H8, H7, H6, cC) || (cM['splice'](H6, 0x1),
                    cM['splice'](H7, 0x0, cz)) : H6 - H7 <= -0x1 && H6 - H7 >= -0xa ? bB['twoPointsInside'](H8, H7, H6, cC) || (cM['splice'](H6, 0x1),
                      cM['splice'](H7 + 0x1, 0x0, cz)) : H6 === H7 && (bB['twoPointsInside'](H8, H7, H6, cC) || (cM['splice'](H6, 0x1),
                        cM['splice'](H6 + 0x1, 0x0, cz)))),
                    H0 = bB['getCrossPointD'](H1, H2),
                    cz = new bf(),
                    cz['Id'] = cG['length'],
                    cz['Point'] = H0,
                    cM['splice'](cC, 0x0, cz),
                    H7 = cC,
                    H8 = H6,
                    H9 = false;
                  break;
                }
                cQ = cm;
              }
              H5['push'](H0),
                H3 = new bV(),
                H3['Value'] = cd['OutLine']['Value'],
                H3['Type'] = cd['OutLine']['Type'],
                H3['PointList'] = H5,
                cG['push'](H3),
                H4 = false,
                H5 = [];
            }
          }
          cL = cR;
        }
        if (cG['length'] > 0x0)
          cO = bB['tracingClipPolygons'](cd, cG, cM);
        else {
          if (bB['pointInPolygonByPList'](cg, cq[0x0])) {
            let HK = new bT()
              , Hb = new bZ();
            Hb['IsBorder'] = true,
              Hb['LowValue'] = cd['LowValue'],
              Hb['HighValue'] = cd['HighValue'],
              Hb['Area'] = bB['getExtentAndArea'](cq, HK),
              Hb['IsClockWise'] = true,
              Hb['Extent'] = HK,
              Hb['OutLine']['PointList'] = cq,
              Hb['OutLine']['Value'] = cd['LowValue'],
              Hb['IsHighCenter'] = cd['IsHighCenter'],
              Hb['OutLine']['Type'] = 'Border',
              Hb['HoleLines'] = [],
              cO['push'](Hb);
          }
        }
        return cO;
      }
      static ['twoPointsInside'] (cd, cq, cJ, cC) {
        if (cq < cd && (cd += 0x1),
          cJ < cd && (cd += 0x1),
          cJ < cq && (cq += 0x1),
          cq < cd) {
          let cO = cd;
          cd = cq,
            cq = cO;
        }
        return cJ > cd && cJ <= cq ? cC > cd && cC <= cq : !(cC > cd && cC <= cq);
      }
      static ['BSplineScanning'] (cd, cq) {
        let cJ, cC, cO, cG, cg, cN = [];
        if (cq < 0x4)
          return null;
        let cP = false;
        cg = cd[0x0];
        let cM = cd[cq - 0x1];
        for (cg['X'] === cM['X'] && cg['Y'] === cM['Y'] && (cd['splice'](0x0, 0x1),
          cd['push'](cd[0x0]),
          cd['push'](cd[0x1]),
          cd['push'](cd[0x2]),
          cd['push'](cd[0x3]),
          cd['push'](cd[0x4]),
          cd['push'](cd[0x5]),
          cd['push'](cd[0x6]),
          cP = true),
          cq = cd['length'],
          cC = 0x0; cC < cq - 0x3; cC++)
          for (cJ = 0x0; cJ <= 0x1; cJ += 0.05) {
            let cz = bB['BSpline'](cd, cJ, cC);
            cO = cz[0x0],
              cG = cz[0x1],
              cP ? cC > 0x3 && (cg = new bE(),
                cg['X'] = cO,
                cg['Y'] = cG,
                cN['push'](cg)) : (cg = new bE(),
                  cg['X'] = cO,
                  cg['Y'] = cG,
                  cN['push'](cg));
          }
        return cP ? cN['push'](cN[0x0]) : (cN['splice'](0x0, 0x0, cd[0x0]),
          cN['push'](cd[cd['length'] - 0x1])),
          cN;
      }
      static ['BSpline'] (cd, cq, cJ) {
        let cC, cO = [];
        bB['fb'](cq, cO);
        let cG, cg = 0x0, cN = 0x0;
        for (cC = 0x0; cC < 0x4; cC++)
          cG = cd[cJ + cC],
            cg += cO[cC] * cG['X'],
            cN += cO[cC] * cG['Y'];
        let cP = [];
        return cP[0x0] = cg,
          cP[0x1] = cN,
          cP;
      }
      static ['f0'] (cd) {
        return 0x1 / 0x6 * (0x1 - cd) * (0x1 - cd) * (0x1 - cd);
      }
      static ['f1'] (cd) {
        return 0x1 / 0x6 * (0x3 * cd * cd * cd - 0x6 * cd * cd + 0x4);
      }
      static ['f2'] (cd) {
        return 0x1 / 0x6 * (-0x3 * cd * cd * cd + 0x3 * cd * cd + 0x3 * cd + 0x1);
      }
      static ['f3'] (cd) {
        return 0x1 / 0x6 * cd * cd * cd;
      }
      static ['fb'] (cd, cq) {
        cq[0x0] = bB['f0'](cd),
          cq[0x1] = bB['f1'](cd),
          cq[0x2] = bB['f2'](cd),
          cq[0x3] = bB['f3'](cd);
      }
      static ['tracingStreamline'] (cd, cq, cJ, cC, cO, cG) {
        let cg = []
          , cN = cd[0x1]['length']
          , cP = cd['length']
          , cM = []
          , cz = []
          , cQ = cJ[0x1] - cJ[0x0]
          , cm = cC[0x1] - cC[0x0];
        0x0 === cG && (cG = 0x1);
        let cL, cR, H0 = cQ / Math['pow'](cG, 0x2), H1 = 1.5 * H0;
        for (cL = 0x0; cL < cP; cL++)
          for (cM[cL] = [],
            cz[cL] = [],
            cR = 0x0; cR < cN; cR++)
            if (Math['abs'](cd[cL][cR] / cO - 0x1) < 0.01)
              cM[cL][cR] = 0.1,
                cz[cL][cR] = 0.1;
            else {
              let H7 = Math['sqrt'](cd[cL][cR] * cd[cL][cR] + cq[cL][cR] * cq[cL][cR]);
              0x0 === H7 && (H7 = 0x1),
                cM[cL][cR] = cd[cL][cR] / H7 * cQ / cG,
                cz[cL][cR] = cq[cL][cR] / H7 * cm / cG;
            }
        let H2, H3, H4 = [], H5 = [];
        for (cL = 0x0; cL < cP - 0x1; cL++)
          for (H4[cL] = [],
            H5[cL] = [],
            cR = 0x0; cR < cN - 0x1; cR++)
            H5[cL][cR] = cL % 0x2 == 0x0 && cR % 0x2 == 0x0 ? 0x0 : 0x1,
              H4[cL][cR] = [];
        let H6 = 0x0;
        for (cL = 0x0; cL < cP - 0x1; cL++)
          for (cR = 0x0; cR < cN - 0x1; cR++)
            if (0x0 === H5[cL][cR]) {
              let H8, H9, Hv, HA = [], Hk = new bE(), Hl = new bV();
              Hk['X'] = cJ[cR] + cQ / 0x2,
                Hk['Y'] = cC[cL] + cm / 0x2,
                HA['push'](Hk['clone']()),
                H3 = new bf(),
                H3['Point'] = Hk['clone'](),
                H3['Id'] = H6,
                H4[cL][cR]['push'](H3),
                H5[cL][cR] = 0x1,
                H8 = cL,
                H9 = cR;
              let HK = 0x1f4;
              for (Hv = 0x0; Hv < HK;) {
                let Hb = [];
                Hb[0x0] = H8,
                  Hb[0x1] = H9;
                let Hc = bB['tracingStreamlinePoint'](Hk, cM, cz, cJ, cC, Hb, true);
                if (H8 = Hb[0x0],
                  H9 = Hb[0x1],
                  !Hc)
                  break;
                if (Math['abs'](cd[H8][H9] / cO - 0x1) < 0.01 || Math['abs'](cd[H8][H9 + 0x1] / cO - 0x1) < 0.01 || Math['abs'](cd[H8 + 0x1][H9] / cO - 0x1) < 0.01 || Math['abs'](cd[H8 + 0x1][H9 + 0x1] / cO - 0x1) < 0.01)
                  break;
                {
                  let HH = false;
                  for (let Hx of H4[H8][H9])
                    if (Math['sqrt']((Hk['X'] - Hx['Point']['X']) * (Hk['X'] - Hx['Point']['X']) + (Hk['Y'] - Hx['Point']['Y']) * (Hk['Y'] - Hx['Point']['Y'])) < H0) {
                      HH = true;
                      break;
                    }
                  if (!HH && H4[H8][H9]['length'] > 0x1) {
                    let Hp = H4[H8][H9][0x0]
                      , HF = H4[H8][H9][0x1];
                    H6 === Hp['Id'] && H6 === HF['Id'] || (H2 = bB['distance_point2line'](Hp['Point'], HF['Point'], Hk),
                      H2 < H1 && (HH = true));
                  }
                  if (HH)
                    break;
                  HA['push'](Hk['clone']()),
                    H3 = new bf(),
                    H3['Point'] = Hk['clone'](),
                    H3['Id'] = H6,
                    H4[H8][H9]['push'](H3),
                    H5[H8][H9] = 0x1;
                }
                Hv += 0x1;
              }
              for (Hk['X'] = cJ[cR] + cQ / 0x2,
                Hk['Y'] = cC[cL] + cm / 0x2,
                H8 = cL,
                H9 = cR,
                Hv = 0x0; Hv < HK;) {
                let Hy = [];
                Hy[0x0] = H8,
                  Hy[0x1] = H9;
                let Hw = bB['tracingStreamlinePoint'](Hk, cM, cz, cJ, cC, Hy, false);
                if (H8 = Hy[0x0],
                  H9 = Hy[0x1],
                  !Hw)
                  break;
                if (Math['abs'](cd[H8][H9] / cO - 0x1) < 0.01 || Math['abs'](cd[H8][H9 + 0x1] / cO - 0x1) < 0.01 || Math['abs'](cd[H8 + 0x1][H9] / cO - 0x1) < 0.01 || Math['abs'](cd[H8 + 0x1][H9 + 0x1] / cO - 0x1) < 0.01)
                  break;
                {
                  let Hh = false;
                  for (let Hu of H4[H8][H9])
                    if (Math['sqrt']((Hk['X'] - Hu['Point']['X']) * (Hk['X'] - Hu['Point']['X']) + (Hk['Y'] - Hu['Point']['Y']) * (Hk['Y'] - Hu['Point']['Y'])) < H0) {
                      Hh = true;
                      break;
                    }
                  if (!Hh && H4[H8][H9]['length'] > 0x1) {
                    let HY = H4[H8][H9][0x0]
                      , HT = H4[H8][H9][0x1];
                    H6 === HY['Id'] && H6 === HT['Id'] || (H2 = bB['distance_point2line'](HY['Point'], HT['Point'], Hk),
                      H2 < H1 && (Hh = true));
                  }
                  if (Hh)
                    break;
                  HA['splice'](0x0, 0x0, Hk['clone']()),
                    H3 = new bf(),
                    H3['Point'] = Hk['clone'](),
                    H3['Id'] = H6,
                    H4[H8][H9]['push'](H3),
                    H5[H8][H9] = 0x1;
                }
                Hv += 0x1;
              }
              HA['length'] > 0x1 && (Hl['PointList'] = HA,
                cg['push'](Hl),
                H6 += 0x1);
            }
        return cg;
      }
      static ['tracingStreamlinePoint'] (cd, cq, cJ, cC, cO, cG, cg) {
        let cN, cP, cM, cz, cQ, cm, cL, cR, H0 = cC['length'], H1 = cO['length'], H2 = cC[0x1] - cC[0x0], H3 = cO[0x1] - cO[0x0], H4 = cG[0x0], H5 = cG[0x1];
        if (cN = cq[H4][H5],
          cP = cq[H4][H5 + 0x1],
          cM = cq[H4 + 0x1][H5],
          cz = cq[H4 + 0x1][H5 + 0x1],
          cQ = cN + (cM - cN) * ((cd['Y'] - cO[H4]) / H3),
          cm = cP + (cz - cP) * ((cd['Y'] - cO[H4]) / H3),
          cL = cQ + (cm - cQ) * ((cd['X'] - cC[H5]) / H2),
          cN = cJ[H4][H5],
          cP = cJ[H4][H5 + 0x1],
          cM = cJ[H4 + 0x1][H5],
          cz = cJ[H4 + 0x1][H5 + 0x1],
          cQ = cN + (cM - cN) * ((cd['Y'] - cO[H4]) / H3),
          cm = cP + (cz - cP) * ((cd['Y'] - cO[H4]) / H3),
          cR = cQ + (cm - cQ) * ((cd['X'] - cC[H5]) / H2),
          cg ? (cd['X'] += cL,
            cd['Y'] += cR) : (cd['X'] -= cL,
              cd['Y'] -= cR),
          !(cd['X'] >= cC[H5] && cd['X'] <= cC[H5 + 0x1] && cd['Y'] >= cO[H4] && cd['Y'] <= cO[H4 + 0x1])) {
          if (cd['X'] < cC[0x0] || cd['X'] > cC[cC['length'] - 0x1] || cd['Y'] < cO[0x0] || cd['Y'] > cO[cO['length'] - 0x1])
            return false;
          for (let H6 = H4 - 0x2; H6 < H4 + 0x3; H6++)
            if (H6 >= 0x0 && H6 < H1 && cd['Y'] >= cO[H6] && cd['Y'] <= cO[H6 + 0x1]) {
              H4 = H6;
              for (let H7 = H5 - 0x2; H7 < H5 + 0x3; H7++)
                if (H7 >= 0x0 && H7 < H0 && cd['X'] >= cC[H7] && cd['X'] <= cC[H7 + 0x1]) {
                  H5 = H7;
                  break;
                }
              break;
            }
        }
        return cG[0x0] = H4,
          cG[0x1] = H5,
          true;
      }
      static ['distance_point2line'] (cd, cq, cJ) {
        let cC = (cq['Y'] - cd['Y']) / (cq['X'] - cd['X'])
          , cO = (cC * cC * cd['X'] + cC * (cJ['Y'] - cd['Y']) + cJ['X']) / (cC * cC + 0x1)
          , cG = cC * (cO - cd['X']) + cd['Y'];
        return Math['sqrt']((cJ['Y'] - cG) * (cJ['Y'] - cG) + (cJ['X'] - cO) * (cJ['X'] - cO));
      }
      static ['getExtent'] (cd) {
        let cq, cJ, cC, cO, cG, cg = cd[0x0];
        for (cq = cg['X'],
          cC = cg['X'],
          cJ = cg['Y'],
          cO = cg['Y'],
          cG = 0x1; cG < cd['length']; cG++)
          cg = cd[cG],
            cg['X'] < cq && (cq = cg['X']),
            cg['X'] > cC && (cC = cg['X']),
            cg['Y'] < cJ && (cJ = cg['Y']),
            cg['Y'] > cO && (cO = cg['Y']);
        let cN = new bT();
        return cN['xMin'] = cq,
          cN['yMin'] = cJ,
          cN['xMax'] = cC,
          cN['yMax'] = cO,
          cN;
      }
      static ['getExtentAndArea'] (cd, cq) {
        let cJ, cC, cO, cG, cg, cN, cP = cd[0x0];
        for (cC = cP['X'],
          cG = cP['X'],
          cO = cP['Y'],
          cg = cP['Y'],
          cN = 0x1; cN < cd['length']; cN++)
          cP = cd[cN],
            cP['X'] < cC && (cC = cP['X']),
            cP['X'] > cG && (cG = cP['X']),
            cP['Y'] < cO && (cO = cP['Y']),
            cP['Y'] > cg && (cg = cP['Y']);
        return cq['xMin'] = cC,
          cq['yMin'] = cO,
          cq['xMax'] = cG,
          cq['yMax'] = cg,
          cJ = (cG - cC) * (cg - cO),
          cJ;
      }
      static ['isClockwise'] (cd) {
        let cq, cJ, cC, cO, cG, cg, cN, cP, cM = 0x0, cz = 0x0;
        for (cq = 0x0; cq < cd['length'] - 0x1; cq++)
          cJ = cd[cq],
            0x0 === cq ? (cM = cJ['Y'],
              cz = 0x0) : cM < cJ['Y'] && (cM = cJ['Y'],
                cz = cq);
        return cg = cz - 0x1,
          cN = cz,
          cP = cz + 0x1,
          0x0 === cz && (cg = cd['length'] - 0x2),
          cC = cd[cg],
          cO = cd[cN],
          cG = cd[cP],
          (cG['X'] - cC['X']) * (cO['Y'] - cC['Y']) - (cO['X'] - cC['X']) * (cG['Y'] - cC['Y']) > 0x0;
      }
      static ['isLineSegmentCross'] (cd, cq) {
        let cJ = new bT()
          , cC = new bT()
          , cO = []
          , cG = [];
        return cO['push'](cd['P1']),
          cO['push'](cd['P2']),
          cG['push'](cq['P1']),
          cG['push'](cq['P2']),
          bB['getExtentAndArea'](cO, cJ),
          bB['getExtentAndArea'](cG, cC),
          !!bB['isExtentCross'](cJ, cC) && !(((cq['P1']['X'] - cd['P1']['X']) * (cd['P2']['Y'] - cd['P1']['Y']) - (cd['P2']['X'] - cd['P1']['X']) * (cq['P1']['Y'] - cd['P1']['Y'])) * ((cq['P2']['X'] - cd['P1']['X']) * (cd['P2']['Y'] - cd['P1']['Y']) - (cd['P2']['X'] - cd['P1']['X']) * (cq['P2']['Y'] - cd['P1']['Y'])) > 0x0);
      }
      static ['isExtentCross'] (cd, cq) {
        return !(cd['xMin'] > cq['xMax'] || cd['xMax'] < cq['xMin'] || cd['yMin'] > cq['yMax'] || cd['yMax'] < cq['yMin']);
      }
      static ['getCrossPointF'] (cd, cq, cJ, cC) {
        let cO, cG, cg, cN, cP, cM, cz = new bD(0x0, 0x0), cQ = (cJ['X'] - cd['X']) * (cq['Y'] - cd['Y']) - (cq['X'] - cd['X']) * (cJ['Y'] - cd['Y']), cm = (cC['X'] - cd['X']) * (cq['Y'] - cd['Y']) - (cq['X'] - cd['X']) * (cC['Y'] - cd['Y']);
        return 0x0 === cQ ? cz = cJ : 0x0 === cm ? cz = cC : (cO = cd,
          cG = cq,
          cg = cJ,
          cN = cC,
          cP = (cN['X'] - cg['X']) * (cO['Y'] - cG['Y']) - (cG['X'] - cO['X']) * (cg['Y'] - cN['Y']),
          cM = (cO['Y'] - cg['Y']) * (cG['X'] - cO['X']) * (cN['X'] - cg['X']) + cg['X'] * (cN['Y'] - cg['Y']) * (cG['X'] - cO['X']) - cO['X'] * (cG['Y'] - cO['Y']) * (cN['X'] - cg['X']),
          cz['X'] = cM / cP,
          cP = (cO['X'] - cG['X']) * (cN['Y'] - cg['Y']) - (cG['Y'] - cO['Y']) * (cg['X'] - cN['X']),
          cM = cG['Y'] * (cO['X'] - cG['X']) * (cN['Y'] - cg['Y']) + (cN['X'] - cG['X']) * (cN['Y'] - cg['Y']) * (cO['Y'] - cG['Y']) - cN['Y'] * (cg['X'] - cN['X']) * (cG['Y'] - cO['Y']),
          cz['Y'] = cM / cP),
          cz;
      }
      static ['getCrossPointD'] (cd, cq) {
        let cJ, cC, cO, cG, cg, cN, cP = new bE(), cM = (cq['P1']['X'] - cd['P1']['X']) * (cd['P2']['Y'] - cd['P1']['Y']) - (cd['P2']['X'] - cd['P1']['X']) * (cq['P1']['Y'] - cd['P1']['Y']), cz = (cq['P2']['X'] - cd['P1']['X']) * (cd['P2']['Y'] - cd['P1']['Y']) - (cd['P2']['X'] - cd['P1']['X']) * (cq['P2']['Y'] - cd['P1']['Y']);
        return 0x0 === cM ? cP = cq['P1'] : 0x0 === cz ? cP = cq['P2'] : (cJ = cd['P1'],
          cC = cd['P2'],
          cO = cq['P1'],
          cG = cq['P2'],
          cg = (cG['X'] - cO['X']) * (cJ['Y'] - cC['Y']) - (cC['X'] - cJ['X']) * (cO['Y'] - cG['Y']),
          cN = (cJ['Y'] - cO['Y']) * (cC['X'] - cJ['X']) * (cG['X'] - cO['X']) + cO['X'] * (cG['Y'] - cO['Y']) * (cC['X'] - cJ['X']) - cJ['X'] * (cC['Y'] - cJ['Y']) * (cG['X'] - cO['X']),
          cP['X'] = cN / cg,
          cg = (cJ['X'] - cC['X']) * (cG['Y'] - cO['Y']) - (cC['Y'] - cJ['Y']) * (cO['X'] - cG['X']),
          cN = cC['Y'] * (cJ['X'] - cC['X']) * (cG['Y'] - cO['Y']) + (cG['X'] - cC['X']) * (cG['Y'] - cO['Y']) * (cJ['Y'] - cC['Y']) - cG['Y'] * (cO['X'] - cG['X']) * (cC['Y'] - cJ['Y']),
          cP['Y'] = cN / cg),
          cP;
      }
      static ['insertPoint2Border'] (cd, cq) {
        let cJ, cC, cO, cG, cg, cN, cP, cM = [];
        for (bB['addAll'](cq, cM),
          cO = 0x0; cO < cd['length']; cO++)
          for (cC = cd[cO],
            cP = cC['Point'],
            cJ = cM[0x0],
            cg = cJ['Point'],
            cG = 0x1; cG < cM['length']; cG++) {
            if (cJ = cM[cG],
              cN = cJ['Point'],
              (cP['X'] - cg['X']) * (cP['X'] - cN['X']) <= 0x0 && (cP['Y'] - cg['Y']) * (cP['Y'] - cN['Y']) <= 0x0 && (cP['X'] - cg['X']) * (cN['Y'] - cg['Y']) - (cN['X'] - cg['X']) * (cP['Y'] - cg['Y']) == 0x0) {
              cM['splice'](cG, 0x0, cC);
              break;
            }
            cg = cN;
          }
        return cM;
      }
      static ['insertPoint2RectangleBorder'] (cd, cq) {
        let cJ, cC, cO, cG, cg, cN, cP, cM, cz, cQ = [], cm = [], cL = [], cR = [], H0 = [];
        for (cg = 0x0; cg < cd['length']; cg++)
          if (cO = cd[cg],
            'Close' !== cO['Type']) {
            for (cM = [],
              bB['addAll'](cO['PointList'], cM),
              cC = new bf(),
              cC['Id'] = cg,
              cP = 0x0; cP <= 0x1; cP++)
              if (cG = 0x0 === cP ? cM[0x0] : cM[cM['length'] - 0x1],
                cC['Point'] = cG,
                cz = false,
                cG['X'] === cq['xMin']) {
                for (cN = 0x0; cN < cQ['length']; cN++)
                  if (cJ = cQ[cN],
                    cG['Y'] < cJ['Point']['Y']) {
                    cQ['splice'](cN, 0x0, cC),
                      cz = true;
                    break;
                  }
                cz || cQ['push'](cC);
              } else {
                if (cG['X'] === cq['xMax']) {
                  for (cN = 0x0; cN < cL['length']; cN++)
                    if (cJ = cL[cN],
                      cG['Y'] > cJ['Point']['Y']) {
                      cL['splice'](cN, 0x0, cC),
                        cz = true;
                      break;
                    }
                  cz || cL['push'](cC);
                } else {
                  if (cG['Y'] === cq['yMin']) {
                    for (cN = 0x0; cN < cR['length']; cN++)
                      if (cJ = cR[cN],
                        cG['X'] > cJ['Point']['X']) {
                        cR['splice'](cN, 0x0, cC),
                          cz = true;
                        break;
                      }
                    cz || cR['push'](cC);
                  } else {
                    if (cG['Y'] === cq['yMax']) {
                      for (cN = 0x0; cN < cm['length']; cN++)
                        if (cJ = cm[cN],
                          cG['X'] < cJ['Point']['X']) {
                          cm['splice'](cN, 0x0, cC),
                            cz = true;
                          break;
                        }
                      cz || cm['push'](cC);
                    }
                  }
                }
              }
          }
        return cC = new bf(),
          cC['Id'] = -0x1,
          cG = new bE(),
          cG['X'] = cq['xMin'],
          cG['Y'] = cq['yMin'],
          cC['Point'] = cG,
          H0['push'](cC),
          bB['addAll'](cQ, H0),
          cC = new bf(),
          cC['Id'] = -0x1,
          cG = new bE(),
          cG['X'] = cq['xMin'],
          cG['Y'] = cq['yMax'],
          cC['Point'] = cG,
          H0['push'](cC),
          bB['addAll'](cm, H0),
          cC = new bf(),
          cC['Id'] = -0x1,
          cG = new bE(),
          cG['X'] = cq['xMax'],
          cG['Y'] = cq['yMax'],
          cC['Point'] = cG,
          H0['push'](cC),
          bB['addAll'](cL, H0),
          cC = new bf(),
          cC['Id'] = -0x1,
          cG = new bE(),
          cG['X'] = cq['xMax'],
          cG['Y'] = cq['yMin'],
          cC['Point'] = cG,
          H0['push'](cC),
          bB['addAll'](cR, H0),
          H0['push'](H0[0x0]),
          H0;
      }
      static ['insertEndPoint2Border'] (cd, cq) {
        let cJ, cC, cO, cG, cg, cN, cP, cM, cz, cQ, cm, cL = [], cR = [], H0 = [];
        for (cM = [],
          bB['addAll'](cd, cM),
          cJ = cq[0x0],
          cN = cJ['Point'],
          H0['push'](cJ),
          cO = 0x1; cO < cq['length']; cO++) {
          for (cJ = cq[cO],
            cP = cJ['Point'],
            cL = [],
            cG = 0x0; cG < cM['length'] && cG !== cM['length']; cG++)
            cz = cM[cG],
              Math['abs'](cz['sPoint']['X'] - cN['X']) < 0.000001 && Math['abs'](cz['sPoint']['Y'] - cN['Y']) < 0.000001 && (cL['push'](cz),
                cM['splice'](cG, 0x1),
                cG -= 0x1);
          if (cL['length'] > 0x0) {
            if (cR = [],
              cL['length'] > 0x1) {
              for (cG = 0x0; cG < cL['length']; cG++)
                if (cz = cL[cG],
                  cQ = Math['pow'](cz['Point']['X'] - cN['X'], 0x2) + Math['pow'](cz['Point']['Y'] - cN['Y'], 0x2),
                  0x0 === cG)
                  cR['push']([cQ, cG]);
                else {
                  for (cm = false,
                    cg = 0x0; cg < cR['length']; cg++)
                    if (cQ < parseFloat(cR[cg][0x0])) {
                      cR['splice'](cg, 0x0, [cQ, cG]),
                        cm = true;
                      break;
                    }
                  cm || cR['push']([cQ, cG]);
                }
              for (cG = 0x0; cG < cR['length']; cG++)
                cz = cL[parseInt(cR[cG][0x1])],
                  cC = new bf(),
                  cC['Id'] = cz['Index'],
                  cC['Point'] = cz['Point'],
                  H0['push'](cC);
            } else
              cz = cL[0x0],
                cC = new bf(),
                cC['Id'] = cz['Index'],
                cC['Point'] = cz['Point'],
                H0['push'](cC);
          }
          H0['push'](cJ),
            cN = cP;
        }
        return H0;
      }
      static ['insertPoint2Border_Ring'] (cd, cq, cJ, cC) {
        let cO, cG, cg, cN, cP, cM, cz, cQ, cm, cL = [], cR = [], H0 = [];
        for (cP = 0x0; cP < cJ['getLineNum'](); cP++) {
          for (cm = cJ['LineList'][cP],
            cR = [],
            cg = 0x0; cg < cm['pointList']['length']; cg++)
            cO = new bf(),
              cO['Id'] = -0x1,
              cO['BorderIdx'] = cP,
              cO['Point'] = cm['pointList'][cg],
              cO['Value'] = cd[cm['ijPointList'][cg]['I']][cm['ijPointList'][cg]['J']],
              cR['push'](cO);
          for (cg = 0x0; cg < cq['length']; cg++)
            for (cG = cq[cg]['clone'](),
              cG['BorderIdx'] = cP,
              cQ = cG['Point'],
              cM = cR[0x0]['Point']['clone'](),
              cN = 0x1; cN < cR['length']; cN++) {
              if (cz = cR[cN]['Point']['clone'](),
                (cQ['X'] - cM['X']) * (cQ['X'] - cz['X']) <= 0x0 && (cQ['Y'] - cM['Y']) * (cQ['Y'] - cz['Y']) <= 0x0 && (cQ['X'] - cM['X']) * (cz['Y'] - cM['Y']) - (cz['X'] - cM['X']) * (cQ['Y'] - cM['Y']) == 0x0) {
                cR['splice'](cN, 0x0, cG);
                break;
              }
              cM = cz;
            }
          for (H0 = [],
            cg = 0x0; cg < cR['length']; cg++)
            cG = cR[cg],
              cG['BInnerIdx'] = cg,
              H0['push'](cG);
          cC[cP] = H0['length'],
            bB['addAll'](H0, cL);
        }
        return cL;
      }
      static ['doubleEquals'] (cd, cq) {
        let cJ = Math['abs'](0.00001 * cd);
        return Math['abs'](cd - cq) <= cJ;
      }
    }
    bB['_endPointList'] = [];
    var bS = function (cd, cq, cJ, cC) {
      return new (cJ || (cJ = Promise))(function (cO, cG) {
        function cg (cM) {
          try {
            cP(cC['next'](cM));
          } catch (cz) {
            cG(cz);
          }
        }
        function cN (cM) {
          try {
            cP(cC['throw'](cM));
          } catch (cz) {
            cG(cz);
          }
        }
        function cP (cM) {
          var cz;
          cM['done'] ? cO(cM['value']) : (cz = cM['value'],
            cz instanceof cJ ? cz : new cJ(function (cQ) {
              cQ(cz);
            }
            ))['then'](cg, cN);
        }
        cP((cC = cC['apply'](cd, cq || []))['next']());
      }
      );
    };
    let bU, bd = null, bq = 0x0;
    function bJ (cd, cq) {
      const cJ = cq(0x8 * cd['length']);
      return (null !== bd && bd['buffer'] === bU['memory']['buffer'] || (bd = new Float64Array(bU['memory']['buffer'])),
        bd)['set'](cd, cJ / 0x8),
        bq = cd['length'],
        cJ;
    }
    let bC = null;
    function bO () {
      return null !== bC && bC['buffer'] === bU['memory']['buffer'] || (bC = new Int32Array(bU['memory']['buffer'])),
        bC;
    }
    const bG = new TextDecoder('utf-8', {
      'ignoreBOM': true,
      'fatal': true
    });
    bG['decode']();
    let bg = null;
    function bN (cd, cq) {
      return bG['decode']((null !== bg && bg['buffer'] === bU['memory']['buffer'] || (bg = new Uint8Array(bU['memory']['buffer'])),
        bg)['subarray'](cd, cd + cq));
    }
    let bP = null;
    function bM () {
      return null !== bP && bP['buffer'] === bU['memory']['buffer'] || (bP = new Float32Array(bU['memory']['buffer'])),
        bP;
    }
    function bz (cd, cq) {
      const cJ = cq(0x4 * cd['length']);
      return bM()['set'](cd, cJ / 0x4),
        bq = cd['length'],
        cJ;
    }
    function bQ (cd) {
      return bS(this, undefined, undefined, function* () {
        if (bU)
          return v0['kg']['debug']('wasm\x20contour\x20already\x20intialized'),
            bU;
        ('string' == typeof (cd = null != cd ? cd : Kg['v']['wasmPath'] + '/qe_lib_bg.wasm') || 'function' == typeof Request && cd instanceof Request || 'function' == typeof URL && cd instanceof URL) && (cd = yield qeFetch(cd)['catch'](cC => {
          v0['kg']['error']('load\x20contour\x20wasm\x20failed\x20from\x20' + cd);
        }
        ));
        const { instance: cq, module: cJ } = yield function (cC, cO) {
          return bS(this, undefined, undefined, function* () {
            if (v0['kg']['debug']('load\x20wasm'),
              'function' == typeof Response && cC instanceof Response) {
              const cG = yield cC['arrayBuffer']();
              return yield WebAssembly['instantiate'](cG, cO);
            }
            {
              const cg = yield WebAssembly['instantiate'](cC, cO);
              return cg instanceof WebAssembly['Instance'] ? {
                'instance': cg,
                'module': cC
              } : cg;
            }
          });
        }(cd, {});
        return bU = cq['exports'],
          bQ['__wbindgen_wasm_module'] = cJ,
          bU;
      });
    }
    var bm = function (cd, cq, cJ, cC) {
      return new (cJ || (cJ = Promise))(function (cO, cG) {
        function cg (cM) {
          try {
            cP(cC['next'](cM));
          } catch (cz) {
            cG(cz);
          }
        }
        function cN (cM) {
          try {
            cP(cC['throw'](cM));
          } catch (cz) {
            cG(cz);
          }
        }
        function cP (cM) {
          var cz;
          cM['done'] ? cO(cM['value']) : (cz = cM['value'],
            cz instanceof cJ ? cz : new cJ(function (cQ) {
              cQ(cz);
            }
            ))['then'](cg, cN);
        }
        cP((cC = cC['apply'](cd, cq || []))['next']());
      }
      );
    };
    class bL {
      static ['createDefaultColorStops'] (cd, cq, cJ) {
        const cC = JSON['parse'](JSON['stringify'](bL['DefaultColorStopOptions']));
        cC['fieldName'] = (0x0,
          Kz['En'])(cq, cC['fieldName']);
        const cO = cd['length'] + 0x1
          , cG = cC['stops']['length'];
        if (cO <= cG) {
          for (let cR = 0x0; cR <= cd['length']; cR++)
            cC['stops'][cR]['value'] = cd[cR];
          return cC['stops']['length'] > cd['length'] + 0x1 && (cC['stops'][cd['length'] + 0x1]['value'] = (0x0,
            Kz['En'])(cJ, Kg['v']['defaultUndef'])),
            cC['stops']['splice'](cO),
            cC;
        }
        const cg = cG - 0x1
          , cN = cO - cG
          , cP = parseInt(cN / cg)
          , cM = cN - cP * (cg - 0x1)
          , cz = {
            'stops': [],
            'fieldName': cC['fieldName']
          };
        let cQ = 0x0;
        const cm = (H0, H1, H2, H3) => {
          const H4 = (H3 + 0x1) / (H2 + 0x1) * 0x64;
          return H0['mix'](H1, H4);
        }
          ;
        let cL = null;
        for (let H0 = 0x0; H0 < cg; H0++) {
          cL = cL || new id['t'](cC['stops'][H0]['stop']),
            cz['stops']['push']({
              'value': cd[cQ++],
              'stop': cL
            });
          const H1 = H0 === cC['stops']['length'] - 0x2 ? cP : cM
            , H2 = new id['t'](cC['stops'][H0 + 0x1]['stop']);
          for (let H3 = 0x0; H3 < H1; H3++)
            cz['stops']['push']({
              'value': cd[cQ++],
              'stop': cm(cL, H2, H1, H3)
            });
          cL = H2;
        }
        return cz['stops']['push']({
          'value': (0x0,
            Kz['En'])(cJ, Kg['v']['defaultUndef']),
          'stop': 'rgba(0,0,0,0)'
        }),
          cz;
      }
      constructor(cd) {
        this['options'] = {},
          (0x0,
            Kz['Ov'])(this['options'], cd);
      }
      ['getFeatureOfPoints'] (cd, cq, cJ, cC, cO) {
        cq = cq || 'value';
        const cG = [];
        for (let cM of cJ['PointList'])
          cG['push']([cM['X'], cM['Y']]);
        let cg, cN = cJ['Value'];
        if ('LineString' === cd)
          cg = {
            'type': 'LineString',
            'coordinates': cG
          };
        else {
          if (cg = {
            'type': 'Polygon',
            'coordinates': [cG]
          },
            cO && cC) {
            if (cO['IsHighCenter']) {
              const cz = cC['indexOf'](cO['LowValue']);
              cN = cz >= 0x0 && cz < cC['length'] - 0x1 ? cC[cz + 0x1] : cO['HighValue'];
            } else
              cN = cO['LowValue'];
            if (cO['HasHoles']())
              for (let cQ = 0x0; cQ < cO['HoleLines']['length']; cQ++) {
                const cm = cO['HoleLines'][cQ]
                  , cL = [];
                for (let cR of cm['PointList'])
                  cL['push']([cR['X'], cR['Y']]);
                cg['coordinates']['push'](cL);
              }
          }
        }
        let cP = {
          'id': cJ['BorderIdx']
        };
        return cP[cq] = cN,
        {
          'type': 'Feature',
          'geometry': cg,
          'properties': cP
        };
      }
      ['traceShaded'] (cd, cq, cJ, cC, cO) {
        let cG = bB['tracingPolygons'](cJ, cd['contourlines'], cd['borders'], cq);
        for (let cg of cG) {
          let cN = cg['OutLine']
            , cP = this['getFeatureOfPoints']('Polygon', cO, cN, cq, cg);
          cC['push'](cP);
        }
        return {
          'type': 'FeatureCollection',
          'features': cC
        };
      }
      ['traceShadedWithContourResult'] (cd) {
        const cq = this['traceShaded'](cd['contourInfo'], cd['analysisValues'], cd['dataSource']['getGrid']()['getYxArr'](), [], cd['valueFieldName'])
          , cJ = new GeoJSONFeatureProvider(cq);
        let cC = cd['drawOptions'];
        return cC || (cC = {
          'polygon': {
            'color': bL['createDefaultColorStops'](cd['analysisValues'], cd['valueFieldName'])
          }
        }),
          this['options']['layerCreator'] && this['options']['layerCreator'](cd['layerOptions'], cJ, cC);
      }
      ['tracingContourShaded'] (cd) {
        if (!cd || !cd['dataSource'])
          return;
        const cq = cd['dataSource']['getGrid']();
        let cJ = (0x0,
          Kz['En'])(cd['undef'], cq['undef']);
        undefined === cJ && (v0['kg']['warn']('格点分析尚未提供缺测值，将使用默认的缺测值：' + Kg['v']['defaultUndef']),
          cJ = Kg['v']['defaultUndef']),
          (0x0,
            KM['T'])(cd['dataSource']['gridOptions']);
        const cC = bu['createGridXY_Delt'](cd['dataSource']['gridOptions']['xStart'], cd['dataSource']['gridOptions']['yStart'], cd['dataSource']['gridOptions']['xEnd'], cd['dataSource']['gridOptions']['yEnd'], cd['dataSource']['gridOptions']['xDelta'], cd['dataSource']['gridOptions']['yDelta'])
          , cO = cq['getYxArr']()
          , cG = []
          , cg = bB['tracingBorders'](cO, cC[0x0], cC[0x1], cG, cJ);
        let cN = bB['tracingContourLines'](cO, cC[0x0], cC[0x1], cd['analysisValues']['length'], cd['analysisValues'], cJ, cg, cG);
        cN = bB['smoothLines'](cN);
        let cP = [];
        for (let cR of cN) {
          let H0 = this['getFeatureOfPoints']('LineString', cd['valueFieldName'], cR);
          cP['push'](H0);
        }
        const cM = {
          'type': 'FeatureCollection',
          'features': cP
        };
        let cz = cd['drawOptions'];
        cz ? ('string' == typeof cz && (cz = iz['Zc']['getResource'](cz),
          cz || v0['kg']['error']('当前资源' + cz + '未找到！请先使用资源管理器加载！')),
          cz['polyline'] = (0x0,
            Kz['En'])(cz['polyline'], JSON['parse'](JSON['stringify'](bL['DefaultContourShadedStyle']['polyline']))),
          cz['polygon'] = (0x0,
            Kz['En'])(cz['polygon'], {
              'color': bL['createDefaultColorStops'](cd['analysisValues'], cd['valueFieldName'])
            })) : cz = {
              'polyline': Object['assign']({}, JSON['parse'](JSON['stringify'](bL['DefaultContourShadedStyle']['polyline']))),
              'polygon': {
                'color': bL['createDefaultColorStops'](cd['analysisValues'], cd['valueFieldName'])
              }
            };
        const cQ = {
          'contourlines': cN,
          'borders': cg,
          'layer': undefined,
          'dataSource': undefined,
          'drawOptions': cz
        };
        cd['withShaded'] && this['traceShaded'](cQ, cd['analysisValues'], cO, cP, cd['valueFieldName']);
        const cm = new GeoJSONFeatureProvider(cM);
        cQ['dataSource'] = cm;
        const cL = this['options']['layerCreator'] && this['options']['layerCreator'](cd['layerOptions'], cm, cz);
        return cQ['layer'] = cL,
          cd['reserveTracingInfo'] ? cQ : {
            'layer': cL
          };
      }
      ['tracingContourShadedWASM'] (cd) {
        var cq, cJ, cC, cO;
        return bm(this, undefined, undefined, function* () {
          if (!cd || !cd['dataSource'])
            return;
          const cG = cd['dataSource']
            , cg = cG['gridOptions'];
          yield bQ();
          const cN = JSON['parse'](cd['withShaded'] ? function (cm, cL, cR, H0, H1, H2, H3, H4, H5) {
            try {
              const H8 = bU['__wbindgen_add_to_stack_pointer'](-0x10)
                , H9 = bJ(cm, bU['__wbindgen_malloc'])
                , Hv = bq
                , HA = bJ(cL, bU['__wbindgen_malloc'])
                , Hk = bq;
              bU['make_contours_lonlat'](H8, H9, Hv, HA, Hk, cR, H0, H1, H2, H3, H4, H5);
              var H6 = bO()[H8 / 0x4 + 0x0]
                , H7 = bO()[H8 / 0x4 + 0x1];
              return bN(H6, H7);
            } finally {
              bU['__wbindgen_add_to_stack_pointer'](0x10),
                bU['__wbindgen_free'](H6, H7);
            }
          }(cG['getGrid']()['toNumberArr'](), cd['analysisValues'], cG['getGrid']()['xSize'], cG['getGrid']()['ySize'], cg['xStart'], cg['xDelta'], cg['yStart'], cg['yDelta'], null !== (cJ = null !== (cq = cd['undef']) && undefined !== cq ? cq : cG['getGrid']()['undef']) && undefined !== cJ ? cJ : Kg['v']['defaultUndef']) : function (cm, cL, cR, H0, H1, H2, H3, H4, H5) {
            try {
              const H8 = bU['__wbindgen_add_to_stack_pointer'](-0x10)
                , H9 = bJ(cm, bU['__wbindgen_malloc'])
                , Hv = bq
                , HA = bJ(cL, bU['__wbindgen_malloc'])
                , Hk = bq;
              bU['make_contour_rings_lonlat'](H8, H9, Hv, HA, Hk, cR, H0, H1, H2, H3, H4, H5);
              var H6 = bO()[H8 / 0x4 + 0x0]
                , H7 = bO()[H8 / 0x4 + 0x1];
              return bN(H6, H7);
            } finally {
              bU['__wbindgen_add_to_stack_pointer'](0x10),
                bU['__wbindgen_free'](H6, H7);
            }
          }(cG['getGrid']()['toNumberArr'](), cd['analysisValues'], cG['getGrid']()['xSize'], cG['getGrid']()['ySize'], cg['xStart'], cg['xDelta'], cg['yStart'], cg['yDelta'], null !== (cO = null !== (cC = cd['undef']) && undefined !== cC ? cC : cG['getGrid']()['undef']) && undefined !== cO ? cO : Kg['v']['defaultUndef']))
            , cP = new GeoJSONFeatureProvider(cN);
          let cM = cd['drawOptions'];
          cM ? 'string' == typeof cM && (cM = iz['Zc']['getResource'](cM),
            cM || v0['kg']['error']('当前资源' + cM + '未找到！请先使用资源管理器加载！')) : cM = {
              'polyline': Object['assign']({}, JSON['parse'](JSON['stringify'](bL['DefaultContourShadedStyle']['polyline']))),
              'polygon': {
                'color': bL['createDefaultColorStops'](cd['analysisValues'], cd['valueFieldName'])
              }
            };
          const cz = this['options']['layerCreator'] && this['options']['layerCreator'](cd['layerOptions'], cP, cM)
            , cQ = {
              'contourlines': cN,
              'layer': cz,
              'dataSource': cP,
              'drawOptions': cM
            };
          return cd['reserveTracingInfo'] ? cQ : {
            'layer': cz
          };
        });
      }
      static ['interpToGridWASM'] (cd, cq, cJ, cC) {
        return bm(this, undefined, undefined, function* () {
          const cO = performance['now']();
          cC = (0x0,
            Kz['En'])(cC, Kg['v']['defaultUndef']);
          const cG = cq['getFeatures']();
          if (!cG || 0x0 === cG['features']['length'])
            return;
          const cg = [];
          if (bw(cG, (cQ, cm) => {
            if ('Point' !== cQ['geometry']['type'])
              return;
            let cL = parseFloat(cQ['properties'][cJ]);
            if ('number' != typeof cL || isNaN(cL) || cL > 0x15f90)
              return;
            let cR = cQ['geometry'];
            cg['push'](parseFloat(cR['coordinates'][0x0]), parseFloat(cR['coordinates'][0x1]), cL);
          }
          ),
            (0x0,
              KM['T'])(cd),
            (cg['length'] > 0xf ? 0x5 : cg['length'] / 0x3 - 0x1) <= 0x0)
            return void v0['kg']['error']('点数太少，无法插值！');
          let cN = new Float32Array(cd['xSize'] * cd['ySize']);
          cN['fill'](cC);
          const cP = new Float32Array(cd['xSize']);
          cP['forEach']((cQ, cm) => {
            cP[cm] = cd['xStart'] + cd['xDelta'] * cm;
          }
          );
          const cM = new Float32Array(cd['ySize']);
          cM['forEach']((cQ, cm) => {
            cM[cm] = cd['yStart'] + cd['yDelta'] * cm;
          }
          ),
            cN = function (cQ, cm, cL, cR) {
              try {
                const H5 = bU['__wbindgen_add_to_stack_pointer'](-0x10)
                  , H6 = bz(cQ, bU['__wbindgen_malloc'])
                  , H7 = bq
                  , H8 = bz(cm, bU['__wbindgen_malloc'])
                  , H9 = bq
                  , Hv = bz(cL, bU['__wbindgen_malloc'])
                  , HA = bq;
                bU['interp_idw'](H5, H6, H7, H8, H9, Hv, HA, cR);
                var H0 = bO()[H5 / 0x4 + 0x0]
                  , H1 = bO()[H5 / 0x4 + 0x1]
                  , H2 = (H3 = H0,
                    H4 = H1,
                    bM()['subarray'](H3 / 0x4, H3 / 0x4 + H4))['slice']();
                return bU['__wbindgen_free'](H0, 0x4 * H1),
                  H2;
              } finally {
                bU['__wbindgen_add_to_stack_pointer'](0x10);
              }
              var H3, H4;
            }(new Float32Array(cg), cP, cM, 0x4);
          const cz = new KN['P'](KP['U']['Float32'], cd['xSize'], cd['ySize'], cN['buffer'], cC);
          return v0['kg']['debug']('interp\x20costs\x20' + (performance['now']() - cO) + 'ms'),
            new iu['o']([[cz]], {
              'gridOptions': cd
            });
        });
      }
      static ['interpToGridProvider'] (cd, cq, cJ, cC) {
        const cO = performance['now']();
        (0x0,
          KM['T'])(cd);
        const cG = new Float32Array(cd['xSize']);
        cG['forEach']((cL, cR) => {
          cG[cR] = cd['xStart'] + cd['xDelta'] * cR;
        }
        );
        const cg = new Float32Array(cd['ySize']);
        cg['forEach']((cL, cR) => {
          cg[cR] = cd['yStart'] + cd['yDelta'] * cR;
        }
        );
        let cN = new Float32Array(cd['xSize'] * cd['ySize']);
        cN['fill'](cC);
        const cP = cq['getFeatures']();
        if (!cP || 0x0 === cP['features']['length'])
          return;
        const cM = [];
        bw(cP, (cL, cR) => {
          if ('Point' !== cL['geometry']['type'])
            return;
          let H0 = parseFloat(cL['properties'][cJ]);
          if ('number' != typeof H0 || isNaN(H0) || H0 > 0x15f90)
            return;
          let H1 = cL['geometry'];
          cM['push'](parseFloat(H1['coordinates'][0x0]), parseFloat(H1['coordinates'][0x1]), H0);
        }
        );
        const cz = cM['length'] > 0xf ? 0x5 : cM['length'] / 0x3 - 0x1;
        if (cz <= 0x0)
          return void v0['kg']['error']('点数太少，无法插值！');
        const cQ = cM['length'] / 0x3;
        for (let cL = 0x0; cL < cd['ySize']; cL++) {
          const cR = cL * cd['xSize'];
          for (let H0 = 0x0; H0 < cd['xSize']; H0++) {
            const H1 = cR + H0
              , H2 = cG[H0]
              , H3 = cg[cL]
              , H4 = [new Float32Array(cz), new Float32Array(cz)];
            for (let H7 = 0x0; H7 < cQ; H7++) {
              let H8 = 0x3 * H7
                , H9 = cM[H8]
                , Hv = cM[H8 + 0x1]
                , HA = cM[H8 + 0x2];
              if (H2 == H9 && H3 == Hv) {
                cN[H1] = HA;
                break;
              }
              {
                let Hk = H2 - H9
                  , Hl = H3 - Hv
                  , HK = 0x1 / (Hk * Hk + Hl * Hl);
                for (let Hb = 0x0; Hb < cz; Hb++)
                  if (H4[0x0][Hb] < HK) {
                    H4[0x0][Hb] = HK,
                      H4[0x1][Hb] = HA;
                    break;
                  }
              }
            }
            let H5 = 0x0
              , H6 = 0x0;
            for (let Hc = 0x0; Hc < cz; Hc++)
              H5 += H4[0x0][Hc] * H4[0x1][Hc],
                H6 += H4[0x0][Hc];
            cN[H1] = H5 / H6;
          }
        }
        for (let HH = 0x1; HH < cd['ySize'] - 0x1; HH++) {
          let Hx = HH * cd['xSize']
            , Hp = Hx + cd['xSize']
            , HF = Hx - cd['xSize'];
          for (let Hy = 0x1; Hy < cd['xSize'] - 0x1; Hy++) {
            let Hw = Hx + Hy
              , Hh = Hp + Hy
              , Hu = HF + Hy
              , HY = Hw + 0x1
              , HT = Hw - 0x1;
            cN[Hw] = cN[Hw] + 0.125 * (cN[Hh] + cN[Hu] + cN[HY] + cN[HT] - 0x4 * cN[Hw]);
          }
        }
        const cm = new KN['P'](KP['U']['Float32'], cd['xSize'], cd['ySize'], cN['buffer'], cC);
        return v0['kg']['debug']('interp\x20costs\x20' + (performance['now']() - cO) + 'ms'),
          new iu['o']([[cm]], {
            'gridOptions': cd
          });
      }
      static ['interpToGrid'] (cd, cq, cJ, cC) {
        const cO = performance['now']()
          , cG = cq['getFeatures']();
        if (!cG || 0x0 === cG['features']['length'])
          return;
        const cg = [];
        let cN = 0x0;
        bw(cG, (cR, H0) => {
          if ('Point' !== cR['geometry']['type'])
            return;
          let H1 = parseFloat(cR['properties'][cJ]);
          if ('number' != typeof H1 || isNaN(H1) || H1 > 0x15f90)
            return;
          let H2 = cR['geometry'];
          cg[cN] = [],
            cg[cN][0x0] = parseFloat(H2['coordinates'][0x0]),
            cg[cN][0x1] = parseFloat(H2['coordinates'][0x1]),
            cg[cN][0x2] = H1,
            cN++;
        }
        ),
          (cd['xDelta'] < 0x0 || cd['yDelta'] < 0x0) && v0['kg']['error']('插值参数中的x\x20y间隔需要为正值！'),
          (0x0,
            KM['T'])(cd);
        let cP = [];
        cP['length'] = cd['xSize'];
        let cM = [];
        cM['length'] = cd['ySize'],
          bu['createGridXY_Num'](cd['xStart'], cd['yStart'], cd['xEnd'], cd['yEnd'], cP, cM);
        const cz = cg['length'] > 0x5 ? 0x5 : cg['length'] - 0x1;
        if (cz <= 0x0)
          return void v0['kg']['warn']('用于插值的站点数量过少，无法插值，建议数量大于5！');
        const cQ = bu['interpolation_IDW_Neighbor_Undef'](cg, cP, cM, cz, (0x0,
          Kz['En'])(cC, Kg['v']['defaultUndef']))
          , cm = new KN['P'](KP['U']['Float32'], cd['xSize'], cd['ySize'], undefined, (0x0,
            Kz['En'])(cC, Kg['v']['defaultUndef']));
        cm['update'](cQ);
        const cL = new iu['o']([[cm]], {
          'gridOptions': cd
        });
        return v0['kg']['debug']('interp\x20costs\x20' + (performance['now']() - cO) + 'ms'),
          cL;
      }
      ['tracingContourShadedFromPoints'] (cd) {
        const cq = bL['interpToGridProvider'](cd['gridOpts'], cd['points'], cd['fieldName'], cd['undef']);
        return this['tracingContourShaded']({
          'dataSource': cq,
          'withShaded': cd['withShaded'],
          'drawOptions': cd['drawOptions'],
          'valueFieldName': (0x0,
            Kz['En'])(cd['valueFieldName'], cd['fieldName']),
          'analysisValues': cd['analysisValues'],
          'layerOptions': cd['layerOptions'],
          'reserveTracingInfo': cd['reserveTracingInfo']
        });
      }
      ['tracingContourShadedFromPointsWASM'] (cd) {
        return bm(this, undefined, undefined, function* () {
          const cq = bL['interpToGridProvider'](cd['gridOpts'], cd['points'], cd['fieldName'], cd['undef']);
          return this['tracingContourShadedWASM']({
            'dataSource': cq,
            'withShaded': cd['withShaded'],
            'drawOptions': cd['drawOptions'],
            'analysisValues': cd['analysisValues'],
            'layerOptions': cd['layerOptions'],
            'reserveTracingInfo': cd['reserveTracingInfo']
          });
        });
      }
      ['tracingStreamLinesAsync'] (cd, cq) {
        var cJ, cC, cO;
        return bm(this, undefined, undefined, function* () {
          const cG = cd['dataSource']['getU']()
            , cg = cd['dataSource']['getV']()
            , cN = cd['dataSource']['wProvider'] && cd['dataSource']['wProvider']['getGrid']();
          (null === (cJ = cd['dataSource']['gridOptions']['zValues']) || undefined === cJ ? undefined : cJ['length']) || (cd['dataSource']['gridOptions']['zValues'] = [0x0]);
          let cP = (0x0,
            Kz['En'])(cd['undef'], cG['undef']);
          undefined === cP && (v0['kg']['warn']('格点分析尚未提供缺测值，将使用默认的缺测值：' + Kg['v']['defaultUndef']),
            cP = Kg['v']['defaultUndef']);
          const cM = null !== (cC = cd['threadCount']) && undefined !== cC ? cC : 0x1;
          cd['needVolume'] && cd['point2D'] && (v0['kg']['debug']('当前设置需要返回管线，但是是用了二维点，自动调整为返回三维点'),
            cd['point2D'] = false);
          const cz = cd['needVolume'] ? new iX(Kg['v']['workerPath'] + '/sl.volume.js', cM, 'streamline', {
            'type': 'classic'
          }) : new iX(Kg['v']['workerPath'] + '/sl.js', cM, 'streamline', {
            'type': 'classic'
          })
            , cQ = []
            , cm = []
            , cL = []
            , cR = (H5, H6) => {
              if (!H5)
                return;
              let H7;
              return H7 = 0x0 === H6['length'] ? H5['slice'](0x0) : H6['pop'](),
                H7;
            }
            , H0 = (null === (cO = cd['dataSource']['gridOptions']['zValues']) || undefined === cO ? undefined : cO['length']) || 0x1;
          let H1, H2, H3, H4 = false;
          if (0x1 === H0)
            H1 = cG['raw']['buffer'],
              H2 = cg['raw']['buffer'],
              H3 = undefined;
          else {
            if (cd['zIdx'] >= 0x0)
              H1 = cd['dataSource']['getU'](undefined, cd['zIdx'])['raw']['buffer'],
                H2 = cd['dataSource']['getV'](undefined, cd['zIdx'])['raw']['buffer'],
                H3 = undefined;
            else {
              const H5 = (0x0,
                Kz['cM'])(cG['dataType'], new ArrayBuffer(cG['raw']['byteLength'] * H0))
                , H6 = (0x0,
                  Kz['cM'])(cg['dataType'], new ArrayBuffer(cg['raw']['byteLength'] * H0))
                , H7 = cd['dataSource']['wProvider'] && (0x0,
                  Kz['cM'])(cd['dataSource']['getW']()['dataType'], new ArrayBuffer(cd['dataSource']['getW']()['raw']['byteLength'] * H0));
              let H8 = 0x0;
              for (let H9 = 0x0; H9 < H0; H9++)
                H5['set'](cd['dataSource']['getU'](undefined, H9)['raw'], H8),
                  H6['set'](cd['dataSource']['getV'](undefined, H9)['raw'], H8),
                  null == H7 || H7['set'](cd['dataSource']['getW'](undefined, H9)['raw'], H8),
                  H8 += cG['raw']['length'];
              H1 = H5['buffer'],
                H2 = H6['buffer'],
                H3 = null == H7 ? undefined : H7['buffer'],
                H4 = true;
            }
          }
          return new Promise((Hv, HA) => {
            var Hk, Hl;
            let HK = 0x0
              , Hb = 0x0;
            const Hc = {
              'type': 'FeatureCollection',
              'features': []
            }
              , HH = []
              , Hx = null !== (Hk = cd['lineCount']) && undefined !== Hk ? Hk : 0x3e8
              , Hp = Math['max'](parseInt(Hx / cM) + 0x1, cM);
            let HF = Hx
              , Hy = 0x0;
            const Hw = Object['assign']({}, cd['dataSource']['gridOptions']);
            let Hh;
            H4 || (cd['zIdx'] > 0x0 && (0x0,
              Kz['ri'])(Hw['zValues'][cd['zIdx']]) ? Hw['zValues'] = [Hw['zValues'][cd['zIdx']]] : Hw['zValues'] = [0x0]),
              Hh = cd['seedGenerator'] ? cd['seedGenerator'] : cd['zIdx'] < 0x0 ? () => (0x0,
                Kz['r_'])(cd['dataSource']['gridOptions']) : () => [...(0x0,
                  Kz['r_'])(cd['dataSource']['gridOptions'], false), cd['dataSource']['gridOptions']['zValues'][cd['zIdx']]];
            const Hu = cd['volumeOptions'] || {}
              , HY = {
                'vertices': [],
                'indices': [],
                'st': [],
                'normals': []
              }
              , HT = (HE, Hf) => {
                if (0x1 === HE)
                  return new Uint8Array(Hf);
                if (0x2 === HE)
                  return new Uint16Array(Hf);
                if (0x4 === HE)
                  return new Uint32Array(Hf);
                throw new Error('不能识别的索引单个长度：' + HE);
              }
              , HX = HE => {
                if (0x1 === HY['vertices']['length']) {
                  HE['vertices'] = new Float32Array(HY['vertices'][0x0]);
                  const HC = HY['indices'][0x0]['len'];
                  return HE['indices'] = HT(HC, HY['indices'][0x0]['data']),
                    HE['normals'] = new Float32Array(HY['normals'][0x0]),
                    void (HE['st'] = new Float32Array(HY['st'][0x0]));
                }
                let Hf = 0x0
                  , HW = 0x0
                  , HI = 0x0
                  , Hj = 0x0;
                for (let HO = 0x0; HO < HY['indices']['length']; HO++)
                  Hf += HY['vertices'][HO]['byteLength'] / 0x4,
                    HW += HY['indices'][HO]['data']['byteLength'] / HY['indices'][HO]['len'],
                    HI += HY['normals'][HO]['byteLength'] / 0x4,
                    Hj += HY['st'][HO]['byteLength'] / 0x4;
                const HD = new Float32Array(Hf)
                  , HV = new Float32Array(HI)
                  , HZ = new Float32Array(Hj);
                let HB = 0x0
                  , HS = 0x0
                  , HU = 0x0;
                for (let HG = 0x0; HG < HY['indices']['length']; HG++) {
                  const Hg = new Float32Array(HY['vertices'][HG]);
                  HD['set'](Hg, HB),
                    HB += Hg['length'];
                  const HN = new Float32Array(HY['normals'][HG]);
                  HV['set'](HN, HS),
                    HS += HN['length'];
                  const HP = new Float32Array(HY['st'][HG]);
                  HZ['set'](HP, HU),
                    HU += HP['length'];
                }
                const Hd = Hf / 0x3 > 0xffff ? new Uint32Array(HW) : new Uint16Array(HW);
                let Hq = 0x0
                  , HJ = 0x0;
                for (let HM = 0x0; HM < HY['indices']['length']; HM++) {
                  const Hz = HY['vertices'][HM]['byteLength'] / 0xc
                    , HQ = HT(HY['indices'][HM]['len'], HY['indices'][HM]['data']);
                  Hq > 0x0 ? HQ['forEach'](Hm => {
                    Hd[HJ++] = Hm + Hq;
                  }
                  ) : (Hd['set'](HQ),
                    HJ = HQ['length']),
                    Hq += Hz;
                }
                HE['vertices'] = HD,
                  HE['indices'] = Hd,
                  HE['normals'] = HV,
                  HE['st'] = HZ;
              }
              ;
            for (; !(HF <= 0x0);) {
              let HE = Hp;
              HF < Hp && (HE = HF);
              const Hf = [];
              for (let HI = 0x0; HI < HE; HI++) {
                const Hj = Hh(Hy);
                Hj && (Hf['push'](...Hj),
                  Hy++);
              }
              const HW = {
                'data': Object['assign']({
                  'gridOptions': Hw,
                  'u': cG['raw']['buffer'],
                  'v': cg['raw']['buffer'],
                  'scale': cG['dataScale'],
                  'offset': cG['dataOffset'],
                  'dataType': cG['dataType'],
                  'algo': cG['algo'],
                  'wScale': null == cN ? undefined : cN['dataScale'],
                  'wOffset': null == cN ? undefined : cN['dataOffset'],
                  'wAlgo': null == cN ? undefined : cN['algo'],
                  'wUndef': null == cN ? undefined : cN['undef'],
                  'undef': cP,
                  'step': cd['step'],
                  'backward': cd['backward'],
                  'seeds': Hf,
                  'hReso': cd['hReso'],
                  'vReso': cd['vReso'],
                  'allLoop': cd['allLoop'],
                  'stayLoop': cd['stayLoop'],
                  'lineMinCount': cd['lineMinCount'],
                  'wDataType': cd['dataSource']['wProvider'] && (null === (Hl = cd['dataSource']['wProvider']['getGrid']()) || undefined === Hl ? undefined : Hl['dataType']),
                  'zScale': cd['zScale'],
                  'disableDensityControl': cd['disableDensityControl'],
                  'point2D': cd['point2D']
                }, Hu),
                'beforeExec': () => {
                  HW['data']['u'] = cR(H1, cQ),
                    HW['data']['v'] = cR(H2, cm),
                    HW['transffers'] = [HW['data']['u'], HW['data']['v']],
                    H3 && (HW['data']['w'] = cR(H3, cL),
                      HW['transffers']['push'](HW['data']['w']));
                }
                ,
                'onCompleted': HD => {
                  var HV, HZ;
                  const HB = {
                    'type': 'FeatureCollection',
                    'features': []
                  };
                  if ((null === (HV = HD['streamlines']) || undefined === HV ? undefined : HV['length']) && HD['streamlines']['forEach'](HS => {
                    const HU = {
                      'type': 'Feature',
                      'geometry': {
                        'type': 'LineString',
                        'coordinates': HS
                      },
                      'properties': {}
                    };
                    HB['features']['push'](HU),
                      Hc['features']['push'](HU),
                      HH['push'](HS);
                  }
                  ),
                    cq && cq({
                      'streamlines': HD['streamlines'],
                      'allFC': Hc,
                      'fc': HB
                    }),
                    cQ['push'](HD['u']),
                    cm['push'](HD['v']),
                    HD['w'] && cL['push'](HD['w']),
                    cd['needVolume'] && (null === (HZ = HD['streamlines']) || undefined === HZ ? undefined : HZ['length']) && (HY['indices']['push']({
                      'len': HD['indiceByteLen'],
                      'data': HD['indices']
                    }),
                      HY['normals']['push'](HD['normals']),
                      HY['st']['push'](HD['st']),
                      HY['vertices']['push'](HD['vertices'])),
                    Hb++,
                    Hb === HK) {
                    const HS = {
                      'provider': new GeoJSONFeatureProvider(Hc),
                      'streamlines': HH
                    };
                    cd['needVolume'] && HX(HS),
                      Hv(HS),
                      cz['destroy']();
                  }
                }
              };
              cz['push'](HW),
                HK++,
                HF -= Hp;
            }
          }
          );
        });
      }
    }
    bL['DefaultContourShadedStyle'] = {
      'polyline': {
        'color': 'rgba(255,255,255,0.5)',
        'label': [{
          'text': {
            'data': '$value',
            'backColor': '#edf2ba',
            'backPadding': [0x8, 0x2],
            'backRoundRect': true,
            'backRoundRadius': 0x8,
            'backHeight': 0xc,
            'color': 'black',
            'font': '12px\x20Arial',
            'backShadowColor': 'gray',
            'backShadowOffset': [0x2, 0x2]
          }
        }]
      },
      'polygon': {}
    },
      bL['DefaultColorStopOptions'] = {
        'stops': [{
          'value': -0x64,
          'stop': 'rgba(0,0,255,0.8)'
        }, {
          'value': 0x0,
          'stop': 'rgba(255,255,255,0.8)'
        }, {
          'value': 0x64,
          'stop': 'rgba(255,0,0,0.8)'
        }],
        'field': 'value'
      };
    class MapToolService {
      constructor(cd) {
        this['map'] = cd;
      }
      ['getCurrent'] () {
        return this['currentTool'];
      }
      ['setCurrent'] (cd) {
        var cq, cJ, cC;
        null === (cq = this['currentTool']) || undefined === cq || cq['end'](),
          this['currentTool'] = cd,
          null === (cJ = this['currentTool']) || undefined === cJ || cJ['setMap'](this['map']),
          null === (cC = this['currentTool']) || undefined === cC || cC['begin']();
      }
    }
    class LegendService extends iT['c'] {
      constructor() {
        super(...arguments),
          this['stopRulesMap'] = {};
      }
      ['attach'] (cd, cq, cJ) {
        cJ || (cJ = (0x0,
          iq['it'])(cd)) || v0['kg']['error']('未能根据' + cd + '找到相应资源！'),
          cJ instanceof iR['NB'] || (cJ = new iR['NB'](cJ));
        const cC = {
          'firer': this,
          'msg': {
            'key': cd,
            'sr': cJ
          }
        };
        this['stopRulesMap'][cd] ? this['stopRulesMap'][cd]['changed']['push'](cq) : (this['stopRulesMap'][cd] = {
          'sr': cJ,
          'changed': [cq]
        },
          this['fire'](LegendService['EventTypes']['attachFirst'], cC)),
          this['fire'](LegendService['EventTypes']['attach'], cC);
      }
      ['setOpacity'] (cd, cq, cJ, cC = iR['DY']['outside'], cO = 0x0) {
        const cG = this['stopRulesMap'][cd];
        cG || v0['kg']['warn']('未能找到key为' + cd + '的调色板！'),
          cG['sr']['setOpacityByIndex'](cq, cC, cO, cJ);
        for (const cg of cG['changed'])
          cg();
        this['fire'](LegendService['EventTypes']['changeOpacity'], {
          'firer': this,
          'msg': {
            'key': cd,
            'sr': cG['sr']
          }
        });
      }
      ['detach'] (cd, cq) {
        const cJ = this['stopRulesMap'][cd];
        cJ || v0['kg']['warn']('未能找到key为' + cd + '的调色板！');
        const cC = () => {
          this['fire'](LegendService['EventTypes']['detachLast'], {
            'firer': this,
            'msg': {
              'key': cd,
              'sr': cJ['sr']
            }
          }),
            this['fire'](LegendService['EventTypes']['detach'], {
              'firer': this,
              'msg': {
                'key': cd,
                'sr': cJ['sr']
              }
            }),
            delete cJ['changed'],
            delete cJ['sr'],
            delete this['stopRulesMap'][cd];
        }
          ;
        if (cq) {
          const cO = cJ['changed']['indexOf'](cq);
          cO >= 0x0 && cJ['changed']['splice'](cO, 0x1),
            0x0 === cJ['changed']['length'] ? cC() : this['fire'](LegendService['EventTypes']['detach'], {
              'firer': this,
              'msg': {
                'key': cd,
                'sr': cJ['sr']
              }
            });
        } else
          cC();
      }
    }
    LegendService['EventTypes'] = {
      'attach': 'attach',
      'attachFirst': 'attach:first',
      'detachLast': 'detach:last',
      'detach': 'detach',
      'changeOpacity': 'change:opacity'
    };
    var e1 = n(0x11d);
    class DODSUnpacker {
      constructor(cd, cq) {
        this['options'] = (0x0,
          Kz['Ov'])({}, cq, DODSUnpacker['DefaultOptions']),
          this['_buf'] = cd,
          this['_pos'] = 0x0;
      }
      ['unpack'] () {
        const cd = performance['now']();
        for (var cq = this['_view'] = new DataView(this['_buf']), cJ = 0x0, cC = ''; cJ < cq['byteLength'] && -0x1 === (cC += String['fromCharCode'](cq['getUint8'](cJ)))['indexOf']('\x0aData:\x0a');)
          cJ += 0x1;
        cC = cC['substr'](0x0, cC['length'] - 0x7),
          this['_pos'] = cJ + 0x1;
        const cO = this['dapvar'] = new e1['cF'](cC)['parse']()
          , cG = this['getValue']();
        return v0['kg']['debug']('unpack\x20dods\x20costs\x20' + (performance['now']() - cd) + 'ms'),
        {
          'dds': cO,
          'dods': cG
        };
      }
      ['getValue'] () {
        var cd = this['dapvar']['type']['toLowerCase']();
        let cq;
        return cq = 'structure' === cd || 'dataset' === cd ? this['_parse_structure']() : 'grid' === cd ? this['_parse_grid']() : 'sequence' === cd ? this['_parse_sequence']() : 'Z\x00\x00\x00' === this['_buf']['slice'](this['_pos'], this['_pos'] + 0x4) ? this['_parse_base_type_sequence']() : this['_parse_base_type'](cd),
          cq;
      }
      ['_parse_structure'] () {
        var cd, cq = {}, cJ = this['dapvar'];
        for (var cC in cJ)
          cJ[cC]['type'] && (this['dapvar'] = cJ[cC],
            cd = this['getValue'](),
            cq[cC] = cd);
        return this['dapvar'] = cJ,
          cq;
      }
      ['_parse_grid'] () {
        var cd, cq = [], cJ = this['dapvar'];
        for (var cC in (this['dapvar'] = cJ['array'],
          cd = this['getValue'](),
          cq['push'](cd),
          cJ['maps']))
          cJ['maps'][cC]['type'] && (this['dapvar'] = cJ['maps'][cC],
            cd = this['getValue'](),
            cq['push'](cd));
        return this['dapvar'] = cJ,
          cq;
      }
      ['_parse_sequence'] () {
        for (var cd, cq = [], cJ = this['_unpack_uint32'](), cC = this['dapvar']; 0xa5000000 !== cJ;) {
          var cO = [];
          for (var cG in cC)
            cC[cG]['type'] && (this['dapvar'] = cC[cG],
              cd = this['getValue'](),
              cO['push'](cd));
          cq['push'](cO),
            cJ = this['_unpack_uint32']();
        }
        return this['dapvar'] = cC,
          cq;
      }
      ['_parse_base_type_sequence'] () {
        for (var cd, cq = [], cJ = this['_unpack_uint32'](); 0xa5000000 !== cJ;)
          cd = this['getValue'](),
            cq['push'](cd),
            cJ = this['_unpack_uint32']();
        return cq;
      }
      ['_parse_base_type'] (cd) {
        var cq = []
          , cJ = 0x1;
        if (this['dapvar']['shape']['length'] && (cJ = this['_unpack_uint32'](),
          'url' !== cd && 'string' !== cd && this['_unpack_uint32']()),
          'byte' === cd)
          cq = this['_unpack_bytes'](cJ);
        else {
          if ('url' === cd || 'string' === cd)
            cq = this['_unpack_string'](cJ);
          else {
            var cC;
            switch (cq = [],
            cd) {
              case 'float64':
                cC = '_unpack_float64',
                  cq = new Float64Array(cJ);
                break;
              case 'float32':
                cC = '_unpack_float32',
                  cq = new Float32Array(cJ);
                break;
              case 'int':
              case 'int32':
                cC = '_unpack_int32',
                  cq = new Int32Array(cJ);
                break;
              case 'uint':
              case 'uint32':
                cC = '_unpack_uint32',
                  cq = new Uint32Array(cJ);
                break;
              case 'int16':
                cC = '_unpack_int32',
                  cq = new Int16Array(cJ);
                break;
              case 'uint16':
                cC = '_unpack_uint32',
                  cq = new Uint16Array(cJ);
                break;
              case 'int8':
                cC = '_unpack_int32',
                  cq = new Int8Array(cJ);
                break;
              case 'uint8':
                cC = '_unpack_uint32',
                  cq = new Uint8Array(cJ);
            }
            for (var cO = 0x0; cO < cJ; cO++)
              cq[cO] = this[cC]();
          }
        }
        return this['dapvar']['shape'] ? this['options']['reshape'] && (cq = this['reshape'](cq, this['dapvar']['shape'])) : cq = cq[0x0],
          cq;
      }
      ['_unpack_byte'] () {
        var cd = this['_pos'];
        return this['_pos'] += 0x1,
          this['_view']['getUint8'](cd);
      }
      ['_unpack_uint32'] () {
        var cd = this['_pos'];
        return this['_pos'] += 0x4,
          this['_view']['getUint32'](cd);
      }
      ['_unpack_int32'] () {
        var cd = this['_pos'];
        return this['_pos'] += 0x4,
          this['_view']['getInt32'](cd);
      }
      ['_unpack_float32'] () {
        var cd = this['_pos'];
        return this['_pos'] += 0x4,
          this['_view']['getFloat32'](cd);
      }
      ['_unpack_float64'] () {
        var cd = this['_pos'];
        return this['_pos'] += 0x8,
          this['_view']['getFloat64'](cd);
      }
      ['_unpack_bytes'] (cd) {
        for (var cq = (0x4 - cd % 0x4) % 0x4, cJ = [], cC = 0x0; cC < cd; cC++)
          cJ['push'](this['_unpack_byte']());
        return this['_pos'] += cq,
          cJ;
      }
      ['_unpack_string'] (cd) {
        for (var cq = [], cJ = 0x0; cJ < cd; cJ++) {
          for (var cC = this['_unpack_uint32'](), cO = (0x4 - cC % 0x4) % 0x4, cG = '', cg = 0x0; cg < cC; cg++)
            cG += String['fromCharCode'](this['_unpack_byte']());
          cq['push'](cG),
            this['_pos'] += cO;
        }
        return cq;
      }
      ['reshape'] (cd, cq) {
        if (!cq['length'])
          return cd[0x0];
        if (0x1 === cq['length'])
          return cd['slice'](0x0, cq[0x0]);
        for (var cJ, cC, cO, cG = [], cg = 0x0; cg < cq[0x0]; cg++)
          cO = (cC = cg * (cJ = cd['length'] / cq[0x0])) + cJ,
            cG['push'](this['reshape'](cd['slice'](cC, cO), cq['slice'](0x1)));
        return cG;
      }
    }
    DODSUnpacker['DefaultOptions'] = {
      'reshape': false
    };
    var e3 = function (cd, cq, cJ, cC) {
      return new (cJ || (cJ = Promise))(function (cO, cG) {
        function cg (cM) {
          try {
            cP(cC['next'](cM));
          } catch (cz) {
            cG(cz);
          }
        }
        function cN (cM) {
          try {
            cP(cC['throw'](cM));
          } catch (cz) {
            cG(cz);
          }
        }
        function cP (cM) {
          var cz;
          cM['done'] ? cO(cM['value']) : (cz = cM['value'],
            cz instanceof cJ ? cz : new cJ(function (cQ) {
              cQ(cz);
            }
            ))['then'](cg, cN);
        }
        cP((cC = cC['apply'](cd, cq || []))['next']());
      }
      );
    };
    class DAPService extends iT['c'] {
      constructor(cd, cq = [], cJ = false) {
        super(),
          this['baseUrl'] = cd,
          this['varList'] = cq,
          this['_loading'] = false,
          cJ && this['loadDataInfo']();
      }
      ['getGridDataType'] (cd) {
        switch (cd['toLowerCase']()) {
          case 'float64':
            return {
              'type': KP['U']['Float64'],
              'len': 0x8
            };
          case 'float32':
            return {
              'type': KP['U']['Float32'],
              'len': 0x4
            };
          case 'int':
          case 'int32':
            return {
              'type': KP['U']['Int32'],
              'len': 0x4
            };
          case 'uint':
          case 'uint32':
            return {
              'type': KP['U']['UInt32'],
              'len': 0x4
            };
          case 'int16':
            return {
              'type': KP['U']['Int16'],
              'len': 0x2
            };
          case 'uint16':
            return {
              'type': KP['U']['UInt16'],
              'len': 0x2
            };
          case 'int8':
          case 'byte':
            return {
              'type': KP['U']['Int8'],
              'len': 0x1
            };
          case 'uint8':
            return {
              'type': KP['U']['UInt8'],
              'len': 0x1
            };
        }
      }
      ['_parseGridOptions'] (cd, cq) {
        var cJ, cC, cO;
        let cG = cd['shape'] || (null === (cJ = cd['array']) || undefined === cJ ? undefined : cJ['shape'])
          , cg = 0x3
          , cN = 0x2
          , cP = 0x1
          , cM = 0x0;
        if (0x4 === cG['length'])
          ;
        else {
          if (0x3 === cG['length'])
            0x0 === (null === (cO = null === (cC = cd['array']) || undefined === cC ? undefined : cC['dimensions']) || undefined === cO ? undefined : cO['indexOf']('level')) ? (cg = 0x2,
              cN = 0x1,
              cP = 0x0,
              cM = -0x1) : (cg = 0x2,
                cN = 0x1,
                cP = -0x1,
                cM = 0x0);
          else {
            if (0x2 !== cG['length'])
              return v0['kg']['debug']('unsupported\x20shape:' + cG),
                void v0['kg']['debug'](cd);
            cg = 0x1,
              cN = 0x0,
              cP = -0x1,
              cM = -0x1;
          }
        }
        const cz = cq[cg + 0x1]
          , cQ = cq[cN + 0x1]
          , cm = {
            'xStart': cz[0x0],
            'xDelta': cz['length'] > 0x1 ? cz[0x1] - cz[0x0] : 0x0,
            'xSize': cG[cg],
            'yStart': cQ[0x0],
            'yDelta': cQ['length'] > 0x1 ? cQ[0x1] - cQ[0x0] : 0x0,
            'ySize': cG[cN],
            'zValues': cP < 0x0 ? [0x0] : cq[cP + 0x1],
            'tCount': cM < 0x0 ? 0x1 : cG[cM],
            'tValues': cM < 0x0 ? [0x0] : cq[cM + 0x1]
          };
        return (0x0,
          KM['T'])(cm),
          cm;
      }
      get ['dataInfo'] () {
        return this['_dataInfo'] || v0['kg']['warn']('请先调用dapService的loadDataInfo后再获取！'),
          this['_dataInfo'];
      }
      ['loadDataInfo'] (cd = false, cq = true) {
        var cJ;
        if (this['_dataInfo'] && !cd)
          return Promise['resolve'](this['_dataInfo']);
        if (this['_loading'])
          return cq ? new Promise((cO, cG) => {
            this['once']('info:loaded', cg => {
              cO(cg['msg']);
            }
            );
          }
          ) : Promise['resolve'](undefined);
        let cC = '.dds';
        return (null === (cJ = this['varList']) || undefined === cJ ? undefined : cJ['length']) && (cC += '?',
          this['varList']['forEach'](cO => {
            cC += cO + ',';
          }
          ),
          cC = cC['slice'](0x0, cC['length'] - 0x1)),
          qeFetch(this['baseUrl'] + cC)['then'](cO => cO['text']()['then'](cG => {
            const cg = new e1['cF'](cG)['parse']();
            return qeFetch(this['baseUrl'] + '.das')['then'](cN => cN['text']()['then'](cP => {
              const cM = new e1['Bn'](cP, cg)['parse']();
              return this['_dataInfo'] = cM,
                this['fire']('info:loaded', {
                  'firer': this,
                  'msg': cM
                }),
                cM;
            }
            )['catch'](v0['kg']['debug']))['catch'](v0['kg']['debug']);
          }
          )['catch'](v0['kg']['debug']))['catch'](v0['kg']['debug']);
      }
      ['loadDataByRawFilter'] (cd) {
        return qeFetch(this['baseUrl'] + ('.dods?' + encodeURI(cd)))['then'](cq => cq['arrayBuffer']()['then'](cJ => new DODSUnpacker(cJ)['unpack']())['catch'](v0['kg']['debug']))['catch'](v0['kg']['debug']);
      }
      ['loadDataByFullFilter'] (cd) {
        return e3(this, undefined, undefined, function* () {
          const cq = () => e3(this, undefined, undefined, function* () {
            var cJ, cC, cO;
            const cG = this['dataInfo'][cd['varName']];
            let cg = cG['shape'] || (null === (cJ = cG['array']) || undefined === cJ ? undefined : cJ['shape'])
              , cN = cd['zFilter']
              , cP = cd['tFilter']
              , cM = cd['yFilter']
              , cz = cd['xFilter'];
            if (0x4 === cg['length'])
              cP = cP || '[0:1:' + (cg[0x0] - 0x1) + ']',
                cN = cN || '[0:1:' + (cg[0x1] - 0x1) + ']';
            else {
              if (0x3 === cg['length'])
                0x0 === (null === (cO = null === (cC = cG['array']) || undefined === cC ? undefined : cC['dimensions']) || undefined === cO ? undefined : cO['indexOf']('level')) ? (cg = [0x1, cg[0x0], cg[0x1], cg[0x2]],
                  cP = '',
                  cN = cN || '[0:1:' + (cg[0x1] - 0x1) + ']') : (cg = [cg[0x0], 0x1, cg[0x1], cg[0x2]],
                    cP = cP || '[0:1:' + (cg[0x0] - 0x1) + ']',
                    cN = '');
              else {
                if (0x2 !== cg['length'])
                  return v0['kg']['debug']('unsupported\x20shape:' + cg),
                    void v0['kg']['debug'](cG);
                cP = '',
                  cN = '',
                  cg = [0x1, 0x1, cg[0x0], cg[0x1]];
              }
            }
            cM = cM || '[0:1:' + (cg[0x2] - 0x1) + ']',
              cz = cz || '[0:1:' + (cg[0x3] - 0x1) + ']';
            const cQ = '' + cd['varName'] + cP + cN + cM + cz
              , cm = yield this['loadDataByRawFilter'](cQ)
              , cL = cm['dods'][cd['varName']];
            return Object['assign'](Object['assign']({}, cm), {
              'data': cL[0x0]
            });
          });
          return this['_dataInfo'] ? cq() : this['loadDataInfo'](false, true)['then'](cJ => cq())['catch'](v0['kg']['debug']);
        });
      }
      ['getFullGridOptions'] (cd, cq = false) {
        return e3(this, undefined, undefined, function* () {
          this['dataInfo'] || (yield this['loadDataInfo']());
          const cJ = {
            'varName': cd,
            'xFilter': '[0:1:1]',
            'yFilter': '[0:1:1]',
            'tFilter': '[0]'
          };
          cq && delete cJ['tFilter'];
          const cC = yield this['loadDataByFullFilter'](cJ)
            , cO = this['dataInfo'][cd]
            , cG = cC['dods'][cd];
          return this['_parseGridOptions'](cO, cG);
        });
      }
      ['dapResultToProvider'] (cd, cq) {
        var cJ;
        const cC = cd['dds'][cq]
          , cO = cd['dods'][cq]
          , cG = this['_parseGridOptions'](cC, cO)
          , cg = this['getGridDataType'](cC['array']['type']);
        let cN = null === (cJ = cC['attributes']) || undefined === cJ ? undefined : cJ['missing_value'];
        (!(0x0,
          Kz['ri'])(cN) || cN > 0xf423f) && (cN = 0xf423f);
        const cP = [];
        let cM = cO[0x0]['buffer'];
        if (!cM && cO[0x0] instanceof Array) {
          let cL;
          switch (v0['kg']['debug']('dap获取的数据不是TypedArray！'),
          cg['type']) {
            case KP['U']['UInt8']:
              cL = new Uint8Array(cO[0x0]);
              break;
            case KP['U']['Int8']:
              cL = new Int8Array(cO[0x0]);
              break;
            case KP['U']['UInt16']:
              cL = new Uint16Array(cO[0x0]);
              break;
            case KP['U']['Int16']:
              cL = new Int16Array(cO[0x0]);
              break;
            case KP['U']['UInt32']:
              cL = new Uint32Array(cO[0x0]);
              break;
            case KP['U']['Int32']:
              cL = new Int32Array(cO[0x0]);
              break;
            case KP['U']['Float32']:
              cL = new Float32Array(cO[0x0]);
              break;
            case KP['U']['Float64']:
              cL = new Float64Array(cO[0x0]);
              break;
            default:
              throw new Error('not\x20supported\x20grid\x20data\x20type\x20' + cg);
          }
          cM = cL['buffer'];
        }
        let cz = 0x0
          , cQ = cG['ySize'] * cG['xSize'] * cg['len'];
        for (let cR = 0x0; cR < cG['tCount']; cR++) {
          const H0 = [];
          for (let H1 = 0x0; H1 < cG['zValues']['length']; H1++) {
            const H2 = cz + cQ
              , H3 = new KN['P'](cg['type'], cG['xSize'], cG['ySize'], cM['slice'](cz, H2), cN);
            H0['push'](H3),
              cz = H2;
          }
          cP['push'](H0);
        }
        const cm = new iu['o'](cP, {
          'gridOptions': cG
        });
        return {
          'dds': cd['dds'],
          'dods': cd['dods'],
          'gridOptions': cG,
          'provider': cm
        };
      }
      ['loadData'] (cd) {
        const cq = (cC, cO) => {
          if ((0x0,
            Kz['ri'])(cC))
            return (0x0,
              Kz['ri'])(cO) ? '[' + cC + ':' + cO + ']' : '[' + cC + ']';
        }
          , cJ = () => {
            var cC, cO, cG, cg, cN, cP, cM;
            const cz = this['dataInfo'][cd['varName']];
            let cQ = cz['shape'] || (null === (cC = cz['array']) || undefined === cC ? undefined : cC['shape'])
              , cm = ''
              , cL = '';
            if (0x4 === cQ['length'])
              cm = '[' + (null !== (cO = cd['zIdx']) && undefined !== cO ? cO : 0x0) + ']',
                cL = '[' + (null !== (cG = cd['tIdx']) && undefined !== cG ? cG : 0x0) + ']';
            else {
              if (0x3 === cQ['length'])
                0x0 === (null === (cN = null === (cg = cz['array']) || undefined === cg ? undefined : cg['dimensions']) || undefined === cN ? undefined : cN['indexOf']('level')) ? (cQ = [0x1, cQ[0x0], cQ[0x1], cQ[0x2]],
                  cm = '[' + (null !== (cP = cd['zIdx']) && undefined !== cP ? cP : 0x0) + ']') : (cQ = [cQ[0x0], 0x1, cQ[0x1], cQ[0x2]],
                    cL = '[' + (null !== (cM = cd['tIdx']) && undefined !== cM ? cM : 0x0) + ']');
              else {
                if (0x2 !== cQ['length'])
                  return v0['kg']['debug']('unsupported\x20shape:' + cQ),
                    void v0['kg']['debug'](cz);
                cQ = [0x1, 0x1, cQ[0x0], cQ[0x1]];
              }
            }
            const cR = cQ[0x2]
              , H0 = cq(cd['yStartIdx'], cd['yEndIdx']) || '[0:' + (cR - 0x1) + ']'
              , H1 = cQ[0x3]
              , H2 = cq(cd['xStartIdx'], cd['xEndIdx']) || '[0:' + (H1 - 0x1) + ']'
              , H3 = '' + cd['varName'] + cL + cm + H0 + H2;
            return this['loadDataByRawFilter'](H3)['then'](H4 => this['dapResultToProvider'](H4, cd['varName']))['catch'](v0['kg']['debug']);
          }
          ;
        return this['_dataInfo'] ? cJ() : this['loadDataInfo'](false, true)['then'](cC => cJ())['catch'](v0['kg']['debug']);
      }
    }
    var e5 = n(0x32b);
    const e6 = function (cd, cq, cJ) {
      undefined === cJ && (cJ = {});
      var cC = (0x0,
        e5['c9'])(cd)
        , cO = (0x0,
          e5['c9'])(cq)
        , cG = (0x0,
          bF['Ht'])(cO[0x1] - cC[0x1])
        , cg = (0x0,
          bF['Ht'])(cO[0x0] - cC[0x0])
        , cN = (0x0,
          bF['Ht'])(cC[0x1])
        , cP = (0x0,
          bF['Ht'])(cO[0x1])
        , cM = Math['pow'](Math['sin'](cG / 0x2), 0x2) + Math['pow'](Math['sin'](cg / 0x2), 0x2) * Math['cos'](cN) * Math['cos'](cP);
      return (0x0,
        bF['DL'])(0x2 * Math['atan2'](Math['sqrt'](cM), Math['sqrt'](0x1 - cM)), cJ['units']);
    };
    function e7 (cd, cq, cJ) {
      if (undefined === cJ && (cJ = {}),
        true === cJ['final'])
        return function (cQ, cm) {
          var cL = e7(cm, cQ);
          return (cL + 0xb4) % 0x168;
        }(cd, cq);
      var cC = (0x0,
        e5['c9'])(cd)
        , cO = (0x0,
          e5['c9'])(cq)
        , cG = (0x0,
          bF['Ht'])(cC[0x0])
        , cg = (0x0,
          bF['Ht'])(cO[0x0])
        , cN = (0x0,
          bF['Ht'])(cC[0x1])
        , cP = (0x0,
          bF['Ht'])(cO[0x1])
        , cM = Math['sin'](cg - cG) * Math['cos'](cP)
        , cz = Math['cos'](cN) * Math['sin'](cP) - Math['sin'](cN) * Math['cos'](cP) * Math['cos'](cg - cG);
      return (0x0,
        bF['vi'])(Math['atan2'](cM, cz));
    }
    var e8 = n(0xcc);
    function e9 (cd, cq, cJ) {
      undefined === cJ && (cJ = {});
      for (var cC = (0x0,
        e5['wA'])(cd)['coordinates'], cO = 0x0, cG = 0x0; cG < cC['length'] && !(cq >= cO && cG === cC['length'] - 0x1); cG++) {
        if (cO >= cq) {
          var cg = cq - cO;
          if (cg) {
            var cN = e7(cC[cG], cC[cG - 0x1]) - 0xb4;
            return (0x0,
              e8['Z'])(cC[cG], cg, cN, cJ);
          }
          return (0x0,
            bF['xm'])(cC[cG]);
        }
        cO += e6(cC[cG], cC[cG + 0x1], cJ);
      }
      return (0x0,
        bF['xm'])(cC[cC['length'] - 0x1]);
    }
    class FrameDrawService {
      constructor(cd) {
        'h' === (null == cd ? undefined : cd['defaultMode']) ? this['_defaultDrawOptions'] = FrameDrawService['HDefaultOptions'] : this['_defaultDrawOptions'] = FrameDrawService['VDefaultOptions'];
      }
      ['setDrawOptions'] (cd, cq = true) {
        if (cd)
          return this['_drawOptions'] && cq ? this['_drawOptions'] = (0x0,
            Kz['uw'])({}, cd, this['_drawOptions']) : this['_drawOptions'] = (0x0,
              Kz['uw'])({}, cd, this['_defaultDrawOptions']),
            this;
        this['_drawOptions'] = (0x0,
          Kz['f8'])(this['_defaultDrawOptions']);
      }
      ['update'] (cd) {
        var cq;
        const { content: cJ, x: cC, y: cO, mainTitle: cG, subTitle: cg, vTitle: cN, hTitle: cP, vSubTitle: cM, hSubTitle: cz } = cd
          , cQ = null !== (cq = this['_drawOptions']) && undefined !== cq ? cq : this['_defaultDrawOptions']
          , cm = cQ['content']['ltOffset']
          , cL = cQ['content']['rbOffset']
          , cR = [cJ['width'], cJ['height']]
          , H0 = [cR[0x0] + cm[0x0] + cL[0x0], cR[0x1] + cm[0x1] + cL[0x1]]
          , H1 = document['createElement']('canvas');
        H1['width'] = H0[0x0],
          H1['height'] = H0[0x1];
        const H2 = H1['getContext']('2d');
        H2['save'](),
          H2['fillStyle'] = cQ['background'],
          H2['fillRect'](0x0, 0x0, H0[0x0], H0[0x1]),
          H2['restore'](),
          H2['drawImage'](cJ, 0x0, 0x0, cR[0x0], cR[0x1], cm[0x0], cm[0x1], cR[0x0], cR[0x1]),
          this['_drawBorder'](H2, cQ['border'], cm, cR);
        let H3 = [cm[0x0] + cR[0x0] / 0x2, Math['floor'](cm[0x1] / 2.5)];
        const H4 = cQ['title'];
        'start' === H4['position'] ? H3 = [...cm] : 'end' === H4['position'] && (H3 = [cm[0x0] + cR[0x0], cm[0x1] + cR[0x1]]),
          this['_drawText'](H2, H4['main'], H3, cG, 0x0),
          this['_drawText'](H2, H4['sub'], H3, cg, 0x1);
        const H5 = [];
        cC['forEach'](HH => {
          H5['push'](cm[0x0] + HH['percent'] * cR[0x0]);
        }
        );
        const H6 = [];
        cO['forEach'](HH => {
          H6['push'](cm[0x1] + cR[0x1] * (0x1 - HH['percent']));
        }
        );
        const H7 = cQ['gridLines']
          , H8 = cQ['axis']['tick'];
        let H9 = cm[0x1] + cR[0x1];
        H5['forEach']((HH, Hx) => {
          let Hp;
          Math['abs'](HH - cm[0x0]) > 0x2 && Math['abs'](HH - (cm[0x0] + cR[0x0])) > 0x2 && this['_drawLine'](H2, H7['major'], [HH, H9], [HH, cm[0x1]]),
            Hp = 'out' === H8['position'] ? [HH, H9 + H8['length']] : 'cross' === H8['position'] ? [HH, H9 + H8['length'] / 0x2] : [HH, H9];
          const HF = [HH, Hp[0x1] - H8['length']];
          this['_drawLine'](H2, H8['line'], Hp, HF);
          const Hy = [HH, Hp[0x1] + 0x3];
          this['_drawText'](H2, cQ['axis']['label']['bottom']['text'], Hy, cC[Hx]['label'], Hx),
            this['_drawText'](H2, cQ['axis']['label']['bottom']['text2'], Hy, cC[Hx]['label2'], Hx);
        }
        ),
          H6['forEach']((HH, Hx) => {
            Math['abs'](HH - cm[0x1]) > 0x2 && Math['abs'](HH - (cm[0x1] + cR[0x1])) > 0x2 && this['_drawLine'](H2, H7['major'], [cm[0x0], HH], [cm[0x0] + cR[0x0], HH]);
            let Hp = [];
            Hp = 'out' === H8['position'] ? [cm[0x0] - H8['length'], HH] : 'cross' === H8['position'] ? [cm[0x0] - H8['length'] / 0x2, HH] : [cm[0x0], HH];
            const HF = [Hp[0x0] + H8['length'], HH];
            this['_drawLine'](H2, H8['line'], Hp, HF);
            const Hy = [Hp[0x0] - 0x3, HH];
            this['_drawText'](H2, cQ['axis']['label']['left']['text'], Hy, cO[Hx]['label'], Hx),
              this['_drawText'](H2, cQ['axis']['label']['left']['text2'], Hy, cO[Hx]['label2'], Hx);
          }
          );
        const Hv = [cm[0x0] + cR[0x0] / 0x2, H9]
          , HA = cQ['axis']['label']['bottom']['title'];
        'start' === HA['position'] ? Hv[0x0] = cm[0x0] : 'end' === HA['position'] && (Hv[0x0] = cm[0x0] + cR[0x0]),
          this['_drawText'](H2, HA['main'], Hv, cP, 0x0),
          this['_drawText'](H2, HA['sub'], Hv, cz, 0x1);
        const Hk = [cm[0x0], cm[0x1] + cR[0x1] / 0x2]
          , Hl = cQ['axis']['label']['left']['title'];
        'start' === Hl['position'] ? Hk[0x1] = cm[0x1] : 'end' === Hl['position'] && (Hk[0x1] = H9),
          this['_drawText'](H2, Hl['main'], Hk, cN, 0x0),
          this['_drawText'](H2, Hl['sub'], Hk, cM, 0x1);
        const HK = []
          , Hb = [];
        if (cQ['axis']['tick']['minorCount'] > 0x0) {
          const HH = (Hx, Hp) => {
            for (let HF = 0x0; HF < Hx['length'] - 0x1; HF++) {
              const Hy = Hx[HF]
                , Hw = (Hx[HF + 0x1] - Hy) / (cQ['axis']['tick']['minorCount'] + 0x1);
              for (let Hh = 0x1; Hh <= cQ['axis']['tick']['minorCount']; Hh++)
                Hp['push'](Hy + Hw * Hh);
            }
          }
            ;
          HH(H5, HK),
            HH(H6, Hb),
            HK['forEach'](Hx => {
              let Hp;
              this['_drawLine'](H2, H7['minor'], [Hx, cm[0x1] + cR[0x1]], [Hx, cm[0x1]]),
                Hp = 'out' === H8['position'] ? [Hx, cm[0x1] + cR[0x1] + H8['length'] / 0x2] : 'cross' === H8['position'] ? [Hx, cm[0x1] + cR[0x1] + H8['length'] / 0x2 / 0x2] : [Hx, cm[0x1] + cR[0x1]];
              const HF = [Hx, Hp[0x1] - H8['length'] / 0x2];
              this['_drawLine'](H2, H8['line'], Hp, HF);
            }
            ),
            Hb['forEach'](Hx => {
              this['_drawLine'](H2, H7['minor'], [cm[0x0], Hx], [cm[0x0] + cR[0x0], Hx]);
              let Hp = [];
              Hp = 'out' === H8['position'] ? [cm[0x0] - H8['length'] / 0x2, Hx] : 'cross' === H8['position'] ? [cm[0x0] - H8['length'] / 0x2 / 0x2, Hx] : [cm[0x0], Hx];
              const HF = [Hp[0x0] + H8['length'] / 0x2, Hx];
              this['_drawLine'](H2, H8['line'], Hp, HF);
            }
            );
        }
        let Hc = [];
        return Hc = 'h' === cQ['legend']['mode'] ? [cm[0x0] + (cR[0x0] - cQ['legend']['width']) / 0x2 + cQ['legend']['offset'][0x0], cm[0x1] + cR[0x1] + cQ['legend']['offset'][0x1]] : [cm[0x0] + cR[0x0] + cQ['legend']['offset'][0x0], cm[0x1] + (cR[0x1] - cQ['legend']['height']) / 0x2 + cQ['legend']['offset'][0x1]],
          this['_drawLegend'](H2, cQ['legend'], Hc),
          H1;
      }
      ['_drawLegend'] (cd, cq, cJ) {
        var cC;
        if (!cq['visible'])
          return;
        let cO = cq['color'];
        if ('string' == typeof cO && (cO = (0x0,
          iq['it'])(cq['color'])),
          cO['width']) {
          const cN = cq['color'];
          return void cd['drawImage'](cN, 0x0, 0x0, cN['width'], cN['height'], cJ[0x0], cJ[0x1], cq['width'], cq['height']);
        }
        if (!cO['stops'])
          return void v0['kg']['error']('色标配置不正确，无法绘制色标！', false);
        cO instanceof iR['NB'] || (cO = new iR['NB'](cO));
        let cG = [...cO['stops']];
        (null === (cC = cG[cG['length'] - 0x1]['stop']) || undefined === cC ? undefined : cC['alpha']()) < 0.01 && cG['pop']();
        const cg = Math['max'](0x0, cq['skip']) + 0x1;
        cG['length'] > cq['height'] ? v0['kg']['warn']('颜色数量大于图例高度，无法绘制图例！') : 'h' === cq['mode'] ? this['_drawHLegend'](cd, cq, cJ, cG, cg) : this['_drawVLegend'](cd, cq, cJ, cG, cg);
      }
      ['_drawVLegend'] (cd, cq, cJ, cC, cO) {
        const cG = 0x1 * cq['height'] / cC['length'];
        cd['save']();
        let cg = cq['reverse'] ? cJ[0x1] + cq['height'] - cG : cJ[0x1];
        for (let cP = 0x0; cP < cC['length']; cP++) {
          const cM = cC[cP]['stop'];
          if (!(cM instanceof id['t']))
            return v0['kg']['error']('颜色实例不正确，无法绘制色标！', false),
              void cd['restore']();
          cd['fillStyle'] = cM['rgbaString'](),
            cd['fillRect'](cJ[0x0], cg, cq['width'], cG),
            cq['reverse'] ? cg -= cG : cg += cG;
        }
        cd['restore'](),
          this['_drawBorder'](cd, cq['border'], cJ, [cq['width'], cq['height']]);
        const cN = [cJ[0x0] + cq['width'], cJ[0x1] + cq['height']];
        for (let cz = 0x0; cz < cC['length'] - 0x1; cz += cO) {
          cg = cq['reverse'] ? cJ[0x1] + cq['height'] - (cz + 0x1) * cG : cJ[0x1] + (cz + 0x1) * cG;
          const cQ = [cN[0x0], cg]
            , cm = [cN[0x0] + cq['tick']['length'], cg];
          this['_drawLine'](cd, cq['tick']['style'], cQ, cm),
            this['_drawText'](cd, cq['label'], cm, cC[cz]['value']['toString'](), cz);
        }
      }
      ['_drawHLegend'] (cd, cq, cJ, cC, cO) {
        const cG = 0x1 * cq['width'] / cC['length'];
        cd['save']();
        let cg = cq['reverse'] ? cJ[0x0] + cq['width'] - cG : cJ[0x0];
        for (let cP = 0x0; cP < cC['length']; cP++) {
          const cM = cC[cP]['stop'];
          if (!(cM instanceof id['t']))
            return v0['kg']['error']('颜色实例不正确，无法绘制色标！', false),
              void cd['restore']();
          cd['fillStyle'] = cM['rgbaString'](),
            cd['fillRect'](cg, cJ[0x1], cG, cq['height']),
            cq['reverse'] ? cg -= cG : cg += cG;
        }
        cd['restore'](),
          this['_drawBorder'](cd, cq['border'], cJ, [cq['width'], cq['height']]);
        const cN = [cJ[0x0] + cq['width'], cJ[0x1] + cq['height']];
        for (let cz = 0x0; cz < cC['length'] - 0x1; cz += cO) {
          cg = cq['reverse'] ? cJ[0x0] + cq['width'] - (cz + 0x1) * cG : cJ[0x0] + (cz + 0x1) * cG;
          const cQ = [cg, cN[0x1]]
            , cm = [cg, cN[0x1] + cq['tick']['length']];
          this['_drawLine'](cd, cq['tick']['style'], cQ, cm),
            this['_drawText'](cd, cq['label'], cm, cC[cz]['value']['toString'](), cz);
        }
      }
      ['_drawText'] (cd, cq, cJ, cC, cO) {
        if (!(0x0,
          Kz['ri'])(cq) || !(null == cC ? undefined : cC['length']) || !cq['visible'])
          return false;
        if (cd['save'](),
          cd['font'] = cq['font'],
          cd['fillStyle'] = cq['color'],
          cd['textAlign'] = cq['textAlign'],
          cd['textBaseline'] = cq['textBase'],
          cq['formater'] && (cC = cq['formater'](cO, cC)),
          cq['offset'] && (cJ = [cJ[0x0] + cq['offset'][0x0], cJ[0x1] + cq['offset'][0x1]]),
          'number' == typeof cq['angle']) {
          const cG = cq['angle'] * Math['PI'] / 0xb4;
          cd['translate'](cJ[0x0], cJ[0x1]),
            cd['rotate'](cG),
            cd['translate'](-cJ[0x0], -cJ[0x1]);
        }
        return cd['fillText'](cC, cJ[0x0], cJ[0x1]),
          cd['restore'](),
          true;
      }
      ['_drawBorder'] (cd, cq, cJ, cC) {
        cq['visible'] && (cd['save'](),
          cd['strokeStyle'] = cq['color'],
          cd['lineWidth'] = cq['width'],
          cq['dashArray'] && cd['setLineDash'](cq['dashArray']),
          cq['width'] > 0x1 ? cd['strokeRect'](Math['floor'](cJ[0x0]), Math['floor'](cJ[0x1]), cC[0x0], cC[0x1]) : cd['strokeRect'](Math['floor'](cJ[0x0]) + 0.5, Math['floor'](cJ[0x1]) + 0.5, cC[0x0], cC[0x1]),
          cd['restore']());
      }
      ['_drawLine'] (cd, cq, cJ, cC) {
        cq['visible'] && (cd['save'](),
          cd['strokeStyle'] = cq['color'],
          cd['lineWidth'] = cq['width'],
          cq['dashArray'] && cd['setLineDash'](cq['dashArray']),
          cd['beginPath'](),
          cq['width'] > 0x1 ? (cd['moveTo'](Math['floor'](cJ[0x0]), Math['floor'](cJ[0x1])),
            cd['lineTo'](Math['floor'](cC[0x0]), Math['floor'](cC[0x1]))) : (cd['moveTo'](Math['floor'](cJ[0x0]) + 0.5, Math['floor'](cJ[0x1]) + 0.5),
              cd['lineTo'](Math['floor'](cC[0x0]) + 0.5, Math['floor'](cC[0x1]) + 0.5)),
          cd['stroke'](),
          cd['restore']());
      }
      static ['getAxisArrayFromZProviderAndPath'] (cd, cq, cJ, cC = 0x6, cO = 0x2) {
        cd['length'];
        const cG = cC;
        let cg = [];
        if (cd['length'] <= cG) {
          for (let cQ = 0x0; cQ < cd['length']; cQ++)
            cg['push']({
              'label': cd[cQ]['y']['toFixed'](cO),
              'label2': cd[cQ]['x']['toFixed'](cO),
              'percent': 0x1 * cQ / (cd['length'] - 0x1)
            });
        } else {
          const cm = {
            'type': 'Feature',
            'geometry': {
              'type': 'LineString',
              'coordinates': cd['map'](cR => [cR['x'], cR['y']])
            },
            'properties': {}
          }
            , cL = (undefined === (cN = {
              'units': 'kilometers'
            }) && (cN = {}),
              bh(cm, function (cR, H0) {
                var H1 = H0['geometry']['coordinates'];
                return cR + e6(H1[0x0], H1[0x1], cN);
              }, 0x0) / (cC - 0x1));
          cg['push']({
            'label': cd[0x0]['y']['toFixed'](cO),
            'label2': cd[0x0]['x']['toFixed'](cO),
            'percent': 0x0
          });
          for (let cR = 0x1; cR < cC - 0x1; cR++) {
            const H0 = e9(cm, cR * cL, {
              'units': 'kilometers'
            });
            cg['push']({
              'label': H0['geometry']['coordinates'][0x1]['toFixed'](cO),
              'label2': H0['geometry']['coordinates'][0x0]['toFixed'](cO),
              'percent': 0x1 * cR / (cC - 0x1)
            });
          }
          cg['push']({
            'label': cd[cd['length'] - 0x1]['y']['toFixed'](cO),
            'label2': cd[cd['length'] - 0x1]['x']['toFixed'](cO),
            'percent': 0x1
          });
        }
        var cN;
        const cP = cJ
          , cM = []
          , cz = cq[cq['length'] - 0x1] - cq[0x0];
        return cP['forEach'](H1 => {
          H1 < cq[0x0] || H1 > cq[cq['length'] - 0x1] ? v0['kg']['warn']('给定的Z坐标超过了zValues的范围！') : cM['push']({
            'label': H1['toString'](),
            'percent': (H1 - cq[0x0]) / cz
          });
        }
        ),
        {
          'xArr': cg,
          'yArr': cM
        };
      }
    }
    FrameDrawService['VDefaultOptions'] = {
      'background': 'black',
      'content': {
        'ltOffset': [0x46, 0x4b],
        'rbOffset': [0x50, 0x32]
      },
      'border': {
        'visible': true,
        'width': 0x2,
        'color': 'white'
      },
      'gridLines': {
        'major': {
          'visible': true,
          'width': 0x1,
          'color': 'gray',
          'dashArray': [0x5, 0x2, 0x5, 0x2]
        },
        'minor': {
          'visible': false,
          'width': 0x1,
          'color': 'gray',
          'dashArray': [0x3, 0x3, 0x3, 0x3]
        }
      },
      'title': {
        'position': 'center',
        'main': {
          'visible': true,
          'font': '22px\x20Arial',
          'color': 'white',
          'textAlign': 'center',
          'textBase': 'middle'
        },
        'sub': {
          'visible': true,
          'font': '16px\x20Arial',
          'color': 'white',
          'textAlign': 'center',
          'textBase': 'middle',
          'offset': [0x0, 0x19]
        }
      },
      'axis': {
        'tick': {
          'position': 'out',
          'length': 0x6,
          'line': {
            'color': 'white',
            'visible': true,
            'width': 0x1
          }
        },
        'label': {
          'bottom': {
            'text': {
              'visible': true,
              'font': '14px\x20Arial',
              'color': 'white',
              'offset': [0x0, 0x5],
              'textAlign': 'center',
              'textBase': 'top'
            },
            'text2': {
              'visible': true,
              'font': '14px\x20Arial',
              'color': 'white',
              'offset': [0x0, 0x14],
              'textAlign': 'center',
              'textBase': 'top'
            },
            'title': {
              'position': 'center',
              'main': {
                'visible': false,
                'font': '14px\x20Arial',
                'color': 'white',
                'textAlign': 'center',
                'textBase': 'middle',
                'offset': [0x0, 0x37]
              },
              'sub': {
                'visible': false,
                'font': '12px\x20Arial',
                'color': 'white',
                'textAlign': 'center',
                'textBase': 'middle',
                'offset': [0x0, 0x4b]
              }
            }
          },
          'left': {
            'text': {
              'visible': true,
              'font': '14px\x20Arial',
              'color': 'white',
              'offset': [-0x5, 0x0],
              'textAlign': 'end',
              'textBase': 'middle'
            },
            'text2': {
              'visible': true,
              'font': '14px\x20Arial',
              'color': 'white',
              'offset': [-0x5, 0x14],
              'textAlign': 'center',
              'textBase': 'middle'
            },
            'title': {
              'position': 'center',
              'main': {
                'visible': true,
                'font': '14px\x20Arial',
                'color': 'white',
                'textAlign': 'center',
                'textBase': 'middle',
                'offset': [-0x32, 0x0],
                'angle': -0x5a
              },
              'sub': {
                'visible': false,
                'font': '12px\x20Arial',
                'color': 'white',
                'textAlign': 'center',
                'textBase': 'middle',
                'offset': [-0x46, 0x0],
                'angle': -0x5a
              }
            }
          }
        }
      },
      'legend': {
        'mode': 'v',
        'width': 0x14,
        'height': 0x12c,
        'skip': 0x0,
        'offset': [0x14, 0x0],
        'visible': true,
        'reverse': false,
        'border': {
          'visible': true,
          'width': 0x1,
          'color': 'white'
        },
        'label': {
          'visible': true,
          'font': '16px\x20Arial',
          'color': 'white',
          'offset': [0x5, 0x0],
          'textAlign': 'start',
          'textBase': 'middle'
        },
        'tick': {
          'style': {
            'visible': true,
            'width': 0x1,
            'color': 'white'
          },
          'length': 0x3
        },
        'color': undefined
      }
    },
      FrameDrawService['HDefaultOptions'] = (0x0,
        Kz['uw'])({}, {
          'content': {
            'rbOffset': [0x32, 0x73]
          },
          'legend': {
            'mode': 'h',
            'width': 0x1c2,
            'height': 0x14,
            'offset': [0x0, 0x3c],
            'label': {
              'textAlign': 'center',
              'textBase': 'top',
              'offset': [0x0, 0x5]
            }
          }
        }, FrameDrawService['VDefaultOptions']);
    class eA {
      constructor(cd) {
        this['finishPointCount'] = -0x1,
          this['freehand'] = false,
          this['setPoints'](cd);
      }
      ['setCoordinates'] (cd) {
        this['coordinates'] = cd;
      }
      ['isPlot'] () {
        return true;
      }
      get ['generated'] () {
        return undefined !== this['coordinates'];
      }
      ['setPoints'] (cd) {
        this['points'] = cd || [],
          this['points']['length'] >= 0x1 ? this['generate']() : this['coordinates'] = undefined;
      }
      ['addPoint'] (cd) {
        if (this['points']['length'] > 0x0) {
          const cq = this['points'][this['points']['length'] - 0x1];
          if (0x0 === Math['abs'](cq[0x0] - cd[0x0]) && 0x0 === Math['abs'](cq[0x1] - cd[0x1]))
            return false;
        }
        return this['points']['push'](cd),
          this['generate'](),
          true;
      }
      ['getPoints'] (cd = true) {
        return cd ? this['points']['slice'](0x0) : this['points'];
      }
      ['getPointCount'] () {
        return this['points']['length'];
      }
      ['updatePoint'] (cd, cq) {
        cq >= 0x0 && cq < this['points']['length'] && (this['points'][cq] = cd,
          this['generate']());
      }
      ['updateLastPoint'] (cd) {
        this['updatePoint'](cd, this['points']['length'] - 0x1);
      }
      ['finishDrawing'] () { }
    }
    class PlotPolygonBase extends eA {
      ['getGeoJSON'] () {
        if (this['coordinates'])
          return {
            'type': 'Polygon',
            'coordinates': this['coordinates']
          };
      }
    }
    class PlotLineBase extends eA {
      ['getGeoJSON'] () {
        if (this['coordinates'])
          return {
            'type': 'LineString',
            'coordinates': this['coordinates']
          };
      }
    }
    class PlotPointBase extends eA {
      ['getGeoJSON'] () {
        if (this['coordinates'])
          return {
            'type': 'Point',
            'coordinates': this['coordinates']
          };
      }
    }
    const PlotConstants = {
      'TWO_PI': 0x2 * Math['PI'],
      'HALF_PI': Math['PI'] / 0x2,
      'FITTING_COUNT': 0x64,
      'ZERO_TOLERANCE': 0.0001
    }
      , eH = {
        'MARKER': '点',
        'POLYLINE': '线',
        'CURVE': '曲线',
        'POLYGON': '多边形',
        'CLOSED_CURVE': '曲面',
        'RECTANGLE': '矩形',
        'CIRCLE': '圆',
        'ELLIPSE': '椭圆',
        'ARC': '弧线',
        'SECTOR': '扇形',
        'FREEHAND_LINE': '手绘线',
        'FREEHAND_POLYGON': '手绘多边形',
        'LUNE': '弓形',
        'DOUBLE_ARROW': '钳击',
        'GATHERING_PLACE': '聚集地',
        'STRAIGHT_ARROW': '直线箭头',
        'ASSAULT_DIRECTION': '突击方向',
        'ATTACK_ARROW': '进攻方向',
        'TAILED_ATTACK_ARROW': '进攻方向（燕尾）',
        'SQUAD_COMBAT': '分队战斗行动',
        'TAILED_SQUAD_COMBAT': '分队战斗行动（燕尾）',
        'FINE_ARROW': '细箭头'
      }
      , ex = function (cd, cq) {
        return Math['sqrt'](Math['pow'](cd[0x0] - cq[0x0], 0x2) + Math['pow'](cd[0x1] - cq[0x1], 0x2));
      }
      , ep = function (cd) {
        for (var cq = 0x0, cJ = 0x0; cJ < cd['length'] - 0x1; cJ++)
          cq += ex(cd[cJ], cd[cJ + 0x1]);
        return cq;
      }
      , eF = function (cd) {
        return Math['pow'](ep(cd), 0.99);
      }
      , ey = function (cd, cq) {
        return [(cd[0x0] + cq[0x0]) / 0x2, (cd[0x1] + cq[0x1]) / 0x2];
      }
      , ew = function (cd, cq, cJ) {
        var cC = [(cd[0x0] + cq[0x0]) / 0x2, (cd[0x1] + cq[0x1]) / 0x2]
          , cO = [cC[0x0] - cd[0x1] + cq[0x1], cC[0x1] + cd[0x0] - cq[0x0]]
          , cG = [(cd[0x0] + cJ[0x0]) / 0x2, (cd[0x1] + cJ[0x1]) / 0x2]
          , cg = [cG[0x0] - cd[0x1] + cJ[0x1], cG[0x1] + cd[0x0] - cJ[0x0]];
        return eh(cC, cO, cG, cg);
      }
      , eh = function (cd, cq, cJ, cC) {
        if (cd[0x1] == cq[0x1]) {
          var cO = (cC[0x0] - cJ[0x0]) / (cC[0x1] - cJ[0x1])
            , cG = cO * (cd[0x1] - cJ[0x1]) + cJ[0x0]
            , cg = cd[0x1];
          return [cG, cg];
        }
        if (cJ[0x1] == cC[0x1]) {
          var cN = (cq[0x0] - cd[0x0]) / (cq[0x1] - cd[0x1]);
          return [cG = cN * (cJ[0x1] - cd[0x1]) + cd[0x0], cg = cJ[0x1]];
        }
        return cN = (cq[0x0] - cd[0x0]) / (cq[0x1] - cd[0x1]),
          cO = (cC[0x0] - cJ[0x0]) / (cC[0x1] - cJ[0x1]),
          [cG = cN * (cg = (cN * cd[0x1] - cd[0x0] - cO * cJ[0x1] + cJ[0x0]) / (cN - cO)) - cN * cd[0x1] + cd[0x0], cg];
      }
      , eu = function (cd, cq) {
        var cJ, cC = Math['asin'](Math['abs'](cq[0x1] - cd[0x1]) / ex(cd, cq));
        return cq[0x1] >= cd[0x1] && cq[0x0] >= cd[0x0] ? cJ = cC + Math['PI'] : cq[0x1] >= cd[0x1] && cq[0x0] < cd[0x0] ? cJ = PlotConstants['TWO_PI'] - cC : cq[0x1] < cd[0x1] && cq[0x0] < cd[0x0] ? cJ = cC : cq[0x1] < cd[0x1] && cq[0x0] >= cd[0x0] && (cJ = Math['PI'] - cC),
          cJ;
      }
      , eY = function (cd, cq, cJ) {
        var cC = eu(cq, cd) - eu(cq, cJ);
        return cC < 0x0 ? cC + PlotConstants['TWO_PI'] : cC;
      }
      , eT = function (cd, cq, cJ) {
        return (cJ[0x1] - cd[0x1]) * (cq[0x0] - cd[0x0]) > (cq[0x1] - cd[0x1]) * (cJ[0x0] - cd[0x0]);
      }
      , eX = function (cd, cq, cJ, cC, cO) {
        var cG = 0x1 - (cd = Math['max'](Math['min'](cd, 0x1), 0x0))
          , cg = cd * cd
          , cN = cg * cd
          , cP = cG * cG
          , cM = cP * cG;
        return [cM * cq[0x0] + 0x3 * cP * cd * cJ[0x0] + 0x3 * cG * cg * cC[0x0] + cN * cO[0x0], cM * cq[0x1] + 0x3 * cP * cd * cJ[0x1] + 0x3 * cG * cg * cC[0x1] + cN * cO[0x1]];
      }
      , eE = function (cd, cq, cJ, cC, cO) {
        var cG = eu(cd, cq)
          , cg = cO ? cG + cJ : cG - cJ
          , cN = cC * Math['cos'](cg)
          , cP = cC * Math['sin'](cg);
        return [cq[0x0] + cN, cq[0x1] + cP];
      }
      , ef = function (cd, cq, cJ, cC) {
        var cO, cG, cg = [], cN = cC - cJ;
        cN = cN < 0x0 ? cN + PlotConstants['TWO_PI'] : cN;
        for (var cP = 0x0; cP <= PlotConstants['FITTING_COUNT']; cP++) {
          var cM = cJ + cN * cP / PlotConstants['FITTING_COUNT'];
          cO = cd[0x0] + cq * Math['cos'](cM),
            cG = cd[0x1] + cq * Math['sin'](cM),
            cg['push']([cO, cG]);
        }
        return cg;
      }
      , eW = function (cd, cq, cJ, cC) {
        var cO = eI(cq, cJ, cC)
          , cG = Math['sqrt'](cO[0x0] * cO[0x0] + cO[0x1] * cO[0x1])
          , cg = cO[0x0] / cG
          , cN = cO[0x1] / cG
          , cP = ex(cq, cJ)
          , cM = ex(cJ, cC);
        if (cG > PlotConstants['ZERO_TOLERANCE']) {
          if (eT(cq, cJ, cC)) {
            var cz = cd * cP
              , cQ = cJ[0x0] - cz * cN
              , cm = cJ[0x1] + cz * cg
              , cL = [cQ, cm];
            cz = cd * cM;
            var cR = [cQ = cJ[0x0] + cz * cN, cm = cJ[0x1] - cz * cg];
          } else
            cz = cd * cP,
              cL = [cQ = cJ[0x0] + cz * cN, cm = cJ[0x1] - cz * cg],
              cz = cd * cM,
              cR = [cQ = cJ[0x0] - cz * cN, cm = cJ[0x1] + cz * cg];
        } else
          cL = [cQ = cJ[0x0] + cd * (cq[0x0] - cJ[0x0]), cm = cJ[0x1] + cd * (cq[0x1] - cJ[0x1])],
            cR = [cQ = cJ[0x0] + cd * (cC[0x0] - cJ[0x0]), cm = cJ[0x1] + cd * (cC[0x1] - cJ[0x1])];
        return [cL, cR];
      }
      , eI = function (cd, cq, cJ) {
        var cC = cd[0x0] - cq[0x0]
          , cO = cd[0x1] - cq[0x1]
          , cG = Math['sqrt'](cC * cC + cO * cO);
        cC /= cG,
          cO /= cG;
        var cg = cJ[0x0] - cq[0x0]
          , cN = cJ[0x1] - cq[0x1]
          , cP = Math['sqrt'](cg * cg + cN * cN);
        return [cC + (cg /= cP), cO + (cN /= cP)];
      }
      , ej = function (cd, cq) {
        var cJ = cd[0x0]
          , cC = cd[0x1]
          , cO = cd[0x2]
          , cG = eW(0x0, cJ, cC, cO)[0x0]
          , cg = eI(cJ, cC, cO);
        if (Math['sqrt'](cg[0x0] * cg[0x0] + cg[0x1] * cg[0x1]) > PlotConstants['ZERO_TOLERANCE'])
          var cN = ey(cJ, cC)
            , cP = cJ[0x0] - cN[0x0]
            , cM = cJ[0x1] - cN[0x1]
            , cz = 0x2 / ex(cJ, cC)
            , cQ = -cz * cM
            , cm = cz * cP
            , cL = cQ * cQ - cm * cm
            , cR = 0x2 * cQ * cm
            , H0 = cm * cm - cQ * cQ
            , H1 = cG[0x0] - cN[0x0]
            , H2 = cG[0x1] - cN[0x1]
            , H3 = cN[0x0] + cL * H1 + cR * H2
            , H4 = cN[0x1] + cR * H1 + H0 * H2;
        else
          H3 = cJ[0x0] + cq * (cC[0x0] - cJ[0x0]),
            H4 = cJ[0x1] + cq * (cC[0x1] - cJ[0x1]);
        return [H3, H4];
      }
      , eD = function (cd) {
        if (cd['length'] <= 0x2)
          return cd;
        for (var cq = [], cJ = cd['length'] - 0x1, cC = 0x0; cC <= 0x1; cC += 0.01) {
          for (var cO = 0x0, cG = 0x0, cg = 0x0; cg <= cJ; cg++) {
            var cN = eV(cJ, cg)
              , cP = Math['pow'](cC, cg)
              , cM = Math['pow'](0x1 - cC, cJ - cg);
            cO += cN * cP * cM * cd[cg][0x0],
              cG += cN * cP * cM * cd[cg][0x1];
          }
          cq['push']([cO, cG]);
        }
        return cq['push'](cd[cJ]),
          cq;
      }
      , eV = function (cd, cq) {
        return eZ(cd) / (eZ(cq) * eZ(cd - cq));
      }
      , eZ = function (cd) {
        if (cd <= 0x1)
          return 0x1;
        if (0x2 == cd)
          return 0x2;
        if (0x3 == cd)
          return 0x6;
        if (0x4 == cd)
          return 0x18;
        if (0x5 == cd)
          return 0x78;
        for (var cq = 0x1, cJ = 0x1; cJ <= cd; cJ++)
          cq *= cJ;
        return cq;
      }
      , eB = function (cd) {
        if (cd['length'] <= 0x2)
          return cd;
        var cq = []
          , cJ = cd['length'] - 0x2 - 0x1;
        cq['push'](cd[0x0]);
        for (var cC = 0x0; cC <= cJ; cC++)
          for (var cO = 0x0; cO <= 0x1; cO += 0.05) {
            for (var cG = 0x0, cg = 0x0, cN = 0x0; cN <= 0x2; cN++) {
              var cP = eS(cN, cO);
              cG += cP * cd[cC + cN][0x0],
                cg += cP * cd[cC + cN][0x1];
            }
            cq['push']([cG, cg]);
          }
        return cq['push'](cd[cd['length'] - 0x1]),
          cq;
      }
      , eS = function (cd, cq) {
        return 0x0 == cd ? Math['pow'](cq - 0x1, 0x2) / 0x2 : 0x1 == cd ? (-0x2 * Math['pow'](cq, 0x2) + 0x2 * cq + 0x1) / 0x2 : 0x2 == cd ? Math['pow'](cq, 0x2) / 0x2 : 0x0;
      };
    class eU extends PlotLineBase {
      constructor() {
        super(...arguments),
          this['type'] = eH['ARC'],
          this['finishPointCount'] = 0x3;
      }
      ['generate'] () {
        if (!(this['getPointCount']() <= 0x2)) {
          var cd = this['points'][0x0]
            , cq = this['points'][0x1]
            , cJ = this['points'][0x2]
            , cC = ew(cd, cq, cJ)
            , cO = ex(cd, cC)
            , cG = eu(cd, cC)
            , cg = eu(cq, cC);
          if (eT(cd, cq, cJ))
            var cN = cg
              , cP = cG;
          else
            cN = cG,
              cP = cg;
          this['setCoordinates'](ef(cC, cO, cN, cP));
        }
      }
    }
    class ed extends PlotPolygonBase {
      constructor() {
        super(...arguments),
          this['type'] = eH['ELLIPSE'],
          this['finishPointCount'] = 0x2;
      }
      ['generate'] () {
        if (!(this['getPointCount']() < 0x2)) {
          var cd = this['points'][0x0]
            , cq = this['points'][0x1]
            , cJ = ey(cd, cq)
            , cC = Math['abs']((cd[0x0] - cq[0x0]) / 0x2)
            , cO = Math['abs']((cd[0x1] - cq[0x1]) / 0x2);
          this['setCoordinates']([this['generatePoints'](cJ, cC, cO)]);
        }
      }
      ['generatePoints'] (cd, cq, cJ) {
        for (var cC, cO, cG, cg = [], cN = 0x0; cN <= PlotConstants['FITTING_COUNT']; cN++)
          cG = 0x2 * Math['PI'] * cN / PlotConstants['FITTING_COUNT'],
            cC = cd[0x0] + cq * Math['cos'](cG),
            cO = cd[0x1] + cJ * Math['sin'](cG),
            cg['push']([cC, cO]);
        return cg;
      }
    }
    class eq extends PlotLineBase {
      constructor() {
        super(...arguments),
          this['type'] = eH['CURVE'],
          this['t'] = 0.3;
      }
      ['generate'] () {
        this['getPointCount']() <= 0x2 || this['setCoordinates'](function (cd, cq) {
          for (var cJ = [ej(cq, cd)], cC = 0x0; cC < cq['length'] - 0x2; cC++) {
            var cO = cq[cC]
              , cG = cq[cC + 0x1]
              , cg = cq[cC + 0x2]
              , cN = eW(cd, cO, cG, cg);
            cJ = cJ['concat'](cN);
          }
          var cP = function (cQ, cm) {
            var cL = cQ['length']
              , cR = cQ[cL - 0x3]
              , H0 = cQ[cL - 0x2]
              , H1 = cQ[cL - 0x1]
              , H2 = eW(0x0, cR, H0, H1)[0x1]
              , H3 = eI(cR, H0, H1);
            if (Math['sqrt'](H3[0x0] * H3[0x0] + H3[0x1] * H3[0x1]) > PlotConstants['ZERO_TOLERANCE'])
              var H4 = ey(H0, H1)
                , H5 = H1[0x0] - H4[0x0]
                , H6 = H1[0x1] - H4[0x1]
                , H7 = 0x2 / ex(H0, H1)
                , H8 = -H7 * H6
                , H9 = H7 * H5
                , Hv = H8 * H8 - H9 * H9
                , HA = 0x2 * H8 * H9
                , Hk = H9 * H9 - H8 * H8
                , Hl = H2[0x0] - H4[0x0]
                , HK = H2[0x1] - H4[0x1]
                , Hb = H4[0x0] + Hv * Hl + HA * HK
                , Hc = H4[0x1] + HA * Hl + Hk * HK;
            else
              Hb = H1[0x0] + cm * (H0[0x0] - H1[0x0]),
                Hc = H1[0x1] + cm * (H0[0x1] - H1[0x1]);
            return [Hb, Hc];
          }(cq, cd);
          cJ['push'](cP);
          var cM = [];
          for (cC = 0x0; cC < cq['length'] - 0x1; cC++) {
            cO = cq[cC],
              cG = cq[cC + 0x1],
              cM['push'](cO);
            for (let cQ = 0x0; cQ < PlotConstants['FITTING_COUNT']; cQ++) {
              var cz = eX(cQ / PlotConstants['FITTING_COUNT'], cO, cJ[0x2 * cC], cJ[0x2 * cC + 0x1], cG);
              cM['push'](cz);
            }
            cM['push'](cG);
          }
          return cM;
        }(this['t'], this['points']));
      }
    }
    class eJ extends PlotPolygonBase {
      constructor() {
        super(...arguments),
          this['type'] = eH['CLOSED_CURVE'],
          this['t'] = 0.3;
      }
      ['generate'] () {
        if (!((cd = this['getPointCount']()) <= 0x2)) {
          var cd, cq = this['getPoints']();
          cq['push'](cq[0x0], cq[0x1]);
          for (var cJ = [], cC = 0x0; cC < cq['length'] - 0x2; cC++) {
            var cO = eW(this['t'], cq[cC], cq[cC + 0x1], cq[cC + 0x2]);
            cJ = cJ['concat'](cO);
          }
          cJ = [cJ[(cd = cJ['length']) - 0x1]]['concat'](cJ['slice'](0x0, cd - 0x1));
          var cG = [];
          for (cC = 0x0; cC < cq['length'] - 0x2; cC++) {
            var cg = cq[cC]
              , cN = cq[cC + 0x1];
            cG['push'](cg);
            for (var cP = 0x0; cP <= PlotConstants['FITTING_COUNT']; cP++) {
              var cM = eX(cP / PlotConstants['FITTING_COUNT'], cg, cJ[0x2 * cC], cJ[0x2 * cC + 0x1], cN);
              cG['push'](cM);
            }
            cG['push'](cN);
          }
          this['setCoordinates']([cG]);
        }
      }
    }
    class eC extends PlotPolygonBase {
      constructor() {
        super(...arguments),
          this['type'] = eH['LUNE'],
          this['finishPointCount'] = 0x3;
      }
      ['generate'] () {
        if (!(this['getPointCount']() < 0x2)) {
          var cd = this['getPoints']();
          if (0x2 == this['getPointCount']()) {
            var cq = ey(cd[0x0], cd[0x1])
              , cJ = ex(cd[0x0], cq)
              , cC = eE(cd[0x0], cq, PlotConstants['HALF_PI'], cJ, undefined);
            cd['push'](cC);
          }
          var cO = cd[0x0]
            , cG = cd[0x1]
            , cg = cd[0x2]
            , cN = ew(cO, cG, cg)
            , cP = ex(cO, cN)
            , cM = eu(cO, cN)
            , cz = eu(cG, cN);
          if (eT(cO, cG, cg))
            var cQ = cz
              , cm = cM;
          else
            cQ = cM,
              cm = cz;
          (cd = ef(cN, cP, cQ, cm))['push'](cd[0x0]),
            this['setCoordinates']([cd]);
        }
      }
    }
    class eO extends PlotPolygonBase {
      constructor() {
        super(...arguments),
          this['type'] = eH['SECTOR'],
          this['finishPointCount'] = 0x3;
      }
      ['generate'] () {
        if (!(this['getPointCount']() <= 0x2)) {
          var cd = this['getPoints']()
            , cq = cd[0x0]
            , cJ = cd[0x1]
            , cC = cd[0x2]
            , cO = ex(cJ, cq)
            , cG = eu(cJ, cq)
            , cg = eu(cC, cq)
            , cN = ef(cq, cO, cG, cg);
          cN['push'](cq, cN[0x0]),
            this['setCoordinates']([cN]);
        }
      }
    }
    class eG extends PlotPolygonBase {
      constructor() {
        super(...arguments),
          this['type'] = eH['GATHERING_PLACE'],
          this['t'] = 0.4,
          this['finishPointCount'] = 0x3;
      }
      ['generate'] () {
        var cd = this['getPoints']();
        if (!(cd['length'] < 0x2)) {
          if (0x2 == this['getPointCount']()) {
            var cq = ey(cd[0x0], cd[0x1])
              , cJ = ex(cd[0x0], cq) / 0.9
              , cC = eE(cd[0x0], cq, PlotConstants['HALF_PI'], cJ, true);
            cd = [cd[0x0], cC, cd[0x1]];
          }
          cq = ey(cd[0x0], cd[0x2]),
            cd['push'](cq, cd[0x0], cd[0x1]);
          for (var cO = [], cG = 0x0; cG < cd['length'] - 0x2; cG++) {
            var cg = cd[cG]
              , cN = cd[cG + 0x1]
              , cP = cd[cG + 0x2]
              , cM = eW(this['t'], cg, cN, cP);
            cO = cO['concat'](cM);
          }
          var cz = cO['length'];
          cO = [cO[cz - 0x1]]['concat'](cO['slice'](0x0, cz - 0x1));
          var cQ = [];
          for (cG = 0x0; cG < cd['length'] - 0x2; cG++) {
            cg = cd[cG],
              cN = cd[cG + 0x1],
              cQ['push'](cg);
            for (var cm = 0x0; cm <= PlotConstants['FITTING_COUNT']; cm++)
              cC = eX(cm / PlotConstants['FITTING_COUNT'], cg, cO[0x2 * cG], cO[0x2 * cG + 0x1], cN),
                cQ['push'](cC);
            cQ['push'](cN);
          }
          this['setCoordinates']([cQ]);
        }
      }
    }
    class eg extends PlotPolygonBase {
      constructor() {
        super(...arguments),
          this['type'] = eH['FINE_ARROW'],
          this['tailWidthFactor'] = 0.15,
          this['neckWidthFactor'] = 0.2,
          this['headWidthFactor'] = 0.25,
          this['headAngle'] = Math['PI'] / 8.5,
          this['neckAngle'] = Math['PI'] / 0xd,
          this['finishPointCount'] = 0x2;
      }
      ['generate'] () {
        if (!(this['getPointCount']() < 0x2)) {
          var cd = this['getPoints']()
            , cq = cd[0x0]
            , cJ = cd[0x1]
            , cC = eF(cd)
            , cO = cC * this['tailWidthFactor']
            , cG = cC * this['neckWidthFactor']
            , cg = cC * this['headWidthFactor']
            , cN = eE(cJ, cq, PlotConstants['HALF_PI'], cO, true)
            , cP = eE(cJ, cq, PlotConstants['HALF_PI'], cO, false)
            , cM = eE(cq, cJ, this['headAngle'], cg, false)
            , cz = eE(cq, cJ, this['headAngle'], cg, true)
            , cQ = [cN, eE(cq, cJ, this['neckAngle'], cG, false), cM, cJ, cz, eE(cq, cJ, this['neckAngle'], cG, true), cP];
          this['setCoordinates']([cQ]);
        }
      }
    }
    class eN extends eg {
      constructor() {
        super(...arguments),
          this['type'] = eH['ASSAULT_DIRECTION'],
          this['tailWidthFactor'] = 0.2,
          this['neckWidthFactor'] = 0.25,
          this['headWidthFactor'] = 0.3,
          this['headAngle'] = Math['PI'] / 0x4,
          this['neckAngle'] = 0.17741 * Math['PI'];
      }
    }
    class eP extends PlotPolygonBase {
      constructor() {
        super(...arguments),
          this['type'] = eH['ATTACK_ARROW'],
          this['headHeightFactor'] = 0.18,
          this['headWidthFactor'] = 0.3,
          this['neckHeightFactor'] = 0.85,
          this['neckWidthFactor'] = 0.15,
          this['headTailFactor'] = 0.8;
      }
      ['generate'] () {
        if (!(this['getPointCount']() <= 0x2)) {
          var cd = this['getPoints']()
            , cq = cd[0x0]
            , cJ = cd[0x1];
          eT(cd[0x0], cd[0x1], cd[0x2]) && (cq = cd[0x1],
            cJ = cd[0x0]);
          var cC = [ey(cq, cJ)]['concat'](cd['slice'](0x2))
            , cO = this['getArrowHeadPoints'](cC, cq, cJ)
            , cG = cO[0x0]
            , cg = cO[0x4]
            , cN = ex(cq, cJ) / eF(cC)
            , cP = this['getArrowBodyPoints'](cC, cG, cg, cN)
            , cM = cP['length']
            , cz = [cq]['concat'](cP['slice'](0x0, cM / 0x2));
          cz['push'](cG);
          var cQ = [cJ]['concat'](cP['slice'](cM / 0x2, cM));
          cQ['push'](cg),
            cz = eB(cz),
            cQ = eB(cQ),
            this['setCoordinates']([cz['concat'](cO, cQ['reverse']())]);
        }
      }
      ['getArrowHeadPoints'] (cd, cq, cJ) {
        var cC = eF(cd)
          , cO = cC * this['headHeightFactor']
          , cG = cd[cd['length'] - 0x1];
        cC = ex(cG, cd[cd['length'] - 0x2]);
        var cg = ex(cq, cJ);
        cO > cg * this['headTailFactor'] && (cO = cg * this['headTailFactor']);
        var cN = cO * this['headWidthFactor']
          , cP = cO * this['neckWidthFactor']
          , cM = (cO = cO > cC ? cC : cO) * this['neckHeightFactor']
          , cz = eE(cd[cd['length'] - 0x2], cG, 0x0, cO, true)
          , cQ = eE(cd[cd['length'] - 0x2], cG, 0x0, cM, true)
          , cm = eE(cG, cz, PlotConstants['HALF_PI'], cN, false)
          , cL = eE(cG, cz, PlotConstants['HALF_PI'], cN, true);
        return [eE(cG, cQ, PlotConstants['HALF_PI'], cP, false), cm, cG, cL, eE(cG, cQ, PlotConstants['HALF_PI'], cP, true)];
      }
      ['getArrowBodyPoints'] (cd, cq, cJ, cC) {
        for (var cO = ep(cd), cG = eF(cd) * cC, cg = (cG - ex(cq, cJ)) / 0x2, cN = 0x0, cP = [], cM = [], cz = 0x1; cz < cd['length'] - 0x1; cz++) {
          var cQ = eY(cd[cz - 0x1], cd[cz], cd[cz + 0x1]) / 0x2
            , cm = (cG / 0x2 - (cN += ex(cd[cz - 0x1], cd[cz])) / cO * cg) / Math['sin'](cQ)
            , cL = eE(cd[cz - 0x1], cd[cz], Math['PI'] - cQ, cm, true)
            , cR = eE(cd[cz - 0x1], cd[cz], cQ, cm, false);
          cP['push'](cL),
            cM['push'](cR);
        }
        return cP['concat'](cM);
      }
    }
    class eM extends PlotPolygonBase {
      constructor() {
        super(...arguments),
          this['type'] = eH['CIRCLE'],
          this['finishPointCount'] = 0x2;
      }
      ['generate'] () {
        if (!(this['getPointCount']() < 0x2)) {
          var cd = this['points'][0x0]
            , cq = ex(cd, this['points'][0x1]);
          this['setCoordinates']([this['generatePoints'](cd, cq)]);
        }
      }
      ['generatePoints'] (cd, cq) {
        for (var cJ, cC, cO, cG = [], cg = 0x0; cg <= PlotConstants['FITTING_COUNT']; cg++)
          cO = 0x2 * Math['PI'] * cg / PlotConstants['FITTING_COUNT'],
            cJ = cd[0x0] + cq * Math['cos'](cO),
            cC = cd[0x1] + cq * Math['sin'](cO),
            cG['push']([cJ, cC]);
        return cG;
      }
    }
    class ez extends PlotPolygonBase {
      constructor() {
        super(...arguments),
          this['type'] = eH['DOUBLE_ARROW'],
          this['headHeightFactor'] = 0.25,
          this['headWidthFactor'] = 0.3,
          this['neckHeightFactor'] = 0.85,
          this['neckWidthFactor'] = 0.15,
          this['connPoint'] = null,
          this['tempPoint4'] = null,
          this['finishPointCount'] = 0x4;
      }
      ['finishDrawing'] () {
        0x3 == this['getPointCount']() && null != this['tempPoint4'] && this['points']['push'](this['tempPoint4']),
          null != this['connPoint'] && this['points']['push'](this['connPoint']);
      }
      ['generate'] () {
        if (!((cG = this['getPointCount']()) <= 0x2)) {
          var cd, cq, cJ = this['points'][0x0], cC = this['points'][0x1], cO = this['points'][0x2], cG = this['getPointCount']();
          this['tempPoint4'] = 0x3 == cG ? this['getTempPoint4'](cJ, cC, cO) : this['points'][0x3],
            this['connPoint'] = 0x3 == cG || 0x4 == cG ? ey(cJ, cC) : this['points'][0x4],
            eT(cJ, cC, cO) ? (cd = this['getArrowPoints'](cJ, this['connPoint'], this['tempPoint4'], false),
              cq = this['getArrowPoints'](this['connPoint'], cC, cO, true)) : (cd = this['getArrowPoints'](cC, this['connPoint'], cO, false),
                cq = this['getArrowPoints'](this['connPoint'], cJ, this['tempPoint4'], true));
          var cg = cd['length']
            , cN = (cg - 0x5) / 0x2
            , cP = cd['slice'](0x0, cN)
            , cM = cd['slice'](cN, cN + 0x5)
            , cz = cd['slice'](cN + 0x5, cg)
            , cQ = cq['slice'](0x0, cN)
            , cm = cq['slice'](cN, cN + 0x5)
            , cL = cq['slice'](cN + 0x5, cg);
          cQ = eD(cQ);
          var cR = eD(cL['concat'](cP['slice'](0x1)));
          cz = eD(cz);
          var H0 = cQ['concat'](cm, cR, cM, cz);
          this['setCoordinates']([H0]);
        }
      }
      ['getArrowPoints'] (cd, cq, cJ, cC) {
        var cO = ey(cd, cq)
          , cG = ex(cO, cJ)
          , cg = eE(cJ, cO, 0x0, 0.3 * cG, true)
          , cN = eE(cJ, cO, 0x0, 0.5 * cG, true)
          , cP = [cO, cg = eE(cO, cg, PlotConstants['HALF_PI'], cG / 0x5, cC), cN = eE(cO, cN, PlotConstants['HALF_PI'], cG / 0x4, cC), cJ]
          , cM = this['getArrowHeadPoints'](cP, this['headHeightFactor'], this['headWidthFactor'])
          , cz = cM[0x0]
          , cQ = cM[0x4]
          , cm = ex(cd, cq) / eF(cP) / 0x2
          , cL = this['getArrowBodyPoints'](cP, cz, cQ, cm)
          , cR = cL['length']
          , H0 = cL['slice'](0x0, cR / 0x2)
          , H1 = cL['slice'](cR / 0x2, cR);
        return H0['push'](cz),
          H1['push'](cQ),
          (H0 = H0['reverse']())['push'](cq),
          (H1 = H1['reverse']())['push'](cd),
          H0['reverse']()['concat'](cM, H1);
      }
      ['getArrowHeadPoints'] (cd, cq, cJ) {
        var cC = eF(cd) * this['headHeightFactor']
          , cO = cd[cd['length'] - 0x1]
          , cG = (ex(cq, cJ),
            cC * this['headWidthFactor'])
          , cg = cC * this['neckWidthFactor']
          , cN = cC * this['neckHeightFactor']
          , cP = eE(cd[cd['length'] - 0x2], cO, 0x0, cC, true)
          , cM = eE(cd[cd['length'] - 0x2], cO, 0x0, cN, true)
          , cz = eE(cO, cP, PlotConstants['HALF_PI'], cG, false)
          , cQ = eE(cO, cP, PlotConstants['HALF_PI'], cG, true);
        return [eE(cO, cM, PlotConstants['HALF_PI'], cg, false), cz, cO, cQ, eE(cO, cM, PlotConstants['HALF_PI'], cg, true)];
      }
      ['getArrowBodyPoints'] (cd, cq, cJ, cC) {
        for (var cO = ep(cd), cG = eF(cd) * cC, cg = (cG - ex(cq, cJ)) / 0x2, cN = 0x0, cP = [], cM = [], cz = 0x1; cz < cd['length'] - 0x1; cz++) {
          var cQ = eY(cd[cz - 0x1], cd[cz], cd[cz + 0x1]) / 0x2
            , cm = (cG / 0x2 - (cN += ex(cd[cz - 0x1], cd[cz])) / cO * cg) / Math['sin'](cQ)
            , cL = eE(cd[cz - 0x1], cd[cz], Math['PI'] - cQ, cm, true)
            , cR = eE(cd[cz - 0x1], cd[cz], cQ, cm, false);
          cP['push'](cL),
            cM['push'](cR);
        }
        return cP['concat'](cM);
      }
      ['getTempPoint4'] (cd, cq, cJ) {
        var cC, cO, cG, cg, cN = ey(cd, cq), cP = ex(cN, cJ), cM = eY(cd, cN, cJ);
        return cM < PlotConstants['HALF_PI'] ? (cO = cP * Math['sin'](cM),
          cG = cP * Math['cos'](cM),
          cg = eE(cd, cN, PlotConstants['HALF_PI'], cO, false),
          cC = eE(cN, cg, PlotConstants['HALF_PI'], cG, true)) : cM >= PlotConstants['HALF_PI'] && cM < Math['PI'] ? (cO = cP * Math['sin'](Math['PI'] - cM),
            cG = cP * Math['cos'](Math['PI'] - cM),
            cg = eE(cd, cN, PlotConstants['HALF_PI'], cO, false),
            cC = eE(cN, cg, PlotConstants['HALF_PI'], cG, false)) : cM >= Math['PI'] && cM < 1.5 * Math['PI'] ? (cO = cP * Math['sin'](cM - Math['PI']),
              cG = cP * Math['cos'](cM - Math['PI']),
              cg = eE(cd, cN, PlotConstants['HALF_PI'], cO, true),
              cC = eE(cN, cg, PlotConstants['HALF_PI'], cG, true)) : (cO = cP * Math['sin'](0x2 * Math['PI'] - cM),
                cG = cP * Math['cos'](0x2 * Math['PI'] - cM),
                cg = eE(cd, cN, PlotConstants['HALF_PI'], cO, true),
                cC = eE(cN, cg, PlotConstants['HALF_PI'], cG, false)),
          cC;
      }
    }
    class eQ extends eP {
      constructor() {
        super(...arguments),
          this['type'] = eH['TAILED_ATTACK_ARROW'],
          this['headHeightFactor'] = 0.18,
          this['headWidthFactor'] = 0.3,
          this['neckHeightFactor'] = 0.85,
          this['neckWidthFactor'] = 0.15,
          this['tailWidthFactor'] = 0.1,
          this['headTailFactor'] = 0.8,
          this['swallowTailFactor'] = 0x1,
          this['swallowTailPnt'] = null;
      }
      ['generate'] () {
        if (!((cm = this['getPointCount']()) <= 0x2)) {
          var cd = this['getPoints']()
            , cq = cd[0x0]
            , cJ = cd[0x1];
          eT(cd[0x0], cd[0x1], cd[0x2]) && (cq = cd[0x1],
            cJ = cd[0x0]);
          var cC = [ey(cq, cJ)]['concat'](cd['slice'](0x2))
            , cO = this['getArrowHeadPoints'](cC, cq, cJ)
            , cG = cO[0x0]
            , cg = cO[0x4]
            , cN = ex(cq, cJ)
            , cP = eF(cC)
            , cM = cP * this['tailWidthFactor'] * this['swallowTailFactor'];
          this['swallowTailPnt'] = eE(cC[0x1], cC[0x0], 0x0, cM, true);
          var cz = cN / cP
            , cQ = this['getArrowBodyPoints'](cC, cG, cg, cz)
            , cm = cQ['length']
            , cL = [cq]['concat'](cQ['slice'](0x0, cm / 0x2));
          cL['push'](cG);
          var cR = [cJ]['concat'](cQ['slice'](cm / 0x2, cm));
          cR['push'](cg),
            cL = eB(cL),
            cR = eB(cR),
            this['setCoordinates']([cL['concat'](cO, cR['reverse'](), [this['swallowTailPnt'], cL[0x0]])]);
        }
      }
    }
    class em extends eP {
      constructor() {
        super(...arguments),
          this['type'] = eH['SQUAD_COMBAT'],
          this['headHeightFactor'] = 0.18,
          this['headWidthFactor'] = 0.3,
          this['neckHeightFactor'] = 0.85,
          this['neckWidthFactor'] = 0.15,
          this['tailWidthFactor'] = 0.1;
      }
      ['generate'] () {
        if (!((cg = this['getPointCount']()) < 0x2)) {
          var cd = this['getPoints']()
            , cq = this['getTailPoints'](cd)
            , cJ = this['getArrowHeadPoints'](cd, cq[0x0], cq[0x1])
            , cC = cJ[0x0]
            , cO = cJ[0x4]
            , cG = this['getArrowBodyPoints'](cd, cC, cO, this['tailWidthFactor'])
            , cg = cG['length']
            , cN = [cq[0x0]]['concat'](cG['slice'](0x0, cg / 0x2));
          cN['push'](cC);
          var cP = [cq[0x1]]['concat'](cG['slice'](cg / 0x2, cg));
          cP['push'](cO),
            cN = eB(cN),
            cP = eB(cP),
            this['setCoordinates']([cN['concat'](cJ, cP['reverse']())]);
        }
      }
      ['getTailPoints'] (cd) {
        var cq = eF(cd) * this['tailWidthFactor'];
        return [eE(cd[0x1], cd[0x0], PlotConstants['HALF_PI'], cq, false), eE(cd[0x1], cd[0x0], PlotConstants['HALF_PI'], cq, true)];
      }
    }
    class eL extends eP {
      constructor() {
        super(...arguments),
          this['type'] = eH['TAILED_SQUAD_COMBAT'],
          this['headHeightFactor'] = 0.18,
          this['headWidthFactor'] = 0.3,
          this['neckHeightFactor'] = 0.85,
          this['neckWidthFactor'] = 0.15,
          this['tailWidthFactor'] = 0.1,
          this['swallowTailFactor'] = 0x1,
          this['swallowTailPnt'] = null;
      }
      ['generate'] () {
        if (!((cg = this['getPointCount']()) < 0x2)) {
          var cd = this['getPoints']()
            , cq = this['getTailPoints'](cd)
            , cJ = this['getArrowHeadPoints'](cd, cq[0x0], cq[0x2])
            , cC = cJ[0x0]
            , cO = cJ[0x4]
            , cG = this['getArrowBodyPoints'](cd, cC, cO, this['tailWidthFactor'])
            , cg = cG['length']
            , cN = [cq[0x0]]['concat'](cG['slice'](0x0, cg / 0x2));
          cN['push'](cC);
          var cP = [cq[0x2]]['concat'](cG['slice'](cg / 0x2, cg));
          cP['push'](cO),
            cN = eB(cN),
            cP = eB(cP),
            this['setCoordinates']([cN['concat'](cJ, cP['reverse'](), [cq[0x1], cN[0x0]])]);
        }
      }
      ['getTailPoints'] (cd) {
        var cq = eF(cd) * this['tailWidthFactor']
          , cJ = eE(cd[0x1], cd[0x0], PlotConstants['HALF_PI'], cq, false)
          , cC = eE(cd[0x1], cd[0x0], PlotConstants['HALF_PI'], cq, true)
          , cO = cq * this['swallowTailFactor'];
        return [cJ, eE(cd[0x1], cd[0x0], 0x0, cO, true), cC];
      }
    }
    class eR extends PlotLineBase {
      constructor() {
        super(...arguments),
          this['type'] = eH['FREEHAND_LINE'],
          this['freehand'] = true;
      }
      ['generate'] () {
        this['getPointCount']() < 0x2 || this['setCoordinates'](this['points']);
      }
    }
    class c0 extends PlotPolygonBase {
      constructor() {
        super(...arguments),
          this['type'] = eH['FREEHAND_POLYGON'],
          this['freehand'] = true;
      }
      ['generate'] () {
        this['getPointCount']() <= 0x2 || this['setCoordinates']([this['points']]);
      }
    }
    class c1 extends PlotPolygonBase {
      constructor() {
        super(...arguments),
          this['type'] = eH['POLYGON'];
      }
      ['generate'] () {
        this['getPointCount']() <= 0x2 || this['setCoordinates']([this['points']]);
      }
    }
    class c2 extends PlotPointBase {
      constructor() {
        super(...arguments),
          this['type'] = eH['MARKER'],
          this['finishPointCount'] = 0x1;
      }
      ['generate'] () {
        var cd = this['points'][0x0];
        this['setCoordinates'](cd);
      }
    }
    class c3 extends PlotLineBase {
      constructor(cd, cq) {
        super(cd),
          this['type'] = eH['POLYLINE'],
          (null == cq ? undefined : cq['finishPointCount']) > 0x1 && (this['finishPointCount'] = cq['finishPointCount']);
      }
      ['generate'] () {
        this['getPointCount']() < 0x2 || this['setCoordinates'](this['points']);
      }
    }
    class c4 extends PlotLineBase {
      constructor() {
        super(...arguments),
          this['type'] = eH['STRAIGHT_ARROW'],
          this['finishPointCount'] = 0x2,
          this['maxArrowLength'] = 0x2dc6c0,
          this['arrowLengthScale'] = 0x5;
      }
      ['generate'] () {
        if (!(this['getPointCount']() < 0x2)) {
          var cd = this['getPoints']()
            , cq = cd[0x0]
            , cJ = cd[0x1]
            , cC = ex(cq, cJ) / this['arrowLengthScale'];
          cC = cC > this['maxArrowLength'] ? this['maxArrowLength'] : cC;
          var cO = eE(cq, cJ, Math['PI'] / 0x6, cC, false)
            , cG = eE(cq, cJ, Math['PI'] / 0x6, cC, true);
          this['setCoordinates']([cq, cJ, cO, cJ, cG]);
        }
      }
    }
    class c5 extends PlotPolygonBase {
      constructor() {
        super(...arguments),
          this['type'] = eH['RECTANGLE'],
          this['finishPointCount'] = 0x2;
      }
      ['generate'] () {
        if (!(this['getPointCount']() < 0x2)) {
          var cd = this['points'][0x0]
            , cq = this['points'][0x1]
            , cJ = Math['min'](cd[0x0], cq[0x0])
            , cC = Math['max'](cd[0x0], cq[0x0])
            , cO = Math['min'](cd[0x1], cq[0x1])
            , cG = Math['max'](cd[0x1], cq[0x1])
            , cg = [cJ, cG]
            , cN = [cC, cG]
            , cP = [cC, cO]
            , cM = [cJ, cO];
          this['setCoordinates']([[cg, cN, cP, cM]]);
        }
      }
    }
    const c6 = {};
    function c7 (cd, cq) {
      c6[cd] = cq;
    }
    function createDrawPlot (cd, cq, cJ) {
      if (c6[cd] && 'function' == typeof c6[cd])
        return c6[cd](cq);
      switch (cd) {
        case eH['ARC']:
          return new eU(cq);
        case eH['ELLIPSE']:
          return new ed(cq);
        case eH['CURVE']:
          return new eq(cq);
        case eH['CLOSED_CURVE']:
          return new eJ(cq);
        case eH['LUNE']:
          return new eC(cq);
        case eH['SECTOR']:
          return new eO(cq);
        case eH['GATHERING_PLACE']:
          return new eG(cq);
        case eH['STRAIGHT_ARROW']:
          return new c4(cq);
        case eH['ASSAULT_DIRECTION']:
          return new eN(cq);
        case eH['ATTACK_ARROW']:
          return new eP(cq);
        case eH['FINE_ARROW']:
          return new eg(cq);
        case eH['CIRCLE']:
          return new eM(cq);
        case eH['DOUBLE_ARROW']:
          return new ez(cq);
        case eH['TAILED_ATTACK_ARROW']:
          return new eQ(cq);
        case eH['SQUAD_COMBAT']:
          return new em(cq);
        case eH['TAILED_SQUAD_COMBAT']:
          return new eL(cq);
        case eH['FREEHAND_LINE']:
          return new eR(cq);
        case eH['FREEHAND_POLYGON']:
          return new c0(cq);
        case eH['POLYGON']:
          return new c1(cq);
        case eH['MARKER']:
          return new c2(cq);
        case eH['RECTANGLE']:
          return new c5(cq);
        case eH['POLYLINE']:
          return new c3(cq, cJ);
      }
      throw new Error('不能识别的绘制类型！' + cd);
    }
    var c9;
    !function (cd) {
      cd[cd['left'] = 0x0] = 'left',
        cd[cd['middle'] = 0x1] = 'middle',
        cd[cd['right'] = 0x2] = 'right';
    }(c9 || (c9 = {}));
    class VectorMapTool extends iT['c'] {
      constructor(cd) {
        super(),
          this['dragging'] = false,
          this['movePointAdded'] = false,
          this['draggingMoved'] = false,
          this['onPointerDown'] = cq => {
            this['dragging'] = true,
              this['draggingMoved'] = true,
              this['pointDownTime'] = performance['now']();
          }
          ,
          this['onPointerMove'] = cq => {
            if (this['dragging'])
              this['draggingMoved'] = true;
            else {
              if (this['shape']) {
                if (this['shape']['freehand'])
                  return this['shape']['addPoint'](cq['coords']),
                    void this['updateShape']();
                this['movePointAdded'] ? this['shape']['updateLastPoint'](cq['coords']) : this['shape']['addPoint'](cq['coords']) && (this['movePointAdded'] = true),
                  this['updateShape']();
              }
            }
          }
          ,
          this['onPointerUp'] = cq => {
            if (this['dragging'] = false,
              cq['buttonType'] === c9['left']) {
              const cJ = this['pointDownTime'] && performance['now']() - this['pointDownTime'] || 0x0;
              if (this['draggingMoved'] && cJ > VectorMapTool['PointDownAsDragTime'])
                return this['draggingMoved'] = false,
                  void (this['pointDownTime'] = undefined);
              v0['kg']['debug']('pointer\x20down\x20time\x20' + cJ),
                this['shape'] ? this['movePointAdded'] || this['shape']['addPoint'](cq['coords']) : (this['shape'] = createDrawPlot(this['options']['drawType'], [cq['coords']], this['options']['shapeOptions']),
                  this['options']['autoClear'] && this['clear']()),
                this['updateShape'](),
                this['fire'](VectorMapTool['EventTypes']['pointAdd'], {
                  'firer': this,
                  'msg': {
                    'point': cq['coords'],
                    'source': cq
                  }
                }),
                this['shape']['finishPointCount'] > 0x0 && this['shape']['getPointCount']() >= this['shape']['finishPointCount'] && this['finishDraw'](cq);
            } else
              this['shape'] && cq['buttonType'] === c9['right'] && (this['fire'](VectorMapTool['EventTypes']['pointAdd'], {
                'firer': this,
                'msg': {
                  'point': cq['coords'],
                  'source': cq
                }
              }),
                this['finishDraw'](cq));
            this['movePointAdded'] = false;
          }
          ,
          this['options'] = cd,
          this['listeners'] = {
            'onPointerDown': this['onPointerDown'],
            'onPointerMove': this['onPointerMove'],
            'onPointerUp': this['onPointerUp']
          };
      }
      ['finishDraw'] (cd) {
        var cq;
        this['shape'] && this['shape']['generated'] && this['fire'](VectorMapTool['EventTypes']['drawFinish'], {
          'firer': this,
          'msg': cd
        }),
          this['options']['continious'] ? (null === (cq = this['options']['tempLineRenderer']) || undefined === cq || cq['clear'](),
            this['tempLineShape'] = undefined,
            this['shape'] = undefined,
            this['drawId'] = (0x0,
              Kz['hQ'])()) : this['end'](),
          this['fire'](VectorMapTool['EventTypes']['afterFinish'], {
            'firer': this,
            'msg': cd
          });
      }
      ['updateShape'] () {
        var cd, cq, cJ;
        if (this['shape']['generated'])
          return this['tempLineShape'] && (null === (cd = this['options']['tempLineRenderer']) || undefined === cd || cd['clear'](),
            this['tempLineShape'] = undefined),
            void (null === (cq = this['options']['renderer']) || undefined === cq || cq['updateShape'](this['drawId'], this['shape'], this['properties']));
        this['tempLineShape'] || (this['tempLineShape'] = new c3()),
          this['tempLineShape']['setPoints'](this['shape']['getPoints'](false)),
          null === (cJ = this['options']['tempLineRenderer']) || undefined === cJ || cJ['updateShape'](this['drawId'] + '_temp', this['tempLineShape'], this['properties']);
      }
      ['addPoint'] (cd) {
        this['shape'] ? this['shape']['addPoint'](cd) : (this['shape'] = createDrawPlot(this['options']['drawType'], [cd], this['options']['shapeOptions']),
          this['options']['autoClear'] && this['clear']());
      }
      ['begin'] (cd) {
        this['options']['renderer'] && this['options']['tempLineRenderer'] ? (this['properties'] = cd,
          this['options']['lockMapWhenPlot'] && this['lockMap'](),
          this['drawId'] = (0x0,
            Kz['hQ'])(),
          this['setListeners']()) : v0['kg']['error']('vector绘制工具需要提供renderer和tempLineRenderer！');
      }
      ['end'] () {
        var cd;
        this['unsetListeners'](),
          this['options']['lockMapWhenPlot'] && this['unlockMap'](),
          null === (cd = this['options']['tempLineRenderer']) || undefined === cd || cd['clear'](),
          this['drawId'] = undefined,
          this['shape'] = undefined;
      }
      ['setMap'] (cd) {
        var cq, cJ;
        this['map'] = cd,
          null === (cq = this['options']['renderer']) || undefined === cq || cq['setMap'](cd),
          null === (cJ = this['options']['tempLineRenderer']) || undefined === cJ || cJ['setMap'](cd);
      }
      ['updateDrawType'] (cd) {
        this['options']['drawType'] = cd,
          this['drawId'] && this['finishDraw'](undefined);
      }
      ['getGeoJSON'] () {
        var cd;
        return null === (cd = this['options']['renderer']) || undefined === cd ? undefined : cd['getGeoJSON']();
      }
      ['pick'] (cd) {
        var cq;
        return null === (cq = this['options']['renderer']) || undefined === cq ? undefined : cq['pick'](cd);
      }
      ['clear'] () {
        var cd, cq;
        null === (cd = this['options']['renderer']) || undefined === cd || cd['clear'](),
          null === (cq = this['options']['tempLineRenderer']) || undefined === cq || cq['clear']();
      }
    }
    VectorMapTool['EventTypes'] = {
      'drawFinish': 'draw:finish',
      'pointAdd': 'point:add',
      'afterFinish': 'after:finish'
    },
      VectorMapTool['PointDownAsDragTime'] = 0xc8;
    class cA {
      constructor() {
        this['EarthRadius'] = 6371.1,
          this['rx'] = this['ry'] = 0x0,
          this['r_res'] = 0x1;
      }
      ['geo2polar'] (cd, cq, cJ) {
        const cC = Math['sin'](cd) * Math['sin'](this['r_phy']) + Math['cos'](cd) * Math['cos'](this['r_phy']) * Math['cos'](cq);
        let cO = Math['sqrt'](0x1 - cC * cC);
        cO > 0x1 ? cO = 0x1 : cO < -0x1 && (cO = -0x1);
        const cG = Math['asin'](cO);
        let cg = Math['cos'](cd) * Math['sin'](cq) / cO;
        cg > 0x1 ? cg = 0x1 : cg < -0x1 && (cg = -0x1);
        let cN = Math['asin'](cg);
        cd < Math['asin'](cC * Math['sin'](this['r_phy'])) ? cN = Math['PI'] - cN : cq < 0x0 && (cN = 0x2 * Math['PI'] + cN),
          cJ['beta'] = cG,
          cJ['theta'] = cN;
      }
      ['polar2geo'] (cd, cq, cJ) {
        const cC = Math['cos'](cd) * Math['sin'](this['r_phy']) + Math['sin'](cd) * Math['cos'](this['r_phy']) * Math['cos'](cq)
          , cO = Math['sqrt'](0x1 - cC * cC)
          , cG = Math['asin'](cC);
        let cg = Math['sin'](cq) * Math['sin'](cd) / cO;
        cg > 0x1 ? cg = 0x1 : cg < -0x1 && (cg = -0x1);
        const cN = Math['asin'](cg);
        cJ['phy'] = cG,
          cJ['delta_numda'] = cN;
      }
      ['arcS_of_gps'] (cd, cq, cJ) {
        const cC = cq / this['EarthRadius']
          , cO = cd * Math['PI'] / 0xb4;
        let cG = {
          'phy': undefined,
          'delta_numda': undefined
        };
        this['polar2geo'](cC, cO, cG);
        const cg = 0xb4 * cG['phy'] / Math['PI']
          , cN = 0xb4 * (cG['delta_numda'] + this['r_numda']) / Math['PI'];
        cJ['lon'] = cN,
          cJ['lat'] = cg;
      }
      ['gps_to_Azimuth'] (cd, cq, cJ) {
        const cC = cq * Math['PI'] / 0xb4
          , cO = cd * Math['PI'] / 0xb4 - this['r_numda'];
        let cG = {
          'beta': undefined,
          'theta': undefined
        };
        this['geo2polar'](cC, cO, cG);
        const cg = 0xb4 * cG['theta'] / Math['PI'];
        cJ['az'] = cg,
          cJ['beta'] = cG['beta'];
      }
      ['gps_to_arcS'] (cd, cq, cJ) {
        const cC = {
          'az': undefined,
          'beta': undefined
        };
        if (this['gps_to_Azimuth'](cd, cq, cC),
          undefined === cJ['S'])
          throw new Error('S\x20can\x27t\x20be\x20undefined');
        let cO = cJ['S'] * this['EarthRadius'];
        cJ['az'] = cC['az'],
          cJ['S'] = cO;
      }
      ['gps_to_arcS_Grid'] (cd, cq, cJ) {
        const cC = cq * Math['PI'] / 0xb4
          , cO = cd * Math['PI'] / 0xb4 - this['r_numda']
          , cG = {
            'beta': undefined,
            'theta': undefined
          };
        this['geo2polar'](cC, cO, cG),
          cJ['sx'] = parseInt((cG['beta'] * this['EarthRadius'] * Math['sin'](cG['theta']) / this['r_res'] + this['rx'] + 0.5)['toString']()),
          cJ['sy'] = parseInt((this['ry'] - cG['beta'] * this['EarthRadius'] * Math['cos'](cG['theta']) / this['r_res'] + 0.5)['toString']());
      }
    }
    class ck extends cA {
      constructor(cd, cq, cJ, cC, cO, cG) {
        super(),
          this['r_numda'] = cd * Math['PI'] / 0xb4,
          this['r_phy'] = cq * Math['PI'] / 0xb4,
          this['r_h'] = 0.001 * cJ,
          this['r_res'] = 0.001 * cG,
          this['rx'] = cC,
          this['ry'] = cO,
          this['Km'] = 0x1;
      }
      ['tilt_of_gps'] (cd, cq, cJ) {
        if (cq < this['r_res'])
          return cJ['dh'] = this['r_h'],
            void (cJ['dS'] = cq);
        const cC = this['Km'] * this['EarthRadius']
          , cO = cd * Math['PI'] / 0xb4
          , cG = this['Km'] * Math['atan'](cq * Math['cos'](cO) / (cC + this['r_h'] + cq * Math['sin'](cO)));
        cJ['dS'] = this['EarthRadius'] * cG,
          cJ['dh'] = Math['sqrt']((cC + this['r_h']) * (cC + this['r_h']) + cq * cq + 0x2 * (cC + this['r_h']) * cq * Math['sin'](cO)) - cC;
      }
      ['tilt_of_gps_lon_lat'] (cd, cq, cJ, cC) {
        if (this['tilt_of_gps'](cd, cJ, cC),
          cJ < this['r_res'])
          return cC['lon'] = 0xb4 * this['r_numda'] / Math['PI'],
            void (cC['lat'] = 0xb4 * this['r_phy'] / Math['PI']);
        this['arcS_of_gps'](cq, cC['dS'], cC);
      }
      ['tilt_of_gps_by_grid'] (cd, cq, cJ, cC) {
        const cO = Math['sqrt']((cq - this['rx']) * (cq - this['rx']) + (this['ry'] - cJ) * (this['ry'] - cJ)) * this['r_res'];
        let cG = Math['asin']((cq - this['rx']) * this['r_res'] / cO);
        cG = cq >= this['rx'] && cJ <= this['ry'] ? 0xb4 * cG / Math['PI'] : cq < this['rx'] && cJ <= this['ry'] ? 0x168 + 0xb4 * cG / Math['PI'] : 0xb4 - 0xb4 * cG / Math['PI'],
          this['tilt_of_gps_lon_lat'](cd, cG, cO, cC);
      }
      ['ES_of_H'] (cd, cq, cJ) {
        if (cq <= this['r_res'])
          cJ['dh'] = this['r_h'];
        else {
          const cC = cd * Math['PI'] / 0xb4
            , cO = this['EarthRadius'] * this['Km']
            , cG = cq / cO;
          cJ['dh'] = (cO + this['r_h']) * Math['cos'](cC) / Math['cos'](cC + cG) - cO;
        }
      }
      ['HS_of_E'] (cd, cq, cJ) {
        const cC = this['EarthRadius'] * this['Km']
          , cO = cq / cC;
        let cG = Math['cos'](cO);
        cG > 0x1 && (cG = 0x1);
        const cg = Math['sin'](cO)
          , cN = (cG * (cC + cd) - (cC + this['r_h'])) / (cg * (cC + cd));
        cJ['ele'] = 0xb4 * Math['atan'](cN) / Math['PI'];
      }
      ['gps_to_tilt'] (cd, cq, cJ, cC) {
        let cO = {
          'beta': undefined,
          'az': cC['Az']
        };
        this['gps_to_Azimuth'](cd, cq, cO),
          cO['beta'] = cO['beta'] / this['Km'];
        const cG = cJ * Math['PI'] / 0xb4;
        cC['L'] = (this['Km'] * this['EarthRadius'] + this['r_h']) * Math['sin'](cO['beta']) / Math['cos'](cG + cO['beta']);
        const cg = this['EarthRadius'] * this['Km'];
        cC['H'] = Math['sqrt']((cg + this['r_h']) * (cg + this['r_h']) + cC['L'] * cC['L'] + 0x2 * (cg + this['r_h']) * cC['L'] * Math['sin'](cG)) - cg,
          cC['Az'] = cO['az'];
      }
      ['gps_to_tilt_grid'] (cd, cq, cJ, cC) {
        const cO = {
          'Az': undefined,
          'L': undefined,
          'H': undefined
        };
        this['gps_to_tilt'](cd, cq, cJ, cO);
        const cG = Math['sin'](cO['Az'] * Math['PI'] / 0xb4)
          , cg = Math['cos'](cO['Az'] * Math['PI'] / 0xb4);
        cC['x'] = cO['L'] * cG / this['r_res'],
          cC['y'] = cO['L'] * cg / this['r_res'];
      }
      ['DEM_to_tilt'] (cd, cq, cJ, cC) {
        const cO = {
          'beta': undefined,
          'az': cC['Az']
        };
        if (this['gps_to_Azimuth'](cd, cq, cO),
          cC['S'] = cO['beta'] * this['EarthRadius'],
          cJ <= this['r_h'])
          return cC['e'] = 0x0,
            void (cC['L'] = cC['S']);
        cO['beta'] = cO['beta'] / this['Km'];
        const cG = this['Km'] * this['EarthRadius'];
        let cg = Math['cos'](cO['beta']);
        cg > 0x1 && (cg = 0x1);
        const cN = Math['sin'](cO['beta']);
        cC['e'] = Math['atan'](((cG + cJ) * cg - (cG + this['r_h'])) / ((cG + cJ) * cN)),
          cC['L'] = (cG + cJ) * cN / Math['cos'](cC['e']),
          cC['e'] = 0xb4 * cC['e'] / Math['PI'],
          cC['Az'] = cO['az'];
      }
      ['RayPath_of_SH'] (cd, cq, cJ) {
        cJ['S'] = cJ['S'] || [],
          cJ['H'] = cJ['H'] || [];
        const cC = {
          'dh': undefined,
          'dS': undefined
        };
        let cO = 0x0;
        for (let cG = 0x0; cG < cq; ++cG)
          this['tilt_of_gps'](cd, cO, cC),
            cJ['S'][cG] = cC['dS'] / this['r_res'] + 0.5,
            cJ['H'][cG] = 0x3e8 * cC['dh'] + 0.5,
            cO += this['r_res'];
      }
    }
    function cK (cd, cq, cJ, cC = 0x1, cO = 0x1, cG = 0x1) {
      cC = Math['floor'](cC),
        cO = Math['floor'](cO),
        cG = Math['floor'](cG);
      const cg = []
        , cN = []
        , cP = []
        , cM = [];
      let cz = 0x0;
      function cQ (cm, cL, cR, H0, H1, H2, H3, H4, H5, H6, H7) {
        const H8 = H2 / H5
          , H9 = H3 / H6
          , Hv = H2 / 0x2
          , HA = H3 / 0x2
          , Hk = H4 / 0x2
          , Hl = H5 + 0x1
          , HK = H6 + 0x1;
        let Hb = 0x0;
        const Hc = {};
        for (let HH = 0x0; HH < HK; HH++) {
          const Hx = HH * H9 - HA;
          for (let Hp = 0x0; Hp < Hl; Hp++) {
            const HF = Hp * H8 - Hv;
            Hc[cm] = HF * H0,
              Hc[cL] = Hx * H1,
              Hc[cR] = Hk,
              cN['push'](Hc['x'], Hc['y'], Hc['z']),
              Hc[cm] = 0x0,
              Hc[cL] = 0x0,
              Hc[cR] = H4 > 0x0 ? 0x1 : -0x1,
              cP['push'](Hc['x'], Hc['y'], Hc['z']),
              cM['push'](Hp / H5),
              cM['push'](0x1 - HH / H6),
              Hb += 0x1;
          }
        }
        for (let Hy = 0x0; Hy < H6; Hy++)
          for (let Hw = 0x0; Hw < H5; Hw++) {
            const Hh = cz + Hw + Hl * Hy
              , Hu = cz + Hw + Hl * (Hy + 0x1)
              , HY = cz + (Hw + 0x1) + Hl * (Hy + 0x1)
              , HT = cz + (Hw + 0x1) + Hl * Hy;
            cg['push'](Hh, Hu, HT),
              cg['push'](Hu, HY, HT);
          }
        cz += Hb;
      }
      return cQ('z', 'y', 'x', -0x1, -0x1, cJ, cq, cd, cG, cO),
        cQ('z', 'y', 'x', 0x1, -0x1, cJ, cq, -cd, cG, cO),
        cQ('x', 'z', 'y', 0x1, 0x1, cd, cJ, cq, cC, cG),
        cQ('x', 'z', 'y', 0x1, -0x1, cd, cJ, -cq, cC, cG),
        cQ('x', 'y', 'z', 0x1, -0x1, cd, cq, cJ, cC, cO),
        cQ('x', 'y', 'z', -0x1, -0x1, cd, cq, -cJ, cC, cO),
      {
        'indices': cg,
        'vertices': cN,
        'normals': cP,
        'uvs': cM
      };
    }
    function cb (cd, cq) {
      return cJ => (cJ - cd['x']) / (cq['x'] - cd['x']) * (cq['y'] - cd['y']) + cd['y'];
    }
    function cc (cd, cq, cJ) {
      if (cd['length'] < 0x2)
        return;
      let cC = {}
        , cO = []
        , cG = 0x0;
      for (let cg = 0x0; cg < cd['length'] - 0x1; cg++) {
        let cN = cd[cg]
          , cP = cd[cg + 0x1];
        if (cN['x'] === cP['x']) {
          let cM = Math['abs'](cJ)
            , cz = cQ => cQ <= cP['y'];
          cP['y'] < cN['y'] && (cz = cQ => cQ >= cP['y'],
            cM = -cM);
          for (let cQ = cN['y']; cz(cQ); cQ += cM)
            cO[cG] = {
              'x': cN['x'],
              'y': cQ
            },
              cG++;
        } else {
          if (cN['y'] === cP['y']) {
            let cm = Math['abs'](cq)
              , cL = cR => cR <= cP['x'];
            cP['x'] < cN['x'] && (cL = cR => cR >= cP['x'],
              cm = -cm);
            for (let cR = cN['x']; cL(cR); cR += cm)
              cO[cG] = {
                'x': cR,
                'y': cN['y']
              },
                cG++;
          } else {
            let H0 = cN['x']['toString']() + cN['y']['toString']() + cP['x']['toString']() + cP['y']['toString']()
              , H1 = cC[H0];
            H1 || (H1 = cb(cN, cP),
              cC[H0] = H1);
            let H2 = Math['abs'](cq)
              , H3 = H4 => H4 <= cP['x'];
            cP['x'] < cN['x'] && (H3 = H4 => H4 >= cP['x'],
              H2 = -H2);
            for (let H4 = cN['x']; H3(H4); H4 += H2) {
              let H5 = H1(H4);
              cO[cG] = {
                'x': H4,
                'y': H5
              },
                cG++;
            }
          }
        }
      }
      return cO['push'](cd[cd['length'] - 0x1]),
      {
        'posMap': cO
      };
    }
    function cH (cd, cq, cJ, cC, cO, cG) {
      cd['beginPath'](),
        cd['arc'](cq + cG, cJ + cG, cG, Math['PI'], 0x3 * Math['PI'] / 0x2),
        cd['lineTo'](cC - cG + cq, cJ),
        cd['arc'](cC - cG + cq, cG + cJ, cG, 0x3 * Math['PI'] / 0x2, 0x2 * Math['PI']),
        cd['lineTo'](cC + cq, cO + cJ - cG),
        cd['arc'](cC - cG + cq, cO - cG + cJ, cG, 0x0, 0x1 * Math['PI'] / 0x2),
        cd['lineTo'](cG + cq, cO + cJ),
        cd['arc'](cG + cq, cO - cG + cJ, cG, 0x1 * Math['PI'] / 0x2, Math['PI']),
        cd['closePath']();
    }
    function cx (cd, cq, cJ, cC = undefined, cO = false, cG = 0x0, cg = 0x200, cN = 0x100, cP = 0x0, cM = undefined) {
      var cz;
      if (!(null == cC ? undefined : cC['length'])) {
        cC = [];
        for (let H7 = 0x1f4; H7 < 0x2710; H7 += 0x1f4)
          cC['push'](H7);
      }
      let cQ;
      cq[0x0] instanceof Array ? (cQ = [],
        cq['forEach'](H8 => cQ['push']({
          'x': H8[0x0],
          'y': H8[0x1]
        }))) : cQ = cq;
      let cm, cL = (0x0,
        iS['m_'])(cJ);
      cM ? cm = cM : (cm = document['createElement']('canvas'),
        cm['width'] = cg,
        cm['height'] = cN);
      let cR = cm['getContext']('2d');
      const H0 = cc(cQ, cd['gridOptions']['xDelta'], cd['gridOptions']['yDelta']);
      if (!(null === (cz = H0['posMap']) || undefined === cz ? undefined : cz['length']))
        return;
      const H1 = H8 => Math['floor'](H8 / cg * (H0['posMap']['length'] - 0x1));
      let H2 = (H8, H9, Hv, HA) => {
        HA = null != HA ? HA : cd['gridOptions']['zValues'];
        const Hk = (0x1 - H8 / cN) * (cC[cC['length'] - 0x1] - cC[0x0]) + cC[0x0];
        let Hl = HA['length'] - 0x1
          , HK = HA['length'] - 0x1
          , Hb = 0x0;
        if (!(Hk < HA[0x0] || Hk > HA[HA['length'] - 0x1])) {
          for (let Hc = 0x0; Hc < HA['length']; Hc++)
            if (Hk <= parseFloat(HA[Hc])) {
              HK = Math['max'](0x0, Hc - 0x1),
                Hl = Hc,
                Hb = HK === Hl ? 0x0 : (Hk - HA[HK]) / (HA[Hl] - HA[HK]);
              break;
            }
          return {
            'upper': Hl,
            'lower': HK,
            'weight': Hb
          };
        }
      }
        ;
      if (cO) {
        const H8 = {}
          , H9 = new ck(cd['centerLon'](), cd['centerLat'](), null != cG ? cG : 0x0, cd['gridOptions']['xSize'], cd['gridOptions']['ySize'], 0x1)
          , Hv = H2;
        H2 = (HA, Hk, Hl) => {
          const HK = Hk['toFixed'](0x3) + '_' + Hl['toFixed'](0x3)
            , Hb = cd['gridOptions']['zValues']['map'](Hc => {
              const HH = HK + '_' + Hc['toFixed'](0x3);
              if (H8[HH])
                return H8[HH]['H'];
              const Hx = {};
              return H9['gps_to_tilt'](Hk, Hl, Hc, Hx),
                Hx['H'] = 0x3e8 * Hx['H'],
                H8[HH] = Hx,
                Hx['H'];
            }
            );
          return Hv(HA, Hk, Hl, Hb);
        }
          ;
      }
      let H3 = cR['getImageData'](0x0, 0x0, cg, cN)
        , H4 = -0x4
        , H5 = -0x1 / 0x0
        , H6 = 0x1 / 0x0;
      for (let HA = 0x0; HA < cN; HA++)
        for (let Hk = 0x0; Hk < cg; Hk++) {
          let Hl = H1(Hk);
          H4 += 0x4;
          const HK = H0['posMap'][Hl]
            , Hb = (0x0,
              Kz['tr'])(cd['gridOptions']['xStart'], cd['gridOptions']['xDelta'], HK['x'])
            , Hc = (0x0,
              Kz['tr'])(cd['gridOptions']['yStart'], cd['gridOptions']['yDelta'], HK['y']);
          if (Hb < 0x0 || Hc < 0x0 || Hb >= cd['gridOptions']['xSize'] || Hc >= cd['gridOptions']['ySize']) {
            H3['data'][H4] = 0x0,
              H3['data'][H4 + 0x1] = 0x0,
              H3['data'][H4 + 0x2] = 0x0,
              H3['data'][H4 + 0x3] = 0x0;
            continue;
          }
          let HH = H2(HA, HK['x'], HK['y']);
          if (!HH) {
            H3['data'][H4] = 0x0,
              H3['data'][H4 + 0x1] = 0x0,
              H3['data'][H4 + 0x2] = 0x0,
              H3['data'][H4 + 0x3] = 0x0;
            continue;
          }
          Hk === Math['floor'](cg / 0x2) && Math['floor'](cN / 0x2);
          const Hx = cd['getGrid'](cP, HH['lower'])
            , Hp = cd['getGrid'](cP, HH['upper'])
            , HF = Hx['getPos'](Hc, Hb);
          let Hy = Hx['read1D'](HF)
            , Hw = Hp['read1D'](HF);
          const Hh = Hx['isUndef'](Hy)
            , Hu = Hp['isUndef'](Hw);
          let HY, HT = false;
          Hh || Hu ? (HT = true,
            HY = Hx['undef']) : HY = Hy * (0x1 - HH['weight']) + Hw * HH['weight'],
            HT || (HY > H5 && (H5 = HY),
              HY < H6 && (H6 = HY));
          let HX = cL['getRule'](HY)['stop'];
          if (!(HX instanceof id['t']))
            return v0['kg']['warn']('颜色规则中的颜色配置有误'),
              v0['kg']['warn'](HX),
            {
              'canvas': cm,
              'path': H0['posMap'],
              'maxVal': H5,
              'minVal': H6
            };
          H3['data'][H4] = HX['red'](),
            H3['data'][H4 + 0x1] = HX['green'](),
            H3['data'][H4 + 0x2] = HX['blue'](),
            H3['data'][H4 + 0x3] = Math['floor'](0xff * HX['alpha']());
        }
      return cR['putImageData'](H3, 0x0, 0x0),
      {
        'canvas': cm,
        'path': H0['posMap'],
        'maxVal': H5,
        'minVal': H6,
        'outputZValues': cC
      };
    }
    function cp (cd, cq, cJ, cC = 0x200, cO = 0x100, cG = -0x1, cg = 0x0, cN = undefined) {
      var cP;
      let cM;
      cq[0x0] instanceof Array ? (cM = [],
        cq['forEach'](H5 => cM['push']({
          'x': H5[0x0],
          'y': H5[0x1]
        }))) : cM = cq;
      let cz, cQ = (0x0,
        iS['m_'])(cJ);
      cN ? cz = cN : (cz = document['createElement']('canvas'),
        cz['width'] = cC,
        cz['height'] = cO);
      let cm = cz['getContext']('2d');
      const cL = cc(cM, cd['gridOptions']['xDelta'], cd['gridOptions']['yDelta']);
      if (!(null === (cP = cL['posMap']) || undefined === cP ? undefined : cP['length']))
        return;
      const cR = H5 => Math['floor'](H5 / cC * (cL['posMap']['length'] - 0x1));
      let H0 = H5 => Math['floor']((0x1 - H5 / cO) * (cd['gridOptions']['zValues']['length'] - 0x1));
      cG > parseFloat(cd['gridOptions']['zValues'][0x0]) && (H0 = H5 => {
        const H6 = (0x1 - H5 / cO) * cG;
        for (let H7 = 0x0; H7 < cd['gridOptions']['zValues']['length']; H7++)
          if (H6 < parseFloat(cd['gridOptions']['zValues'][H7]))
            return H7;
        return cd['gridOptions']['zValues']['length'] - 0x1;
      }
      );
      let H1 = cm['getImageData'](0x0, 0x0, cC, cO)
        , H2 = -0x4
        , H3 = -0x1 / 0x0
        , H4 = 0x1 / 0x0;
      for (let H5 = 0x0; H5 < cO; H5++) {
        let H6 = H0(H5);
        for (let H7 = 0x0; H7 < cC; H7++) {
          H2 += 0x4;
          let H8 = cR(H7);
          const H9 = cd['getGrid'](cg, H6)
            , Hv = cL['posMap'][H8]
            , HA = (0x0,
              Kz['tr'])(cd['gridOptions']['xStart'], cd['gridOptions']['xDelta'], Hv['x'])
            , Hk = (0x0,
              Kz['tr'])(cd['gridOptions']['yStart'], cd['gridOptions']['yDelta'], Hv['y']);
          if (HA < 0x0 || Hk < 0x0 || HA >= H9['xSize'] || Hk >= H9['ySize']) {
            H1['data'][H2] = 0x0,
              H1['data'][H2 + 0x1] = 0x0,
              H1['data'][H2 + 0x2] = 0x0,
              H1['data'][H2 + 0x3] = 0x0;
            continue;
          }
          let Hl = H9['read2D'](Hk, HA);
          H9['isUndef'](Hl) || (Hl > H3 && (H3 = Hl),
            Hl < H4 && (H4 = Hl));
          let HK = cQ['getRule'](Hl)['stop'];
          if (!(HK instanceof id['t']))
            return v0['kg']['warn']('颜色规则中的颜色配置有误'),
              v0['kg']['warn'](HK),
            {
              'canvas': cz,
              'path': cL['posMap'],
              'maxVal': H3,
              'minVal': H4
            };
          H1['data'][H2] = HK['red'](),
            H1['data'][H2 + 0x1] = HK['green'](),
            H1['data'][H2 + 0x2] = HK['blue'](),
            H1['data'][H2 + 0x3] = Math['floor'](0xff * HK['alpha']());
        }
      }
      return cm['putImageData'](H1, 0x0, 0x0),
      {
        'canvas': cz,
        'path': cL['posMap'],
        'maxVal': H3,
        'minVal': H4
      };
    }
    var cF = n(0xfb);
    const cy = ['0', '1', '2', '3', '4', '5', '6', '7']
      , cw = ['1', '2', '3', '4']
      , ch = ['0', '1', '2', '3']
      , cu = {
        'tdt': 'c4f61f8b0b036ff262d8b480fa826711',
        'zkxt': '8a2174987fca73490355324d79908f10d36d7d114759abd832eb1fc5fb1d105d'
      }
      , cY = {
        'tdtSatellite': 'tdtSatellite',
        'tdtSatelliteAnnotation': 'tdtSatelliteAnnotation',
        'tdtNormal': 'tdtNormal',
        'tdtNormalAnnotation': 'tdtNormalAnnotation',
        'tdtBounds': 'tdtBounds',
        'tdtTerrain': 'tdtTerrain',
        'tdtTerrainAnnotation': 'tdtTerrainAnnotation',
        'gdSatellite': 'gdSatellite',
        'gdSatelliteAnnotation': 'gdSatelliteAnnotation',
        'gdNormal': 'gdNormal',
        'gdWarm': 'gdWarm',
        'geoQNormal': 'geoQNormal',
        'geoQPurplishBlue': 'geoQPurplishBlue',
        'geoQGray': 'geoQGray',
        'geoQWarm': 'geoQWarm',
        'geoQBoundary': 'geoQBoundary',
        'geoQWater': 'geoQWater',
        'tencentStreet': 'tencentStreet',
        'tencentDem': 'tencentDem',
        'tencentAnnotation': 'tencentAnnotation',
        'stamenTerrain': 'stamenTerrain',
        'stamenWaterColor': 'stamenWaterColor',
        'esriSate': 'esriSate',
        'esriTerrain': 'esriTarrain',
        'esriShaded': 'esriShaded',
        'mtb': 'mtb',
        'nasaNight': 'nasaNight',
        'windy': 'windy',
        'vectorTop': 'vectorTop',
        'zkxtNormal': 'zkxtNormal',
        'zkxtTerrain': 'zkxtTerrain',
        'zkxtSatellite': 'zkxtSatellite',
        'zkxtSatelliteAnnotation': 'zkxtSatelliteAnnotation',
        'zkxtTerrainAnnotation': 'zkxtTerrainAnnotation'
      }
      , cT = {};
    function cX (cd, cq) {
      cY[cd] = cd,
        cT[cd] = cq;
    }
    function cE (cd) {
      let cq = {
        'url': 'https://t{s}.tianditu.gov.cn/DataServer?T=img_w&X={x}&Y={y}&L={z}&tk=' + cu['tdt'],
        'subdomains': cy
      };
      switch (cd) {
        case cY['tdtSatellite']:
          break;
        case cY['tdtSatelliteAnnotation']:
          cq = {
            'url': 'https://t{s}.tianditu.gov.cn/DataServer?T=cia_w&X={x}&Y={y}&L={z}&tk=' + cu['tdt'],
            'subdomains': cy
          };
          break;
        case cY['tdtNormal']:
          cq = {
            'url': 'https://t{s}.tianditu.gov.cn/DataServer?T=vec_w&X={x}&Y={y}&L={z}&tk=' + cu['tdt'],
            'subdomains': cy
          };
          break;
        case cY['tdtNormalAnnotation']:
          cq = {
            'url': 'https://t{s}.tianditu.gov.cn/DataServer?T=cva_w&X={x}&Y={y}&L={z}&tk=' + cu['tdt'],
            'subdomains': cy
          };
          break;
        case cY['tdtTerrain']:
          cq = {
            'url': 'https://t{s}.tianditu.gov.cn/DataServer?T=ter_w&X={x}&Y={y}&L={z}&tk=' + cu['tdt'],
            'subdomains': cy
          };
          break;
        case cY['tdtTerrainAnnotation']:
          cq = {
            'url': 'https://t{s}.tianditu.gov.cn/DataServer?T=cta_w&X={x}&Y={y}&L={z}&tk=' + cu['tdt'],
            'subdomains': cy
          };
          break;
        case cY['tdtBounds']:
          cq = {
            'url': 'https://t{s}.tianditu.gov.cn/ibo_w/wmts?service=wmts&request=GetTile&version=1.0.0&LAYER=ibo&tileMatrixSet=w&TileMatrix={z}&TileRow={y}&TileCol={x}&style=default&format=tiles&tk=' + cu['tdt'],
            'subdomains': cy
          };
          break;
        case cY['gdSatellite']:
          cq = {
            'url': 'https://webst0{s}.is.autonavi.com/appmaptile?style=6&x={x}&y={y}&z={z}',
            'subdomains': cw
          };
          break;
        case cY['gdSatelliteAnnotation']:
          cq = {
            'url': 'https://webst0{s}.is.autonavi.com/appmaptile?style=8&x={x}&y={y}&z={z}',
            'subdomains': cw
          };
          break;
        case cY['gdNormal']:
          cq = {
            'url': 'https://webrd0{s}.is.autonavi.com/appmaptile?lang=zh_cn&size=1&scale=1&style=8&x={x}&y={y}&z={z}',
            'subdomains': cw
          };
          break;
        case cY['gdWarm']:
          cq = {
            'url': 'https://webrd0{s}.is.autonavi.com/appmaptile?lang=zh_cn&size=1&scale=1&style=7&x={x}&y={y}&z={z}',
            'subdomains': cw
          };
          break;
        case cY['geoQNormal']:
          cq = {
            'url': 'https://mapnew.geoq.cn/ArcGIS/rest/services/ChinaOnlineCommunity/MapServer/tile/{z}/{y}/{x}'
          };
          break;
        case cY['geoQPurplishBlue']:
          cq = {
            'url': 'https://mapnew.geoq.cn/ArcGIS/rest/services/ChinaOnlineStreetPurplishBlue/MapServer/tile/{z}/{y}/{x}'
          };
          break;
        case cY['geoQGray']:
          cq = {
            'url': 'https://mapnew.geoq.cn/ArcGIS/rest/services/ChinaOnlineStreetGray/MapServer/tile/{z}/{y}/{x}'
          };
          break;
        case cY['geoQWarm']:
          cq = {
            'url': 'https://mapnew.geoq.cn/ArcGIS/rest/services/ChinaOnlineStreetWarm/MapServer/tile/{z}/{y}/{x}'
          };
          break;
        case cY['geoQBoundary']:
          cq = {
            'url': 'https://thematic.geoq.cn/arcgis/rest/services/ThematicMaps/administrative_division_boundaryandlabel/MapServer/tile/{z}/{y}/{x}'
          };
          break;
        case cY['geoQWater']:
          cq = {
            'url': 'https://thematic.geoq.cn/arcgis/rest/services/ThematicMaps/WorldHydroMap/MapServer/tile/{z}/{y}/{x}'
          };
          break;
        case cY['tencentStreet']:
          cq = {
            'url': 'https://rt{s}.map.gtimg.com/realtimerender?z={z}&x={x}&y={y}&type=vector&style=0',
            'subdomains': ch,
            'tms': true
          };
          break;
        case cY['tencentDem']:
          cq = {
            'url': 'https://p{s}.map.gtimg.com/demTiles/{z}/{x}/{y}/{x}_{y}.jpg',
            'subdomains': ch,
            'tms': true
          };
          break;
        case cY['tencentAnnotation']:
          cq = {
            'url': 'https://rt{s}.map.gtimg.com/tile?z={z}&x={x}&y={y}&styleid=2&version=837',
            'subdomains': ch,
            'tms': true
          };
          break;
        case cY['stamenTerrain']:
          cq = {
            'url': 'https://stamen-tiles-{s}.a.ssl.fastly.net/terrain-background/{z}/{x}/{y}{r}.{ext}',
            'subdomains': 'abcd',
            'minZoom': 0x0,
            'maxZoom': 0x12,
            'ext': 'png'
          };
          break;
        case cY['stamenWaterColor']:
          cq = {
            'url': 'https://stamen-tiles-{s}.a.ssl.fastly.net/terrain-background/{z}/{x}/{y}{r}.{ext}',
            'subdomains': 'abcd',
            'minZoom': 0x1,
            'maxZoom': 0x10,
            'ext': 'jpg'
          };
          break;
        case cY['esriSate']:
          cq = {
            'url': 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'
          };
          break;
        case cY['esriShaded']:
          cq = {
            'url': 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Shaded_Relief/MapServer/tile/{z}/{y}/{x}'
          };
          break;
        case cY['esriTerrain']:
          cq = {
            'url': 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Terrain_Base/MapServer/tile/{z}/{y}/{x}'
          };
          break;
        case cY['mtb']:
          cq = {
            'url': 'https://tile.mtbmap.cz/mtbmap_tiles/{z}/{x}/{y}.png'
          };
          break;
        case cY['nasaNight']:
          cq = {
            'url': 'https://map1.vis.earthdata.nasa.gov/wmts-webmerc/VIIRS_CityLights_2012/default/{time}/{tilematrixset}{maxZoom}/{z}/{y}/{x}.{format}',
            'bounds': [[-85.0511287776, -179.999999975], [85.0511287776, 179.999999975]],
            'minZoom': 0x1,
            'maxZoom': 0x8,
            'format': 'jpg',
            'time': '',
            'tilematrixset': 'GoogleMapsCompatible_Level'
          };
          break;
        case cY['vectorTop']:
          cq = {
            'url': 'https://qefiles.91weather.com/cdn-repo/mlog/cloud/terrain/tile/gaode/d461a96842e24b958142f84c3051e588/{z}/{x}_{y}.png'
          };
          break;
        case cY['zkxtNormal']:
          cq = {
            'url': 'https://tiles{s}.geovisearth.com/base/v1/vec/{z}/{x}/{y}?format=webp&tmsIds=w&token=' + cu['zkxt'],
            'subdomains': ['1', '2', '3']
          };
          break;
        case cY['zkxtSatellite']:
          cq = {
            'url': 'https://tiles{s}.geovisearth.com/base/v1/img/{z}/{x}/{y}?format=webp&tmsIds=w&token=' + cu['zkxt'],
            'subdomains': ['1', '2', '3']
          };
          break;
        case cY['zkxtSatelliteAnnotation']:
          cq = {
            'url': 'https://tiles{s}.geovisearth.com/base/v1/cia/{z}/{x}/{y}?format=webp&tmsIds=w&token=' + cu['zkxt'],
            'subdomains': ['1', '2', '3']
          };
          break;
        case cY['zkxtTerrain']:
          cq = {
            'url': 'https://tiles{s}.geovisearth.com/base/v1/ter/{z}/{x}/{y}?format=webp&tmsIds=w&token=' + cu['zkxt'],
            'subdomains': ['1', '2', '3']
          };
          break;
        case cY['zkxtTerrainAnnotation']:
          cq = {
            'url': 'https://tiles{s}.geovisearth.com/base/v1/cat/{z}/{x}/{y}?format=webp&tmsIds=w&token=' + cu['zkxt'],
            'subdomains': ['1', '2', '3']
          };
          break;
        case cY['windy']:
          cq = {
            'url': 'https://tiles.windy.com/tiles/v10.0/darkmap/{z}/{x}/{y}.png'
          };
          break;
        default:
          cT[cd] && (cq = cT[cd]);
      }
      return cq;
    }
    const cf = {
      'code': '%8C%C6%DE%CC%CE%B0%A6%D3%E6%DC%u4E92%u9CE4%uA007%uDE86%uFF81%u7154%u788D%uE4E3%uC0A8%uCA6E%u7548%9C%9Cc%B2%DF%E9%EB%DB%D0%CF%DC%B4%u8CA1%u1BF2%u0962%uDC51%u62A0%9C%9C%u5566%uCA6E%uD8B0%uCACB%uF33A%u0C4B%uFD4F%uDCA9%uAF8F%u4EFB%uFF87%DC%D5%C7%CF%D5%C9%C3%D0'
    };
    function cW (cd) {
      cd = unescape(cd);
      for (var cq = String['fromCharCode'](cd['charCodeAt'](0x0) - cd['length']), cJ = 0x1; cJ < cd['length']; cJ++)
        cq += String['fromCharCode'](cd['charCodeAt'](cJ) - cq['charCodeAt'](cJ - 0x1));
      return cq;
    }
    var cI = function (cd, cq, cJ, cC) {
      return new (cJ || (cJ = Promise))(function (cO, cG) {
        function cg (cM) {
          try {
            cP(cC['next'](cM));
          } catch (cz) {
            cG(cz);
          }
        }
        function cN (cM) {
          try {
            cP(cC['throw'](cM));
          } catch (cz) {
            cG(cz);
          }
        }
        function cP (cM) {
          var cz;
          cM['done'] ? cO(cM['value']) : (cz = cM['value'],
            cz instanceof cJ ? cz : new cJ(function (cQ) {
              cQ(cz);
            }
            ))['then'](cg, cN);
        }
        cP((cC = cC['apply'](cd, cq || []))['next']());
      }
      );
    };
    let cj = false;
    function cV (cd, cq = true) {
      if (cj) return

      cj = true,
        iH(),
        ih(),
        (0x0,
          v0['qr'])(),
        false === cq && cB();
    }
    function cB () { }
  }
  )(),
    k;
}
)());
