!function(v, A) {
  'object' == typeof exports && 'object' == typeof module ? module['exports'] = A() : 'function' == typeof define && define['amd'] ? define([], A) : 'object' == typeof exports ? exports['QE'] = A() : v['QE'] = A();
}(self, ()=>(()=>{
  var v = {
      0x399: l=>{
          function K(i) {
              var b = new Error('Cannot\x20find\x20module\x20\x27' + i + '\x27');
              throw b['code'] = 'MODULE_NOT_FOUND',
              b;
          }
          K['keys'] = ()=>[],
          K['resolve'] = K,
          K['id'] = 0x399,
          l['exports'] = K;
      }
      ,
      0x17a: (l,K,i)=>{
          l['exports'] = function b(c, H, x) {
              function p(w, Y) {
                  if (!H[w]) {
                      if (!c[w]) {
                          if (!Y && i(0x399))
                              return require(w, !0);
                          if (F)
                              return F(w, true);
                          var T = new Error('Cannot\x20find\x20module\x20\x27' + w + '\x27');
                          throw T['code'] = 'MODULE_NOT_FOUND',
                          T;
                      }
                      var X = H[w] = {
                          'exports': {}
                      };
                      c[w][0x0]['call'](X['exports'], function(E) {
                          return p(c[w][0x1][E] || E);
                      }, X, X['exports'], b, c, H, x);
                  }
                  return H[w]['exports'];
              }
              for (var F = undefined, y = 0x0; y < x['length']; y++)
                  p(x[y]);
              return p;
          }({
              0x1: [function(c, H, x) {
                  'use strict';
                  var p = c('./utils')
                    , F = c('./support')
                    , y = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
                  x['encode'] = function(w) {
                      for (var Y, T, X, E, W, I, j, D = [], V = 0x0, Z = w['length'], B = Z, S = 'string' !== p['getTypeOf'](w); V < w['length']; )
                          B = Z - V,
                          X = S ? (Y = w[V++],
                          T = V < Z ? w[V++] : 0x0,
                          V < Z ? w[V++] : 0x0) : (Y = w['charCodeAt'](V++),
                          T = V < Z ? w['charCodeAt'](V++) : 0x0,
                          V < Z ? w['charCodeAt'](V++) : 0x0),
                          E = Y >> 0x2,
                          W = (0x3 & Y) << 0x4 | T >> 0x4,
                          I = 0x1 < B ? (0xf & T) << 0x2 | X >> 0x6 : 0x40,
                          j = 0x2 < B ? 0x3f & X : 0x40,
                          D['push'](y['charAt'](E) + y['charAt'](W) + y['charAt'](I) + y['charAt'](j));
                      return D['join']('');
                  }
                  ,
                  x['decode'] = function(w) {
                      var Y, T, X, E, W, I, j = 0x0, D = 0x0, V = 'data:';
                      if (w['substr'](0x0, 0x5) === V)
                          throw new Error('Invalid\x20base64\x20input,\x20it\x20looks\x20like\x20a\x20data\x20url.');
                      var Z, B = 0x3 * (w = w['replace'](/[^A-Za-z0-9+/=]/g, ''))['length'] / 0x4;
                      if (w['charAt'](w['length'] - 0x1) === y['charAt'](0x40) && B--,
                      w['charAt'](w['length'] - 0x2) === y['charAt'](0x40) && B--,
                      B % 0x1 != 0x0)
                          throw new Error('Invalid\x20base64\x20input,\x20bad\x20content\x20length.');
                      for (Z = F['uint8array'] ? new Uint8Array(0x0 | B) : new Array(0x0 | B); j < w['length']; )
                          Y = y['indexOf'](w['charAt'](j++)) << 0x2 | (E = y['indexOf'](w['charAt'](j++))) >> 0x4,
                          T = (0xf & E) << 0x4 | (W = y['indexOf'](w['charAt'](j++))) >> 0x2,
                          X = (0x3 & W) << 0x6 | (I = y['indexOf'](w['charAt'](j++))),
                          Z[D++] = Y,
                          0x40 !== W && (Z[D++] = T),
                          0x40 !== I && (Z[D++] = X);
                      return Z;
                  }
                  ;
              }
              , {
                  './support': 0x1e,
                  './utils': 0x20
              }],
              0x2: [function(c, H, x) {
                  'use strict';
                  var p = c('./external')
                    , F = c('./stream/DataWorker')
                    , y = c('./stream/Crc32Probe')
                    , w = c('./stream/DataLengthProbe');
                  function h(u, Y, T, X, E) {
                      this['compressedSize'] = u,
                      this['uncompressedSize'] = Y,
                      this['crc32'] = T,
                      this['compression'] = X,
                      this['compressedContent'] = E;
                  }
                  h['prototype'] = {
                      'getContentWorker': function() {
                          var u = new F(p['Promise']['resolve'](this['compressedContent']))['pipe'](this['compression']['uncompressWorker']())['pipe'](new w('data_length'))
                            , Y = this;
                          return u['on']('end', function() {
                              if (this['streamInfo']['data_length'] !== Y['uncompressedSize'])
                                  throw new Error('Bug\x20:\x20uncompressed\x20data\x20size\x20mismatch');
                          }),
                          u;
                      },
                      'getCompressedWorker': function() {
                          return new F(p['Promise']['resolve'](this['compressedContent']))['withStreamInfo']('compressedSize', this['compressedSize'])['withStreamInfo']('uncompressedSize', this['uncompressedSize'])['withStreamInfo']('crc32', this['crc32'])['withStreamInfo']('compression', this['compression']);
                      }
                  },
                  h['createWorkerFrom'] = function(u, Y, T) {
                      return u['pipe'](new y())['pipe'](new w('uncompressedSize'))['pipe'](Y['compressWorker'](T))['pipe'](new w('compressedSize'))['withStreamInfo']('compression', Y);
                  }
                  ,
                  H['exports'] = h;
              }
              , {
                  './external': 0x6,
                  './stream/Crc32Probe': 0x19,
                  './stream/DataLengthProbe': 0x1a,
                  './stream/DataWorker': 0x1b
              }],
              0x3: [function(c, H, x) {
                  'use strict';
                  var p = c('./stream/GenericWorker');
                  x['STORE'] = {
                      'magic': '\x00\x00',
                      'compressWorker': function() {
                          return new p('STORE\x20compression');
                      },
                      'uncompressWorker': function() {
                          return new p('STORE\x20decompression');
                      }
                  },
                  x['DEFLATE'] = c('./flate');
              }
              , {
                  './flate': 0x7,
                  './stream/GenericWorker': 0x1c
              }],
              0x4: [function(c, H, x) {
                  'use strict';
                  var p = c('./utils')
                    , F = function() {
                      for (var y, w = [], s = 0x0; s < 0x100; s++) {
                          y = s;
                          for (var h = 0x0; h < 0x8; h++)
                              y = 0x1 & y ? 0xedb88320 ^ y >>> 0x1 : y >>> 0x1;
                          w[s] = y;
                      }
                      return w;
                  }();
                  H['exports'] = function(y, w) {
                      return undefined !== y && y['length'] ? 'string' !== p['getTypeOf'](y) ? function(h, u, Y, T) {
                          var X = F
                            , E = 0x0 + Y;
                          h ^= -0x1;
                          for (var f = 0x0; f < E; f++)
                              h = h >>> 0x8 ^ X[0xff & (h ^ u[f])];
                          return -0x1 ^ h;
                      }(0x0 | w, y, y['length']) : function(h, u, Y, T) {
                          var X = F
                            , E = 0x0 + Y;
                          h ^= -0x1;
                          for (var f = 0x0; f < E; f++)
                              h = h >>> 0x8 ^ X[0xff & (h ^ u['charCodeAt'](f))];
                          return -0x1 ^ h;
                      }(0x0 | w, y, y['length']) : 0x0;
                  }
                  ;
              }
              , {
                  './utils': 0x20
              }],
              0x5: [function(c, H, x) {
                  'use strict';
                  x['base64'] = false,
                  x['binary'] = false,
                  x['dir'] = false,
                  x['createFolders'] = true,
                  x['date'] = null,
                  x['compression'] = null,
                  x['compressionOptions'] = null,
                  x['comment'] = null,
                  x['unixPermissions'] = null,
                  x['dosPermissions'] = null;
              }
              , {}],
              0x6: [function(c, H, x) {
                  'use strict';
                  var p;
                  p = 'undefined' != typeof Promise ? Promise : c('lie'),
                  H['exports'] = {
                      'Promise': p
                  };
              }
              , {
                  'lie': 0x25
              }],
              0x7: [function(c, H, x) {
                  'use strict';
                  var p = 'undefined' != typeof Uint8Array && 'undefined' != typeof Uint16Array && 'undefined' != typeof Uint32Array
                    , F = c('pako')
                    , y = c('./utils')
                    , w = c('./stream/GenericWorker')
                    , h = p ? 'uint8array' : 'array';
                  function u(Y, T) {
                      w['call'](this, 'FlateWorker/' + Y),
                      this['_pako'] = null,
                      this['_pakoAction'] = Y,
                      this['_pakoOptions'] = T,
                      this['meta'] = {};
                  }
                  x['magic'] = '\x08\x00',
                  y['inherits'](u, w),
                  u['prototype']['processChunk'] = function(Y) {
                      this['meta'] = Y['meta'],
                      null === this['_pako'] && this['_createPako'](),
                      this['_pako']['push'](y['transformTo'](h, Y['data']), false);
                  }
                  ,
                  u['prototype']['flush'] = function() {
                      w['prototype']['flush']['call'](this),
                      null === this['_pako'] && this['_createPako'](),
                      this['_pako']['push']([], true);
                  }
                  ,
                  u['prototype']['cleanUp'] = function() {
                      w['prototype']['cleanUp']['call'](this),
                      this['_pako'] = null;
                  }
                  ,
                  u['prototype']['_createPako'] = function() {
                      this['_pako'] = new F[this['_pakoAction']]({
                          'raw': true,
                          'level': this['_pakoOptions']['level'] || -0x1
                      });
                      var Y = this;
                      this['_pako']['onData'] = function(T) {
                          Y['push']({
                              'data': T,
                              'meta': Y['meta']
                          });
                      }
                      ;
                  }
                  ,
                  x['compressWorker'] = function(Y) {
                      return new u('Deflate',Y);
                  }
                  ,
                  x['uncompressWorker'] = function() {
                      return new u('Inflate',{});
                  }
                  ;
              }
              , {
                  './stream/GenericWorker': 0x1c,
                  './utils': 0x20,
                  'pako': 0x26
              }],
              0x8: [function(c, H, x) {
                  'use strict';
                  function p(f, W) {
                      var I, j = '';
                      for (I = 0x0; I < W; I++)
                          j += String['fromCharCode'](0xff & f),
                          f >>>= 0x8;
                      return j;
                  }
                  function F(W, j, V, Z, B, U) {
                      var q, J, G = W['file'], N = W['compression'], M = U !== Y['utf8encode'], z = y['transformTo']('string', U(G['name'])), Q = y['transformTo']('string', Y['utf8encode'](G['name'])), R = G['comment'], v0 = y['transformTo']('string', U(R)), v1 = y['transformTo']('string', Y['utf8encode'](R)), v2 = Q['length'] !== G['name']['length'], v3 = v1['length'] !== R['length'], v4 = '', v5 = '', v6 = '', v7 = G['dir'], v8 = G['date'], v9 = {
                          'crc32': 0x0,
                          'compressedSize': 0x0,
                          'uncompressedSize': 0x0
                      };
                      j && !V || (v9['crc32'] = W['crc32'],
                      v9['compressedSize'] = W['compressedSize'],
                      v9['uncompressedSize'] = W['uncompressedSize']);
                      var vv = 0x0;
                      j && (vv |= 0x8),
                      M || !v2 && !v3 || (vv |= 0x800);
                      var vA = 0x0
                        , vn = 0x0;
                      v7 && (vA |= 0x10),
                      'UNIX' === B ? (vn = 0x31e,
                      vA |= function(vl, vK) {
                          var vi = vl;
                          return vl || (vi = vK ? 0x41fd : 0x81b4),
                          (0xffff & vi) << 0x10;
                      }(G['unixPermissions'], v7)) : (vn = 0x14,
                      vA |= function(vl) {
                          return 0x3f & (vl || 0x0);
                      }(G['dosPermissions'])),
                      q = v8['getUTCHours'](),
                      q <<= 0x6,
                      q |= v8['getUTCMinutes'](),
                      q <<= 0x5,
                      q |= v8['getUTCSeconds']() / 0x2,
                      J = v8['getUTCFullYear']() - 0x7bc,
                      J <<= 0x4,
                      J |= v8['getUTCMonth']() + 0x1,
                      J <<= 0x5,
                      J |= v8['getUTCDate'](),
                      v2 && (v5 = p(0x1, 0x1) + p(T(z), 0x4) + Q,
                      v4 += 'up' + p(v5['length'], 0x2) + v5),
                      v3 && (v6 = p(0x1, 0x1) + p(T(v0), 0x4) + v1,
                      v4 += 'uc' + p(v6['length'], 0x2) + v6);
                      var vk = '';
                      return vk += '\x0a\x00',
                      vk += p(vv, 0x2),
                      vk += N['magic'],
                      vk += p(q, 0x2),
                      vk += p(J, 0x2),
                      vk += p(v9['crc32'], 0x4),
                      vk += p(v9['compressedSize'], 0x4),
                      vk += p(v9['uncompressedSize'], 0x4),
                      vk += p(z['length'], 0x2),
                      vk += p(v4['length'], 0x2),
                      {
                          'fileRecord': X['LOCAL_FILE_HEADER'] + vk + z + v4,
                          'dirRecord': X['CENTRAL_FILE_HEADER'] + p(vn, 0x2) + vk + p(v0['length'], 0x2) + '\x00\x00\x00\x00' + p(vA, 0x4) + p(Z, 0x4) + z + v4 + v0
                      };
                  }
                  var y = c('../utils')
                    , w = c('../stream/GenericWorker')
                    , Y = c('../utf8')
                    , T = c('../crc32')
                    , X = c('../signature');
                  function E(f, W, I, j) {
                      w['call'](this, 'ZipFileWorker'),
                      this['bytesWritten'] = 0x0,
                      this['zipComment'] = W,
                      this['zipPlatform'] = I,
                      this['encodeFileName'] = j,
                      this['streamFiles'] = f,
                      this['accumulate'] = false,
                      this['contentBuffer'] = [],
                      this['dirRecords'] = [],
                      this['currentSourceOffset'] = 0x0,
                      this['entriesCount'] = 0x0,
                      this['currentFile'] = null,
                      this['_sources'] = [];
                  }
                  y['inherits'](E, w),
                  E['prototype']['push'] = function(f) {
                      var W = f['meta']['percent'] || 0x0
                        , I = this['entriesCount']
                        , j = this['_sources']['length'];
                      this['accumulate'] ? this['contentBuffer']['push'](f) : (this['bytesWritten'] += f['data']['length'],
                      w['prototype']['push']['call'](this, {
                          'data': f['data'],
                          'meta': {
                              'currentFile': this['currentFile'],
                              'percent': I ? (W + 0x64 * (I - j - 0x1)) / I : 0x64
                          }
                      }));
                  }
                  ,
                  E['prototype']['openedSource'] = function(f) {
                      this['currentSourceOffset'] = this['bytesWritten'],
                      this['currentFile'] = f['file']['name'];
                      var W = this['streamFiles'] && !f['file']['dir'];
                      if (W) {
                          var I = F(f, W, false, this['currentSourceOffset'], this['zipPlatform'], this['encodeFileName']);
                          this['push']({
                              'data': I['fileRecord'],
                              'meta': {
                                  'percent': 0x0
                              }
                          });
                      } else
                          this['accumulate'] = true;
                  }
                  ,
                  E['prototype']['closedSource'] = function(f) {
                      this['accumulate'] = false;
                      var W = this['streamFiles'] && !f['file']['dir']
                        , I = F(f, W, true, this['currentSourceOffset'], this['zipPlatform'], this['encodeFileName']);
                      if (this['dirRecords']['push'](I['dirRecord']),
                      W)
                          this['push']({
                              'data': function(j) {
                                  return X['DATA_DESCRIPTOR'] + p(j['crc32'], 0x4) + p(j['compressedSize'], 0x4) + p(j['uncompressedSize'], 0x4);
                              }(f),
                              'meta': {
                                  'percent': 0x64
                              }
                          });
                      else {
                          for (this['push']({
                              'data': I['fileRecord'],
                              'meta': {
                                  'percent': 0x0
                              }
                          }); this['contentBuffer']['length']; )
                              this['push'](this['contentBuffer']['shift']());
                      }
                      this['currentFile'] = null;
                  }
                  ,
                  E['prototype']['flush'] = function() {
                      for (var f = this['bytesWritten'], W = 0x0; W < this['dirRecords']['length']; W++)
                          this['push']({
                              'data': this['dirRecords'][W],
                              'meta': {
                                  'percent': 0x64
                              }
                          });
                      var I = this['bytesWritten'] - f
                        , j = function(D, V, Z, B, S) {
                          var U = y['transformTo']('string', S(B));
                          return X['CENTRAL_DIRECTORY_END'] + '\x00\x00\x00\x00' + p(D, 0x2) + p(D, 0x2) + p(V, 0x4) + p(Z, 0x4) + p(U['length'], 0x2) + U;
                      }(this['dirRecords']['length'], I, f, this['zipComment'], this['encodeFileName']);
                      this['push']({
                          'data': j,
                          'meta': {
                              'percent': 0x64
                          }
                      });
                  }
                  ,
                  E['prototype']['prepareNextSource'] = function() {
                      this['previous'] = this['_sources']['shift'](),
                      this['openedSource'](this['previous']['streamInfo']),
                      this['isPaused'] ? this['previous']['pause']() : this['previous']['resume']();
                  }
                  ,
                  E['prototype']['registerPrevious'] = function(f) {
                      this['_sources']['push'](f);
                      var W = this;
                      return f['on']('data', function(I) {
                          W['processChunk'](I);
                      }),
                      f['on']('end', function() {
                          W['closedSource'](W['previous']['streamInfo']),
                          W['_sources']['length'] ? W['prepareNextSource']() : W['end']();
                      }),
                      f['on']('error', function(I) {
                          W['error'](I);
                      }),
                      this;
                  }
                  ,
                  E['prototype']['resume'] = function() {
                      return !!w['prototype']['resume']['call'](this) && (!this['previous'] && this['_sources']['length'] ? (this['prepareNextSource'](),
                      true) : this['previous'] || this['_sources']['length'] || this['generatedError'] ? undefined : (this['end'](),
                      true));
                  }
                  ,
                  E['prototype']['error'] = function(f) {
                      var W = this['_sources'];
                      if (!w['prototype']['error']['call'](this, f))
                          return false;
                      for (var I = 0x0; I < W['length']; I++)
                          try {
                              W[I]['error'](f);
                          } catch (j) {}
                      return true;
                  }
                  ,
                  E['prototype']['lock'] = function() {
                      w['prototype']['lock']['call'](this);
                      for (var f = this['_sources'], W = 0x0; W < f['length']; W++)
                          f[W]['lock']();
                  }
                  ,
                  H['exports'] = E;
              }
              , {
                  '../crc32': 0x4,
                  '../signature': 0x17,
                  '../stream/GenericWorker': 0x1c,
                  '../utf8': 0x1f,
                  '../utils': 0x20
              }],
              0x9: [function(c, H, x) {
                  'use strict';
                  var p = c('../compressions')
                    , F = c('./ZipFileWorker');
                  x['generateWorker'] = function(y, w, h) {
                      var u = new F(w['streamFiles'],h,w['platform'],w['encodeFileName'])
                        , Y = 0x0;
                      try {
                          y['forEach'](function(T, X) {
                              Y++;
                              var E = function(j, D) {
                                  var V = j || D
                                    , Z = p[V];
                                  if (!Z)
                                      throw new Error(V + '\x20is\x20not\x20a\x20valid\x20compression\x20method\x20!');
                                  return Z;
                              }(X['options']['compression'], w['compression'])
                                , f = X['options']['compressionOptions'] || w['compressionOptions'] || {}
                                , W = X['dir']
                                , I = X['date'];
                              X['_compressWorker'](E, f)['withStreamInfo']('file', {
                                  'name': T,
                                  'dir': W,
                                  'date': I,
                                  'comment': X['comment'] || '',
                                  'unixPermissions': X['unixPermissions'],
                                  'dosPermissions': X['dosPermissions']
                              })['pipe'](u);
                          }),
                          u['entriesCount'] = Y;
                      } catch (T) {
                          u['error'](T);
                      }
                      return u;
                  }
                  ;
              }
              , {
                  '../compressions': 0x3,
                  './ZipFileWorker': 0x8
              }],
              0xa: [function(c, H, x) {
                  'use strict';
                  function p() {
                      if (!(this instanceof p))
                          return new p();
                      if (arguments['length'])
                          throw new Error('The\x20constructor\x20with\x20parameters\x20has\x20been\x20removed\x20in\x20JSZip\x203.0,\x20please\x20check\x20the\x20upgrade\x20guide.');
                      this['files'] = Object['create'](null),
                      this['comment'] = null,
                      this['root'] = '',
                      this['clone'] = function() {
                          var F = new p();
                          for (var y in this)
                              'function' != typeof this[y] && (F[y] = this[y]);
                          return F;
                      }
                      ;
                  }
                  (p['prototype'] = c('./object'))['loadAsync'] = c('./load'),
                  p['support'] = c('./support'),
                  p['defaults'] = c('./defaults'),
                  p['version'] = '3.10.1',
                  p['loadAsync'] = function(F, y) {
                      return new p()['loadAsync'](F, y);
                  }
                  ,
                  p['external'] = c('./external'),
                  H['exports'] = p;
              }
              , {
                  './defaults': 0x5,
                  './external': 0x6,
                  './load': 0xb,
                  './object': 0xf,
                  './support': 0x1e
              }],
              0xb: [function(c, H, x) {
                  'use strict';
                  var p = c('./utils')
                    , F = c('./external')
                    , y = c('./utf8')
                    , w = c('./zipEntries')
                    , h = c('./stream/Crc32Probe')
                    , Y = c('./nodejsUtils');
                  function T(X) {
                      return new F['Promise'](function(E, f) {
                          var W = X['decompressed']['getContentWorker']()['pipe'](new h());
                          W['on']('error', function(I) {
                              f(I);
                          })['on']('end', function() {
                              W['streamInfo']['crc32'] !== X['decompressed']['crc32'] ? f(new Error('Corrupted\x20zip\x20:\x20CRC32\x20mismatch')) : E();
                          })['resume']();
                      }
                      );
                  }
                  H['exports'] = function(X, E) {
                      var f = this;
                      return E = p['extend'](E || {}, {
                          'base64': false,
                          'checkCRC32': false,
                          'optimizedBinaryString': false,
                          'createFolders': false,
                          'decodeFileName': y['utf8decode']
                      }),
                      Y['isNode'] && Y['isStream'](X) ? F['Promise']['reject'](new Error('JSZip\x20can\x27t\x20accept\x20a\x20stream\x20when\x20loading\x20a\x20zip\x20file.')) : p['prepareContent']('the\x20loaded\x20zip\x20file', X, true, E['optimizedBinaryString'], E['base64'])['then'](function(W) {
                          var I = new w(E);
                          return I['load'](W),
                          I;
                      })['then'](function(W) {
                          var I = [F['Promise']['resolve'](W)]
                            , j = W['files'];
                          if (E['checkCRC32']) {
                              for (var D = 0x0; D < j['length']; D++)
                                  I['push'](T(j[D]));
                          }
                          return F['Promise']['all'](I);
                      })['then'](function(W) {
                          for (var I = W['shift'](), j = I['files'], D = 0x0; D < j['length']; D++) {
                              var V = j[D]
                                , Z = V['fileNameStr']
                                , B = p['resolve'](V['fileNameStr']);
                              f['file'](B, V['decompressed'], {
                                  'binary': true,
                                  'optimizedBinaryString': true,
                                  'date': V['date'],
                                  'dir': V['dir'],
                                  'comment': V['fileCommentStr']['length'] ? V['fileCommentStr'] : null,
                                  'unixPermissions': V['unixPermissions'],
                                  'dosPermissions': V['dosPermissions'],
                                  'createFolders': E['createFolders']
                              }),
                              V['dir'] || (f['file'](B)['unsafeOriginalName'] = Z);
                          }
                          return I['zipComment']['length'] && (f['comment'] = I['zipComment']),
                          f;
                      });
                  }
                  ;
              }
              , {
                  './external': 0x6,
                  './nodejsUtils': 0xe,
                  './stream/Crc32Probe': 0x19,
                  './utf8': 0x1f,
                  './utils': 0x20,
                  './zipEntries': 0x21
              }],
              0xc: [function(c, H, x) {
                  'use strict';
                  var p = c('../utils')
                    , F = c('../stream/GenericWorker');
                  function y(w, h) {
                      F['call'](this, 'Nodejs\x20stream\x20input\x20adapter\x20for\x20' + w),
                      this['_upstreamEnded'] = false,
                      this['_bindStream'](h);
                  }
                  p['inherits'](y, F),
                  y['prototype']['_bindStream'] = function(w) {
                      var h = this;
                      (this['_stream'] = w)['pause'](),
                      w['on']('data', function(u) {
                          h['push']({
                              'data': u,
                              'meta': {
                                  'percent': 0x0
                              }
                          });
                      })['on']('error', function(u) {
                          h['isPaused'] ? this['generatedError'] = u : h['error'](u);
                      })['on']('end', function() {
                          h['isPaused'] ? h['_upstreamEnded'] = true : h['end']();
                      });
                  }
                  ,
                  y['prototype']['pause'] = function() {
                      return !!F['prototype']['pause']['call'](this) && (this['_stream']['pause'](),
                      true);
                  }
                  ,
                  y['prototype']['resume'] = function() {
                      return !!F['prototype']['resume']['call'](this) && (this['_upstreamEnded'] ? this['end']() : this['_stream']['resume'](),
                      true);
                  }
                  ,
                  H['exports'] = y;
              }
              , {
                  '../stream/GenericWorker': 0x1c,
                  '../utils': 0x20
              }],
              0xd: [function(c, H, x) {
                  'use strict';
                  var p = c('readable-stream')['Readable'];
                  function F(y, w, s) {
                      p['call'](this, w),
                      this['_helper'] = y;
                      var h = this;
                      y['on']('data', function(u, Y) {
                          h['push'](u) || h['_helper']['pause'](),
                          s && s(Y);
                      })['on']('error', function(u) {
                          h['emit']('error', u);
                      })['on']('end', function() {
                          h['push'](null);
                      });
                  }
                  c('../utils')['inherits'](F, p),
                  F['prototype']['_read'] = function() {
                      this['_helper']['resume']();
                  }
                  ,
                  H['exports'] = F;
              }
              , {
                  '../utils': 0x20,
                  'readable-stream': 0x10
              }],
              0xe: [function(c, H, x) {
                  'use strict';
                  H['exports'] = {
                      'isNode': 'undefined' != typeof Buffer,
                      'newBufferFrom': function(p, F) {
                          if (Buffer['from'] && Buffer['from'] !== Uint8Array['from'])
                              return Buffer['from'](p, F);
                          if ('number' == typeof p)
                              throw new Error('The\x20\x22data\x22\x20argument\x20must\x20not\x20be\x20a\x20number');
                          return new Buffer(p,F);
                      },
                      'allocBuffer': function(p) {
                          if (Buffer['alloc'])
                              return Buffer['alloc'](p);
                          var F = new Buffer(p);
                          return F['fill'](0x0),
                          F;
                      },
                      'isBuffer': function(p) {
                          return Buffer['isBuffer'](p);
                      },
                      'isStream': function(p) {
                          return p && 'function' == typeof p['on'] && 'function' == typeof p['pause'] && 'function' == typeof p['resume'];
                      }
                  };
              }
              , {}],
              0xf: [function(H, x, F) {
                  'use strict';
                  function w(C, O, G) {
                      var N, P = T['getTypeOf'](O), M = T['extend'](G || {}, W);
                      M['date'] = M['date'] || new Date(),
                      null !== M['compression'] && (M['compression'] = M['compression']['toUpperCase']()),
                      'string' == typeof M['unixPermissions'] && (M['unixPermissions'] = parseInt(M['unixPermissions'], 0x8)),
                      M['unixPermissions'] && 0x4000 & M['unixPermissions'] && (M['dir'] = true),
                      M['dosPermissions'] && 0x10 & M['dosPermissions'] && (M['dir'] = true),
                      M['dir'] && (C = S(C)),
                      M['createFolders'] && (N = B(C)) && U['call'](this, N, true);
                      var z = 'string' === P && false === M['binary'] && false === M['base64'];
                      G && undefined !== G['binary'] || (M['binary'] = !z),
                      (O instanceof I && 0x0 === O['uncompressedSize'] || M['dir'] || !O || 0x0 === O['length']) && (M['base64'] = false,
                      M['binary'] = true,
                      O = '',
                      M['compression'] = 'STORE',
                      P = 'string');
                      var Q;
                      Q = O instanceof I || O instanceof X ? O : V['isNode'] && V['isStream'](O) ? new Z(C,O) : T['prepareContent'](C, O, M['binary'], M['optimizedBinaryString'], M['base64']);
                      var L = new j(C,Q,M);
                      this['files'][C] = L;
                  }
                  var Y = H('./utf8')
                    , T = H('./utils')
                    , X = H('./stream/GenericWorker')
                    , E = H('./stream/StreamHelper')
                    , W = H('./defaults')
                    , I = H('./compressedObject')
                    , j = H('./zipObject')
                    , D = H('./generate')
                    , V = H('./nodejsUtils')
                    , Z = H('./nodejs/NodejsStreamInputAdapter')
                    , B = function(C) {
                      '/' === C['slice'](-0x1) && (C = C['substring'](0x0, C['length'] - 0x1));
                      var O = C['lastIndexOf']('/');
                      return 0x0 < O ? C['substring'](0x0, O) : '';
                  }
                    , S = function(C) {
                      return '/' !== C['slice'](-0x1) && (C += '/'),
                      C;
                  }
                    , U = function(C, O) {
                      return O = undefined !== O ? O : W['createFolders'],
                      C = S(C),
                      this['files'][C] || w['call'](this, C, null, {
                          'dir': true,
                          'createFolders': O
                      }),
                      this['files'][C];
                  };
                  function q(C) {
                      return '[object\x20RegExp]' === Object['prototype']['toString']['call'](C);
                  }
                  var J = {
                      'load': function() {
                          throw new Error('This\x20method\x20has\x20been\x20removed\x20in\x20JSZip\x203.0,\x20please\x20check\x20the\x20upgrade\x20guide.');
                      },
                      'forEach': function(C) {
                          var O, G, N;
                          for (O in this['files'])
                              N = this['files'][O],
                              (G = O['slice'](this['root']['length'], O['length'])) && O['slice'](0x0, this['root']['length']) === this['root'] && C(G, N);
                      },
                      'filter': function(C) {
                          var O = [];
                          return this['forEach'](function(G, N) {
                              C(G, N) && O['push'](N);
                          }),
                          O;
                      },
                      'file': function(C, O, G) {
                          if (0x1 !== arguments['length'])
                              return C = this['root'] + C,
                              w['call'](this, C, O, G),
                              this;
                          if (q(C)) {
                              var N = C;
                              return this['filter'](function(M, z) {
                                  return !z['dir'] && N['test'](M);
                              });
                          }
                          var P = this['files'][this['root'] + C];
                          return P && !P['dir'] ? P : null;
                      },
                      'folder': function(C) {
                          if (!C)
                              return this;
                          if (q(C))
                              return this['filter'](function(P, M) {
                                  return M['dir'] && C['test'](P);
                              });
                          var O = this['root'] + C
                            , G = U['call'](this, O)
                            , N = this['clone']();
                          return N['root'] = G['name'],
                          N;
                      },
                      'remove': function(C) {
                          C = this['root'] + C;
                          var O = this['files'][C];
                          if (O || ('/' !== C['slice'](-0x1) && (C += '/'),
                          O = this['files'][C]),
                          O && !O['dir'])
                              delete this['files'][C];
                          else {
                              for (var G = this['filter'](function(P, M) {
                                  return M['name']['slice'](0x0, C['length']) === C;
                              }), N = 0x0; N < G['length']; N++)
                                  delete this['files'][G[N]['name']];
                          }
                          return this;
                      },
                      'generate': function() {
                          throw new Error('This\x20method\x20has\x20been\x20removed\x20in\x20JSZip\x203.0,\x20please\x20check\x20the\x20upgrade\x20guide.');
                      },
                      'generateInternalStream': function(C) {
                          var O, G = {};
                          try {
                              if ((G = T['extend'](C || {}, {
                                  'streamFiles': false,
                                  'compression': 'STORE',
                                  'compressionOptions': null,
                                  'type': '',
                                  'platform': 'DOS',
                                  'comment': null,
                                  'mimeType': 'application/zip',
                                  'encodeFileName': Y['utf8encode']
                              }))['type'] = G['type']['toLowerCase'](),
                              G['compression'] = G['compression']['toUpperCase'](),
                              'binarystring' === G['type'] && (G['type'] = 'string'),
                              !G['type'])
                                  throw new Error('No\x20output\x20type\x20specified.');
                              T['checkSupport'](G['type']),
                              'darwin' !== G['platform'] && 'freebsd' !== G['platform'] && 'linux' !== G['platform'] && 'sunos' !== G['platform'] || (G['platform'] = 'UNIX'),
                              'win32' === G['platform'] && (G['platform'] = 'DOS');
                              var N = G['comment'] || this['comment'] || '';
                              O = D['generateWorker'](this, G, N);
                          } catch (P) {
                              (O = new X('error'))['error'](P);
                          }
                          return new E(O,G['type'] || 'string',G['mimeType']);
                      },
                      'generateAsync': function(C, O) {
                          return this['generateInternalStream'](C)['accumulate'](O);
                      },
                      'generateNodeStream': function(C, O) {
                          return (C = C || {})['type'] || (C['type'] = 'nodebuffer'),
                          this['generateInternalStream'](C)['toNodejsStream'](O);
                      }
                  };
                  x['exports'] = J;
              }
              , {
                  './compressedObject': 0x2,
                  './defaults': 0x5,
                  './generate': 0x9,
                  './nodejs/NodejsStreamInputAdapter': 0xc,
                  './nodejsUtils': 0xe,
                  './stream/GenericWorker': 0x1c,
                  './stream/StreamHelper': 0x1d,
                  './utf8': 0x1f,
                  './utils': 0x20,
                  './zipObject': 0x23
              }],
              0x10: [function(c, H, x) {
                  'use strict';
                  H['exports'] = c('stream');
              }
              , {
                  'stream': undefined
              }],
              0x11: [function(c, H, x) {
                  'use strict';
                  var p = c('./DataReader');
                  function F(y) {
                      p['call'](this, y);
                      for (var w = 0x0; w < this['data']['length']; w++)
                          y[w] = 0xff & y[w];
                  }
                  c('../utils')['inherits'](F, p),
                  F['prototype']['byteAt'] = function(y) {
                      return this['data'][this['zero'] + y];
                  }
                  ,
                  F['prototype']['lastIndexOfSignature'] = function(y) {
                      for (var w = y['charCodeAt'](0x0), h = y['charCodeAt'](0x1), u = y['charCodeAt'](0x2), Y = y['charCodeAt'](0x3), T = this['length'] - 0x4; 0x0 <= T; --T)
                          if (this['data'][T] === w && this['data'][T + 0x1] === h && this['data'][T + 0x2] === u && this['data'][T + 0x3] === Y)
                              return T - this['zero'];
                      return -0x1;
                  }
                  ,
                  F['prototype']['readAndCheckSignature'] = function(y) {
                      var w = y['charCodeAt'](0x0)
                        , h = y['charCodeAt'](0x1)
                        , u = y['charCodeAt'](0x2)
                        , Y = y['charCodeAt'](0x3)
                        , T = this['readData'](0x4);
                      return w === T[0x0] && h === T[0x1] && u === T[0x2] && Y === T[0x3];
                  }
                  ,
                  F['prototype']['readData'] = function(y) {
                      if (this['checkOffset'](y),
                      0x0 === y)
                          return [];
                      var w = this['data']['slice'](this['zero'] + this['index'], this['zero'] + this['index'] + y);
                      return this['index'] += y,
                      w;
                  }
                  ,
                  H['exports'] = F;
              }
              , {
                  '../utils': 0x20,
                  './DataReader': 0x12
              }],
              0x12: [function(c, H, x) {
                  'use strict';
                  var p = c('../utils');
                  function F(y) {
                      this['data'] = y,
                      this['length'] = y['length'],
                      this['index'] = 0x0,
                      this['zero'] = 0x0;
                  }
                  F['prototype'] = {
                      'checkOffset': function(y) {
                          this['checkIndex'](this['index'] + y);
                      },
                      'checkIndex': function(y) {
                          if (this['length'] < this['zero'] + y || y < 0x0)
                              throw new Error('End\x20of\x20data\x20reached\x20(data\x20length\x20=\x20' + this['length'] + ',\x20asked\x20index\x20=\x20' + y + ').\x20Corrupted\x20zip\x20?');
                      },
                      'setIndex': function(y) {
                          this['checkIndex'](y),
                          this['index'] = y;
                      },
                      'skip': function(y) {
                          this['setIndex'](this['index'] + y);
                      },
                      'byteAt': function() {},
                      'readInt': function(y) {
                          var w, s = 0x0;
                          for (this['checkOffset'](y),
                          w = this['index'] + y - 0x1; w >= this['index']; w--)
                              s = (s << 0x8) + this['byteAt'](w);
                          return this['index'] += y,
                          s;
                      },
                      'readString': function(y) {
                          return p['transformTo']('string', this['readData'](y));
                      },
                      'readData': function() {},
                      'lastIndexOfSignature': function() {},
                      'readAndCheckSignature': function() {},
                      'readDate': function() {
                          var y = this['readInt'](0x4);
                          return new Date(Date['UTC'](0x7bc + (y >> 0x19 & 0x7f), (y >> 0x15 & 0xf) - 0x1, y >> 0x10 & 0x1f, y >> 0xb & 0x1f, y >> 0x5 & 0x3f, (0x1f & y) << 0x1));
                      }
                  },
                  H['exports'] = F;
              }
              , {
                  '../utils': 0x20
              }],
              0x13: [function(c, H, x) {
                  'use strict';
                  var p = c('./Uint8ArrayReader');
                  function F(y) {
                      p['call'](this, y);
                  }
                  c('../utils')['inherits'](F, p),
                  F['prototype']['readData'] = function(y) {
                      this['checkOffset'](y);
                      var w = this['data']['slice'](this['zero'] + this['index'], this['zero'] + this['index'] + y);
                      return this['index'] += y,
                      w;
                  }
                  ,
                  H['exports'] = F;
              }
              , {
                  '../utils': 0x20,
                  './Uint8ArrayReader': 0x15
              }],
              0x14: [function(c, H, x) {
                  'use strict';
                  var p = c('./DataReader');
                  function F(y) {
                      p['call'](this, y);
                  }
                  c('../utils')['inherits'](F, p),
                  F['prototype']['byteAt'] = function(y) {
                      return this['data']['charCodeAt'](this['zero'] + y);
                  }
                  ,
                  F['prototype']['lastIndexOfSignature'] = function(y) {
                      return this['data']['lastIndexOf'](y) - this['zero'];
                  }
                  ,
                  F['prototype']['readAndCheckSignature'] = function(y) {
                      return y === this['readData'](0x4);
                  }
                  ,
                  F['prototype']['readData'] = function(y) {
                      this['checkOffset'](y);
                      var w = this['data']['slice'](this['zero'] + this['index'], this['zero'] + this['index'] + y);
                      return this['index'] += y,
                      w;
                  }
                  ,
                  H['exports'] = F;
              }
              , {
                  '../utils': 0x20,
                  './DataReader': 0x12
              }],
              0x15: [function(c, H, x) {
                  'use strict';
                  var p = c('./ArrayReader');
                  function F(y) {
                      p['call'](this, y);
                  }
                  c('../utils')['inherits'](F, p),
                  F['prototype']['readData'] = function(y) {
                      if (this['checkOffset'](y),
                      0x0 === y)
                          return new Uint8Array(0x0);
                      var w = this['data']['subarray'](this['zero'] + this['index'], this['zero'] + this['index'] + y);
                      return this['index'] += y,
                      w;
                  }
                  ,
                  H['exports'] = F;
              }
              , {
                  '../utils': 0x20,
                  './ArrayReader': 0x11
              }],
              0x16: [function(c, H, x) {
                  'use strict';
                  var p = c('../utils')
                    , F = c('../support')
                    , y = c('./ArrayReader')
                    , w = c('./StringReader')
                    , h = c('./NodeBufferReader')
                    , u = c('./Uint8ArrayReader');
                  H['exports'] = function(Y) {
                      var T = p['getTypeOf'](Y);
                      return p['checkSupport'](T),
                      'string' !== T || F['uint8array'] ? 'nodebuffer' === T ? new h(Y) : F['uint8array'] ? new u(p['transformTo']('uint8array', Y)) : new y(p['transformTo']('array', Y)) : new w(Y);
                  }
                  ;
              }
              , {
                  '../support': 0x1e,
                  '../utils': 0x20,
                  './ArrayReader': 0x11,
                  './NodeBufferReader': 0x13,
                  './StringReader': 0x14,
                  './Uint8ArrayReader': 0x15
              }],
              0x17: [function(c, H, x) {
                  'use strict';
                  x['LOCAL_FILE_HEADER'] = 'PK\x03\x04',
                  x['CENTRAL_FILE_HEADER'] = 'PK\x01\x02',
                  x['CENTRAL_DIRECTORY_END'] = 'PK\x05\x06',
                  x['ZIP64_CENTRAL_DIRECTORY_LOCATOR'] = 'PK\x06\x07',
                  x['ZIP64_CENTRAL_DIRECTORY_END'] = 'PK\x06\x06',
                  x['DATA_DESCRIPTOR'] = 'PK\x07\x08';
              }
              , {}],
              0x18: [function(c, H, x) {
                  'use strict';
                  var p = c('./GenericWorker')
                    , F = c('../utils');
                  function y(w) {
                      p['call'](this, 'ConvertWorker\x20to\x20' + w),
                      this['destType'] = w;
                  }
                  F['inherits'](y, p),
                  y['prototype']['processChunk'] = function(w) {
                      this['push']({
                          'data': F['transformTo'](this['destType'], w['data']),
                          'meta': w['meta']
                      });
                  }
                  ,
                  H['exports'] = y;
              }
              , {
                  '../utils': 0x20,
                  './GenericWorker': 0x1c
              }],
              0x19: [function(c, H, x) {
                  'use strict';
                  var p = c('./GenericWorker')
                    , F = c('../crc32');
                  function y() {
                      p['call'](this, 'Crc32Probe'),
                      this['withStreamInfo']('crc32', 0x0);
                  }
                  c('../utils')['inherits'](y, p),
                  y['prototype']['processChunk'] = function(w) {
                      this['streamInfo']['crc32'] = F(w['data'], this['streamInfo']['crc32'] || 0x0),
                      this['push'](w);
                  }
                  ,
                  H['exports'] = y;
              }
              , {
                  '../crc32': 0x4,
                  '../utils': 0x20,
                  './GenericWorker': 0x1c
              }],
              0x1a: [function(c, H, x) {
                  'use strict';
                  var p = c('../utils')
                    , F = c('./GenericWorker');
                  function y(w) {
                      F['call'](this, 'DataLengthProbe\x20for\x20' + w),
                      this['propName'] = w,
                      this['withStreamInfo'](w, 0x0);
                  }
                  p['inherits'](y, F),
                  y['prototype']['processChunk'] = function(w) {
                      if (w) {
                          var h = this['streamInfo'][this['propName']] || 0x0;
                          this['streamInfo'][this['propName']] = h + w['data']['length'];
                      }
                      F['prototype']['processChunk']['call'](this, w);
                  }
                  ,
                  H['exports'] = y;
              }
              , {
                  '../utils': 0x20,
                  './GenericWorker': 0x1c
              }],
              0x1b: [function(c, H, x) {
                  'use strict';
                  var p = c('../utils')
                    , F = c('./GenericWorker');
                  function y(w) {
                      F['call'](this, 'DataWorker');
                      var h = this;
                      this['dataIsReady'] = false,
                      this['index'] = 0x0,
                      this['max'] = 0x0,
                      this['data'] = null,
                      this['type'] = '',
                      this['_tickScheduled'] = false,
                      w['then'](function(u) {
                          h['dataIsReady'] = true,
                          h['data'] = u,
                          h['max'] = u && u['length'] || 0x0,
                          h['type'] = p['getTypeOf'](u),
                          h['isPaused'] || h['_tickAndRepeat']();
                      }, function(u) {
                          h['error'](u);
                      });
                  }
                  p['inherits'](y, F),
                  y['prototype']['cleanUp'] = function() {
                      F['prototype']['cleanUp']['call'](this),
                      this['data'] = null;
                  }
                  ,
                  y['prototype']['resume'] = function() {
                      return !!F['prototype']['resume']['call'](this) && (!this['_tickScheduled'] && this['dataIsReady'] && (this['_tickScheduled'] = true,
                      p['delay'](this['_tickAndRepeat'], [], this)),
                      true);
                  }
                  ,
                  y['prototype']['_tickAndRepeat'] = function() {
                      this['_tickScheduled'] = false,
                      this['isPaused'] || this['isFinished'] || (this['_tick'](),
                      this['isFinished'] || (p['delay'](this['_tickAndRepeat'], [], this),
                      this['_tickScheduled'] = true));
                  }
                  ,
                  y['prototype']['_tick'] = function() {
                      if (this['isPaused'] || this['isFinished'])
                          return false;
                      var w = null
                        , h = Math['min'](this['max'], this['index'] + 0x4000);
                      if (this['index'] >= this['max'])
                          return this['end']();
                      switch (this['type']) {
                      case 'string':
                          w = this['data']['substring'](this['index'], h);
                          break;
                      case 'uint8array':
                          w = this['data']['subarray'](this['index'], h);
                          break;
                      case 'array':
                      case 'nodebuffer':
                          w = this['data']['slice'](this['index'], h);
                      }
                      return this['index'] = h,
                      this['push']({
                          'data': w,
                          'meta': {
                              'percent': this['max'] ? this['index'] / this['max'] * 0x64 : 0x0
                          }
                      });
                  }
                  ,
                  H['exports'] = y;
              }
              , {
                  '../utils': 0x20,
                  './GenericWorker': 0x1c
              }],
              0x1c: [function(c, H, x) {
                  'use strict';
                  function p(F) {
                      this['name'] = F || 'default',
                      this['streamInfo'] = {},
                      this['generatedError'] = null,
                      this['extraStreamInfo'] = {},
                      this['isPaused'] = true,
                      this['isFinished'] = false,
                      this['isLocked'] = false,
                      this['_listeners'] = {
                          'data': [],
                          'end': [],
                          'error': []
                      },
                      this['previous'] = null;
                  }
                  p['prototype'] = {
                      'push': function(F) {
                          this['emit']('data', F);
                      },
                      'end': function() {
                          if (this['isFinished'])
                              return false;
                          this['flush']();
                          try {
                              this['emit']('end'),
                              this['cleanUp'](),
                              this['isFinished'] = true;
                          } catch (F) {
                              this['emit']('error', F);
                          }
                          return true;
                      },
                      'error': function(F) {
                          return !this['isFinished'] && (this['isPaused'] ? this['generatedError'] = F : (this['isFinished'] = true,
                          this['emit']('error', F),
                          this['previous'] && this['previous']['error'](F),
                          this['cleanUp']()),
                          true);
                      },
                      'on': function(F, y) {
                          return this['_listeners'][F]['push'](y),
                          this;
                      },
                      'cleanUp': function() {
                          this['streamInfo'] = this['generatedError'] = this['extraStreamInfo'] = null,
                          this['_listeners'] = [];
                      },
                      'emit': function(F, y) {
                          if (this['_listeners'][F]) {
                              for (var w = 0x0; w < this['_listeners'][F]['length']; w++)
                                  this['_listeners'][F][w]['call'](this, y);
                          }
                      },
                      'pipe': function(F) {
                          return F['registerPrevious'](this);
                      },
                      'registerPrevious': function(F) {
                          if (this['isLocked'])
                              throw new Error('The\x20stream\x20\x27' + this + '\x27\x20has\x20already\x20been\x20used.');
                          this['streamInfo'] = F['streamInfo'],
                          this['mergeStreamInfo'](),
                          this['previous'] = F;
                          var y = this;
                          return F['on']('data', function(w) {
                              y['processChunk'](w);
                          }),
                          F['on']('end', function() {
                              y['end']();
                          }),
                          F['on']('error', function(w) {
                              y['error'](w);
                          }),
                          this;
                      },
                      'pause': function() {
                          return !this['isPaused'] && !this['isFinished'] && (this['isPaused'] = true,
                          this['previous'] && this['previous']['pause'](),
                          true);
                      },
                      'resume': function() {
                          if (!this['isPaused'] || this['isFinished'])
                              return false;
                          var F = this['isPaused'] = false;
                          return this['generatedError'] && (this['error'](this['generatedError']),
                          F = true),
                          this['previous'] && this['previous']['resume'](),
                          !F;
                      },
                      'flush': function() {},
                      'processChunk': function(F) {
                          this['push'](F);
                      },
                      'withStreamInfo': function(F, y) {
                          return this['extraStreamInfo'][F] = y,
                          this['mergeStreamInfo'](),
                          this;
                      },
                      'mergeStreamInfo': function() {
                          for (var F in this['extraStreamInfo'])
                              Object['prototype']['hasOwnProperty']['call'](this['extraStreamInfo'], F) && (this['streamInfo'][F] = this['extraStreamInfo'][F]);
                      },
                      'lock': function() {
                          if (this['isLocked'])
                              throw new Error('The\x20stream\x20\x27' + this + '\x27\x20has\x20already\x20been\x20used.');
                          this['isLocked'] = true,
                          this['previous'] && this['previous']['lock']();
                      },
                      'toString': function() {
                          var F = 'Worker\x20' + this['name'];
                          return this['previous'] ? this['previous'] + '\x20->\x20' + F : F;
                      }
                  },
                  H['exports'] = p;
              }
              , {}],
              0x1d: [function(c, H, x) {
                  'use strict';
                  var p = c('../utils')
                    , F = c('./ConvertWorker')
                    , y = c('./GenericWorker')
                    , w = c('../base64')
                    , Y = c('../support')
                    , T = c('../external')
                    , X = null;
                  if (Y['nodestream'])
                      try {
                          X = c('../nodejs/NodejsStreamOutputAdapter');
                      } catch (f) {}
                  function E(W, I, j) {
                      var D = I;
                      switch (I) {
                      case 'blob':
                      case 'arraybuffer':
                          D = 'uint8array';
                          break;
                      case 'base64':
                          D = 'string';
                      }
                      try {
                          this['_internalType'] = D,
                          this['_outputType'] = I,
                          this['_mimeType'] = j,
                          p['checkSupport'](D),
                          this['_worker'] = W['pipe'](new F(D)),
                          W['lock']();
                      } catch (V) {
                          this['_worker'] = new y('error'),
                          this['_worker']['error'](V);
                      }
                  }
                  E['prototype'] = {
                      'accumulate': function(W) {
                          return function(I, j) {
                              return new T['Promise'](function(D, V) {
                                  var Z = []
                                    , B = I['_internalType']
                                    , S = I['_outputType']
                                    , U = I['_mimeType'];
                                  I['on']('data', function(d, q) {
                                      Z['push'](d),
                                      j && j(q);
                                  })['on']('error', function(d) {
                                      Z = [],
                                      V(d);
                                  })['on']('end', function() {
                                      try {
                                          var d = function(q, J, C) {
                                              switch (q) {
                                              case 'blob':
                                                  return p['newBlob'](p['transformTo']('arraybuffer', J), C);
                                              case 'base64':
                                                  return w['encode'](J);
                                              default:
                                                  return p['transformTo'](q, J);
                                              }
                                          }(S, function(q, J) {
                                              var C, O = 0x0, G = null, g = 0x0;
                                              for (C = 0x0; C < J['length']; C++)
                                                  g += J[C]['length'];
                                              switch (q) {
                                              case 'string':
                                                  return J['join']('');
                                              case 'array':
                                                  return Array['prototype']['concat']['apply']([], J);
                                              case 'uint8array':
                                                  for (G = new Uint8Array(g),
                                                  C = 0x0; C < J['length']; C++)
                                                      G['set'](J[C], O),
                                                      O += J[C]['length'];
                                                  return G;
                                              case 'nodebuffer':
                                                  return Buffer['concat'](J);
                                              default:
                                                  throw new Error('concat\x20:\x20unsupported\x20type\x20\x27' + q + '\x27');
                                              }
                                          }(B, Z), U);
                                          D(d);
                                      } catch (q) {
                                          V(q);
                                      }
                                      Z = [];
                                  })['resume']();
                              }
                              );
                          }(this, W);
                      },
                      'on': function(W, I) {
                          var j = this;
                          return 'data' === W ? this['_worker']['on'](W, function(D) {
                              I['call'](j, D['data'], D['meta']);
                          }) : this['_worker']['on'](W, function() {
                              p['delay'](I, arguments, j);
                          }),
                          this;
                      },
                      'resume': function() {
                          return p['delay'](this['_worker']['resume'], [], this['_worker']),
                          this;
                      },
                      'pause': function() {
                          return this['_worker']['pause'](),
                          this;
                      },
                      'toNodejsStream': function(W) {
                          if (p['checkSupport']('nodestream'),
                          'nodebuffer' !== this['_outputType'])
                              throw new Error(this['_outputType'] + '\x20is\x20not\x20supported\x20by\x20this\x20method');
                          return new X(this,{
                              'objectMode': 'nodebuffer' !== this['_outputType']
                          },W);
                      }
                  },
                  H['exports'] = E;
              }
              , {
                  '../base64': 0x1,
                  '../external': 0x6,
                  '../nodejs/NodejsStreamOutputAdapter': 0xd,
                  '../support': 0x1e,
                  '../utils': 0x20,
                  './ConvertWorker': 0x18,
                  './GenericWorker': 0x1c
              }],
              0x1e: [function(c, H, x) {
                  'use strict';
                  if (x['base64'] = true,
                  x['array'] = true,
                  x['string'] = true,
                  x['arraybuffer'] = 'undefined' != typeof ArrayBuffer && 'undefined' != typeof Uint8Array,
                  x['nodebuffer'] = 'undefined' != typeof Buffer,
                  x['uint8array'] = 'undefined' != typeof Uint8Array,
                  'undefined' == typeof ArrayBuffer)
                      x['blob'] = false;
                  else {
                      var p = new ArrayBuffer(0x0);
                      try {
                          x['blob'] = 0x0 === new Blob([p],{
                              'type': 'application/zip'
                          })['size'];
                      } catch (y) {
                          try {
                              var F = new (self['BlobBuilder'] || self['WebKitBlobBuilder'] || self['MozBlobBuilder'] || self['MSBlobBuilder'])();
                              F['append'](p),
                              x['blob'] = 0x0 === F['getBlob']('application/zip')['size'];
                          } catch (w) {
                              x['blob'] = false;
                          }
                      }
                  }
                  try {
                      x['nodestream'] = !!c('readable-stream')['Readable'];
                  } catch (s) {
                      x['nodestream'] = false;
                  }
              }
              , {
                  'readable-stream': 0x10
              }],
              0x1f: [function(c, H, x) {
                  'use strict';
                  for (var p = c('./utils'), F = c('./support'), y = c('./nodejsUtils'), w = c('./stream/GenericWorker'), Y = new Array(0x100), T = 0x0; T < 0x100; T++)
                      Y[T] = 0xfc <= T ? 0x6 : 0xf8 <= T ? 0x5 : 0xf0 <= T ? 0x4 : 0xe0 <= T ? 0x3 : 0xc0 <= T ? 0x2 : 0x1;
                  function X() {
                      w['call'](this, 'utf-8\x20decode'),
                      this['leftOver'] = null;
                  }
                  function E() {
                      w['call'](this, 'utf-8\x20encode');
                  }
                  Y[0xfe] = Y[0xfe] = 0x1,
                  x['utf8encode'] = function(f) {
                      return F['nodebuffer'] ? y['newBufferFrom'](f, 'utf-8') : function(W) {
                          var I, j, D, V, Z, B = W['length'], S = 0x0;
                          for (V = 0x0; V < B; V++)
                              0xd800 == (0xfc00 & (j = W['charCodeAt'](V))) && V + 0x1 < B && 0xdc00 == (0xfc00 & (D = W['charCodeAt'](V + 0x1))) && (j = 0x10000 + (j - 0xd800 << 0xa) + (D - 0xdc00),
                              V++),
                              S += j < 0x80 ? 0x1 : j < 0x800 ? 0x2 : j < 0x10000 ? 0x3 : 0x4;
                          for (I = F['uint8array'] ? new Uint8Array(S) : new Array(S),
                          V = Z = 0x0; Z < S; V++)
                              0xd800 == (0xfc00 & (j = W['charCodeAt'](V))) && V + 0x1 < B && 0xdc00 == (0xfc00 & (D = W['charCodeAt'](V + 0x1))) && (j = 0x10000 + (j - 0xd800 << 0xa) + (D - 0xdc00),
                              V++),
                              j < 0x80 ? I[Z++] = j : (j < 0x800 ? I[Z++] = 0xc0 | j >>> 0x6 : (j < 0x10000 ? I[Z++] = 0xe0 | j >>> 0xc : (I[Z++] = 0xf0 | j >>> 0x12,
                              I[Z++] = 0x80 | j >>> 0xc & 0x3f),
                              I[Z++] = 0x80 | j >>> 0x6 & 0x3f),
                              I[Z++] = 0x80 | 0x3f & j);
                          return I;
                      }(f);
                  }
                  ,
                  x['utf8decode'] = function(f) {
                      return F['nodebuffer'] ? p['transformTo']('nodebuffer', f)['toString']('utf-8') : function(W) {
                          var I, j, D, V, Z = W['length'], B = new Array(0x2 * Z);
                          for (I = j = 0x0; I < Z; )
                              if ((D = W[I++]) < 0x80)
                                  B[j++] = D;
                              else {
                                  if (0x4 < (V = Y[D]))
                                      B[j++] = 0xfffd,
                                      I += V - 0x1;
                                  else {
                                      for (D &= 0x2 === V ? 0x1f : 0x3 === V ? 0xf : 0x7; 0x1 < V && I < Z; )
                                          D = D << 0x6 | 0x3f & W[I++],
                                          V--;
                                      0x1 < V ? B[j++] = 0xfffd : D < 0x10000 ? B[j++] = D : (D -= 0x10000,
                                      B[j++] = 0xd800 | D >> 0xa & 0x3ff,
                                      B[j++] = 0xdc00 | 0x3ff & D);
                                  }
                              }
                          return B['length'] !== j && (B['subarray'] ? B = B['subarray'](0x0, j) : B['length'] = j),
                          p['applyFromCharCode'](B);
                      }(f = p['transformTo'](F['uint8array'] ? 'uint8array' : 'array', f));
                  }
                  ,
                  p['inherits'](X, w),
                  X['prototype']['processChunk'] = function(f) {
                      var W = p['transformTo'](F['uint8array'] ? 'uint8array' : 'array', f['data']);
                      if (this['leftOver'] && this['leftOver']['length']) {
                          if (F['uint8array']) {
                              var I = W;
                              (W = new Uint8Array(I['length'] + this['leftOver']['length']))['set'](this['leftOver'], 0x0),
                              W['set'](I, this['leftOver']['length']);
                          } else
                              W = this['leftOver']['concat'](W);
                          this['leftOver'] = null;
                      }
                      var j = function(V, Z) {
                          var B;
                          for ((Z = Z || V['length']) > V['length'] && (Z = V['length']),
                          B = Z - 0x1; 0x0 <= B && 0x80 == (0xc0 & V[B]); )
                              B--;
                          return B < 0x0 || 0x0 === B ? Z : B + Y[V[B]] > Z ? B : Z;
                      }(W)
                        , D = W;
                      j !== W['length'] && (F['uint8array'] ? (D = W['subarray'](0x0, j),
                      this['leftOver'] = W['subarray'](j, W['length'])) : (D = W['slice'](0x0, j),
                      this['leftOver'] = W['slice'](j, W['length']))),
                      this['push']({
                          'data': x['utf8decode'](D),
                          'meta': f['meta']
                      });
                  }
                  ,
                  X['prototype']['flush'] = function() {
                      this['leftOver'] && this['leftOver']['length'] && (this['push']({
                          'data': x['utf8decode'](this['leftOver']),
                          'meta': {}
                      }),
                      this['leftOver'] = null);
                  }
                  ,
                  x['Utf8DecodeWorker'] = X,
                  p['inherits'](E, w),
                  E['prototype']['processChunk'] = function(f) {
                      this['push']({
                          'data': x['utf8encode'](f['data']),
                          'meta': f['meta']
                      });
                  }
                  ,
                  x['Utf8EncodeWorker'] = E;
              }
              , {
                  './nodejsUtils': 0xe,
                  './stream/GenericWorker': 0x1c,
                  './support': 0x1e,
                  './utils': 0x20
              }],
              0x20: [function(H, x, p) {
                  'use strict';
                  var F = H('./support')
                    , y = H('./base64')
                    , w = H('./nodejsUtils')
                    , Y = H('./external');
                  function T(j) {
                      return j;
                  }
                  function X(j, D) {
                      for (var V = 0x0; V < j['length']; ++V)
                          D[V] = 0xff & j['charCodeAt'](V);
                      return D;
                  }
                  H('setimmediate'),
                  p['newBlob'] = function(j, D) {
                      p['checkSupport']('blob');
                      try {
                          return new Blob([j],{
                              'type': D
                          });
                      } catch (Z) {
                          try {
                              var V = new (self['BlobBuilder'] || self['WebKitBlobBuilder'] || self['MozBlobBuilder'] || self['MSBlobBuilder'])();
                              return V['append'](j),
                              V['getBlob'](D);
                          } catch (B) {
                              throw new Error('Bug\x20:\x20can\x27t\x20construct\x20the\x20Blob.');
                          }
                      }
                  }
                  ;
                  var E = {
                      'stringifyByChunk': function(j, D, V) {
                          var Z = []
                            , B = 0x0
                            , S = j['length'];
                          if (S <= V)
                              return String['fromCharCode']['apply'](null, j);
                          for (; B < S; )
                              'array' === D || 'nodebuffer' === D ? Z['push'](String['fromCharCode']['apply'](null, j['slice'](B, Math['min'](B + V, S)))) : Z['push'](String['fromCharCode']['apply'](null, j['subarray'](B, Math['min'](B + V, S)))),
                              B += V;
                          return Z['join']('');
                      },
                      'stringifyByChar': function(j) {
                          for (var D = '', V = 0x0; V < j['length']; V++)
                              D += String['fromCharCode'](j[V]);
                          return D;
                      },
                      'applyCanBeUsed': {
                          'uint8array': function() {
                              try {
                                  return F['uint8array'] && 0x1 === String['fromCharCode']['apply'](null, new Uint8Array(0x1))['length'];
                              } catch (j) {
                                  return false;
                              }
                          }(),
                          'nodebuffer': function() {
                              try {
                                  return F['nodebuffer'] && 0x1 === String['fromCharCode']['apply'](null, w['allocBuffer'](0x1))['length'];
                              } catch (j) {
                                  return false;
                              }
                          }()
                      }
                  };
                  function f(j) {
                      var D = 0x10000
                        , V = p['getTypeOf'](j)
                        , Z = true;
                      if ('uint8array' === V ? Z = E['applyCanBeUsed']['uint8array'] : 'nodebuffer' === V && (Z = E['applyCanBeUsed']['nodebuffer']),
                      Z) {
                          for (; 0x1 < D; )
                              try {
                                  return E['stringifyByChunk'](j, V, D);
                              } catch (B) {
                                  D = Math['floor'](D / 0x2);
                              }
                      }
                      return E['stringifyByChar'](j);
                  }
                  function W(j, D) {
                      for (var V = 0x0; V < j['length']; V++)
                          D[V] = j[V];
                      return D;
                  }
                  p['applyFromCharCode'] = f;
                  var I = {};
                  I['string'] = {
                      'string': T,
                      'array': function(j) {
                          return X(j, new Array(j['length']));
                      },
                      'arraybuffer': function(j) {
                          return I['string']['uint8array'](j)['buffer'];
                      },
                      'uint8array': function(j) {
                          return X(j, new Uint8Array(j['length']));
                      },
                      'nodebuffer': function(j) {
                          return X(j, w['allocBuffer'](j['length']));
                      }
                  },
                  I['array'] = {
                      'string': f,
                      'array': T,
                      'arraybuffer': function(j) {
                          return new Uint8Array(j)['buffer'];
                      },
                      'uint8array': function(j) {
                          return new Uint8Array(j);
                      },
                      'nodebuffer': function(j) {
                          return w['newBufferFrom'](j);
                      }
                  },
                  I['arraybuffer'] = {
                      'string': function(j) {
                          return f(new Uint8Array(j));
                      },
                      'array': function(j) {
                          return W(new Uint8Array(j), new Array(j['byteLength']));
                      },
                      'arraybuffer': T,
                      'uint8array': function(j) {
                          return new Uint8Array(j);
                      },
                      'nodebuffer': function(j) {
                          return w['newBufferFrom'](new Uint8Array(j));
                      }
                  },
                  I['uint8array'] = {
                      'string': f,
                      'array': function(j) {
                          return W(j, new Array(j['length']));
                      },
                      'arraybuffer': function(j) {
                          return j['buffer'];
                      },
                      'uint8array': T,
                      'nodebuffer': function(j) {
                          return w['newBufferFrom'](j);
                      }
                  },
                  I['nodebuffer'] = {
                      'string': f,
                      'array': function(j) {
                          return W(j, new Array(j['length']));
                      },
                      'arraybuffer': function(j) {
                          return I['nodebuffer']['uint8array'](j)['buffer'];
                      },
                      'uint8array': function(j) {
                          return W(j, new Uint8Array(j['length']));
                      },
                      'nodebuffer': T
                  },
                  p['transformTo'] = function(j, D) {
                      if (D = D || '',
                      !j)
                          return D;
                      p['checkSupport'](j);
                      var V = p['getTypeOf'](D);
                      return I[V][j](D);
                  }
                  ,
                  p['resolve'] = function(j) {
                      for (var D = j['split']('/'), V = [], Z = 0x0; Z < D['length']; Z++) {
                          var B = D[Z];
                          '.' === B || '' === B && 0x0 !== Z && Z !== D['length'] - 0x1 || ('..' === B ? V['pop']() : V['push'](B));
                      }
                      return V['join']('/');
                  }
                  ,
                  p['getTypeOf'] = function(j) {
                      return 'string' == typeof j ? 'string' : '[object\x20Array]' === Object['prototype']['toString']['call'](j) ? 'array' : F['nodebuffer'] && w['isBuffer'](j) ? 'nodebuffer' : F['uint8array'] && j instanceof Uint8Array ? 'uint8array' : F['arraybuffer'] && j instanceof ArrayBuffer ? 'arraybuffer' : undefined;
                  }
                  ,
                  p['checkSupport'] = function(j) {
                      if (!F[j['toLowerCase']()])
                          throw new Error(j + '\x20is\x20not\x20supported\x20by\x20this\x20platform');
                  }
                  ,
                  p['MAX_VALUE_16BITS'] = 0xffff,
                  p['MAX_VALUE_32BITS'] = -0x1,
                  p['pretty'] = function(j) {
                      var D, V, Z = '';
                      for (V = 0x0; V < (j || '')['length']; V++)
                          Z += '\x5cx' + ((D = j['charCodeAt'](V)) < 0x10 ? '0' : '') + D['toString'](0x10)['toUpperCase']();
                      return Z;
                  }
                  ,
                  p['delay'] = function(j, D, V) {
                      setImmediate(function() {
                          j['apply'](V || null, D || []);
                      });
                  }
                  ,
                  p['inherits'] = function(j, D) {
                      function V() {}
                      V['prototype'] = D['prototype'],
                      j['prototype'] = new V();
                  }
                  ,
                  p['extend'] = function() {
                      var j, D, V = {};
                      for (j = 0x0; j < arguments['length']; j++)
                          for (D in arguments[j])
                              Object['prototype']['hasOwnProperty']['call'](arguments[j], D) && undefined === V[D] && (V[D] = arguments[j][D]);
                      return V;
                  }
                  ,
                  p['prepareContent'] = function(j, D, V, Z, B) {
                      return Y['Promise']['resolve'](D)['then'](function(S) {
                          return F['blob'] && (S instanceof Blob || -0x1 !== ['[object\x20File]', '[object\x20Blob]']['indexOf'](Object['prototype']['toString']['call'](S))) && 'undefined' != typeof FileReader ? new Y['Promise'](function(U, q) {
                              var J = new FileReader();
                              J['onload'] = function(C) {
                                  U(C['target']['result']);
                              }
                              ,
                              J['onerror'] = function(C) {
                                  q(C['target']['error']);
                              }
                              ,
                              J['readAsArrayBuffer'](S);
                          }
                          ) : S;
                      })['then'](function(S) {
                          var U = p['getTypeOf'](S);
                          return U ? ('arraybuffer' === U ? S = p['transformTo']('uint8array', S) : 'string' === U && (B ? S = y['decode'](S) : V && true !== Z && (S = function(q) {
                              return X(q, F['uint8array'] ? new Uint8Array(q['length']) : new Array(q['length']));
                          }(S))),
                          S) : Y['Promise']['reject'](new Error('Can\x27t\x20read\x20the\x20data\x20of\x20\x27' + j + '\x27.\x20Is\x20it\x20in\x20a\x20supported\x20JavaScript\x20type\x20(String,\x20Blob,\x20ArrayBuffer,\x20etc)\x20?'));
                      });
                  }
                  ;
              }
              , {
                  './base64': 0x1,
                  './external': 0x6,
                  './nodejsUtils': 0xe,
                  './support': 0x1e,
                  'setimmediate': 0x36
              }],
              0x21: [function(c, H, x) {
                  'use strict';
                  var p = c('./reader/readerFor')
                    , F = c('./utils')
                    , y = c('./signature')
                    , w = c('./zipEntry')
                    , h = c('./support');
                  function u(Y) {
                      this['files'] = [],
                      this['loadOptions'] = Y;
                  }
                  u['prototype'] = {
                      'checkSignature': function(Y) {
                          if (!this['reader']['readAndCheckSignature'](Y)) {
                              this['reader']['index'] -= 0x4;
                              var T = this['reader']['readString'](0x4);
                              throw new Error('Corrupted\x20zip\x20or\x20bug:\x20unexpected\x20signature\x20(' + F['pretty'](T) + ',\x20expected\x20' + F['pretty'](Y) + ')');
                          }
                      },
                      'isSignature': function(Y, T) {
                          var X = this['reader']['index'];
                          this['reader']['setIndex'](Y);
                          var E = this['reader']['readString'](0x4) === T;
                          return this['reader']['setIndex'](X),
                          E;
                      },
                      'readBlockEndOfCentral': function() {
                          this['diskNumber'] = this['reader']['readInt'](0x2),
                          this['diskWithCentralDirStart'] = this['reader']['readInt'](0x2),
                          this['centralDirRecordsOnThisDisk'] = this['reader']['readInt'](0x2),
                          this['centralDirRecords'] = this['reader']['readInt'](0x2),
                          this['centralDirSize'] = this['reader']['readInt'](0x4),
                          this['centralDirOffset'] = this['reader']['readInt'](0x4),
                          this['zipCommentLength'] = this['reader']['readInt'](0x2);
                          var Y = this['reader']['readData'](this['zipCommentLength'])
                            , T = h['uint8array'] ? 'uint8array' : 'array'
                            , X = F['transformTo'](T, Y);
                          this['zipComment'] = this['loadOptions']['decodeFileName'](X);
                      },
                      'readBlockZip64EndOfCentral': function() {
                          this['zip64EndOfCentralSize'] = this['reader']['readInt'](0x8),
                          this['reader']['skip'](0x4),
                          this['diskNumber'] = this['reader']['readInt'](0x4),
                          this['diskWithCentralDirStart'] = this['reader']['readInt'](0x4),
                          this['centralDirRecordsOnThisDisk'] = this['reader']['readInt'](0x8),
                          this['centralDirRecords'] = this['reader']['readInt'](0x8),
                          this['centralDirSize'] = this['reader']['readInt'](0x8),
                          this['centralDirOffset'] = this['reader']['readInt'](0x8),
                          this['zip64ExtensibleData'] = {};
                          for (var Y, T, X, E = this['zip64EndOfCentralSize'] - 0x2c; 0x0 < E; )
                              Y = this['reader']['readInt'](0x2),
                              T = this['reader']['readInt'](0x4),
                              X = this['reader']['readData'](T),
                              this['zip64ExtensibleData'][Y] = {
                                  'id': Y,
                                  'length': T,
                                  'value': X
                              };
                      },
                      'readBlockZip64EndOfCentralLocator': function() {
                          if (this['diskWithZip64CentralDirStart'] = this['reader']['readInt'](0x4),
                          this['relativeOffsetEndOfZip64CentralDir'] = this['reader']['readInt'](0x8),
                          this['disksCount'] = this['reader']['readInt'](0x4),
                          0x1 < this['disksCount'])
                              throw new Error('Multi-volumes\x20zip\x20are\x20not\x20supported');
                      },
                      'readLocalFiles': function() {
                          var Y, T;
                          for (Y = 0x0; Y < this['files']['length']; Y++)
                              T = this['files'][Y],
                              this['reader']['setIndex'](T['localHeaderOffset']),
                              this['checkSignature'](y['LOCAL_FILE_HEADER']),
                              T['readLocalPart'](this['reader']),
                              T['handleUTF8'](),
                              T['processAttributes']();
                      },
                      'readCentralDir': function() {
                          var Y;
                          for (this['reader']['setIndex'](this['centralDirOffset']); this['reader']['readAndCheckSignature'](y['CENTRAL_FILE_HEADER']); )
                              (Y = new w({
                                  'zip64': this['zip64']
                              },this['loadOptions']))['readCentralPart'](this['reader']),
                              this['files']['push'](Y);
                          if (this['centralDirRecords'] !== this['files']['length'] && 0x0 !== this['centralDirRecords'] && 0x0 === this['files']['length'])
                              throw new Error('Corrupted\x20zip\x20or\x20bug:\x20expected\x20' + this['centralDirRecords'] + '\x20records\x20in\x20central\x20dir,\x20got\x20' + this['files']['length']);
                      },
                      'readEndOfCentral': function() {
                          var Y = this['reader']['lastIndexOfSignature'](y['CENTRAL_DIRECTORY_END']);
                          if (Y < 0x0)
                              throw this['isSignature'](0x0, y['LOCAL_FILE_HEADER']) ? new Error('Corrupted\x20zip:\x20can\x27t\x20find\x20end\x20of\x20central\x20directory') : new Error('Can\x27t\x20find\x20end\x20of\x20central\x20directory\x20:\x20is\x20this\x20a\x20zip\x20file\x20?\x20If\x20it\x20is,\x20see\x20https://stuk.github.io/jszip/documentation/howto/read_zip.html');
                          this['reader']['setIndex'](Y);
                          var T = Y;
                          if (this['checkSignature'](y['CENTRAL_DIRECTORY_END']),
                          this['readBlockEndOfCentral'](),
                          this['diskNumber'] === F['MAX_VALUE_16BITS'] || this['diskWithCentralDirStart'] === F['MAX_VALUE_16BITS'] || this['centralDirRecordsOnThisDisk'] === F['MAX_VALUE_16BITS'] || this['centralDirRecords'] === F['MAX_VALUE_16BITS'] || this['centralDirSize'] === F['MAX_VALUE_32BITS'] || this['centralDirOffset'] === F['MAX_VALUE_32BITS']) {
                              if (this['zip64'] = true,
                              (Y = this['reader']['lastIndexOfSignature'](y['ZIP64_CENTRAL_DIRECTORY_LOCATOR'])) < 0x0)
                                  throw new Error('Corrupted\x20zip:\x20can\x27t\x20find\x20the\x20ZIP64\x20end\x20of\x20central\x20directory\x20locator');
                              if (this['reader']['setIndex'](Y),
                              this['checkSignature'](y['ZIP64_CENTRAL_DIRECTORY_LOCATOR']),
                              this['readBlockZip64EndOfCentralLocator'](),
                              !this['isSignature'](this['relativeOffsetEndOfZip64CentralDir'], y['ZIP64_CENTRAL_DIRECTORY_END']) && (this['relativeOffsetEndOfZip64CentralDir'] = this['reader']['lastIndexOfSignature'](y['ZIP64_CENTRAL_DIRECTORY_END']),
                              this['relativeOffsetEndOfZip64CentralDir'] < 0x0))
                                  throw new Error('Corrupted\x20zip:\x20can\x27t\x20find\x20the\x20ZIP64\x20end\x20of\x20central\x20directory');
                              this['reader']['setIndex'](this['relativeOffsetEndOfZip64CentralDir']),
                              this['checkSignature'](y['ZIP64_CENTRAL_DIRECTORY_END']),
                              this['readBlockZip64EndOfCentral']();
                          }
                          var X = this['centralDirOffset'] + this['centralDirSize'];
                          this['zip64'] && (X += 0x14,
                          X += 0xc + this['zip64EndOfCentralSize']);
                          var E = T - X;
                          if (0x0 < E)
                              this['isSignature'](T, y['CENTRAL_FILE_HEADER']) || (this['reader']['zero'] = E);
                          else {
                              if (E < 0x0)
                                  throw new Error('Corrupted\x20zip:\x20missing\x20' + Math['abs'](E) + '\x20bytes.');
                          }
                      },
                      'prepareReader': function(Y) {
                          this['reader'] = p(Y);
                      },
                      'load': function(Y) {
                          this['prepareReader'](Y),
                          this['readEndOfCentral'](),
                          this['readCentralDir'](),
                          this['readLocalFiles']();
                      }
                  },
                  H['exports'] = u;
              }
              , {
                  './reader/readerFor': 0x16,
                  './signature': 0x17,
                  './support': 0x1e,
                  './utils': 0x20,
                  './zipEntry': 0x22
              }],
              0x22: [function(c, H, x) {
                  'use strict';
                  var p = c('./reader/readerFor')
                    , F = c('./utils')
                    , y = c('./compressedObject')
                    , w = c('./crc32')
                    , Y = c('./utf8')
                    , T = c('./compressions')
                    , X = c('./support');
                  function E(f, W) {
                      this['options'] = f,
                      this['loadOptions'] = W;
                  }
                  E['prototype'] = {
                      'isEncrypted': function() {
                          return 0x1 == (0x1 & this['bitFlag']);
                      },
                      'useUTF8': function() {
                          return 0x800 == (0x800 & this['bitFlag']);
                      },
                      'readLocalPart': function(f) {
                          var W, I;
                          if (f['skip'](0x16),
                          this['fileNameLength'] = f['readInt'](0x2),
                          I = f['readInt'](0x2),
                          this['fileName'] = f['readData'](this['fileNameLength']),
                          f['skip'](I),
                          -0x1 === this['compressedSize'] || -0x1 === this['uncompressedSize'])
                              throw new Error('Bug\x20or\x20corrupted\x20zip\x20:\x20didn\x27t\x20get\x20enough\x20information\x20from\x20the\x20central\x20directory\x20(compressedSize\x20===\x20-1\x20||\x20uncompressedSize\x20===\x20-1)');
                          if (null === (W = function(j) {
                              for (var D in T)
                                  if (Object['prototype']['hasOwnProperty']['call'](T, D) && T[D]['magic'] === j)
                                      return T[D];
                              return null;
                          }(this['compressionMethod'])))
                              throw new Error('Corrupted\x20zip\x20:\x20compression\x20' + F['pretty'](this['compressionMethod']) + '\x20unknown\x20(inner\x20file\x20:\x20' + F['transformTo']('string', this['fileName']) + ')');
                          this['decompressed'] = new y(this['compressedSize'],this['uncompressedSize'],this['crc32'],W,f['readData'](this['compressedSize']));
                      },
                      'readCentralPart': function(f) {
                          this['versionMadeBy'] = f['readInt'](0x2),
                          f['skip'](0x2),
                          this['bitFlag'] = f['readInt'](0x2),
                          this['compressionMethod'] = f['readString'](0x2),
                          this['date'] = f['readDate'](),
                          this['crc32'] = f['readInt'](0x4),
                          this['compressedSize'] = f['readInt'](0x4),
                          this['uncompressedSize'] = f['readInt'](0x4);
                          var W = f['readInt'](0x2);
                          if (this['extraFieldsLength'] = f['readInt'](0x2),
                          this['fileCommentLength'] = f['readInt'](0x2),
                          this['diskNumberStart'] = f['readInt'](0x2),
                          this['internalFileAttributes'] = f['readInt'](0x2),
                          this['externalFileAttributes'] = f['readInt'](0x4),
                          this['localHeaderOffset'] = f['readInt'](0x4),
                          this['isEncrypted']())
                              throw new Error('Encrypted\x20zip\x20are\x20not\x20supported');
                          f['skip'](W),
                          this['readExtraFields'](f),
                          this['parseZIP64ExtraField'](f),
                          this['fileComment'] = f['readData'](this['fileCommentLength']);
                      },
                      'processAttributes': function() {
                          this['unixPermissions'] = null,
                          this['dosPermissions'] = null;
                          var f = this['versionMadeBy'] >> 0x8;
                          this['dir'] = !!(0x10 & this['externalFileAttributes']),
                          0x0 == f && (this['dosPermissions'] = 0x3f & this['externalFileAttributes']),
                          0x3 == f && (this['unixPermissions'] = this['externalFileAttributes'] >> 0x10 & 0xffff),
                          this['dir'] || '/' !== this['fileNameStr']['slice'](-0x1) || (this['dir'] = true);
                      },
                      'parseZIP64ExtraField': function() {
                          if (this['extraFields'][0x1]) {
                              var f = p(this['extraFields'][0x1]['value']);
                              this['uncompressedSize'] === F['MAX_VALUE_32BITS'] && (this['uncompressedSize'] = f['readInt'](0x8)),
                              this['compressedSize'] === F['MAX_VALUE_32BITS'] && (this['compressedSize'] = f['readInt'](0x8)),
                              this['localHeaderOffset'] === F['MAX_VALUE_32BITS'] && (this['localHeaderOffset'] = f['readInt'](0x8)),
                              this['diskNumberStart'] === F['MAX_VALUE_32BITS'] && (this['diskNumberStart'] = f['readInt'](0x4));
                          }
                      },
                      'readExtraFields': function(f) {
                          var W, I, j, D = f['index'] + this['extraFieldsLength'];
                          for (this['extraFields'] || (this['extraFields'] = {}); f['index'] + 0x4 < D; )
                              W = f['readInt'](0x2),
                              I = f['readInt'](0x2),
                              j = f['readData'](I),
                              this['extraFields'][W] = {
                                  'id': W,
                                  'length': I,
                                  'value': j
                              };
                          f['setIndex'](D);
                      },
                      'handleUTF8': function() {
                          var f = X['uint8array'] ? 'uint8array' : 'array';
                          if (this['useUTF8']())
                              this['fileNameStr'] = Y['utf8decode'](this['fileName']),
                              this['fileCommentStr'] = Y['utf8decode'](this['fileComment']);
                          else {
                              var W = this['findExtraFieldUnicodePath']();
                              if (null !== W)
                                  this['fileNameStr'] = W;
                              else {
                                  var I = F['transformTo'](f, this['fileName']);
                                  this['fileNameStr'] = this['loadOptions']['decodeFileName'](I);
                              }
                              var j = this['findExtraFieldUnicodeComment']();
                              if (null !== j)
                                  this['fileCommentStr'] = j;
                              else {
                                  var D = F['transformTo'](f, this['fileComment']);
                                  this['fileCommentStr'] = this['loadOptions']['decodeFileName'](D);
                              }
                          }
                      },
                      'findExtraFieldUnicodePath': function() {
                          var f = this['extraFields'][0x7075];
                          if (f) {
                              var W = p(f['value']);
                              return 0x1 !== W['readInt'](0x1) || w(this['fileName']) !== W['readInt'](0x4) ? null : Y['utf8decode'](W['readData'](f['length'] - 0x5));
                          }
                          return null;
                      },
                      'findExtraFieldUnicodeComment': function() {
                          var f = this['extraFields'][0x6375];
                          if (f) {
                              var W = p(f['value']);
                              return 0x1 !== W['readInt'](0x1) || w(this['fileComment']) !== W['readInt'](0x4) ? null : Y['utf8decode'](W['readData'](f['length'] - 0x5));
                          }
                          return null;
                      }
                  },
                  H['exports'] = E;
              }
              , {
                  './compressedObject': 0x2,
                  './compressions': 0x3,
                  './crc32': 0x4,
                  './reader/readerFor': 0x16,
                  './support': 0x1e,
                  './utf8': 0x1f,
                  './utils': 0x20
              }],
              0x23: [function(c, H, x) {
                  'use strict';
                  function p(W, I, j) {
                      this['name'] = W,
                      this['dir'] = j['dir'],
                      this['date'] = j['date'],
                      this['comment'] = j['comment'],
                      this['unixPermissions'] = j['unixPermissions'],
                      this['dosPermissions'] = j['dosPermissions'],
                      this['_data'] = I,
                      this['_dataBinary'] = j['binary'],
                      this['options'] = {
                          'compression': j['compression'],
                          'compressionOptions': j['compressionOptions']
                      };
                  }
                  var F = c('./stream/StreamHelper')
                    , y = c('./stream/DataWorker')
                    , w = c('./utf8')
                    , Y = c('./compressedObject')
                    , T = c('./stream/GenericWorker');
                  p['prototype'] = {
                      'internalStream': function(W) {
                          var I = null
                            , j = 'string';
                          try {
                              if (!W)
                                  throw new Error('No\x20output\x20type\x20specified.');
                              var D = 'string' === (j = W['toLowerCase']()) || 'text' === j;
                              'binarystring' !== j && 'text' !== j || (j = 'string'),
                              I = this['_decompressWorker']();
                              var V = !this['_dataBinary'];
                              V && !D && (I = I['pipe'](new w['Utf8EncodeWorker']())),
                              !V && D && (I = I['pipe'](new w['Utf8DecodeWorker']()));
                          } catch (Z) {
                              (I = new T('error'))['error'](Z);
                          }
                          return new F(I,j,'');
                      },
                      'async': function(W, I) {
                          return this['internalStream'](W)['accumulate'](I);
                      },
                      'nodeStream': function(W, I) {
                          return this['internalStream'](W || 'nodebuffer')['toNodejsStream'](I);
                      },
                      '_compressWorker': function(W, I) {
                          if (this['_data']instanceof Y && this['_data']['compression']['magic'] === W['magic'])
                              return this['_data']['getCompressedWorker']();
                          var j = this['_decompressWorker']();
                          return this['_dataBinary'] || (j = j['pipe'](new w['Utf8EncodeWorker']())),
                          Y['createWorkerFrom'](j, W, I);
                      },
                      '_decompressWorker': function() {
                          return this['_data']instanceof Y ? this['_data']['getContentWorker']() : this['_data']instanceof T ? this['_data'] : new y(this['_data']);
                      }
                  };
                  for (var X = ['asText', 'asBinary', 'asNodeBuffer', 'asUint8Array', 'asArrayBuffer'], E = function() {
                      throw new Error('This\x20method\x20has\x20been\x20removed\x20in\x20JSZip\x203.0,\x20please\x20check\x20the\x20upgrade\x20guide.');
                  }, f = 0x0; f < X['length']; f++)
                      p['prototype'][X[f]] = E;
                  H['exports'] = p;
              }
              , {
                  './compressedObject': 0x2,
                  './stream/DataWorker': 0x1b,
                  './stream/GenericWorker': 0x1c,
                  './stream/StreamHelper': 0x1d,
                  './utf8': 0x1f
              }],
              0x24: [function(c, H, x) {
                  (function(p) {
                      'use strict';
                      var F, y, w = p['MutationObserver'] || p['WebKitMutationObserver'];
                      if (w) {
                          var Y = 0x0
                            , T = new w(W)
                            , X = p['document']['createTextNode']('');
                          T['observe'](X, {
                              'characterData': true
                          }),
                          F = function() {
                              X['data'] = Y = ++Y % 0x2;
                          }
                          ;
                      } else {
                          if (p['setImmediate'] || undefined === p['MessageChannel'])
                              F = 'document'in p && 'onreadystatechange'in p['document']['createElement']('script') ? function() {
                                  var I = p['document']['createElement']('script');
                                  I['onreadystatechange'] = function() {
                                      W(),
                                      I['onreadystatechange'] = null,
                                      I['parentNode']['removeChild'](I),
                                      I = null;
                                  }
                                  ,
                                  p['document']['documentElement']['appendChild'](I);
                              }
                              : function() {
                                  setTimeout(W, 0x0);
                              }
                              ;
                          else {
                              var E = new p['MessageChannel']();
                              E['port1']['onmessage'] = W,
                              F = function() {
                                  E['port2']['postMessage'](0x0);
                              }
                              ;
                          }
                      }
                      var f = [];
                      function W() {
                          var I, j;
                          y = true;
                          for (var D = f['length']; D; ) {
                              for (j = f,
                              f = [],
                              I = -0x1; ++I < D; )
                                  j[I]();
                              D = f['length'];
                          }
                          y = false;
                      }
                      H['exports'] = function(I) {
                          0x1 !== f['push'](I) || y || F();
                      }
                      ;
                  }
                  ['call'](this, 'undefined' != typeof global ? global : 'undefined' != typeof self ? self : 'undefined' != typeof window ? window : {}));
              }
              , {}],
              0x25: [function(H, x, F) {
                  'use strict';
                  var y = H('immediate');
                  function w() {}
                  var Y = {}
                    , T = ['REJECTED']
                    , X = ['FULFILLED']
                    , E = ['PENDING'];
                  function W(B) {
                      if ('function' != typeof B)
                          throw new TypeError('resolver\x20must\x20be\x20a\x20function');
                      this['state'] = E,
                      this['queue'] = [],
                      this['outcome'] = undefined,
                      B !== w && V(this, B);
                  }
                  function I(B, S, U) {
                      this['promise'] = B,
                      'function' == typeof S && (this['onFulfilled'] = S,
                      this['callFulfilled'] = this['otherCallFulfilled']),
                      'function' == typeof U && (this['onRejected'] = U,
                      this['callRejected'] = this['otherCallRejected']);
                  }
                  function j(B, S, U) {
                      y(function() {
                          var q;
                          try {
                              q = S(U);
                          } catch (J) {
                              return Y['reject'](B, J);
                          }
                          q === B ? Y['reject'](B, new TypeError('Cannot\x20resolve\x20promise\x20with\x20itself')) : Y['resolve'](B, q);
                      });
                  }
                  function D(B) {
                      var S = B && B['then'];
                      if (B && ('object' == typeof B || 'function' == typeof B) && 'function' == typeof S)
                          return function() {
                              S['apply'](B, arguments);
                          }
                          ;
                  }
                  function V(B, S) {
                      var U = false;
                      function q(O) {
                          U || (U = true,
                          Y['reject'](B, O));
                      }
                      function J(O) {
                          U || (U = true,
                          Y['resolve'](B, O));
                      }
                      var C = Z(function() {
                          S(J, q);
                      });
                      'error' === C['status'] && q(C['value']);
                  }
                  function Z(B, S) {
                      var U = {};
                      try {
                          U['value'] = B(S),
                          U['status'] = 'success';
                      } catch (q) {
                          U['status'] = 'error',
                          U['value'] = q;
                      }
                      return U;
                  }
                  (x['exports'] = W)['prototype']['finally'] = function(B) {
                      if ('function' != typeof B)
                          return this;
                      var S = this['constructor'];
                      return this['then'](function(U) {
                          return S['resolve'](B())['then'](function() {
                              return U;
                          });
                      }, function(U) {
                          return S['resolve'](B())['then'](function() {
                              throw U;
                          });
                      });
                  }
                  ,
                  W['prototype']['catch'] = function(B) {
                      return this['then'](null, B);
                  }
                  ,
                  W['prototype']['then'] = function(B, S) {
                      if ('function' != typeof B && this['state'] === X || 'function' != typeof S && this['state'] === T)
                          return this;
                      var U = new this['constructor'](w);
                      return this['state'] !== E ? j(U, this['state'] === X ? B : S, this['outcome']) : this['queue']['push'](new I(U,B,S)),
                      U;
                  }
                  ,
                  I['prototype']['callFulfilled'] = function(B) {
                      Y['resolve'](this['promise'], B);
                  }
                  ,
                  I['prototype']['otherCallFulfilled'] = function(B) {
                      j(this['promise'], this['onFulfilled'], B);
                  }
                  ,
                  I['prototype']['callRejected'] = function(B) {
                      Y['reject'](this['promise'], B);
                  }
                  ,
                  I['prototype']['otherCallRejected'] = function(B) {
                      j(this['promise'], this['onRejected'], B);
                  }
                  ,
                  Y['resolve'] = function(B, S) {
                      var U = Z(D, S);
                      if ('error' === U['status'])
                          return Y['reject'](B, U['value']);
                      var q = U['value'];
                      if (q)
                          V(B, q);
                      else {
                          B['state'] = X,
                          B['outcome'] = S;
                          for (var J = -0x1, C = B['queue']['length']; ++J < C; )
                              B['queue'][J]['callFulfilled'](S);
                      }
                      return B;
                  }
                  ,
                  Y['reject'] = function(B, S) {
                      B['state'] = T,
                      B['outcome'] = S;
                      for (var U = -0x1, q = B['queue']['length']; ++U < q; )
                          B['queue'][U]['callRejected'](S);
                      return B;
                  }
                  ,
                  W['resolve'] = function(B) {
                      return B instanceof this ? B : Y['resolve'](new this(w), B);
                  }
                  ,
                  W['reject'] = function(B) {
                      var S = new this(w);
                      return Y['reject'](S, B);
                  }
                  ,
                  W['all'] = function(B) {
                      var S = this;
                      if ('[object\x20Array]' !== Object['prototype']['toString']['call'](B))
                          return this['reject'](new TypeError('must\x20be\x20an\x20array'));
                      var U = B['length']
                        , q = false;
                      if (!U)
                          return this['resolve']([]);
                      for (var J = new Array(U), C = 0x0, O = -0x1, G = new this(w); ++O < U; )
                          g(B[O], O);
                      return G;
                      function g(N, P) {
                          S['resolve'](N)['then'](function(M) {
                              J[P] = M,
                              ++C !== U || q || (q = true,
                              Y['resolve'](G, J));
                          }, function(M) {
                              q || (q = true,
                              Y['reject'](G, M));
                          });
                      }
                  }
                  ,
                  W['race'] = function(B) {
                      if ('[object\x20Array]' !== Object['prototype']['toString']['call'](B))
                          return this['reject'](new TypeError('must\x20be\x20an\x20array'));
                      var S = B['length']
                        , U = false;
                      if (!S)
                          return this['resolve']([]);
                      for (var q, J = -0x1, C = new this(w); ++J < S; )
                          q = B[J],
                          this['resolve'](q)['then'](function(O) {
                              U || (U = true,
                              Y['resolve'](C, O));
                          }, function(O) {
                              U || (U = true,
                              Y['reject'](C, O));
                          });
                      return C;
                  }
                  ;
              }
              , {
                  'immediate': 0x24
              }],
              0x26: [function(c, H, x) {
                  'use strict';
                  var p = {};
                  (0x0,
                  c('./lib/utils/common')['assign'])(p, c('./lib/deflate'), c('./lib/inflate'), c('./lib/zlib/constants')),
                  H['exports'] = p;
              }
              , {
                  './lib/deflate': 0x27,
                  './lib/inflate': 0x28,
                  './lib/utils/common': 0x29,
                  './lib/zlib/constants': 0x2c
              }],
              0x27: [function(H, x, F) {
                  'use strict';
                  var y = H('./zlib/deflate')
                    , w = H('./utils/common')
                    , Y = H('./utils/strings')
                    , T = H('./zlib/messages')
                    , X = H('./zlib/zstream')
                    , E = Object['prototype']['toString']
                    , W = 0x0
                    , I = -0x1
                    , j = 0x0
                    , D = 0x8;
                  function V(B) {
                      if (!(this instanceof V))
                          return new V(B);
                      this['options'] = w['assign']({
                          'level': I,
                          'method': D,
                          'chunkSize': 0x4000,
                          'windowBits': 0xf,
                          'memLevel': 0x8,
                          'strategy': j,
                          'to': ''
                      }, B || {});
                      var S = this['options'];
                      S['raw'] && 0x0 < S['windowBits'] ? S['windowBits'] = -S['windowBits'] : S['gzip'] && 0x0 < S['windowBits'] && S['windowBits'] < 0x10 && (S['windowBits'] += 0x10),
                      this['err'] = 0x0,
                      this['msg'] = '',
                      this['ended'] = false,
                      this['chunks'] = [],
                      this['strm'] = new X(),
                      this['strm']['avail_out'] = 0x0;
                      var U = y['deflateInit2'](this['strm'], S['level'], S['method'], S['windowBits'], S['memLevel'], S['strategy']);
                      if (U !== W)
                          throw new Error(T[U]);
                      if (S['header'] && y['deflateSetHeader'](this['strm'], S['header']),
                      S['dictionary']) {
                          var q;
                          if (q = 'string' == typeof S['dictionary'] ? Y['string2buf'](S['dictionary']) : '[object\x20ArrayBuffer]' === E['call'](S['dictionary']) ? new Uint8Array(S['dictionary']) : S['dictionary'],
                          (U = y['deflateSetDictionary'](this['strm'], q)) !== W)
                              throw new Error(T[U]);
                          this['_dict_set'] = true;
                      }
                  }
                  function Z(B, S) {
                      var U = new V(S);
                      if (U['push'](B, true),
                      U['err'])
                          throw U['msg'] || T[U['err']];
                      return U['result'];
                  }
                  V['prototype']['push'] = function(B, S) {
                      var U, q, J = this['strm'], C = this['options']['chunkSize'];
                      if (this['ended'])
                          return false;
                      q = S === ~~S ? S : true === S ? 0x4 : 0x0,
                      'string' == typeof B ? J['input'] = Y['string2buf'](B) : '[object\x20ArrayBuffer]' === E['call'](B) ? J['input'] = new Uint8Array(B) : J['input'] = B,
                      J['next_in'] = 0x0,
                      J['avail_in'] = J['input']['length'];
                      do {
                          if (0x0 === J['avail_out'] && (J['output'] = new w['Buf8'](C),
                          J['next_out'] = 0x0,
                          J['avail_out'] = C),
                          0x1 !== (U = y['deflate'](J, q)) && U !== W)
                              return this['onEnd'](U),
                              !(this['ended'] = true);
                          0x0 !== J['avail_out'] && (0x0 !== J['avail_in'] || 0x4 !== q && 0x2 !== q) || ('string' === this['options']['to'] ? this['onData'](Y['buf2binstring'](w['shrinkBuf'](J['output'], J['next_out']))) : this['onData'](w['shrinkBuf'](J['output'], J['next_out'])));
                      } while ((0x0 < J['avail_in'] || 0x0 === J['avail_out']) && 0x1 !== U);
                      return 0x4 === q ? (U = y['deflateEnd'](this['strm']),
                      this['onEnd'](U),
                      this['ended'] = true,
                      U === W) : 0x2 !== q || (this['onEnd'](W),
                      !(J['avail_out'] = 0x0));
                  }
                  ,
                  V['prototype']['onData'] = function(B) {
                      this['chunks']['push'](B);
                  }
                  ,
                  V['prototype']['onEnd'] = function(B) {
                      B === W && ('string' === this['options']['to'] ? this['result'] = this['chunks']['join']('') : this['result'] = w['flattenChunks'](this['chunks'])),
                      this['chunks'] = [],
                      this['err'] = B,
                      this['msg'] = this['strm']['msg'];
                  }
                  ,
                  F['Deflate'] = V,
                  F['deflate'] = Z,
                  F['deflateRaw'] = function(B, S) {
                      return (S = S || {})['raw'] = true,
                      Z(B, S);
                  }
                  ,
                  F['gzip'] = function(B, S) {
                      return (S = S || {})['gzip'] = true,
                      Z(B, S);
                  }
                  ;
              }
              , {
                  './utils/common': 0x29,
                  './utils/strings': 0x2a,
                  './zlib/deflate': 0x2e,
                  './zlib/messages': 0x33,
                  './zlib/zstream': 0x35
              }],
              0x28: [function(H, x, p) {
                  'use strict';
                  var F = H('./zlib/inflate')
                    , y = H('./utils/common')
                    , w = H('./utils/strings')
                    , Y = H('./zlib/constants')
                    , T = H('./zlib/messages')
                    , X = H('./zlib/zstream')
                    , E = H('./zlib/gzheader')
                    , f = Object['prototype']['toString'];
                  function W(j) {
                      if (!(this instanceof W))
                          return new W(j);
                      this['options'] = y['assign']({
                          'chunkSize': 0x4000,
                          'windowBits': 0x0,
                          'to': ''
                      }, j || {});
                      var D = this['options'];
                      D['raw'] && 0x0 <= D['windowBits'] && D['windowBits'] < 0x10 && (D['windowBits'] = -D['windowBits'],
                      0x0 === D['windowBits'] && (D['windowBits'] = -0xf)),
                      !(0x0 <= D['windowBits'] && D['windowBits'] < 0x10) || j && j['windowBits'] || (D['windowBits'] += 0x20),
                      0xf < D['windowBits'] && D['windowBits'] < 0x30 && 0x0 == (0xf & D['windowBits']) && (D['windowBits'] |= 0xf),
                      this['err'] = 0x0,
                      this['msg'] = '',
                      this['ended'] = false,
                      this['chunks'] = [],
                      this['strm'] = new X(),
                      this['strm']['avail_out'] = 0x0;
                      var V = F['inflateInit2'](this['strm'], D['windowBits']);
                      if (V !== Y['Z_OK'])
                          throw new Error(T[V]);
                      this['header'] = new E(),
                      F['inflateGetHeader'](this['strm'], this['header']);
                  }
                  function I(j, D) {
                      var V = new W(D);
                      if (V['push'](j, true),
                      V['err'])
                          throw V['msg'] || T[V['err']];
                      return V['result'];
                  }
                  W['prototype']['push'] = function(j, D) {
                      var V, Z, B, S, U, q, J = this['strm'], C = this['options']['chunkSize'], O = this['options']['dictionary'], G = false;
                      if (this['ended'])
                          return false;
                      Z = D === ~~D ? D : true === D ? Y['Z_FINISH'] : Y['Z_NO_FLUSH'],
                      'string' == typeof j ? J['input'] = w['binstring2buf'](j) : '[object\x20ArrayBuffer]' === f['call'](j) ? J['input'] = new Uint8Array(j) : J['input'] = j,
                      J['next_in'] = 0x0,
                      J['avail_in'] = J['input']['length'];
                      do {
                          if (0x0 === J['avail_out'] && (J['output'] = new y['Buf8'](C),
                          J['next_out'] = 0x0,
                          J['avail_out'] = C),
                          (V = F['inflate'](J, Y['Z_NO_FLUSH'])) === Y['Z_NEED_DICT'] && O && (q = 'string' == typeof O ? w['string2buf'](O) : '[object\x20ArrayBuffer]' === f['call'](O) ? new Uint8Array(O) : O,
                          V = F['inflateSetDictionary'](this['strm'], q)),
                          V === Y['Z_BUF_ERROR'] && true === G && (V = Y['Z_OK'],
                          G = false),
                          V !== Y['Z_STREAM_END'] && V !== Y['Z_OK'])
                              return this['onEnd'](V),
                              !(this['ended'] = true);
                          J['next_out'] && (0x0 !== J['avail_out'] && V !== Y['Z_STREAM_END'] && (0x0 !== J['avail_in'] || Z !== Y['Z_FINISH'] && Z !== Y['Z_SYNC_FLUSH']) || ('string' === this['options']['to'] ? (B = w['utf8border'](J['output'], J['next_out']),
                          S = J['next_out'] - B,
                          U = w['buf2string'](J['output'], B),
                          J['next_out'] = S,
                          J['avail_out'] = C - S,
                          S && y['arraySet'](J['output'], J['output'], B, S, 0x0),
                          this['onData'](U)) : this['onData'](y['shrinkBuf'](J['output'], J['next_out'])))),
                          0x0 === J['avail_in'] && 0x0 === J['avail_out'] && (G = true);
                      } while ((0x0 < J['avail_in'] || 0x0 === J['avail_out']) && V !== Y['Z_STREAM_END']);
                      return V === Y['Z_STREAM_END'] && (Z = Y['Z_FINISH']),
                      Z === Y['Z_FINISH'] ? (V = F['inflateEnd'](this['strm']),
                      this['onEnd'](V),
                      this['ended'] = true,
                      V === Y['Z_OK']) : Z !== Y['Z_SYNC_FLUSH'] || (this['onEnd'](Y['Z_OK']),
                      !(J['avail_out'] = 0x0));
                  }
                  ,
                  W['prototype']['onData'] = function(j) {
                      this['chunks']['push'](j);
                  }
                  ,
                  W['prototype']['onEnd'] = function(j) {
                      j === Y['Z_OK'] && ('string' === this['options']['to'] ? this['result'] = this['chunks']['join']('') : this['result'] = y['flattenChunks'](this['chunks'])),
                      this['chunks'] = [],
                      this['err'] = j,
                      this['msg'] = this['strm']['msg'];
                  }
                  ,
                  p['Inflate'] = W,
                  p['inflate'] = I,
                  p['inflateRaw'] = function(j, D) {
                      return (D = D || {})['raw'] = true,
                      I(j, D);
                  }
                  ,
                  p['ungzip'] = I;
              }
              , {
                  './utils/common': 0x29,
                  './utils/strings': 0x2a,
                  './zlib/constants': 0x2c,
                  './zlib/gzheader': 0x2f,
                  './zlib/inflate': 0x31,
                  './zlib/messages': 0x33,
                  './zlib/zstream': 0x35
              }],
              0x29: [function(c, H, x) {
                  'use strict';
                  var p = 'undefined' != typeof Uint8Array && 'undefined' != typeof Uint16Array && 'undefined' != typeof Int32Array;
                  x['assign'] = function(w) {
                      for (var h = Array['prototype']['slice']['call'](arguments, 0x1); h['length']; ) {
                          var u = h['shift']();
                          if (u) {
                              if ('object' != typeof u)
                                  throw new TypeError(u + 'must\x20be\x20non-object');
                              for (var Y in u)
                                  u['hasOwnProperty'](Y) && (w[Y] = u[Y]);
                          }
                      }
                      return w;
                  }
                  ,
                  x['shrinkBuf'] = function(w, h) {
                      return w['length'] === h ? w : w['subarray'] ? w['subarray'](0x0, h) : (w['length'] = h,
                      w);
                  }
                  ;
                  var F = {
                      'arraySet': function(w, h, u, Y, T) {
                          if (h['subarray'] && w['subarray'])
                              w['set'](h['subarray'](u, u + Y), T);
                          else {
                              for (var X = 0x0; X < Y; X++)
                                  w[T + X] = h[u + X];
                          }
                      },
                      'flattenChunks': function(w) {
                          var h, u, Y, T, X, E;
                          for (h = Y = 0x0,
                          u = w['length']; h < u; h++)
                              Y += w[h]['length'];
                          for (E = new Uint8Array(Y),
                          h = T = 0x0,
                          u = w['length']; h < u; h++)
                              X = w[h],
                              E['set'](X, T),
                              T += X['length'];
                          return E;
                      }
                  }
                    , y = {
                      'arraySet': function(w, h, u, Y, T) {
                          for (var X = 0x0; X < Y; X++)
                              w[T + X] = h[u + X];
                      },
                      'flattenChunks': function(w) {
                          return []['concat']['apply']([], w);
                      }
                  };
                  x['setTyped'] = function(w) {
                      w ? (x['Buf8'] = Uint8Array,
                      x['Buf16'] = Uint16Array,
                      x['Buf32'] = Int32Array,
                      x['assign'](x, F)) : (x['Buf8'] = Array,
                      x['Buf16'] = Array,
                      x['Buf32'] = Array,
                      x['assign'](x, y));
                  }
                  ,
                  x['setTyped'](p);
              }
              , {}],
              0x2a: [function(c, H, x) {
                  'use strict';
                  var p = c('./common')
                    , F = true
                    , y = true;
                  try {
                      String['fromCharCode']['apply'](null, [0x0]);
                  } catch (Y) {
                      F = false;
                  }
                  try {
                      String['fromCharCode']['apply'](null, new Uint8Array(0x1));
                  } catch (T) {
                      y = false;
                  }
                  for (var w = new p['Buf8'](0x100), h = 0x0; h < 0x100; h++)
                      w[h] = 0xfc <= h ? 0x6 : 0xf8 <= h ? 0x5 : 0xf0 <= h ? 0x4 : 0xe0 <= h ? 0x3 : 0xc0 <= h ? 0x2 : 0x1;
                  function u(X, E) {
                      if (E < 0x10001 && (X['subarray'] && y || !X['subarray'] && F))
                          return String['fromCharCode']['apply'](null, p['shrinkBuf'](X, E));
                      for (var f = '', W = 0x0; W < E; W++)
                          f += String['fromCharCode'](X[W]);
                      return f;
                  }
                  w[0xfe] = w[0xfe] = 0x1,
                  x['string2buf'] = function(X) {
                      var E, f, W, I, j, D = X['length'], V = 0x0;
                      for (I = 0x0; I < D; I++)
                          0xd800 == (0xfc00 & (f = X['charCodeAt'](I))) && I + 0x1 < D && 0xdc00 == (0xfc00 & (W = X['charCodeAt'](I + 0x1))) && (f = 0x10000 + (f - 0xd800 << 0xa) + (W - 0xdc00),
                          I++),
                          V += f < 0x80 ? 0x1 : f < 0x800 ? 0x2 : f < 0x10000 ? 0x3 : 0x4;
                      for (E = new p['Buf8'](V),
                      I = j = 0x0; j < V; I++)
                          0xd800 == (0xfc00 & (f = X['charCodeAt'](I))) && I + 0x1 < D && 0xdc00 == (0xfc00 & (W = X['charCodeAt'](I + 0x1))) && (f = 0x10000 + (f - 0xd800 << 0xa) + (W - 0xdc00),
                          I++),
                          f < 0x80 ? E[j++] = f : (f < 0x800 ? E[j++] = 0xc0 | f >>> 0x6 : (f < 0x10000 ? E[j++] = 0xe0 | f >>> 0xc : (E[j++] = 0xf0 | f >>> 0x12,
                          E[j++] = 0x80 | f >>> 0xc & 0x3f),
                          E[j++] = 0x80 | f >>> 0x6 & 0x3f),
                          E[j++] = 0x80 | 0x3f & f);
                      return E;
                  }
                  ,
                  x['buf2binstring'] = function(X) {
                      return u(X, X['length']);
                  }
                  ,
                  x['binstring2buf'] = function(X) {
                      for (var E = new p['Buf8'](X['length']), f = 0x0, W = E['length']; f < W; f++)
                          E[f] = X['charCodeAt'](f);
                      return E;
                  }
                  ,
                  x['buf2string'] = function(X, E) {
                      var f, W, I, j, D = E || X['length'], V = new Array(0x2 * D);
                      for (f = W = 0x0; f < D; )
                          if ((I = X[f++]) < 0x80)
                              V[W++] = I;
                          else {
                              if (0x4 < (j = w[I]))
                                  V[W++] = 0xfffd,
                                  f += j - 0x1;
                              else {
                                  for (I &= 0x2 === j ? 0x1f : 0x3 === j ? 0xf : 0x7; 0x1 < j && f < D; )
                                      I = I << 0x6 | 0x3f & X[f++],
                                      j--;
                                  0x1 < j ? V[W++] = 0xfffd : I < 0x10000 ? V[W++] = I : (I -= 0x10000,
                                  V[W++] = 0xd800 | I >> 0xa & 0x3ff,
                                  V[W++] = 0xdc00 | 0x3ff & I);
                              }
                          }
                      return u(V, W);
                  }
                  ,
                  x['utf8border'] = function(X, E) {
                      var f;
                      for ((E = E || X['length']) > X['length'] && (E = X['length']),
                      f = E - 0x1; 0x0 <= f && 0x80 == (0xc0 & X[f]); )
                          f--;
                      return f < 0x0 || 0x0 === f ? E : f + w[X[f]] > E ? f : E;
                  }
                  ;
              }
              , {
                  './common': 0x29
              }],
              0x2b: [function(c, H, x) {
                  'use strict';
                  H['exports'] = function(p, F, y, w) {
                      for (var h = 0xffff & p | 0x0, u = p >>> 0x10 & 0xffff | 0x0, Y = 0x0; 0x0 !== y; ) {
                          for (y -= Y = 0x7d0 < y ? 0x7d0 : y; u = u + (h = h + F[w++] | 0x0) | 0x0,
                          --Y; )
                              ;
                          h %= 0xfff1,
                          u %= 0xfff1;
                      }
                      return h | u << 0x10 | 0x0;
                  }
                  ;
              }
              , {}],
              0x2c: [function(c, H, x) {
                  'use strict';
                  H['exports'] = {
                      'Z_NO_FLUSH': 0x0,
                      'Z_PARTIAL_FLUSH': 0x1,
                      'Z_SYNC_FLUSH': 0x2,
                      'Z_FULL_FLUSH': 0x3,
                      'Z_FINISH': 0x4,
                      'Z_BLOCK': 0x5,
                      'Z_TREES': 0x6,
                      'Z_OK': 0x0,
                      'Z_STREAM_END': 0x1,
                      'Z_NEED_DICT': 0x2,
                      'Z_ERRNO': -0x1,
                      'Z_STREAM_ERROR': -0x2,
                      'Z_DATA_ERROR': -0x3,
                      'Z_BUF_ERROR': -0x5,
                      'Z_NO_COMPRESSION': 0x0,
                      'Z_BEST_SPEED': 0x1,
                      'Z_BEST_COMPRESSION': 0x9,
                      'Z_DEFAULT_COMPRESSION': -0x1,
                      'Z_FILTERED': 0x1,
                      'Z_HUFFMAN_ONLY': 0x2,
                      'Z_RLE': 0x3,
                      'Z_FIXED': 0x4,
                      'Z_DEFAULT_STRATEGY': 0x0,
                      'Z_BINARY': 0x0,
                      'Z_TEXT': 0x1,
                      'Z_UNKNOWN': 0x2,
                      'Z_DEFLATED': 0x8
                  };
              }
              , {}],
              0x2d: [function(c, H, x) {
                  'use strict';
                  var p = function() {
                      for (var F, y = [], w = 0x0; w < 0x100; w++) {
                          F = w;
                          for (var s = 0x0; s < 0x8; s++)
                              F = 0x1 & F ? 0xedb88320 ^ F >>> 0x1 : F >>> 0x1;
                          y[w] = F;
                      }
                      return y;
                  }();
                  H['exports'] = function(F, y, w, h) {
                      var u = p
                        , Y = h + w;
                      F ^= -0x1;
                      for (var T = h; T < Y; T++)
                          F = F >>> 0x8 ^ u[0xff & (F ^ y[T])];
                      return -0x1 ^ F;
                  }
                  ;
              }
              , {}],
              0x2e: [function(H, Y, X) {
                  'use strict';
                  var W, j = H('../utils/common'), V = H('./trees'), Z = H('./adler32'), q = H('./crc32'), J = H('./messages'), G = 0x0, N = 0x0, Q = -0x2, v0 = 0x2, v1 = 0x8, v2 = 0x11e, v3 = 0x1e, v4 = 0x13, v5 = 0x2 * v2 + 0x1, v6 = 0xf, v7 = 0x3, v8 = 0x102, v9 = v8 + v7 + 0x1, vv = 0x2a, vA = 0x71;
                  function vn(vs, vh) {
                      return vs['msg'] = J[vh],
                      vh;
                  }
                  function vk(vs) {
                      return (vs << 0x1) - (0x4 < vs ? 0x9 : 0x0);
                  }
                  function vl(vs) {
                      for (var vh = vs['length']; 0x0 <= --vh; )
                          vs[vh] = 0x0;
                  }
                  function vK(vs) {
                      var vh = vs['state']
                        , vu = vh['pending'];
                      vu > vs['avail_out'] && (vu = vs['avail_out']),
                      0x0 !== vu && (j['arraySet'](vs['output'], vh['pending_buf'], vh['pending_out'], vu, vs['next_out']),
                      vs['next_out'] += vu,
                      vh['pending_out'] += vu,
                      vs['total_out'] += vu,
                      vs['avail_out'] -= vu,
                      vh['pending'] -= vu,
                      0x0 === vh['pending'] && (vh['pending_out'] = 0x0));
                  }
                  function vi(vs, vh) {
                      V['_tr_flush_block'](vs, 0x0 <= vs['block_start'] ? vs['block_start'] : -0x1, vs['strstart'] - vs['block_start'], vh),
                      vs['block_start'] = vs['strstart'],
                      vK(vs['strm']);
                  }
                  function vb(vs, vh) {
                      vs['pending_buf'][vs['pending']++] = vh;
                  }
                  function ve(vs, vh) {
                      vs['pending_buf'][vs['pending']++] = vh >>> 0x8 & 0xff,
                      vs['pending_buf'][vs['pending']++] = 0xff & vh;
                  }
                  function vc(vs, vh) {
                      var vu, vY, vT = vs['max_chain_length'], vX = vs['strstart'], Quadtree = vs['prev_length'], vf = vs['nice_match'], vW = vs['strstart'] > vs['w_size'] - v9 ? vs['strstart'] - (vs['w_size'] - v9) : 0x0, vI = vs['window'], vj = vs['w_mask'], vD = vs['prev'], vV = vs['strstart'] + v8, vZ = vI[vX + Quadtree - 0x1], vB = vI[vX + Quadtree];
                      vs['prev_length'] >= vs['good_match'] && (vT >>= 0x2),
                      vf > vs['lookahead'] && (vf = vs['lookahead']);
                      do {
                          if (vI[(vu = vh) + Quadtree] === vB && vI[vu + Quadtree - 0x1] === vZ && vI[vu] === vI[vX] && vI[++vu] === vI[vX + 0x1]) {
                              vX += 0x2,
                              vu++;
                              do {} while (vI[++vX] === vI[++vu] && vI[++vX] === vI[++vu] && vI[++vX] === vI[++vu] && vI[++vX] === vI[++vu] && vI[++vX] === vI[++vu] && vI[++vX] === vI[++vu] && vI[++vX] === vI[++vu] && vI[++vX] === vI[++vu] && vX < vV);
                              if (vY = v8 - (vV - vX),
                              vX = vV - v8,
                              Quadtree < vY) {
                                  if (vs['match_start'] = vh,
                                  vf <= (Quadtree = vY))
                                      break;
                                  vZ = vI[vX + Quadtree - 0x1],
                                  vB = vI[vX + Quadtree];
                              }
                          }
                      } while ((vh = vD[vh & vj]) > vW && 0x0 != --vT);
                      return Quadtree <= vs['lookahead'] ? Quadtree : vs['lookahead'];
                  }
                  function vH(vs) {
                      var vh, vu, vY, vT, vX, Quadtree, vf, vW, vI, vj, vD = vs['w_size'];
                      do {
                          if (vT = vs['window_size'] - vs['lookahead'] - vs['strstart'],
                          vs['strstart'] >= vD + (vD - v9)) {
                              for (j['arraySet'](vs['window'], vs['window'], vD, vD, 0x0),
                              vs['match_start'] -= vD,
                              vs['strstart'] -= vD,
                              vs['block_start'] -= vD,
                              vh = vu = vs['hash_size']; vY = vs['head'][--vh],
                              vs['head'][vh] = vD <= vY ? vY - vD : 0x0,
                              --vu; )
                                  ;
                              for (vh = vu = vD; vY = vs['prev'][--vh],
                              vs['prev'][vh] = vD <= vY ? vY - vD : 0x0,
                              --vu; )
                                  ;
                              vT += vD;
                          }
                          if (0x0 === vs['strm']['avail_in'])
                              break;
                          if (Quadtree = vs['strm'],
                          vf = vs['window'],
                          vW = vs['strstart'] + vs['lookahead'],
                          vj = undefined,
                          (vI = vT) < (vj = Quadtree['avail_in']) && (vj = vI),
                          vu = 0x0 === vj ? 0x0 : (Quadtree['avail_in'] -= vj,
                          j['arraySet'](vf, Quadtree['input'], Quadtree['next_in'], vj, vW),
                          0x1 === Quadtree['state']['wrap'] ? Quadtree['adler'] = Z(Quadtree['adler'], vf, vj, vW) : 0x2 === Quadtree['state']['wrap'] && (Quadtree['adler'] = q(Quadtree['adler'], vf, vj, vW)),
                          Quadtree['next_in'] += vj,
                          Quadtree['total_in'] += vj,
                          vj),
                          vs['lookahead'] += vu,
                          vs['lookahead'] + vs['insert'] >= v7) {
                              for (vX = vs['strstart'] - vs['insert'],
                              vs['ins_h'] = vs['window'][vX],
                              vs['ins_h'] = (vs['ins_h'] << vs['hash_shift'] ^ vs['window'][vX + 0x1]) & vs['hash_mask']; vs['insert'] && (vs['ins_h'] = (vs['ins_h'] << vs['hash_shift'] ^ vs['window'][vX + v7 - 0x1]) & vs['hash_mask'],
                              vs['prev'][vX & vs['w_mask']] = vs['head'][vs['ins_h']],
                              vs['head'][vs['ins_h']] = vX,
                              vX++,
                              vs['insert']--,
                              !(vs['lookahead'] + vs['insert'] < v7)); )
                                  ;
                          }
                      } while (vs['lookahead'] < v9 && 0x0 !== vs['strm']['avail_in']);
                  }
                  function vt(vs, vh) {
                      for (var vu, vY; ; ) {
                          if (vs['lookahead'] < v9) {
                              if (vH(vs),
                              vs['lookahead'] < v9 && vh === G)
                                  return 0x1;
                              if (0x0 === vs['lookahead'])
                                  break;
                          }
                          if (vu = 0x0,
                          vs['lookahead'] >= v7 && (vs['ins_h'] = (vs['ins_h'] << vs['hash_shift'] ^ vs['window'][vs['strstart'] + v7 - 0x1]) & vs['hash_mask'],
                          vu = vs['prev'][vs['strstart'] & vs['w_mask']] = vs['head'][vs['ins_h']],
                          vs['head'][vs['ins_h']] = vs['strstart']),
                          0x0 !== vu && vs['strstart'] - vu <= vs['w_size'] - v9 && (vs['match_length'] = vc(vs, vu)),
                          vs['match_length'] >= v7) {
                              if (vY = V['_tr_tally'](vs, vs['strstart'] - vs['match_start'], vs['match_length'] - v7),
                              vs['lookahead'] -= vs['match_length'],
                              vs['match_length'] <= vs['max_lazy_match'] && vs['lookahead'] >= v7) {
                                  for (vs['match_length']--; vs['strstart']++,
                                  vs['ins_h'] = (vs['ins_h'] << vs['hash_shift'] ^ vs['window'][vs['strstart'] + v7 - 0x1]) & vs['hash_mask'],
                                  vu = vs['prev'][vs['strstart'] & vs['w_mask']] = vs['head'][vs['ins_h']],
                                  vs['head'][vs['ins_h']] = vs['strstart'],
                                  0x0 != --vs['match_length']; )
                                      ;
                                  vs['strstart']++;
                              } else
                                  vs['strstart'] += vs['match_length'],
                                  vs['match_length'] = 0x0,
                                  vs['ins_h'] = vs['window'][vs['strstart']],
                                  vs['ins_h'] = (vs['ins_h'] << vs['hash_shift'] ^ vs['window'][vs['strstart'] + 0x1]) & vs['hash_mask'];
                          } else
                              vY = V['_tr_tally'](vs, 0x0, vs['window'][vs['strstart']]),
                              vs['lookahead']--,
                              vs['strstart']++;
                          if (vY && (vi(vs, false),
                          0x0 === vs['strm']['avail_out']))
                              return 0x1;
                      }
                      return vs['insert'] = vs['strstart'] < v7 - 0x1 ? vs['strstart'] : v7 - 0x1,
                      0x4 === vh ? (vi(vs, true),
                      0x0 === vs['strm']['avail_out'] ? 0x3 : 0x4) : vs['last_lit'] && (vi(vs, false),
                      0x0 === vs['strm']['avail_out']) ? 0x1 : 0x2;
                  }
                  function vx(vs, vh) {
                      for (var vu, vY, vT; ; ) {
                          if (vs['lookahead'] < v9) {
                              if (vH(vs),
                              vs['lookahead'] < v9 && vh === G)
                                  return 0x1;
                              if (0x0 === vs['lookahead'])
                                  break;
                          }
                          if (vu = 0x0,
                          vs['lookahead'] >= v7 && (vs['ins_h'] = (vs['ins_h'] << vs['hash_shift'] ^ vs['window'][vs['strstart'] + v7 - 0x1]) & vs['hash_mask'],
                          vu = vs['prev'][vs['strstart'] & vs['w_mask']] = vs['head'][vs['ins_h']],
                          vs['head'][vs['ins_h']] = vs['strstart']),
                          vs['prev_length'] = vs['match_length'],
                          vs['prev_match'] = vs['match_start'],
                          vs['match_length'] = v7 - 0x1,
                          0x0 !== vu && vs['prev_length'] < vs['max_lazy_match'] && vs['strstart'] - vu <= vs['w_size'] - v9 && (vs['match_length'] = vc(vs, vu),
                          vs['match_length'] <= 0x5 && (0x1 === vs['strategy'] || vs['match_length'] === v7 && 0x1000 < vs['strstart'] - vs['match_start']) && (vs['match_length'] = v7 - 0x1)),
                          vs['prev_length'] >= v7 && vs['match_length'] <= vs['prev_length']) {
                              for (vT = vs['strstart'] + vs['lookahead'] - v7,
                              vY = V['_tr_tally'](vs, vs['strstart'] - 0x1 - vs['prev_match'], vs['prev_length'] - v7),
                              vs['lookahead'] -= vs['prev_length'] - 0x1,
                              vs['prev_length'] -= 0x2; ++vs['strstart'] <= vT && (vs['ins_h'] = (vs['ins_h'] << vs['hash_shift'] ^ vs['window'][vs['strstart'] + v7 - 0x1]) & vs['hash_mask'],
                              vu = vs['prev'][vs['strstart'] & vs['w_mask']] = vs['head'][vs['ins_h']],
                              vs['head'][vs['ins_h']] = vs['strstart']),
                              0x0 != --vs['prev_length']; )
                                  ;
                              if (vs['match_available'] = 0x0,
                              vs['match_length'] = v7 - 0x1,
                              vs['strstart']++,
                              vY && (vi(vs, false),
                              0x0 === vs['strm']['avail_out']))
                                  return 0x1;
                          } else {
                              if (vs['match_available']) {
                                  if ((vY = V['_tr_tally'](vs, 0x0, vs['window'][vs['strstart'] - 0x1])) && vi(vs, false),
                                  vs['strstart']++,
                                  vs['lookahead']--,
                                  0x0 === vs['strm']['avail_out'])
                                      return 0x1;
                              } else
                                  vs['match_available'] = 0x1,
                                  vs['strstart']++,
                                  vs['lookahead']--;
                          }
                      }
                      return vs['match_available'] && (vY = V['_tr_tally'](vs, 0x0, vs['window'][vs['strstart'] - 0x1]),
                      vs['match_available'] = 0x0),
                      vs['insert'] = vs['strstart'] < v7 - 0x1 ? vs['strstart'] : v7 - 0x1,
                      0x4 === vh ? (vi(vs, true),
                      0x0 === vs['strm']['avail_out'] ? 0x3 : 0x4) : vs['last_lit'] && (vi(vs, false),
                      0x0 === vs['strm']['avail_out']) ? 0x1 : 0x2;
                  }
                  function vp(vs, vh, vu, vY, vT) {
                      this['good_length'] = vs,
                      this['max_lazy'] = vh,
                      this['nice_length'] = vu,
                      this['max_chain'] = vY,
                      this['func'] = vT;
                  }
                  function vF() {
                      this['strm'] = null,
                      this['status'] = 0x0,
                      this['pending_buf'] = null,
                      this['pending_buf_size'] = 0x0,
                      this['pending_out'] = 0x0,
                      this['pending'] = 0x0,
                      this['wrap'] = 0x0,
                      this['gzhead'] = null,
                      this['gzindex'] = 0x0,
                      this['method'] = v1,
                      this['last_flush'] = -0x1,
                      this['w_size'] = 0x0,
                      this['w_bits'] = 0x0,
                      this['w_mask'] = 0x0,
                      this['window'] = null,
                      this['window_size'] = 0x0,
                      this['prev'] = null,
                      this['head'] = null,
                      this['ins_h'] = 0x0,
                      this['hash_size'] = 0x0,
                      this['hash_bits'] = 0x0,
                      this['hash_mask'] = 0x0,
                      this['hash_shift'] = 0x0,
                      this['block_start'] = 0x0,
                      this['match_length'] = 0x0,
                      this['prev_match'] = 0x0,
                      this['match_available'] = 0x0,
                      this['strstart'] = 0x0,
                      this['match_start'] = 0x0,
                      this['lookahead'] = 0x0,
                      this['prev_length'] = 0x0,
                      this['max_chain_length'] = 0x0,
                      this['max_lazy_match'] = 0x0,
                      this['level'] = 0x0,
                      this['strategy'] = 0x0,
                      this['good_match'] = 0x0,
                      this['nice_match'] = 0x0,
                      this['dyn_ltree'] = new j['Buf16'](0x2 * v5),
                      this['dyn_dtree'] = new j['Buf16'](0x2 * (0x2 * v3 + 0x1)),
                      this['bl_tree'] = new j['Buf16'](0x2 * (0x2 * v4 + 0x1)),
                      vl(this['dyn_ltree']),
                      vl(this['dyn_dtree']),
                      vl(this['bl_tree']),
                      this['l_desc'] = null,
                      this['d_desc'] = null,
                      this['bl_desc'] = null,
                      this['bl_count'] = new j['Buf16'](v6 + 0x1),
                      this['heap'] = new j['Buf16'](0x2 * v2 + 0x1),
                      vl(this['heap']),
                      this['heap_len'] = 0x0,
                      this['heap_max'] = 0x0,
                      this['depth'] = new j['Buf16'](0x2 * v2 + 0x1),
                      vl(this['depth']),
                      this['l_buf'] = 0x0,
                      this['lit_bufsize'] = 0x0,
                      this['last_lit'] = 0x0,
                      this['d_buf'] = 0x0,
                      this['opt_len'] = 0x0,
                      this['static_len'] = 0x0,
                      this['matches'] = 0x0,
                      this['insert'] = 0x0,
                      this['bi_buf'] = 0x0,
                      this['bi_valid'] = 0x0;
                  }
                  function vy(vs) {
                      var vh;
                      return vs && vs['state'] ? (vs['total_in'] = vs['total_out'] = 0x0,
                      vs['data_type'] = v0,
                      (vh = vs['state'])['pending'] = 0x0,
                      vh['pending_out'] = 0x0,
                      vh['wrap'] < 0x0 && (vh['wrap'] = -vh['wrap']),
                      vh['status'] = vh['wrap'] ? vv : vA,
                      vs['adler'] = 0x2 === vh['wrap'] ? 0x0 : 0x1,
                      vh['last_flush'] = G,
                      V['_tr_init'](vh),
                      N) : vn(vs, Q);
                  }
                  function vr(vs) {
                      var vh = vy(vs);
                      return vh === N && function(vu) {
                          vu['window_size'] = 0x2 * vu['w_size'],
                          vl(vu['head']),
                          vu['max_lazy_match'] = W[vu['level']]['max_lazy'],
                          vu['good_match'] = W[vu['level']]['good_length'],
                          vu['nice_match'] = W[vu['level']]['nice_length'],
                          vu['max_chain_length'] = W[vu['level']]['max_chain'],
                          vu['strstart'] = 0x0,
                          vu['block_start'] = 0x0,
                          vu['lookahead'] = 0x0,
                          vu['insert'] = 0x0,
                          vu['match_length'] = vu['prev_length'] = v7 - 0x1,
                          vu['match_available'] = 0x0,
                          vu['ins_h'] = 0x0;
                      }(vs['state']),
                      vh;
                  }
                  function vw(vs, vh, vu, vY, vT, vX) {
                      if (!vs)
                          return Q;
                      var Quadtree = 0x1;
                      if (-0x1 === vh && (vh = 0x6),
                      vY < 0x0 ? (Quadtree = 0x0,
                      vY = -vY) : 0xf < vY && (Quadtree = 0x2,
                      vY -= 0x10),
                      vT < 0x1 || 0x9 < vT || vu !== v1 || vY < 0x8 || 0xf < vY || vh < 0x0 || 0x9 < vh || vX < 0x0 || 0x4 < vX)
                          return vn(vs, Q);
                      0x8 === vY && (vY = 0x9);
                      var vf = new vF();
                      return (vs['state'] = vf)['strm'] = vs,
                      vf['wrap'] = Quadtree,
                      vf['gzhead'] = null,
                      vf['w_bits'] = vY,
                      vf['w_size'] = 0x1 << vf['w_bits'],
                      vf['w_mask'] = vf['w_size'] - 0x1,
                      vf['hash_bits'] = vT + 0x7,
                      vf['hash_size'] = 0x1 << vf['hash_bits'],
                      vf['hash_mask'] = vf['hash_size'] - 0x1,
                      vf['hash_shift'] = ~~((vf['hash_bits'] + v7 - 0x1) / v7),
                      vf['window'] = new j['Buf8'](0x2 * vf['w_size']),
                      vf['head'] = new j['Buf16'](vf['hash_size']),
                      vf['prev'] = new j['Buf16'](vf['w_size']),
                      vf['lit_bufsize'] = 0x1 << vT + 0x6,
                      vf['pending_buf_size'] = 0x4 * vf['lit_bufsize'],
                      vf['pending_buf'] = new j['Buf8'](vf['pending_buf_size']),
                      vf['d_buf'] = 0x1 * vf['lit_bufsize'],
                      vf['l_buf'] = 0x3 * vf['lit_bufsize'],
                      vf['level'] = vh,
                      vf['strategy'] = vX,
                      vf['method'] = vu,
                      vr(vs);
                  }
                  W = [new vp(0x0,0x0,0x0,0x0,function(vs, vh) {
                      var vu = 0xffff;
                      for (vu > vs['pending_buf_size'] - 0x5 && (vu = vs['pending_buf_size'] - 0x5); ; ) {
                          if (vs['lookahead'] <= 0x1) {
                              if (vH(vs),
                              0x0 === vs['lookahead'] && vh === G)
                                  return 0x1;
                              if (0x0 === vs['lookahead'])
                                  break;
                          }
                          vs['strstart'] += vs['lookahead'],
                          vs['lookahead'] = 0x0;
                          var vY = vs['block_start'] + vu;
                          if ((0x0 === vs['strstart'] || vs['strstart'] >= vY) && (vs['lookahead'] = vs['strstart'] - vY,
                          vs['strstart'] = vY,
                          vi(vs, false),
                          0x0 === vs['strm']['avail_out']))
                              return 0x1;
                          if (vs['strstart'] - vs['block_start'] >= vs['w_size'] - v9 && (vi(vs, false),
                          0x0 === vs['strm']['avail_out']))
                              return 0x1;
                      }
                      return vs['insert'] = 0x0,
                      0x4 === vh ? (vi(vs, true),
                      0x0 === vs['strm']['avail_out'] ? 0x3 : 0x4) : (vs['strstart'] > vs['block_start'] && (vi(vs, false),
                      vs['strm']['avail_out']),
                      0x1);
                  }
                  ), new vp(0x4,0x4,0x8,0x4,vt), new vp(0x4,0x5,0x10,0x8,vt), new vp(0x4,0x6,0x20,0x20,vt), new vp(0x4,0x4,0x10,0x10,vx), new vp(0x8,0x10,0x20,0x20,vx), new vp(0x8,0x10,0x80,0x80,vx), new vp(0x8,0x20,0x80,0x100,vx), new vp(0x20,0x80,0x102,0x400,vx), new vp(0x20,0x102,0x102,0x1000,vx)],
                  X['deflateInit'] = function(vs, vh) {
                      return vw(vs, vh, v1, 0xf, 0x8, 0x0);
                  }
                  ,
                  X['deflateInit2'] = vw,
                  X['deflateReset'] = vr,
                  X['deflateResetKeep'] = vy,
                  X['deflateSetHeader'] = function(vs, vh) {
                      return vs && vs['state'] ? 0x2 !== vs['state']['wrap'] ? Q : (vs['state']['gzhead'] = vh,
                      N) : Q;
                  }
                  ,
                  X['deflate'] = function(vs, vh) {
                      var vu, vY, vT, vX;
                      if (!vs || !vs['state'] || 0x5 < vh || vh < 0x0)
                          return vs ? vn(vs, Q) : Q;
                      if (vY = vs['state'],
                      !vs['output'] || !vs['input'] && 0x0 !== vs['avail_in'] || 0x29a === vY['status'] && 0x4 !== vh)
                          return vn(vs, 0x0 === vs['avail_out'] ? -0x5 : Q);
                      if (vY['strm'] = vs,
                      vu = vY['last_flush'],
                      vY['last_flush'] = vh,
                      vY['status'] === vv) {
                          if (0x2 === vY['wrap'])
                              vs['adler'] = 0x0,
                              vb(vY, 0x1f),
                              vb(vY, 0x8b),
                              vb(vY, 0x8),
                              vY['gzhead'] ? (vb(vY, (vY['gzhead']['text'] ? 0x1 : 0x0) + (vY['gzhead']['hcrc'] ? 0x2 : 0x0) + (vY['gzhead']['extra'] ? 0x4 : 0x0) + (vY['gzhead']['name'] ? 0x8 : 0x0) + (vY['gzhead']['comment'] ? 0x10 : 0x0)),
                              vb(vY, 0xff & vY['gzhead']['time']),
                              vb(vY, vY['gzhead']['time'] >> 0x8 & 0xff),
                              vb(vY, vY['gzhead']['time'] >> 0x10 & 0xff),
                              vb(vY, vY['gzhead']['time'] >> 0x18 & 0xff),
                              vb(vY, 0x9 === vY['level'] ? 0x2 : 0x2 <= vY['strategy'] || vY['level'] < 0x2 ? 0x4 : 0x0),
                              vb(vY, 0xff & vY['gzhead']['os']),
                              vY['gzhead']['extra'] && vY['gzhead']['extra']['length'] && (vb(vY, 0xff & vY['gzhead']['extra']['length']),
                              vb(vY, vY['gzhead']['extra']['length'] >> 0x8 & 0xff)),
                              vY['gzhead']['hcrc'] && (vs['adler'] = q(vs['adler'], vY['pending_buf'], vY['pending'], 0x0)),
                              vY['gzindex'] = 0x0,
                              vY['status'] = 0x45) : (vb(vY, 0x0),
                              vb(vY, 0x0),
                              vb(vY, 0x0),
                              vb(vY, 0x0),
                              vb(vY, 0x0),
                              vb(vY, 0x9 === vY['level'] ? 0x2 : 0x2 <= vY['strategy'] || vY['level'] < 0x2 ? 0x4 : 0x0),
                              vb(vY, 0x3),
                              vY['status'] = vA);
                          else {
                              var Quadtree = v1 + (vY['w_bits'] - 0x8 << 0x4) << 0x8;
                              Quadtree |= (0x2 <= vY['strategy'] || vY['level'] < 0x2 ? 0x0 : vY['level'] < 0x6 ? 0x1 : 0x6 === vY['level'] ? 0x2 : 0x3) << 0x6,
                              0x0 !== vY['strstart'] && (Quadtree |= 0x20),
                              Quadtree += 0x1f - Quadtree % 0x1f,
                              vY['status'] = vA,
                              ve(vY, Quadtree),
                              0x0 !== vY['strstart'] && (ve(vY, vs['adler'] >>> 0x10),
                              ve(vY, 0xffff & vs['adler'])),
                              vs['adler'] = 0x1;
                          }
                      }
                      if (0x45 === vY['status']) {
                          if (vY['gzhead']['extra']) {
                              for (vT = vY['pending']; vY['gzindex'] < (0xffff & vY['gzhead']['extra']['length']) && (vY['pending'] !== vY['pending_buf_size'] || (vY['gzhead']['hcrc'] && vY['pending'] > vT && (vs['adler'] = q(vs['adler'], vY['pending_buf'], vY['pending'] - vT, vT)),
                              vK(vs),
                              vT = vY['pending'],
                              vY['pending'] !== vY['pending_buf_size'])); )
                                  vb(vY, 0xff & vY['gzhead']['extra'][vY['gzindex']]),
                                  vY['gzindex']++;
                              vY['gzhead']['hcrc'] && vY['pending'] > vT && (vs['adler'] = q(vs['adler'], vY['pending_buf'], vY['pending'] - vT, vT)),
                              vY['gzindex'] === vY['gzhead']['extra']['length'] && (vY['gzindex'] = 0x0,
                              vY['status'] = 0x49);
                          } else
                              vY['status'] = 0x49;
                      }
                      if (0x49 === vY['status']) {
                          if (vY['gzhead']['name']) {
                              vT = vY['pending'];
                              do {
                                  if (vY['pending'] === vY['pending_buf_size'] && (vY['gzhead']['hcrc'] && vY['pending'] > vT && (vs['adler'] = q(vs['adler'], vY['pending_buf'], vY['pending'] - vT, vT)),
                                  vK(vs),
                                  vT = vY['pending'],
                                  vY['pending'] === vY['pending_buf_size'])) {
                                      vX = 0x1;
                                      break;
                                  }
                                  vX = vY['gzindex'] < vY['gzhead']['name']['length'] ? 0xff & vY['gzhead']['name']['charCodeAt'](vY['gzindex']++) : 0x0,
                                  vb(vY, vX);
                              } while (0x0 !== vX);
                              vY['gzhead']['hcrc'] && vY['pending'] > vT && (vs['adler'] = q(vs['adler'], vY['pending_buf'], vY['pending'] - vT, vT)),
                              0x0 === vX && (vY['gzindex'] = 0x0,
                              vY['status'] = 0x5b);
                          } else
                              vY['status'] = 0x5b;
                      }
                      if (0x5b === vY['status']) {
                          if (vY['gzhead']['comment']) {
                              vT = vY['pending'];
                              do {
                                  if (vY['pending'] === vY['pending_buf_size'] && (vY['gzhead']['hcrc'] && vY['pending'] > vT && (vs['adler'] = q(vs['adler'], vY['pending_buf'], vY['pending'] - vT, vT)),
                                  vK(vs),
                                  vT = vY['pending'],
                                  vY['pending'] === vY['pending_buf_size'])) {
                                      vX = 0x1;
                                      break;
                                  }
                                  vX = vY['gzindex'] < vY['gzhead']['comment']['length'] ? 0xff & vY['gzhead']['comment']['charCodeAt'](vY['gzindex']++) : 0x0,
                                  vb(vY, vX);
                              } while (0x0 !== vX);
                              vY['gzhead']['hcrc'] && vY['pending'] > vT && (vs['adler'] = q(vs['adler'], vY['pending_buf'], vY['pending'] - vT, vT)),
                              0x0 === vX && (vY['status'] = 0x67);
                          } else
                              vY['status'] = 0x67;
                      }
                      if (0x67 === vY['status'] && (vY['gzhead']['hcrc'] ? (vY['pending'] + 0x2 > vY['pending_buf_size'] && vK(vs),
                      vY['pending'] + 0x2 <= vY['pending_buf_size'] && (vb(vY, 0xff & vs['adler']),
                      vb(vY, vs['adler'] >> 0x8 & 0xff),
                      vs['adler'] = 0x0,
                      vY['status'] = vA)) : vY['status'] = vA),
                      0x0 !== vY['pending']) {
                          if (vK(vs),
                          0x0 === vs['avail_out'])
                              return vY['last_flush'] = -0x1,
                              N;
                      } else {
                          if (0x0 === vs['avail_in'] && vk(vh) <= vk(vu) && 0x4 !== vh)
                              return vn(vs, -0x5);
                      }
                      if (0x29a === vY['status'] && 0x0 !== vs['avail_in'])
                          return vn(vs, -0x5);
                      if (0x0 !== vs['avail_in'] || 0x0 !== vY['lookahead'] || vh !== G && 0x29a !== vY['status']) {
                          var vf = 0x2 === vY['strategy'] ? function(vW, vI) {
                              for (var vj; ; ) {
                                  if (0x0 === vW['lookahead'] && (vH(vW),
                                  0x0 === vW['lookahead'])) {
                                      if (vI === G)
                                          return 0x1;
                                      break;
                                  }
                                  if (vW['match_length'] = 0x0,
                                  vj = V['_tr_tally'](vW, 0x0, vW['window'][vW['strstart']]),
                                  vW['lookahead']--,
                                  vW['strstart']++,
                                  vj && (vi(vW, false),
                                  0x0 === vW['strm']['avail_out']))
                                      return 0x1;
                              }
                              return vW['insert'] = 0x0,
                              0x4 === vI ? (vi(vW, true),
                              0x0 === vW['strm']['avail_out'] ? 0x3 : 0x4) : vW['last_lit'] && (vi(vW, false),
                              0x0 === vW['strm']['avail_out']) ? 0x1 : 0x2;
                          }(vY, vh) : 0x3 === vY['strategy'] ? function(vW, vI) {
                              for (var vj, vD, vV, vZ, vB = vW['window']; ; ) {
                                  if (vW['lookahead'] <= v8) {
                                      if (vH(vW),
                                      vW['lookahead'] <= v8 && vI === G)
                                          return 0x1;
                                      if (0x0 === vW['lookahead'])
                                          break;
                                  }
                                  if (vW['match_length'] = 0x0,
                                  vW['lookahead'] >= v7 && 0x0 < vW['strstart'] && (vD = vB[vV = vW['strstart'] - 0x1]) === vB[++vV] && vD === vB[++vV] && vD === vB[++vV]) {
                                      vZ = vW['strstart'] + v8;
                                      do {} while (vD === vB[++vV] && vD === vB[++vV] && vD === vB[++vV] && vD === vB[++vV] && vD === vB[++vV] && vD === vB[++vV] && vD === vB[++vV] && vD === vB[++vV] && vV < vZ);
                                      vW['match_length'] = v8 - (vZ - vV),
                                      vW['match_length'] > vW['lookahead'] && (vW['match_length'] = vW['lookahead']);
                                  }
                                  if (vW['match_length'] >= v7 ? (vj = V['_tr_tally'](vW, 0x1, vW['match_length'] - v7),
                                  vW['lookahead'] -= vW['match_length'],
                                  vW['strstart'] += vW['match_length'],
                                  vW['match_length'] = 0x0) : (vj = V['_tr_tally'](vW, 0x0, vW['window'][vW['strstart']]),
                                  vW['lookahead']--,
                                  vW['strstart']++),
                                  vj && (vi(vW, false),
                                  0x0 === vW['strm']['avail_out']))
                                      return 0x1;
                              }
                              return vW['insert'] = 0x0,
                              0x4 === vI ? (vi(vW, true),
                              0x0 === vW['strm']['avail_out'] ? 0x3 : 0x4) : vW['last_lit'] && (vi(vW, false),
                              0x0 === vW['strm']['avail_out']) ? 0x1 : 0x2;
                          }(vY, vh) : W[vY['level']]['func'](vY, vh);
                          if (0x3 !== vf && 0x4 !== vf || (vY['status'] = 0x29a),
                          0x1 === vf || 0x3 === vf)
                              return 0x0 === vs['avail_out'] && (vY['last_flush'] = -0x1),
                              N;
                          if (0x2 === vf && (0x1 === vh ? V['_tr_align'](vY) : 0x5 !== vh && (V['_tr_stored_block'](vY, 0x0, 0x0, false),
                          0x3 === vh && (vl(vY['head']),
                          0x0 === vY['lookahead'] && (vY['strstart'] = 0x0,
                          vY['block_start'] = 0x0,
                          vY['insert'] = 0x0))),
                          vK(vs),
                          0x0 === vs['avail_out']))
                              return vY['last_flush'] = -0x1,
                              N;
                      }
                      return 0x4 !== vh ? N : vY['wrap'] <= 0x0 ? 0x1 : (0x2 === vY['wrap'] ? (vb(vY, 0xff & vs['adler']),
                      vb(vY, vs['adler'] >> 0x8 & 0xff),
                      vb(vY, vs['adler'] >> 0x10 & 0xff),
                      vb(vY, vs['adler'] >> 0x18 & 0xff),
                      vb(vY, 0xff & vs['total_in']),
                      vb(vY, vs['total_in'] >> 0x8 & 0xff),
                      vb(vY, vs['total_in'] >> 0x10 & 0xff),
                      vb(vY, vs['total_in'] >> 0x18 & 0xff)) : (ve(vY, vs['adler'] >>> 0x10),
                      ve(vY, 0xffff & vs['adler'])),
                      vK(vs),
                      0x0 < vY['wrap'] && (vY['wrap'] = -vY['wrap']),
                      0x0 !== vY['pending'] ? N : 0x1);
                  }
                  ,
                  X['deflateEnd'] = function(vs) {
                      var vh;
                      return vs && vs['state'] ? (vh = vs['state']['status']) !== vv && 0x45 !== vh && 0x49 !== vh && 0x5b !== vh && 0x67 !== vh && vh !== vA && 0x29a !== vh ? vn(vs, Q) : (vs['state'] = null,
                      vh === vA ? vn(vs, -0x3) : N) : Q;
                  }
                  ,
                  X['deflateSetDictionary'] = function(vs, vh) {
                      var vu, vY, vT, vX, Quadtree, vf, vW, vI, vj = vh['length'];
                      if (!vs || !vs['state'])
                          return Q;
                      if (0x2 === (vX = (vu = vs['state'])['wrap']) || 0x1 === vX && vu['status'] !== vv || vu['lookahead'])
                          return Q;
                      for (0x1 === vX && (vs['adler'] = Z(vs['adler'], vh, vj, 0x0)),
                      vu['wrap'] = 0x0,
                      vj >= vu['w_size'] && (0x0 === vX && (vl(vu['head']),
                      vu['strstart'] = 0x0,
                      vu['block_start'] = 0x0,
                      vu['insert'] = 0x0),
                      vI = new j['Buf8'](vu['w_size']),
                      j['arraySet'](vI, vh, vj - vu['w_size'], vu['w_size'], 0x0),
                      vh = vI,
                      vj = vu['w_size']),
                      Quadtree = vs['avail_in'],
                      vf = vs['next_in'],
                      vW = vs['input'],
                      vs['avail_in'] = vj,
                      vs['next_in'] = 0x0,
                      vs['input'] = vh,
                      vH(vu); vu['lookahead'] >= v7; ) {
                          for (vY = vu['strstart'],
                          vT = vu['lookahead'] - (v7 - 0x1); vu['ins_h'] = (vu['ins_h'] << vu['hash_shift'] ^ vu['window'][vY + v7 - 0x1]) & vu['hash_mask'],
                          vu['prev'][vY & vu['w_mask']] = vu['head'][vu['ins_h']],
                          vu['head'][vu['ins_h']] = vY,
                          vY++,
                          --vT; )
                              ;
                          vu['strstart'] = vY,
                          vu['lookahead'] = v7 - 0x1,
                          vH(vu);
                      }
                      return vu['strstart'] += vu['lookahead'],
                      vu['block_start'] = vu['strstart'],
                      vu['insert'] = vu['lookahead'],
                      vu['lookahead'] = 0x0,
                      vu['match_length'] = vu['prev_length'] = v7 - 0x1,
                      vu['match_available'] = 0x0,
                      vs['next_in'] = vf,
                      vs['input'] = vW,
                      vs['avail_in'] = Quadtree,
                      vu['wrap'] = vX,
                      N;
                  }
                  ,
                  X['deflateInfo'] = 'pako\x20deflate\x20(from\x20Nodeca\x20project)';
              }
              , {
                  '../utils/common': 0x29,
                  './adler32': 0x2b,
                  './crc32': 0x2d,
                  './messages': 0x33,
                  './trees': 0x34
              }],
              0x2f: [function(c, H, x) {
                  'use strict';
                  H['exports'] = function() {
                      this['text'] = 0x0,
                      this['time'] = 0x0,
                      this['xflags'] = 0x0,
                      this['os'] = 0x0,
                      this['extra'] = null,
                      this['extra_len'] = 0x0,
                      this['name'] = '',
                      this['comment'] = '',
                      this['hcrc'] = 0x0,
                      this['done'] = false;
                  }
                  ;
              }
              , {}],
              0x30: [function(c, H, x) {
                  'use strict';
                  H['exports'] = function(F, Y) {
                      var T, X, E, W, j, D, V, Z, B, U, q, J, C, O, G, N, M, z, Q, L, R, v0, v1, v2, v3;
                      T = F['state'],
                      X = F['next_in'],
                      v2 = F['input'],
                      E = X + (F['avail_in'] - 0x5),
                      W = F['next_out'],
                      v3 = F['output'],
                      j = W - (Y - F['avail_out']),
                      D = W + (F['avail_out'] - 0x101),
                      V = T['dmax'],
                      Z = T['wsize'],
                      B = T['whave'],
                      U = T['wnext'],
                      q = T['window'],
                      J = T['hold'],
                      C = T['bits'],
                      O = T['lencode'],
                      G = T['distcode'],
                      N = (0x1 << T['lenbits']) - 0x1,
                      M = (0x1 << T['distbits']) - 0x1;
                      v4: do {
                          C < 0xf && (J += v2[X++] << C,
                          C += 0x8,
                          J += v2[X++] << C,
                          C += 0x8),
                          z = O[J & N];
                          v5: for (; ; ) {
                              if (J >>>= Q = z >>> 0x18,
                              C -= Q,
                              0x0 == (Q = z >>> 0x10 & 0xff))
                                  v3[W++] = 0xffff & z;
                              else {
                                  if (!(0x10 & Q)) {
                                      if (0x0 == (0x40 & Q)) {
                                          z = O[(0xffff & z) + (J & (0x1 << Q) - 0x1)];
                                          continue v5;
                                      }
                                      if (0x20 & Q) {
                                          T['mode'] = 0xc;
                                          break v4;
                                      }
                                      F['msg'] = 'invalid\x20literal/length\x20code',
                                      T['mode'] = 0x1e;
                                      break v4;
                                  }
                                  L = 0xffff & z,
                                  (Q &= 0xf) && (C < Q && (J += v2[X++] << C,
                                  C += 0x8),
                                  L += J & (0x1 << Q) - 0x1,
                                  J >>>= Q,
                                  C -= Q),
                                  C < 0xf && (J += v2[X++] << C,
                                  C += 0x8,
                                  J += v2[X++] << C,
                                  C += 0x8),
                                  z = G[J & M];
                                  v6: for (; ; ) {
                                      if (J >>>= Q = z >>> 0x18,
                                      C -= Q,
                                      !(0x10 & (Q = z >>> 0x10 & 0xff))) {
                                          if (0x0 == (0x40 & Q)) {
                                              z = G[(0xffff & z) + (J & (0x1 << Q) - 0x1)];
                                              continue v6;
                                          }
                                          F['msg'] = 'invalid\x20distance\x20code',
                                          T['mode'] = 0x1e;
                                          break v4;
                                      }
                                      if (R = 0xffff & z,
                                      C < (Q &= 0xf) && (J += v2[X++] << C,
                                      (C += 0x8) < Q && (J += v2[X++] << C,
                                      C += 0x8)),
                                      V < (R += J & (0x1 << Q) - 0x1)) {
                                          F['msg'] = 'invalid\x20distance\x20too\x20far\x20back',
                                          T['mode'] = 0x1e;
                                          break v4;
                                      }
                                      if (J >>>= Q,
                                      C -= Q,
                                      (Q = W - j) < R) {
                                          if (B < (Q = R - Q) && T['sane']) {
                                              F['msg'] = 'invalid\x20distance\x20too\x20far\x20back',
                                              T['mode'] = 0x1e;
                                              break v4;
                                          }
                                          if (v1 = q,
                                          (v0 = 0x0) === U) {
                                              if (v0 += Z - Q,
                                              Q < L) {
                                                  for (L -= Q; v3[W++] = q[v0++],
                                                  --Q; )
                                                      ;
                                                  v0 = W - R,
                                                  v1 = v3;
                                              }
                                          } else {
                                              if (U < Q) {
                                                  if (v0 += Z + U - Q,
                                                  (Q -= U) < L) {
                                                      for (L -= Q; v3[W++] = q[v0++],
                                                      --Q; )
                                                          ;
                                                      if (v0 = 0x0,
                                                      U < L) {
                                                          for (L -= Q = U; v3[W++] = q[v0++],
                                                          --Q; )
                                                              ;
                                                          v0 = W - R,
                                                          v1 = v3;
                                                      }
                                                  }
                                              } else {
                                                  if (v0 += U - Q,
                                                  Q < L) {
                                                      for (L -= Q; v3[W++] = q[v0++],
                                                      --Q; )
                                                          ;
                                                      v0 = W - R,
                                                      v1 = v3;
                                                  }
                                              }
                                          }
                                          for (; 0x2 < L; )
                                              v3[W++] = v1[v0++],
                                              v3[W++] = v1[v0++],
                                              v3[W++] = v1[v0++],
                                              L -= 0x3;
                                          L && (v3[W++] = v1[v0++],
                                          0x1 < L && (v3[W++] = v1[v0++]));
                                      } else {
                                          for (v0 = W - R; v3[W++] = v3[v0++],
                                          v3[W++] = v3[v0++],
                                          v3[W++] = v3[v0++],
                                          0x2 < (L -= 0x3); )
                                              ;
                                          L && (v3[W++] = v3[v0++],
                                          0x1 < L && (v3[W++] = v3[v0++]));
                                      }
                                      break;
                                  }
                              }
                              break;
                          }
                      } while (X < E && W < D);
                      X -= L = C >> 0x3,
                      J &= (0x1 << (C -= L << 0x3)) - 0x1,
                      F['next_in'] = X,
                      F['next_out'] = W,
                      F['avail_in'] = X < E ? E - X + 0x5 : 0x5 - (X - E),
                      F['avail_out'] = W < D ? D - W + 0x101 : 0x101 - (W - D),
                      T['hold'] = J,
                      T['bits'] = C;
                  }
                  ;
              }
              , {}],
              0x31: [function(H, F, Y) {
                  'use strict';
                  var T = H('../utils/common')
                    , X = H('./adler32')
                    , E = H('./crc32')
                    , W = H('./inffast')
                    , I = H('./inftrees')
                    , j = 0x0
                    , D = -0x2
                    , V = 0x1
                    , Z = 0x354
                    , B = 0x250;
                  function U(L) {
                      return (L >>> 0x18 & 0xff) + (L >>> 0x8 & 0xff00) + ((0xff00 & L) << 0x8) + ((0xff & L) << 0x18);
                  }
                  function q() {
                      this['mode'] = 0x0,
                      this['last'] = false,
                      this['wrap'] = 0x0,
                      this['havedict'] = false,
                      this['flags'] = 0x0,
                      this['dmax'] = 0x0,
                      this['check'] = 0x0,
                      this['total'] = 0x0,
                      this['head'] = null,
                      this['wbits'] = 0x0,
                      this['wsize'] = 0x0,
                      this['whave'] = 0x0,
                      this['wnext'] = 0x0,
                      this['window'] = null,
                      this['hold'] = 0x0,
                      this['bits'] = 0x0,
                      this['length'] = 0x0,
                      this['offset'] = 0x0,
                      this['extra'] = 0x0,
                      this['lencode'] = null,
                      this['distcode'] = null,
                      this['lenbits'] = 0x0,
                      this['distbits'] = 0x0,
                      this['ncode'] = 0x0,
                      this['nlen'] = 0x0,
                      this['ndist'] = 0x0,
                      this['have'] = 0x0,
                      this['next'] = null,
                      this['lens'] = new T['Buf16'](0x140),
                      this['work'] = new T['Buf16'](0x120),
                      this['lendyn'] = null,
                      this['distdyn'] = null,
                      this['sane'] = 0x0,
                      this['back'] = 0x0,
                      this['was'] = 0x0;
                  }
                  function J(L) {
                      var R;
                      return L && L['state'] ? (R = L['state'],
                      L['total_in'] = L['total_out'] = R['total'] = 0x0,
                      L['msg'] = '',
                      R['wrap'] && (L['adler'] = 0x1 & R['wrap']),
                      R['mode'] = V,
                      R['last'] = 0x0,
                      R['havedict'] = 0x0,
                      R['dmax'] = 0x8000,
                      R['head'] = null,
                      R['hold'] = 0x0,
                      R['bits'] = 0x0,
                      R['lencode'] = R['lendyn'] = new T['Buf32'](Z),
                      R['distcode'] = R['distdyn'] = new T['Buf32'](B),
                      R['sane'] = 0x1,
                      R['back'] = -0x1,
                      j) : D;
                  }
                  function C(L) {
                      var R;
                      return L && L['state'] ? ((R = L['state'])['wsize'] = 0x0,
                      R['whave'] = 0x0,
                      R['wnext'] = 0x0,
                      J(L)) : D;
                  }
                  function O(L, R) {
                      var v0, v1;
                      return L && L['state'] ? (v1 = L['state'],
                      R < 0x0 ? (v0 = 0x0,
                      R = -R) : (v0 = 0x1 + (R >> 0x4),
                      R < 0x30 && (R &= 0xf)),
                      R && (R < 0x8 || 0xf < R) ? D : (null !== v1['window'] && v1['wbits'] !== R && (v1['window'] = null),
                      v1['wrap'] = v0,
                      v1['wbits'] = R,
                      C(L))) : D;
                  }
                  function G(L, R) {
                      var v0, v1;
                      return L ? (v1 = new q(),
                      (L['state'] = v1)['window'] = null,
                      (v0 = O(L, R)) !== j && (L['state'] = null),
                      v0) : D;
                  }
                  var N, P, M = true;
                  function z(L) {
                      if (M) {
                          var R;
                          for (N = new T['Buf32'](0x200),
                          P = new T['Buf32'](0x20),
                          R = 0x0; R < 0x90; )
                              L['lens'][R++] = 0x8;
                          for (; R < 0x100; )
                              L['lens'][R++] = 0x9;
                          for (; R < 0x118; )
                              L['lens'][R++] = 0x7;
                          for (; R < 0x120; )
                              L['lens'][R++] = 0x8;
                          for (I(0x1, L['lens'], 0x0, 0x120, N, 0x0, L['work'], {
                              'bits': 0x9
                          }),
                          R = 0x0; R < 0x20; )
                              L['lens'][R++] = 0x5;
                          I(0x2, L['lens'], 0x0, 0x20, P, 0x0, L['work'], {
                              'bits': 0x5
                          }),
                          M = false;
                      }
                      L['lencode'] = N,
                      L['lenbits'] = 0x9,
                      L['distcode'] = P,
                      L['distbits'] = 0x5;
                  }
                  function Q(L, R, v0, v1) {
                      var v2, v3 = L['state'];
                      return null === v3['window'] && (v3['wsize'] = 0x1 << v3['wbits'],
                      v3['wnext'] = 0x0,
                      v3['whave'] = 0x0,
                      v3['window'] = new T['Buf8'](v3['wsize'])),
                      v1 >= v3['wsize'] ? (T['arraySet'](v3['window'], R, v0 - v3['wsize'], v3['wsize'], 0x0),
                      v3['wnext'] = 0x0,
                      v3['whave'] = v3['wsize']) : (v1 < (v2 = v3['wsize'] - v3['wnext']) && (v2 = v1),
                      T['arraySet'](v3['window'], R, v0 - v1, v2, v3['wnext']),
                      (v1 -= v2) ? (T['arraySet'](v3['window'], R, v0 - v1, v1, 0x0),
                      v3['wnext'] = v1,
                      v3['whave'] = v3['wsize']) : (v3['wnext'] += v2,
                      v3['wnext'] === v3['wsize'] && (v3['wnext'] = 0x0),
                      v3['whave'] < v3['wsize'] && (v3['whave'] += v2))),
                      0x0;
                  }
                  Y['inflateReset'] = C,
                  Y['inflateReset2'] = O,
                  Y['inflateResetKeep'] = J,
                  Y['inflateInit'] = function(L) {
                      return G(L, 0xf);
                  }
                  ,
                  Y['inflateInit2'] = G,
                  Y['inflate'] = function(v0, v1) {
                      var v2, v3, v4, v5, v6, v7, v8, v9, vv, vA, vn, vk, vl, vK, vi, vb, ve, vc, vH, vt, vx, vp, vF, vy, vr = 0x0, vw = new T['Buf8'](0x4), vs = [0x10, 0x11, 0x12, 0x0, 0x8, 0x7, 0x9, 0x6, 0xa, 0x5, 0xb, 0x4, 0xc, 0x3, 0xd, 0x2, 0xe, 0x1, 0xf];
                      if (!v0 || !v0['state'] || !v0['output'] || !v0['input'] && 0x0 !== v0['avail_in'])
                          return D;
                      0xc === (v2 = v0['state'])['mode'] && (v2['mode'] = 0xd),
                      v6 = v0['next_out'],
                      v4 = v0['output'],
                      v8 = v0['avail_out'],
                      v5 = v0['next_in'],
                      v3 = v0['input'],
                      v7 = v0['avail_in'],
                      v9 = v2['hold'],
                      vv = v2['bits'],
                      vA = v7,
                      vn = v8,
                      vp = j;
                      vh: for (; ; )
                          switch (v2['mode']) {
                          case V:
                              if (0x0 === v2['wrap']) {
                                  v2['mode'] = 0xd;
                                  break;
                              }
                              for (; vv < 0x10; ) {
                                  if (0x0 === v7)
                                      break vh;
                                  v7--,
                                  v9 += v3[v5++] << vv,
                                  vv += 0x8;
                              }
                              if (0x2 & v2['wrap'] && 0x8b1f === v9) {
                                  vw[v2['check'] = 0x0] = 0xff & v9,
                                  vw[0x1] = v9 >>> 0x8 & 0xff,
                                  v2['check'] = E(v2['check'], vw, 0x2, 0x0),
                                  vv = v9 = 0x0,
                                  v2['mode'] = 0x2;
                                  break;
                              }
                              if (v2['flags'] = 0x0,
                              v2['head'] && (v2['head']['done'] = false),
                              !(0x1 & v2['wrap']) || (((0xff & v9) << 0x8) + (v9 >> 0x8)) % 0x1f) {
                                  v0['msg'] = 'incorrect\x20header\x20check',
                                  v2['mode'] = 0x1e;
                                  break;
                              }
                              if (0x8 != (0xf & v9)) {
                                  v0['msg'] = 'unknown\x20compression\x20method',
                                  v2['mode'] = 0x1e;
                                  break;
                              }
                              if (vv -= 0x4,
                              vx = 0x8 + (0xf & (v9 >>>= 0x4)),
                              0x0 === v2['wbits'])
                                  v2['wbits'] = vx;
                              else {
                                  if (vx > v2['wbits']) {
                                      v0['msg'] = 'invalid\x20window\x20size',
                                      v2['mode'] = 0x1e;
                                      break;
                                  }
                              }
                              v2['dmax'] = 0x1 << vx,
                              v0['adler'] = v2['check'] = 0x1,
                              v2['mode'] = 0x200 & v9 ? 0xa : 0xc,
                              vv = v9 = 0x0;
                              break;
                          case 0x2:
                              for (; vv < 0x10; ) {
                                  if (0x0 === v7)
                                      break vh;
                                  v7--,
                                  v9 += v3[v5++] << vv,
                                  vv += 0x8;
                              }
                              if (v2['flags'] = v9,
                              0x8 != (0xff & v2['flags'])) {
                                  v0['msg'] = 'unknown\x20compression\x20method',
                                  v2['mode'] = 0x1e;
                                  break;
                              }
                              if (0xe000 & v2['flags']) {
                                  v0['msg'] = 'unknown\x20header\x20flags\x20set',
                                  v2['mode'] = 0x1e;
                                  break;
                              }
                              v2['head'] && (v2['head']['text'] = v9 >> 0x8 & 0x1),
                              0x200 & v2['flags'] && (vw[0x0] = 0xff & v9,
                              vw[0x1] = v9 >>> 0x8 & 0xff,
                              v2['check'] = E(v2['check'], vw, 0x2, 0x0)),
                              vv = v9 = 0x0,
                              v2['mode'] = 0x3;
                          case 0x3:
                              for (; vv < 0x20; ) {
                                  if (0x0 === v7)
                                      break vh;
                                  v7--,
                                  v9 += v3[v5++] << vv,
                                  vv += 0x8;
                              }
                              v2['head'] && (v2['head']['time'] = v9),
                              0x200 & v2['flags'] && (vw[0x0] = 0xff & v9,
                              vw[0x1] = v9 >>> 0x8 & 0xff,
                              vw[0x2] = v9 >>> 0x10 & 0xff,
                              vw[0x3] = v9 >>> 0x18 & 0xff,
                              v2['check'] = E(v2['check'], vw, 0x4, 0x0)),
                              vv = v9 = 0x0,
                              v2['mode'] = 0x4;
                          case 0x4:
                              for (; vv < 0x10; ) {
                                  if (0x0 === v7)
                                      break vh;
                                  v7--,
                                  v9 += v3[v5++] << vv,
                                  vv += 0x8;
                              }
                              v2['head'] && (v2['head']['xflags'] = 0xff & v9,
                              v2['head']['os'] = v9 >> 0x8),
                              0x200 & v2['flags'] && (vw[0x0] = 0xff & v9,
                              vw[0x1] = v9 >>> 0x8 & 0xff,
                              v2['check'] = E(v2['check'], vw, 0x2, 0x0)),
                              vv = v9 = 0x0,
                              v2['mode'] = 0x5;
                          case 0x5:
                              if (0x400 & v2['flags']) {
                                  for (; vv < 0x10; ) {
                                      if (0x0 === v7)
                                          break vh;
                                      v7--,
                                      v9 += v3[v5++] << vv,
                                      vv += 0x8;
                                  }
                                  v2['length'] = v9,
                                  v2['head'] && (v2['head']['extra_len'] = v9),
                                  0x200 & v2['flags'] && (vw[0x0] = 0xff & v9,
                                  vw[0x1] = v9 >>> 0x8 & 0xff,
                                  v2['check'] = E(v2['check'], vw, 0x2, 0x0)),
                                  vv = v9 = 0x0;
                              } else
                                  v2['head'] && (v2['head']['extra'] = null);
                              v2['mode'] = 0x6;
                          case 0x6:
                              if (0x400 & v2['flags'] && (v7 < (vk = v2['length']) && (vk = v7),
                              vk && (v2['head'] && (vx = v2['head']['extra_len'] - v2['length'],
                              v2['head']['extra'] || (v2['head']['extra'] = new Array(v2['head']['extra_len'])),
                              T['arraySet'](v2['head']['extra'], v3, v5, vk, vx)),
                              0x200 & v2['flags'] && (v2['check'] = E(v2['check'], v3, vk, v5)),
                              v7 -= vk,
                              v5 += vk,
                              v2['length'] -= vk),
                              v2['length']))
                                  break vh;
                              v2['length'] = 0x0,
                              v2['mode'] = 0x7;
                          case 0x7:
                              if (0x800 & v2['flags']) {
                                  if (0x0 === v7)
                                      break vh;
                                  for (vk = 0x0; vx = v3[v5 + vk++],
                                  v2['head'] && vx && v2['length'] < 0x10000 && (v2['head']['name'] += String['fromCharCode'](vx)),
                                  vx && vk < v7; )
                                      ;
                                  if (0x200 & v2['flags'] && (v2['check'] = E(v2['check'], v3, vk, v5)),
                                  v7 -= vk,
                                  v5 += vk,
                                  vx)
                                      break vh;
                              } else
                                  v2['head'] && (v2['head']['name'] = null);
                              v2['length'] = 0x0,
                              v2['mode'] = 0x8;
                          case 0x8:
                              if (0x1000 & v2['flags']) {
                                  if (0x0 === v7)
                                      break vh;
                                  for (vk = 0x0; vx = v3[v5 + vk++],
                                  v2['head'] && vx && v2['length'] < 0x10000 && (v2['head']['comment'] += String['fromCharCode'](vx)),
                                  vx && vk < v7; )
                                      ;
                                  if (0x200 & v2['flags'] && (v2['check'] = E(v2['check'], v3, vk, v5)),
                                  v7 -= vk,
                                  v5 += vk,
                                  vx)
                                      break vh;
                              } else
                                  v2['head'] && (v2['head']['comment'] = null);
                              v2['mode'] = 0x9;
                          case 0x9:
                              if (0x200 & v2['flags']) {
                                  for (; vv < 0x10; ) {
                                      if (0x0 === v7)
                                          break vh;
                                      v7--,
                                      v9 += v3[v5++] << vv,
                                      vv += 0x8;
                                  }
                                  if (v9 !== (0xffff & v2['check'])) {
                                      v0['msg'] = 'header\x20crc\x20mismatch',
                                      v2['mode'] = 0x1e;
                                      break;
                                  }
                                  vv = v9 = 0x0;
                              }
                              v2['head'] && (v2['head']['hcrc'] = v2['flags'] >> 0x9 & 0x1,
                              v2['head']['done'] = true),
                              v0['adler'] = v2['check'] = 0x0,
                              v2['mode'] = 0xc;
                              break;
                          case 0xa:
                              for (; vv < 0x20; ) {
                                  if (0x0 === v7)
                                      break vh;
                                  v7--,
                                  v9 += v3[v5++] << vv,
                                  vv += 0x8;
                              }
                              v0['adler'] = v2['check'] = U(v9),
                              vv = v9 = 0x0,
                              v2['mode'] = 0xb;
                          case 0xb:
                              if (0x0 === v2['havedict'])
                                  return v0['next_out'] = v6,
                                  v0['avail_out'] = v8,
                                  v0['next_in'] = v5,
                                  v0['avail_in'] = v7,
                                  v2['hold'] = v9,
                                  v2['bits'] = vv,
                                  0x2;
                              v0['adler'] = v2['check'] = 0x1,
                              v2['mode'] = 0xc;
                          case 0xc:
                              if (0x5 === v1 || 0x6 === v1)
                                  break vh;
                          case 0xd:
                              if (v2['last']) {
                                  v9 >>>= 0x7 & vv,
                                  vv -= 0x7 & vv,
                                  v2['mode'] = 0x1b;
                                  break;
                              }
                              for (; vv < 0x3; ) {
                                  if (0x0 === v7)
                                      break vh;
                                  v7--,
                                  v9 += v3[v5++] << vv,
                                  vv += 0x8;
                              }
                              switch (v2['last'] = 0x1 & v9,
                              vv -= 0x1,
                              0x3 & (v9 >>>= 0x1)) {
                              case 0x0:
                                  v2['mode'] = 0xe;
                                  break;
                              case 0x1:
                                  if (z(v2),
                                  v2['mode'] = 0x14,
                                  0x6 !== v1)
                                      break;
                                  v9 >>>= 0x2,
                                  vv -= 0x2;
                                  break vh;
                              case 0x2:
                                  v2['mode'] = 0x11;
                                  break;
                              case 0x3:
                                  v0['msg'] = 'invalid\x20block\x20type',
                                  v2['mode'] = 0x1e;
                              }
                              v9 >>>= 0x2,
                              vv -= 0x2;
                              break;
                          case 0xe:
                              for (v9 >>>= 0x7 & vv,
                              vv -= 0x7 & vv; vv < 0x20; ) {
                                  if (0x0 === v7)
                                      break vh;
                                  v7--,
                                  v9 += v3[v5++] << vv,
                                  vv += 0x8;
                              }
                              if ((0xffff & v9) != (v9 >>> 0x10 ^ 0xffff)) {
                                  v0['msg'] = 'invalid\x20stored\x20block\x20lengths',
                                  v2['mode'] = 0x1e;
                                  break;
                              }
                              if (v2['length'] = 0xffff & v9,
                              vv = v9 = 0x0,
                              v2['mode'] = 0xf,
                              0x6 === v1)
                                  break vh;
                          case 0xf:
                              v2['mode'] = 0x10;
                          case 0x10:
                              if (vk = v2['length']) {
                                  if (v7 < vk && (vk = v7),
                                  v8 < vk && (vk = v8),
                                  0x0 === vk)
                                      break vh;
                                  T['arraySet'](v4, v3, v5, vk, v6),
                                  v7 -= vk,
                                  v5 += vk,
                                  v8 -= vk,
                                  v6 += vk,
                                  v2['length'] -= vk;
                                  break;
                              }
                              v2['mode'] = 0xc;
                              break;
                          case 0x11:
                              for (; vv < 0xe; ) {
                                  if (0x0 === v7)
                                      break vh;
                                  v7--,
                                  v9 += v3[v5++] << vv,
                                  vv += 0x8;
                              }
                              if (v2['nlen'] = 0x101 + (0x1f & v9),
                              v9 >>>= 0x5,
                              vv -= 0x5,
                              v2['ndist'] = 0x1 + (0x1f & v9),
                              v9 >>>= 0x5,
                              vv -= 0x5,
                              v2['ncode'] = 0x4 + (0xf & v9),
                              v9 >>>= 0x4,
                              vv -= 0x4,
                              0x11e < v2['nlen'] || 0x1e < v2['ndist']) {
                                  v0['msg'] = 'too\x20many\x20length\x20or\x20distance\x20symbols',
                                  v2['mode'] = 0x1e;
                                  break;
                              }
                              v2['have'] = 0x0,
                              v2['mode'] = 0x12;
                          case 0x12:
                              for (; v2['have'] < v2['ncode']; ) {
                                  for (; vv < 0x3; ) {
                                      if (0x0 === v7)
                                          break vh;
                                      v7--,
                                      v9 += v3[v5++] << vv,
                                      vv += 0x8;
                                  }
                                  v2['lens'][vs[v2['have']++]] = 0x7 & v9,
                                  v9 >>>= 0x3,
                                  vv -= 0x3;
                              }
                              for (; v2['have'] < 0x13; )
                                  v2['lens'][vs[v2['have']++]] = 0x0;
                              if (v2['lencode'] = v2['lendyn'],
                              v2['lenbits'] = 0x7,
                              vF = {
                                  'bits': v2['lenbits']
                              },
                              vp = I(0x0, v2['lens'], 0x0, 0x13, v2['lencode'], 0x0, v2['work'], vF),
                              v2['lenbits'] = vF['bits'],
                              vp) {
                                  v0['msg'] = 'invalid\x20code\x20lengths\x20set',
                                  v2['mode'] = 0x1e;
                                  break;
                              }
                              v2['have'] = 0x0,
                              v2['mode'] = 0x13;
                          case 0x13:
                              for (; v2['have'] < v2['nlen'] + v2['ndist']; ) {
                                  for (; vb = (vr = v2['lencode'][v9 & (0x1 << v2['lenbits']) - 0x1]) >>> 0x10 & 0xff,
                                  ve = 0xffff & vr,
                                  !((vi = vr >>> 0x18) <= vv); ) {
                                      if (0x0 === v7)
                                          break vh;
                                      v7--,
                                      v9 += v3[v5++] << vv,
                                      vv += 0x8;
                                  }
                                  if (ve < 0x10)
                                      v9 >>>= vi,
                                      vv -= vi,
                                      v2['lens'][v2['have']++] = ve;
                                  else {
                                      if (0x10 === ve) {
                                          for (vy = vi + 0x2; vv < vy; ) {
                                              if (0x0 === v7)
                                                  break vh;
                                              v7--,
                                              v9 += v3[v5++] << vv,
                                              vv += 0x8;
                                          }
                                          if (v9 >>>= vi,
                                          vv -= vi,
                                          0x0 === v2['have']) {
                                              v0['msg'] = 'invalid\x20bit\x20length\x20repeat',
                                              v2['mode'] = 0x1e;
                                              break;
                                          }
                                          vx = v2['lens'][v2['have'] - 0x1],
                                          vk = 0x3 + (0x3 & v9),
                                          v9 >>>= 0x2,
                                          vv -= 0x2;
                                      } else {
                                          if (0x11 === ve) {
                                              for (vy = vi + 0x3; vv < vy; ) {
                                                  if (0x0 === v7)
                                                      break vh;
                                                  v7--,
                                                  v9 += v3[v5++] << vv,
                                                  vv += 0x8;
                                              }
                                              vv -= vi,
                                              vx = 0x0,
                                              vk = 0x3 + (0x7 & (v9 >>>= vi)),
                                              v9 >>>= 0x3,
                                              vv -= 0x3;
                                          } else {
                                              for (vy = vi + 0x7; vv < vy; ) {
                                                  if (0x0 === v7)
                                                      break vh;
                                                  v7--,
                                                  v9 += v3[v5++] << vv,
                                                  vv += 0x8;
                                              }
                                              vv -= vi,
                                              vx = 0x0,
                                              vk = 0xb + (0x7f & (v9 >>>= vi)),
                                              v9 >>>= 0x7,
                                              vv -= 0x7;
                                          }
                                      }
                                      if (v2['have'] + vk > v2['nlen'] + v2['ndist']) {
                                          v0['msg'] = 'invalid\x20bit\x20length\x20repeat',
                                          v2['mode'] = 0x1e;
                                          break;
                                      }
                                      for (; vk--; )
                                          v2['lens'][v2['have']++] = vx;
                                  }
                              }
                              if (0x1e === v2['mode'])
                                  break;
                              if (0x0 === v2['lens'][0x100]) {
                                  v0['msg'] = 'invalid\x20code\x20--\x20missing\x20end-of-block',
                                  v2['mode'] = 0x1e;
                                  break;
                              }
                              if (v2['lenbits'] = 0x9,
                              vF = {
                                  'bits': v2['lenbits']
                              },
                              vp = I(0x1, v2['lens'], 0x0, v2['nlen'], v2['lencode'], 0x0, v2['work'], vF),
                              v2['lenbits'] = vF['bits'],
                              vp) {
                                  v0['msg'] = 'invalid\x20literal/lengths\x20set',
                                  v2['mode'] = 0x1e;
                                  break;
                              }
                              if (v2['distbits'] = 0x6,
                              v2['distcode'] = v2['distdyn'],
                              vF = {
                                  'bits': v2['distbits']
                              },
                              vp = I(0x2, v2['lens'], v2['nlen'], v2['ndist'], v2['distcode'], 0x0, v2['work'], vF),
                              v2['distbits'] = vF['bits'],
                              vp) {
                                  v0['msg'] = 'invalid\x20distances\x20set',
                                  v2['mode'] = 0x1e;
                                  break;
                              }
                              if (v2['mode'] = 0x14,
                              0x6 === v1)
                                  break vh;
                          case 0x14:
                              v2['mode'] = 0x15;
                          case 0x15:
                              if (0x6 <= v7 && 0x102 <= v8) {
                                  v0['next_out'] = v6,
                                  v0['avail_out'] = v8,
                                  v0['next_in'] = v5,
                                  v0['avail_in'] = v7,
                                  v2['hold'] = v9,
                                  v2['bits'] = vv,
                                  W(v0, vn),
                                  v6 = v0['next_out'],
                                  v4 = v0['output'],
                                  v8 = v0['avail_out'],
                                  v5 = v0['next_in'],
                                  v3 = v0['input'],
                                  v7 = v0['avail_in'],
                                  v9 = v2['hold'],
                                  vv = v2['bits'],
                                  0xc === v2['mode'] && (v2['back'] = -0x1);
                                  break;
                              }
                              for (v2['back'] = 0x0; vb = (vr = v2['lencode'][v9 & (0x1 << v2['lenbits']) - 0x1]) >>> 0x10 & 0xff,
                              ve = 0xffff & vr,
                              !((vi = vr >>> 0x18) <= vv); ) {
                                  if (0x0 === v7)
                                      break vh;
                                  v7--,
                                  v9 += v3[v5++] << vv,
                                  vv += 0x8;
                              }
                              if (vb && 0x0 == (0xf0 & vb)) {
                                  for (vc = vi,
                                  vH = vb,
                                  vt = ve; vb = (vr = v2['lencode'][vt + ((v9 & (0x1 << vc + vH) - 0x1) >> vc)]) >>> 0x10 & 0xff,
                                  ve = 0xffff & vr,
                                  !(vc + (vi = vr >>> 0x18) <= vv); ) {
                                      if (0x0 === v7)
                                          break vh;
                                      v7--,
                                      v9 += v3[v5++] << vv,
                                      vv += 0x8;
                                  }
                                  v9 >>>= vc,
                                  vv -= vc,
                                  v2['back'] += vc;
                              }
                              if (v9 >>>= vi,
                              vv -= vi,
                              v2['back'] += vi,
                              v2['length'] = ve,
                              0x0 === vb) {
                                  v2['mode'] = 0x1a;
                                  break;
                              }
                              if (0x20 & vb) {
                                  v2['back'] = -0x1,
                                  v2['mode'] = 0xc;
                                  break;
                              }
                              if (0x40 & vb) {
                                  v0['msg'] = 'invalid\x20literal/length\x20code',
                                  v2['mode'] = 0x1e;
                                  break;
                              }
                              v2['extra'] = 0xf & vb,
                              v2['mode'] = 0x16;
                          case 0x16:
                              if (v2['extra']) {
                                  for (vy = v2['extra']; vv < vy; ) {
                                      if (0x0 === v7)
                                          break vh;
                                      v7--,
                                      v9 += v3[v5++] << vv,
                                      vv += 0x8;
                                  }
                                  v2['length'] += v9 & (0x1 << v2['extra']) - 0x1,
                                  v9 >>>= v2['extra'],
                                  vv -= v2['extra'],
                                  v2['back'] += v2['extra'];
                              }
                              v2['was'] = v2['length'],
                              v2['mode'] = 0x17;
                          case 0x17:
                              for (; vb = (vr = v2['distcode'][v9 & (0x1 << v2['distbits']) - 0x1]) >>> 0x10 & 0xff,
                              ve = 0xffff & vr,
                              !((vi = vr >>> 0x18) <= vv); ) {
                                  if (0x0 === v7)
                                      break vh;
                                  v7--,
                                  v9 += v3[v5++] << vv,
                                  vv += 0x8;
                              }
                              if (0x0 == (0xf0 & vb)) {
                                  for (vc = vi,
                                  vH = vb,
                                  vt = ve; vb = (vr = v2['distcode'][vt + ((v9 & (0x1 << vc + vH) - 0x1) >> vc)]) >>> 0x10 & 0xff,
                                  ve = 0xffff & vr,
                                  !(vc + (vi = vr >>> 0x18) <= vv); ) {
                                      if (0x0 === v7)
                                          break vh;
                                      v7--,
                                      v9 += v3[v5++] << vv,
                                      vv += 0x8;
                                  }
                                  v9 >>>= vc,
                                  vv -= vc,
                                  v2['back'] += vc;
                              }
                              if (v9 >>>= vi,
                              vv -= vi,
                              v2['back'] += vi,
                              0x40 & vb) {
                                  v0['msg'] = 'invalid\x20distance\x20code',
                                  v2['mode'] = 0x1e;
                                  break;
                              }
                              v2['offset'] = ve,
                              v2['extra'] = 0xf & vb,
                              v2['mode'] = 0x18;
                          case 0x18:
                              if (v2['extra']) {
                                  for (vy = v2['extra']; vv < vy; ) {
                                      if (0x0 === v7)
                                          break vh;
                                      v7--,
                                      v9 += v3[v5++] << vv,
                                      vv += 0x8;
                                  }
                                  v2['offset'] += v9 & (0x1 << v2['extra']) - 0x1,
                                  v9 >>>= v2['extra'],
                                  vv -= v2['extra'],
                                  v2['back'] += v2['extra'];
                              }
                              if (v2['offset'] > v2['dmax']) {
                                  v0['msg'] = 'invalid\x20distance\x20too\x20far\x20back',
                                  v2['mode'] = 0x1e;
                                  break;
                              }
                              v2['mode'] = 0x19;
                          case 0x19:
                              if (0x0 === v8)
                                  break vh;
                              if (vk = vn - v8,
                              v2['offset'] > vk) {
                                  if ((vk = v2['offset'] - vk) > v2['whave'] && v2['sane']) {
                                      v0['msg'] = 'invalid\x20distance\x20too\x20far\x20back',
                                      v2['mode'] = 0x1e;
                                      break;
                                  }
                                  vl = vk > v2['wnext'] ? (vk -= v2['wnext'],
                                  v2['wsize'] - vk) : v2['wnext'] - vk,
                                  vk > v2['length'] && (vk = v2['length']),
                                  vK = v2['window'];
                              } else
                                  vK = v4,
                                  vl = v6 - v2['offset'],
                                  vk = v2['length'];
                              for (v8 < vk && (vk = v8),
                              v8 -= vk,
                              v2['length'] -= vk; v4[v6++] = vK[vl++],
                              --vk; )
                                  ;
                              0x0 === v2['length'] && (v2['mode'] = 0x15);
                              break;
                          case 0x1a:
                              if (0x0 === v8)
                                  break vh;
                              v4[v6++] = v2['length'],
                              v8--,
                              v2['mode'] = 0x15;
                              break;
                          case 0x1b:
                              if (v2['wrap']) {
                                  for (; vv < 0x20; ) {
                                      if (0x0 === v7)
                                          break vh;
                                      v7--,
                                      v9 |= v3[v5++] << vv,
                                      vv += 0x8;
                                  }
                                  if (vn -= v8,
                                  v0['total_out'] += vn,
                                  v2['total'] += vn,
                                  vn && (v0['adler'] = v2['check'] = v2['flags'] ? E(v2['check'], v4, vn, v6 - vn) : X(v2['check'], v4, vn, v6 - vn)),
                                  vn = v8,
                                  (v2['flags'] ? v9 : U(v9)) !== v2['check']) {
                                      v0['msg'] = 'incorrect\x20data\x20check',
                                      v2['mode'] = 0x1e;
                                      break;
                                  }
                                  vv = v9 = 0x0;
                              }
                              v2['mode'] = 0x1c;
                          case 0x1c:
                              if (v2['wrap'] && v2['flags']) {
                                  for (; vv < 0x20; ) {
                                      if (0x0 === v7)
                                          break vh;
                                      v7--,
                                      v9 += v3[v5++] << vv,
                                      vv += 0x8;
                                  }
                                  if (v9 !== (0xffffffff & v2['total'])) {
                                      v0['msg'] = 'incorrect\x20length\x20check',
                                      v2['mode'] = 0x1e;
                                      break;
                                  }
                                  vv = v9 = 0x0;
                              }
                              v2['mode'] = 0x1d;
                          case 0x1d:
                              vp = 0x1;
                              break vh;
                          case 0x1e:
                              vp = -0x3;
                              break vh;
                          case 0x1f:
                              return -0x4;
                          default:
                              return D;
                          }
                      return v0['next_out'] = v6,
                      v0['avail_out'] = v8,
                      v0['next_in'] = v5,
                      v0['avail_in'] = v7,
                      v2['hold'] = v9,
                      v2['bits'] = vv,
                      (v2['wsize'] || vn !== v0['avail_out'] && v2['mode'] < 0x1e && (v2['mode'] < 0x1b || 0x4 !== v1)) && Q(v0, v0['output'], v0['next_out'], vn - v0['avail_out']) ? (v2['mode'] = 0x1f,
                      -0x4) : (vA -= v0['avail_in'],
                      vn -= v0['avail_out'],
                      v0['total_in'] += vA,
                      v0['total_out'] += vn,
                      v2['total'] += vn,
                      v2['wrap'] && vn && (v0['adler'] = v2['check'] = v2['flags'] ? E(v2['check'], v4, vn, v0['next_out'] - vn) : X(v2['check'], v4, vn, v0['next_out'] - vn)),
                      v0['data_type'] = v2['bits'] + (v2['last'] ? 0x40 : 0x0) + (0xc === v2['mode'] ? 0x80 : 0x0) + (0x14 === v2['mode'] || 0xf === v2['mode'] ? 0x100 : 0x0),
                      (0x0 == vA && 0x0 === vn || 0x4 === v1) && vp === j && (vp = -0x5),
                      vp);
                  }
                  ,
                  Y['inflateEnd'] = function(L) {
                      if (!L || !L['state'])
                          return D;
                      var R = L['state'];
                      return R['window'] && (R['window'] = null),
                      L['state'] = null,
                      j;
                  }
                  ,
                  Y['inflateGetHeader'] = function(L, R) {
                      var v0;
                      return L && L['state'] ? 0x0 == (0x2 & (v0 = L['state'])['wrap']) ? D : ((v0['head'] = R)['done'] = false,
                      j) : D;
                  }
                  ,
                  Y['inflateSetDictionary'] = function(L, R) {
                      var v0, v1 = R['length'];
                      return L && L['state'] ? 0x0 !== (v0 = L['state'])['wrap'] && 0xb !== v0['mode'] ? D : 0xb === v0['mode'] && X(0x1, R, v1, 0x0) !== v0['check'] ? -0x3 : Q(L, R, v1, v1) ? (v0['mode'] = 0x1f,
                      -0x4) : (v0['havedict'] = 0x1,
                      j) : D;
                  }
                  ,
                  Y['inflateInfo'] = 'pako\x20inflate\x20(from\x20Nodeca\x20project)';
              }
              , {
                  '../utils/common': 0x29,
                  './adler32': 0x2b,
                  './crc32': 0x2d,
                  './inffast': 0x30,
                  './inftrees': 0x32
              }],
              0x32: [function(c, H, x) {
                  'use strict';
                  var p = c('../utils/common')
                    , F = [0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xd, 0xf, 0x11, 0x13, 0x17, 0x1b, 0x1f, 0x23, 0x2b, 0x33, 0x3b, 0x43, 0x53, 0x63, 0x73, 0x83, 0xa3, 0xc3, 0xe3, 0x102, 0x0, 0x0]
                    , y = [0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x11, 0x11, 0x11, 0x11, 0x12, 0x12, 0x12, 0x12, 0x13, 0x13, 0x13, 0x13, 0x14, 0x14, 0x14, 0x14, 0x15, 0x15, 0x15, 0x15, 0x10, 0x48, 0x4e]
                    , w = [0x1, 0x2, 0x3, 0x4, 0x5, 0x7, 0x9, 0xd, 0x11, 0x19, 0x21, 0x31, 0x41, 0x61, 0x81, 0xc1, 0x101, 0x181, 0x201, 0x301, 0x401, 0x601, 0x801, 0xc01, 0x1001, 0x1801, 0x2001, 0x3001, 0x4001, 0x6001, 0x0, 0x0]
                    , h = [0x10, 0x10, 0x10, 0x10, 0x11, 0x11, 0x12, 0x12, 0x13, 0x13, 0x14, 0x14, 0x15, 0x15, 0x16, 0x16, 0x17, 0x17, 0x18, 0x18, 0x19, 0x19, 0x1a, 0x1a, 0x1b, 0x1b, 0x1c, 0x1c, 0x1d, 0x1d, 0x40, 0x40];
                  H['exports'] = function(Y, X, W, j, V, Z, U, q) {
                      var J, G, N, Q, v0, v1, v2, v3, v4, v5 = q['bits'], v6 = 0x0, v7 = 0x0, v8 = 0x0, v9 = 0x0, vv = 0x0, vA = 0x0, vn = 0x0, vk = 0x0, vl = 0x0, vK = 0x0, vi = null, vb = 0x0, ve = new p['Buf16'](0x10), vc = new p['Buf16'](0x10), vH = null, vt = 0x0;
                      for (v6 = 0x0; v6 <= 0xf; v6++)
                          ve[v6] = 0x0;
                      for (v7 = 0x0; v7 < j; v7++)
                          ve[X[W + v7]]++;
                      for (vv = v5,
                      v9 = 0xf; 0x1 <= v9 && 0x0 === ve[v9]; v9--)
                          ;
                      if (v9 < vv && (vv = v9),
                      0x0 === v9)
                          return V[Z++] = 0x1400000,
                          V[Z++] = 0x1400000,
                          q['bits'] = 0x1,
                          0x0;
                      for (v8 = 0x1; v8 < v9 && 0x0 === ve[v8]; v8++)
                          ;
                      for (vv < v8 && (vv = v8),
                      v6 = vk = 0x1; v6 <= 0xf; v6++)
                          if (vk <<= 0x1,
                          (vk -= ve[v6]) < 0x0)
                              return -0x1;
                      if (0x0 < vk && (0x0 === Y || 0x1 !== v9))
                          return -0x1;
                      for (vc[0x1] = 0x0,
                      v6 = 0x1; v6 < 0xf; v6++)
                          vc[v6 + 0x1] = vc[v6] + ve[v6];
                      for (v7 = 0x0; v7 < j; v7++)
                          0x0 !== X[W + v7] && (U[vc[X[W + v7]]++] = v7);
                      if (v1 = 0x0 === Y ? (vi = vH = U,
                      0x13) : 0x1 === Y ? (vi = F,
                      vb -= 0x101,
                      vH = y,
                      vt -= 0x101,
                      0x100) : (vi = w,
                      vH = h,
                      -0x1),
                      v6 = v8,
                      v0 = Z,
                      vn = v7 = vK = 0x0,
                      N = -0x1,
                      Q = (vl = 0x1 << (vA = vv)) - 0x1,
                      0x1 === Y && 0x354 < vl || 0x2 === Y && 0x250 < vl)
                          return 0x1;
                      for (; ; ) {
                          for (v2 = v6 - vn,
                          v4 = U[v7] < v1 ? (v3 = 0x0,
                          U[v7]) : U[v7] > v1 ? (v3 = vH[vt + U[v7]],
                          vi[vb + U[v7]]) : (v3 = 0x60,
                          0x0),
                          J = 0x1 << v6 - vn,
                          v8 = G = 0x1 << vA; V[v0 + (vK >> vn) + (G -= J)] = v2 << 0x18 | v3 << 0x10 | v4 | 0x0,
                          0x0 !== G; )
                              ;
                          for (J = 0x1 << v6 - 0x1; vK & J; )
                              J >>= 0x1;
                          if (0x0 !== J ? (vK &= J - 0x1,
                          vK += J) : vK = 0x0,
                          v7++,
                          0x0 == --ve[v6]) {
                              if (v6 === v9)
                                  break;
                              v6 = X[W + U[v7]];
                          }
                          if (vv < v6 && (vK & Q) !== N) {
                              for (0x0 === vn && (vn = vv),
                              v0 += v8,
                              vk = 0x1 << (vA = v6 - vn); vA + vn < v9 && !((vk -= ve[vA + vn]) <= 0x0); )
                                  vA++,
                                  vk <<= 0x1;
                              if (vl += 0x1 << vA,
                              0x1 === Y && 0x354 < vl || 0x2 === Y && 0x250 < vl)
                                  return 0x1;
                              V[N = vK & Q] = vv << 0x18 | vA << 0x10 | v0 - Z | 0x0;
                          }
                      }
                      return 0x0 !== vK && (V[v0 + vK] = v6 - vn << 0x18 | 0x40 << 0x10 | 0x0),
                      q['bits'] = vv,
                      0x0;
                  }
                  ;
              }
              , {
                  '../utils/common': 0x29
              }],
              0x33: [function(c, H, x) {
                  'use strict';
                  H['exports'] = {
                      0x2: 'need\x20dictionary',
                      0x1: 'stream\x20end',
                      0x0: '',
                      '-1': 'file\x20error',
                      '-2': 'stream\x20error',
                      '-3': 'data\x20error',
                      '-4': 'insufficient\x20memory',
                      '-5': 'buffer\x20error',
                      '-6': 'incompatible\x20version'
                  };
              }
              , {}],
              0x34: [function(H, Y, X) {
                  'use strict';
                  var W = H('../utils/common');
                  function j(vu) {
                      for (var vY = vu['length']; 0x0 <= --vY; )
                          vu[vY] = 0x0;
                  }
                  var Z = 0x100
                    , q = 0x11e
                    , J = 0x1e
                    , G = 0xf
                    , N = 0x10
                    , Q = [0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x1, 0x1, 0x2, 0x2, 0x2, 0x2, 0x3, 0x3, 0x3, 0x3, 0x4, 0x4, 0x4, 0x4, 0x5, 0x5, 0x5, 0x5, 0x0]
                    , v0 = [0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x2, 0x2, 0x3, 0x3, 0x4, 0x4, 0x5, 0x5, 0x6, 0x6, 0x7, 0x7, 0x8, 0x8, 0x9, 0x9, 0xa, 0xa, 0xb, 0xb, 0xc, 0xc, 0xd, 0xd]
                    , v1 = [0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x3, 0x7]
                    , v2 = [0x10, 0x11, 0x12, 0x0, 0x8, 0x7, 0x9, 0x6, 0xa, 0x5, 0xb, 0x4, 0xc, 0x3, 0xd, 0x2, 0xe, 0x1, 0xf]
                    , v3 = new Array(0x240);
                  j(v3);
                  var v4 = new Array(0x3c);
                  j(v4);
                  var v5 = new Array(0x200);
                  j(v5);
                  var v6 = new Array(0x100);
                  j(v6);
                  var v7 = new Array(0x1d);
                  j(v7);
                  var v8, v9, vv, vA = new Array(J);
                  function vn(vu, vY, vT, vX, Quadtree) {
                      this['static_tree'] = vu,
                      this['extra_bits'] = vY,
                      this['extra_base'] = vT,
                      this['elems'] = vX,
                      this['max_length'] = Quadtree,
                      this['has_stree'] = vu && vu['length'];
                  }
                  function vk(vu, vY) {
                      this['dyn_tree'] = vu,
                      this['max_code'] = 0x0,
                      this['stat_desc'] = vY;
                  }
                  function vl(vu) {
                      return vu < 0x100 ? v5[vu] : v5[0x100 + (vu >>> 0x7)];
                  }
                  function vK(vu, vY) {
                      vu['pending_buf'][vu['pending']++] = 0xff & vY,
                      vu['pending_buf'][vu['pending']++] = vY >>> 0x8 & 0xff;
                  }
                  function vi(vu, vY, vT) {
                      vu['bi_valid'] > N - vT ? (vu['bi_buf'] |= vY << vu['bi_valid'] & 0xffff,
                      vK(vu, vu['bi_buf']),
                      vu['bi_buf'] = vY >> N - vu['bi_valid'],
                      vu['bi_valid'] += vT - N) : (vu['bi_buf'] |= vY << vu['bi_valid'] & 0xffff,
                      vu['bi_valid'] += vT);
                  }
                  function vb(vu, vY, vT) {
                      vi(vu, vT[0x2 * vY], vT[0x2 * vY + 0x1]);
                  }
                  function ve(vu, vY) {
                      for (var vT = 0x0; vT |= 0x1 & vu,
                      vu >>>= 0x1,
                      vT <<= 0x1,
                      0x0 < --vY; )
                          ;
                      return vT >>> 0x1;
                  }
                  function vc(vu, vY, vT) {
                      var vX, Quadtree, vf = new Array(G + 0x1), vW = 0x0;
                      for (vX = 0x1; vX <= G; vX++)
                          vf[vX] = vW = vW + vT[vX - 0x1] << 0x1;
                      for (Quadtree = 0x0; Quadtree <= vY; Quadtree++) {
                          var vI = vu[0x2 * Quadtree + 0x1];
                          0x0 !== vI && (vu[0x2 * Quadtree] = ve(vf[vI]++, vI));
                      }
                  }
                  function vH(vu) {
                      var vY;
                      for (vY = 0x0; vY < q; vY++)
                          vu['dyn_ltree'][0x2 * vY] = 0x0;
                      for (vY = 0x0; vY < J; vY++)
                          vu['dyn_dtree'][0x2 * vY] = 0x0;
                      for (vY = 0x0; vY < 0x13; vY++)
                          vu['bl_tree'][0x2 * vY] = 0x0;
                      vu['dyn_ltree'][0x200] = 0x1,
                      vu['opt_len'] = vu['static_len'] = 0x0,
                      vu['last_lit'] = vu['matches'] = 0x0;
                  }
                  function vt(vu) {
                      0x8 < vu['bi_valid'] ? vK(vu, vu['bi_buf']) : 0x0 < vu['bi_valid'] && (vu['pending_buf'][vu['pending']++] = vu['bi_buf']),
                      vu['bi_buf'] = 0x0,
                      vu['bi_valid'] = 0x0;
                  }
                  function vx(vu, vY, vT, vX) {
                      var Quadtree = 0x2 * vY
                        , vf = 0x2 * vT;
                      return vu[Quadtree] < vu[vf] || vu[Quadtree] === vu[vf] && vX[vY] <= vX[vT];
                  }
                  function vp(vu, vY, vT) {
                      for (var vX = vu['heap'][vT], Quadtree = vT << 0x1; Quadtree <= vu['heap_len'] && (Quadtree < vu['heap_len'] && vx(vY, vu['heap'][Quadtree + 0x1], vu['heap'][Quadtree], vu['depth']) && Quadtree++,
                      !vx(vY, vX, vu['heap'][Quadtree], vu['depth'])); )
                          vu['heap'][vT] = vu['heap'][Quadtree],
                          vT = Quadtree,
                          Quadtree <<= 0x1;
                      vu['heap'][vT] = vX;
                  }
                  function vF(vu, vY, vT) {
                      var vX, Quadtree, vf, vW, vI = 0x0;
                      if (0x0 !== vu['last_lit']) {
                          for (; vX = vu['pending_buf'][vu['d_buf'] + 0x2 * vI] << 0x8 | vu['pending_buf'][vu['d_buf'] + 0x2 * vI + 0x1],
                          Quadtree = vu['pending_buf'][vu['l_buf'] + vI],
                          vI++,
                          0x0 === vX ? vb(vu, Quadtree, vY) : (vb(vu, (vf = v6[Quadtree]) + Z + 0x1, vY),
                          0x0 !== (vW = Q[vf]) && vi(vu, Quadtree -= v7[vf], vW),
                          vb(vu, vf = vl(--vX), vT),
                          0x0 !== (vW = v0[vf]) && vi(vu, vX -= vA[vf], vW)),
                          vI < vu['last_lit']; )
                              ;
                      }
                      vb(vu, 0x100, vY);
                  }
                  function vy(vu, vY) {
                      var vT, vX, Quadtree, vf = vY['dyn_tree'], vW = vY['stat_desc']['static_tree'], vI = vY['stat_desc']['has_stree'], vj = vY['stat_desc']['elems'], vD = -0x1;
                      for (vu['heap_len'] = 0x0,
                      vu['heap_max'] = 0x23d,
                      vT = 0x0; vT < vj; vT++)
                          0x0 !== vf[0x2 * vT] ? (vu['heap'][++vu['heap_len']] = vD = vT,
                          vu['depth'][vT] = 0x0) : vf[0x2 * vT + 0x1] = 0x0;
                      for (; vu['heap_len'] < 0x2; )
                          vf[0x2 * (Quadtree = vu['heap'][++vu['heap_len']] = vD < 0x2 ? ++vD : 0x0)] = 0x1,
                          vu['depth'][Quadtree] = 0x0,
                          vu['opt_len']--,
                          vI && (vu['static_len'] -= vW[0x2 * Quadtree + 0x1]);
                      for (vY['max_code'] = vD,
                      vT = vu['heap_len'] >> 0x1; 0x1 <= vT; vT--)
                          vp(vu, vf, vT);
                      for (Quadtree = vj; vT = vu['heap'][0x1],
                      vu['heap'][0x1] = vu['heap'][vu['heap_len']--],
                      vp(vu, vf, 0x1),
                      vX = vu['heap'][0x1],
                      vu['heap'][--vu['heap_max']] = vT,
                      vu['heap'][--vu['heap_max']] = vX,
                      vf[0x2 * Quadtree] = vf[0x2 * vT] + vf[0x2 * vX],
                      vu['depth'][Quadtree] = (vu['depth'][vT] >= vu['depth'][vX] ? vu['depth'][vT] : vu['depth'][vX]) + 0x1,
                      vf[0x2 * vT + 0x1] = vf[0x2 * vX + 0x1] = Quadtree,
                      vu['heap'][0x1] = Quadtree++,
                      vp(vu, vf, 0x1),
                      0x2 <= vu['heap_len']; )
                          ;
                      vu['heap'][--vu['heap_max']] = vu['heap'][0x1],
                      function(vV, vZ) {
                          var vB, vS, vU, vd, vq, vJ, vo = vZ['dyn_tree'], vC = vZ['max_code'], vO = vZ['stat_desc']['static_tree'], vG = vZ['stat_desc']['has_stree'], vg = vZ['stat_desc']['extra_bits'], vN = vZ['stat_desc']['extra_base'], vP = vZ['stat_desc']['max_length'], vM = 0x0;
                          for (vd = 0x0; vd <= G; vd++)
                              vV['bl_count'][vd] = 0x0;
                          for (vo[0x2 * vV['heap'][vV['heap_max']] + 0x1] = 0x0,
                          vB = vV['heap_max'] + 0x1; vB < 0x23d; vB++)
                              vP < (vd = vo[0x2 * vo[0x2 * (vS = vV['heap'][vB]) + 0x1] + 0x1] + 0x1) && (vd = vP,
                              vM++),
                              vo[0x2 * vS + 0x1] = vd,
                              vC < vS || (vV['bl_count'][vd]++,
                              vq = 0x0,
                              vN <= vS && (vq = vg[vS - vN]),
                              vJ = vo[0x2 * vS],
                              vV['opt_len'] += vJ * (vd + vq),
                              vG && (vV['static_len'] += vJ * (vO[0x2 * vS + 0x1] + vq)));
                          if (0x0 !== vM) {
                              do {
                                  for (vd = vP - 0x1; 0x0 === vV['bl_count'][vd]; )
                                      vd--;
                                  vV['bl_count'][vd]--,
                                  vV['bl_count'][vd + 0x1] += 0x2,
                                  vV['bl_count'][vP]--,
                                  vM -= 0x2;
                              } while (0x0 < vM);
                              for (vd = vP; 0x0 !== vd; vd--)
                                  for (vS = vV['bl_count'][vd]; 0x0 !== vS; )
                                      vC < (vU = vV['heap'][--vB]) || (vo[0x2 * vU + 0x1] !== vd && (vV['opt_len'] += (vd - vo[0x2 * vU + 0x1]) * vo[0x2 * vU],
                                      vo[0x2 * vU + 0x1] = vd),
                                      vS--);
                          }
                      }(vu, vY),
                      vc(vf, vD, vu['bl_count']);
                  }
                  function vr(vu, vY, vT) {
                      var vX, Quadtree, vf = -0x1, vW = vY[0x1], vI = 0x0, vj = 0x7, vD = 0x4;
                      for (0x0 === vW && (vj = 0x8a,
                      vD = 0x3),
                      vY[0x2 * (vT + 0x1) + 0x1] = 0xffff,
                      vX = 0x0; vX <= vT; vX++)
                          Quadtree = vW,
                          vW = vY[0x2 * (vX + 0x1) + 0x1],
                          ++vI < vj && Quadtree === vW || (vI < vD ? vu['bl_tree'][0x2 * Quadtree] += vI : 0x0 !== Quadtree ? (Quadtree !== vf && vu['bl_tree'][0x2 * Quadtree]++,
                          vu['bl_tree'][0x20]++) : vI <= 0xa ? vu['bl_tree'][0x22]++ : vu['bl_tree'][0x24]++,
                          vf = Quadtree,
                          vD = (vI = 0x0) === vW ? (vj = 0x8a,
                          0x3) : Quadtree === vW ? (vj = 0x6,
                          0x3) : (vj = 0x7,
                          0x4));
                  }
                  function vw(vu, vY, vT) {
                      var vX, Quadtree, vf = -0x1, vW = vY[0x1], vI = 0x0, vj = 0x7, vD = 0x4;
                      for (0x0 === vW && (vj = 0x8a,
                      vD = 0x3),
                      vX = 0x0; vX <= vT; vX++)
                          if (Quadtree = vW,
                          vW = vY[0x2 * (vX + 0x1) + 0x1],
                          !(++vI < vj && Quadtree === vW)) {
                              if (vI < vD) {
                                  for (; vb(vu, Quadtree, vu['bl_tree']),
                                  0x0 != --vI; )
                                      ;
                              } else
                                  0x0 !== Quadtree ? (Quadtree !== vf && (vb(vu, Quadtree, vu['bl_tree']),
                                  vI--),
                                  vb(vu, 0x10, vu['bl_tree']),
                                  vi(vu, vI - 0x3, 0x2)) : vI <= 0xa ? (vb(vu, 0x11, vu['bl_tree']),
                                  vi(vu, vI - 0x3, 0x3)) : (vb(vu, 0x12, vu['bl_tree']),
                                  vi(vu, vI - 0xb, 0x7));
                              vf = Quadtree,
                              vD = (vI = 0x0) === vW ? (vj = 0x8a,
                              0x3) : Quadtree === vW ? (vj = 0x6,
                              0x3) : (vj = 0x7,
                              0x4);
                          }
                  }
                  j(vA);
                  var vs = false;
                  function vh(vu, vY, vT, vX) {
                      vi(vu, 0x0 + (vX ? 0x1 : 0x0), 0x3),
                      function(Quadtree, vf, vW, vI) {
                          vt(Quadtree),
                          vK(Quadtree, vW),
                          vK(Quadtree, ~vW),
                          W['arraySet'](Quadtree['pending_buf'], Quadtree['window'], vf, vW, Quadtree['pending']),
                          Quadtree['pending'] += vW;
                      }(vu, vY, vT);
                  }
                  X['_tr_init'] = function(vu) {
                      vs || (function() {
                          var vY, vT, vX, Quadtree, vf, vW = new Array(G + 0x1);
                          for (Quadtree = vX = 0x0; Quadtree < 0x1c; Quadtree++)
                              for (v7[Quadtree] = vX,
                              vY = 0x0; vY < 0x1 << Q[Quadtree]; vY++)
                                  v6[vX++] = Quadtree;
                          for (v6[vX - 0x1] = Quadtree,
                          Quadtree = vf = 0x0; Quadtree < 0x10; Quadtree++)
                              for (vA[Quadtree] = vf,
                              vY = 0x0; vY < 0x1 << v0[Quadtree]; vY++)
                                  v5[vf++] = Quadtree;
                          for (vf >>= 0x7; Quadtree < J; Quadtree++)
                              for (vA[Quadtree] = vf << 0x7,
                              vY = 0x0; vY < 0x1 << v0[Quadtree] - 0x7; vY++)
                                  v5[0x100 + vf++] = Quadtree;
                          for (vT = 0x0; vT <= G; vT++)
                              vW[vT] = 0x0;
                          for (vY = 0x0; vY <= 0x8f; )
                              v3[0x2 * vY + 0x1] = 0x8,
                              vY++,
                              vW[0x8]++;
                          for (; vY <= 0xff; )
                              v3[0x2 * vY + 0x1] = 0x9,
                              vY++,
                              vW[0x9]++;
                          for (; vY <= 0x117; )
                              v3[0x2 * vY + 0x1] = 0x7,
                              vY++,
                              vW[0x7]++;
                          for (; vY <= 0x11f; )
                              v3[0x2 * vY + 0x1] = 0x8,
                              vY++,
                              vW[0x8]++;
                          for (vc(v3, 0x11f, vW),
                          vY = 0x0; vY < J; vY++)
                              v4[0x2 * vY + 0x1] = 0x5,
                              v4[0x2 * vY] = ve(vY, 0x5);
                          v8 = new vn(v3,Q,0x101,q,G),
                          v9 = new vn(v4,v0,0x0,J,G),
                          vv = new vn(new Array(0x0),v1,0x0,0x13,0x7);
                      }(),
                      vs = true),
                      vu['l_desc'] = new vk(vu['dyn_ltree'],v8),
                      vu['d_desc'] = new vk(vu['dyn_dtree'],v9),
                      vu['bl_desc'] = new vk(vu['bl_tree'],vv),
                      vu['bi_buf'] = 0x0,
                      vu['bi_valid'] = 0x0,
                      vH(vu);
                  }
                  ,
                  X['_tr_stored_block'] = vh,
                  X['_tr_flush_block'] = function(vu, vY, vT, vX) {
                      var Quadtree, vf, vW = 0x0;
                      0x0 < vu['level'] ? (0x2 === vu['strm']['data_type'] && (vu['strm']['data_type'] = function(vI) {
                          var vj, vD = 0xf3ffc07f;
                          for (vj = 0x0; vj <= 0x1f; vj++,
                          vD >>>= 0x1)
                              if (0x1 & vD && 0x0 !== vI['dyn_ltree'][0x2 * vj])
                                  return 0x0;
                          if (0x0 !== vI['dyn_ltree'][0x12] || 0x0 !== vI['dyn_ltree'][0x14] || 0x0 !== vI['dyn_ltree'][0x1a])
                              return 0x1;
                          for (vj = 0x20; vj < Z; vj++)
                              if (0x0 !== vI['dyn_ltree'][0x2 * vj])
                                  return 0x1;
                          return 0x0;
                      }(vu)),
                      vy(vu, vu['l_desc']),
                      vy(vu, vu['d_desc']),
                      vW = function(vI) {
                          var vj;
                          for (vr(vI, vI['dyn_ltree'], vI['l_desc']['max_code']),
                          vr(vI, vI['dyn_dtree'], vI['d_desc']['max_code']),
                          vy(vI, vI['bl_desc']),
                          vj = 0x12; 0x3 <= vj && 0x0 === vI['bl_tree'][0x2 * v2[vj] + 0x1]; vj--)
                              ;
                          return vI['opt_len'] += 0x3 * (vj + 0x1) + 0x5 + 0x5 + 0x4,
                          vj;
                      }(vu),
                      Quadtree = vu['opt_len'] + 0x3 + 0x7 >>> 0x3,
                      (vf = vu['static_len'] + 0x3 + 0x7 >>> 0x3) <= Quadtree && (Quadtree = vf)) : Quadtree = vf = vT + 0x5,
                      vT + 0x4 <= Quadtree && -0x1 !== vY ? vh(vu, vY, vT, vX) : 0x4 === vu['strategy'] || vf === Quadtree ? (vi(vu, 0x2 + (vX ? 0x1 : 0x0), 0x3),
                      vF(vu, v3, v4)) : (vi(vu, 0x4 + (vX ? 0x1 : 0x0), 0x3),
                      function(vI, vj, vD, vV) {
                          var vZ;
                          for (vi(vI, vj - 0x101, 0x5),
                          vi(vI, vD - 0x1, 0x5),
                          vi(vI, vV - 0x4, 0x4),
                          vZ = 0x0; vZ < vV; vZ++)
                              vi(vI, vI['bl_tree'][0x2 * v2[vZ] + 0x1], 0x3);
                          vw(vI, vI['dyn_ltree'], vj - 0x1),
                          vw(vI, vI['dyn_dtree'], vD - 0x1);
                      }(vu, vu['l_desc']['max_code'] + 0x1, vu['d_desc']['max_code'] + 0x1, vW + 0x1),
                      vF(vu, vu['dyn_ltree'], vu['dyn_dtree'])),
                      vH(vu),
                      vX && vt(vu);
                  }
                  ,
                  X['_tr_tally'] = function(vu, vY, vT) {
                      return vu['pending_buf'][vu['d_buf'] + 0x2 * vu['last_lit']] = vY >>> 0x8 & 0xff,
                      vu['pending_buf'][vu['d_buf'] + 0x2 * vu['last_lit'] + 0x1] = 0xff & vY,
                      vu['pending_buf'][vu['l_buf'] + vu['last_lit']] = 0xff & vT,
                      vu['last_lit']++,
                      0x0 === vY ? vu['dyn_ltree'][0x2 * vT]++ : (vu['matches']++,
                      vY--,
                      vu['dyn_ltree'][0x2 * (v6[vT] + Z + 0x1)]++,
                      vu['dyn_dtree'][0x2 * vl(vY)]++),
                      vu['last_lit'] === vu['lit_bufsize'] - 0x1;
                  }
                  ,
                  X['_tr_align'] = function(vu) {
                      vi(vu, 0x2, 0x3),
                      vb(vu, 0x100, v3),
                      function(vY) {
                          0x10 === vY['bi_valid'] ? (vK(vY, vY['bi_buf']),
                          vY['bi_buf'] = 0x0,
                          vY['bi_valid'] = 0x0) : 0x8 <= vY['bi_valid'] && (vY['pending_buf'][vY['pending']++] = 0xff & vY['bi_buf'],
                          vY['bi_buf'] >>= 0x8,
                          vY['bi_valid'] -= 0x8);
                      }(vu);
                  }
                  ;
              }
              , {
                  '../utils/common': 0x29
              }],
              0x35: [function(c, H, x) {
                  'use strict';
                  H['exports'] = function() {
                      this['input'] = null,
                      this['next_in'] = 0x0,
                      this['avail_in'] = 0x0,
                      this['total_in'] = 0x0,
                      this['output'] = null,
                      this['next_out'] = 0x0,
                      this['avail_out'] = 0x0,
                      this['total_out'] = 0x0,
                      this['msg'] = '',
                      this['state'] = null,
                      this['data_type'] = 0x2,
                      this['adler'] = 0x0;
                  }
                  ;
              }
              , {}],
              0x36: [function(c, H, x) {
                  (function(p) {
                      !function(F, y) {
                          'use strict';
                          if (!F['setImmediate']) {
                              var w, Y, T, X, E = 0x1, W = {}, I = false, j = F['document'], D = Object['getPrototypeOf'] && Object['getPrototypeOf'](F);
                              D = D && D['setTimeout'] ? D : F,
                              w = '[object\x20process]' === {}['toString']['call'](F['process']) ? function(S) {
                                  process['nextTick'](function() {
                                      Z(S);
                                  });
                              }
                              : function() {
                                  if (F['postMessage'] && !F['importScripts']) {
                                      var S = true
                                        , U = F['onmessage'];
                                      return F['onmessage'] = function() {
                                          S = false;
                                      }
                                      ,
                                      F['postMessage']('', '*'),
                                      F['onmessage'] = U,
                                      S;
                                  }
                              }() ? (X = 'setImmediate$' + Math['random']() + '$',
                              F['addEventListener'] ? F['addEventListener']('message', B, false) : F['attachEvent']('onmessage', B),
                              function(S) {
                                  F['postMessage'](X + S, '*');
                              }
                              ) : F['MessageChannel'] ? ((T = new MessageChannel())['port1']['onmessage'] = function(S) {
                                  Z(S['data']);
                              }
                              ,
                              function(S) {
                                  T['port2']['postMessage'](S);
                              }
                              ) : j && 'onreadystatechange'in j['createElement']('script') ? (Y = j['documentElement'],
                              function(S) {
                                  var U = j['createElement']('script');
                                  U['onreadystatechange'] = function() {
                                      Z(S),
                                      U['onreadystatechange'] = null,
                                      Y['removeChild'](U),
                                      U = null;
                                  }
                                  ,
                                  Y['appendChild'](U);
                              }
                              ) : function(S) {
                                  setTimeout(Z, 0x0, S);
                              }
                              ,
                              D['setImmediate'] = function(S) {
                                  'function' != typeof S && (S = new Function('' + S));
                                  for (var U = new Array(arguments['length'] - 0x1), q = 0x0; q < U['length']; q++)
                                      U[q] = arguments[q + 0x1];
                                  var J = {
                                      'callback': S,
                                      'args': U
                                  };
                                  return W[E] = J,
                                  w(E),
                                  E++;
                              }
                              ,
                              D['clearImmediate'] = V;
                          }
                          function V(S) {
                              delete W[S];
                          }
                          function Z(S) {
                              if (I)
                                  setTimeout(Z, 0x0, S);
                              else {
                                  var U = W[S];
                                  if (U) {
                                      I = true;
                                      try {
                                          !function(q) {
                                              var J = q['callback']
                                                , C = q['args'];
                                              switch (C['length']) {
                                              case 0x0:
                                                  J();
                                                  break;
                                              case 0x1:
                                                  J(C[0x0]);
                                                  break;
                                              case 0x2:
                                                  J(C[0x0], C[0x1]);
                                                  break;
                                              case 0x3:
                                                  J(C[0x0], C[0x1], C[0x2]);
                                                  break;
                                              default:
                                                  J['apply'](y, C);
                                              }
                                          }(U);
                                      } finally {
                                          V(S),
                                          I = false;
                                      }
                                  }
                              }
                          }
                          function B(S) {
                              S['source'] === F && 'string' == typeof S['data'] && 0x0 === S['data']['indexOf'](X) && Z(+S['data']['slice'](X['length']));
                          }
                      }('undefined' == typeof self ? undefined === p ? this : p : self);
                  }
                  ['call'](this, 'undefined' != typeof global ? global : 'undefined' != typeof self ? self : 'undefined' != typeof window ? window : {}));
              }
              , {}]
          }, {}, [0xa])(0xa);
      }
      ,
      0x346: (l,K,i)=>{
          'use strict';
          i['d'](K, {
              'v': ()=>b
          });
          const b = {
              'Debug': true,
              'resourcePath': 'public',
              'defaultLegendPath': 'public/styles/colors',
              'fieldLoaderIndicator': '#',
              'fieldPropertiesIndicator': '$',
              'themeIndicator': '@',
              'functionIndicator': '//!QuickEarth',
              'customPanes': {
                  'feature': {
                      'name': 'featurePane',
                      'zIdx': 0x1c2
                  },
                  'filled': {
                      'name': 'filledPane',
                      'zIdx': 0x17c
                  },
                  'topmap': {
                      'name': 'tommapPane',
                      'zIdx': 0x1ae
                  },
                  'bottommap': {
                      'name': 'bottommapPane',
                      'zIdx': 0x104
                  },
                  'station': {
                      'name': 'stationPane',
                      'zIdx': 0x1e0
                  },
                  'bellowtile': {
                      'name': 'bellowtilePane',
                      'zIdx': 0x64
                  }
              },
              'defaultUndef': 0xf423f,
              'useWebGL2': true,
              'checkRetina': true,
              'retinaRatio': undefined,
              'licPath': 'public/qe.lic',
              'wasmPath': 'public/libs/wasm',
              'workerPath': 'public/libs/workers'
          };
          b['defaultLegendPath'] = b['resourcePath'] + '/styles/colors',
          b['licPath'] = b['resourcePath'] + '/qe.lic',
          b['wasmPath'] = b['resourcePath'] + '/libs/wasm';
      }
      ,
      0x393: (l,K,b)=>{
          'use strict';
          b['d'](K, {
              'c': ()=>p
          });
          var c = b(0x39b)
            , H = b(0x1);
          function x() {
              return false;
          }
          class p {
              constructor() {
                  this['_events'] = {},
                  this['_firingCount'] = 0x0,
                  this['_eventParents'] = {},
                  this['_locked'] = 0x0,
                  this['_lockedEvents'] = {};
              }
              ['on'](F, y, w) {
                  if ('object' == typeof F) {
                      for (var h in F)
                          this['_on'](h, F[h], y);
                  } else {
                      for (var u = 0x0, Y = (F = (0x0,
                      H['nf'])(F))['length']; u < Y; u++)
                          this['_on'](F[u], y, w);
                  }
                  return this;
              }
              ['off'](F, y, w) {
                  if (F) {
                      if ('object' == typeof F) {
                          for (var h in F)
                              this['_off'](h, F[h], y);
                      } else {
                          for (var u = 0x0, Y = (F = (0x0,
                          H['nf'])(F))['length']; u < Y; u++)
                              this['_off'](F[u], y, w);
                      }
                  } else
                      delete this['_events'];
                  return this;
              }
              ['lock']() {
                  return this['_locked']++,
                  this;
              }
              ['unlock'](F=true) {
                  if (this['_locked']--,
                  this['_locked'] < 0x0 && (this['_locked'] = 0x0),
                  0x0 === this['_locked'] && F) {
                      const y = Object['keys'](this['_lockedEvents']);
                      for (const w of y)
                          this['fire'](w, this['_lockedEvents'][w]['data'], this['_lockedEvents'][w]['prop']);
                      y['length'] > 0x0 && c['kg']['debug']('locked\x20msg\x20fired,count\x20' + y['length']);
                  }
              }
              ['_on'](F, y, w) {
                  this['_events'] = this['_events'] || {};
                  var h = this['_events'][F];
                  h || (h = [],
                  this['_events'][F] = h),
                  w === this && (w = undefined);
                  for (var u = {
                      'fn': y,
                      'ctx': w
                  }, Y = h, T = 0x0, X = Y['length']; T < X; T++)
                      if (Y[T]['fn'] === y && Y[T]['ctx'] === w)
                          return;
                  Y['push'](u);
              }
              ['_off'](F, y, w) {
                  var h, u, Y;
                  if (this['_events'] && (h = this['_events'][F])) {
                      if (y) {
                          if (w === this && (w = undefined),
                          h)
                              for (u = 0x0,
                              Y = h['length']; u < Y; u++) {
                                  var T = h[u];
                                  if (T['ctx'] === w && T['fn'] === y)
                                      return T['fn'] = x,
                                      this['_firingCount'] && (this['_events'][F] = h = h['slice']()),
                                      void h['splice'](u, 0x1);
                              }
                      } else {
                          for (u = 0x0,
                          Y = h['length']; u < Y; u++)
                              h[u]['fn'] = x;
                          delete this['_events'][F];
                      }
                  }
              }
              ['fire'](F, y, w) {
                  if (!(this['_locked'] > 0x0)) {
                      if (!this['listens'](F, w))
                          return this;
                      var h = (0x0,
                      H['l7'])({}, y, {
                          'type': F,
                          'target': this,
                          'sourceTarget': y && y['firer'] || this
                      });
                      if (this['_events']) {
                          var u = this['_events'][F];
                          if (u) {
                              this['_firingCount'] = this['_firingCount'] + 0x1 || 0x1;
                              for (var Y = 0x0, T = u['length']; Y < T; Y++) {
                                  var X = u[Y];
                                  X['fn']['call'](X['ctx'] || this, h);
                              }
                              this['_firingCount']--;
                          }
                      }
                      return w && this['_propagateEvent'](h),
                      this;
                  }
                  this['_lockedEvents'][F] = {
                      'data': y,
                      'prop': w
                  };
              }
              ['listens'](F, y) {
                  var w = this['_events'] && this['_events'][F];
                  if (w && w['length'])
                      return true;
                  if (y) {
                      for (var h in this['_eventParents'])
                          if (this['_eventParents'][h]['listens'](F, y))
                              return true;
                  }
                  return false;
              }
              ['once'](F, y, w) {
                  if ('object' == typeof F) {
                      for (var h in F)
                          this['once'](h, F[h], y);
                      return this;
                  }
                  var u = function(Y, T) {
                      var X = Array['prototype']['slice'];
                      if (Y['bind'])
                          return Y['bind']['apply'](Y, X['call'](arguments, 0x1));
                      var E = X['call'](arguments, 0x2);
                      return function() {
                          return Y['apply'](T, E['length'] ? E['concat'](X['call'](arguments)) : arguments);
                      }
                      ;
                  }(function() {
                      this['off'](F, y, w)['off'](F, u, w);
                  }, this);
                  return this['on'](F, y, w)['on'](F, u, w);
              }
              ['addEventParent'](F) {
                  return this['_eventParents'] = this['_eventParents'] || {},
                  this['_eventParents'][(0x0,
                  H['Rc'])(F)] = F,
                  this;
              }
              ['removeEventParent'](F) {
                  return this['_eventParents'] && delete this['_eventParents'][(0x0,
                  H['Rc'])(F)],
                  this;
              }
              ['_propagateEvent'](F) {
                  for (var y in this['_eventParents'])
                      this['_eventParents'][y]['fire'](F['type'], (0x0,
                      H['l7'])({
                          'layer': F['target'],
                          'propagatedFrom': F['target']
                      }, F), true);
              }
          }
      }
      ,
      0x19d: (K,H,F)=>{
          'use strict';
          F['d'](H, {
              'CI': ()=>L,
              'Fj': ()=>q,
              'JW': ()=>U,
              'Jf': ()=>O,
              'M': ()=>v3,
              'NX': ()=>v4,
              'PE': ()=>Q,
              'SC': ()=>R,
              'Tw': ()=>M,
              'Xx': ()=>v0,
              '_7': ()=>v1,
              'cQ': ()=>G,
              'oL': ()=>z,
              'pd': ()=>J,
              'q$': ()=>C,
              'rJ': ()=>N,
              'sC': ()=>v2
          });
          var Y = F(0x39b)
            , T = F(0xfb)
            , X = F(0x1)
            , W = F(0x346)
            , j = F(0x240)
            , D = F(0x1de)
            , V = F(0x260)
            , Z = F(0x133);
          function B(v5, v6) {
              let v7, v8, v9 = v6;
              if (v6['indexOf'](W['v']['fieldLoaderIndicator']) > 0x0) {
                  const vA = v9['split'](W['v']['fieldLoaderIndicator']);
                  v9 = vA[0x0];
                  const vn = vA[0x1]['split']('?');
                  v8 = (0x0,
                  Z['vl'])(vn[0x1]),
                  v7 = (0x0,
                  T['nA'])(vn[0x0]);
              } else
                  0x0 === v6['indexOf'](W['v']['fieldLoaderIndicator']) && (v9 = v6['slice'](0x1),
                  Y['kg']['error']('loader' + v6));
              const vv = v5['properties'] && v5['properties'][v9];
              if (null != vv)
                  return v7 ? v7(vv, Object['assign'](Object['assign']({}, v8), {
                      'feature': v5,
                      'fieldName': v9
                  })) : vv;
          }
          function U(v5) {
              const v6 = (0x0,
              Z['it'])(v5);
              if ('number' == typeof v6)
                  return v7=>v6;
              if ('function' == typeof v6)
                  return v6;
              if ('object' == typeof v6 && v6['stops']) {
                  const v7 = new V['NB'](v6,v8=>(v8['stop'] = parseFloat(v8['stop']),
                  v8));
                  return v8=>v7['getRule'](v8['properties'][v7['fieldName']])['stop'];
              }
              if ('string' == typeof v6) {
                  if (v6['startsWith'](W['v']['fieldPropertiesIndicator'])) {
                      const v8 = v6['substr'](0x1);
                      return v9=>B(v9, v8);
                  }
                  {
                      const v9 = parseFloat(v6);
                      return undefined === v9 && Y['kg']['error']('' + v6 + ''),
                      vv=>v9;
                  }
              }
              Y['kg']['error']('' + typeof v6);
          }
          function q(v5) {
              const v6 = (0x0,
              Z['it'])(v5);
              if ('number' == typeof v6) {
                  const v7 = v6['toString']();
                  return v8=>v7;
              }
              if ('function' == typeof v6)
                  return v6;
              if ('object' == typeof v6 && v6['stops']) {
                  const v8 = new V['NB'](v6,v9=>(v9['stop']['toString'] && v9['stop']['toString'](),
                  v9));
                  return v9=>v8['getRule'](v9['properties'][v8['fieldName']])['stop'];
              }
              if ('string' == typeof v6) {
                  if (v6['startsWith'](W['v']['fieldPropertiesIndicator'])) {
                      let v9 = v6['substr'](0x1);
                      return vv=>B(vv, v9);
                  }
                  return vv=>v6;
              }
              Y['kg']['error']('' + typeof v6);
          }
          function J(v5) {
              const v6 = (0x0,
              Z['it'])(v5);
              if ('number' == typeof v6) {
                  const v7 = 0x0 !== v6;
                  return v8=>v7;
              }
              if ('boolean' == typeof v6)
                  return v8=>v6;
              if ('function' == typeof v6)
                  return v6;
              if ('object' == typeof v6 && v6['stops']) {
                  const v8 = new V['NB'](v6);
                  return v9=>v8['getRule'](v9['properties'][v8['fieldName']])['stop'];
              }
              if ('string' == typeof v6) {
                  if (v6['startsWith'](W['v']['fieldPropertiesIndicator'])) {
                      const v9 = v6['substr'](0x1);
                      return vv=>{
                          const vA = B(vv, v9);
                          return !!vA && ('number' == typeof vA ? 0x0 !== vA : 'string' == typeof vA ? '0' !== vA && 'false' !== vA['toLowerCase']() : false !== vA);
                      }
                      ;
                  }
                  {
                      const vv = '0' !== v6 && 'false' !== v6['toLowerCase']();
                      return vA=>vv;
                  }
              }
              Y['kg']['error']('' + typeof v6);
          }
          function C(v5) {
              const v6 = (0x0,
              Z['it'])(v5);
              if (v6 instanceof Array)
                  return v7=>v6;
              if ('function' == typeof v6)
                  return v6;
              if ('object' == typeof v6 && v6['stops']) {
                  const v7 = new V['NB'](v6);
                  return v8=>v7['getRule'](v8['properties'][v7['fieldName']])['stop'];
              }
              Y['kg']['error']('' + typeof v6);
          }
          function O(v5) {
              const v6 = (0x0,
              Z['it'])(v5);
              if ('string' == typeof v6) {
                  if (v6['startsWith'](W['v']['fieldPropertiesIndicator'])) {
                      const v7 = v6['substr'](0x1);
                      return v8=>{
                          const v9 = B(v8, v7);
                          return v9 ? 'string' == typeof v9 ? (0x0,
                          Z['$P'])(v9) : 'number' == typeof v9 ? (0x0,
                          Z['lW'])(v9) : v9 instanceof D['t'] ? v9 : v9 instanceof Array ? (0x0,
                          Z['LH'])(v9) : void Y['kg']['error']('' + v9) : new D['t']('black');
                      }
                      ;
                  }
                  {
                      const v8 = (0x0,
                      Z['$P'])(v6);
                      return v9=>v8;
                  }
              }
              if ('number' == typeof v6) {
                  const v9 = (0x0,
                  Z['lW'])(v6);
                  return vv=>v9;
              }
              if (v6 instanceof D['t'])
                  return vv=>v6;
              if (v6 instanceof Array) {
                  const vv = new D['t']({
                      'r': v6[0x0],
                      'g': v6[0x1],
                      'b': v6[0x2],
                      'a': 0x3 === v6['length'] ? 0x1 : v6[0x3]
                  });
                  return vA=>vv;
              }
              if ('function' == typeof v6)
                  return vA=>{
                      const vn = v6(vA);
                      return vn instanceof D['t'] ? vn : 'string' == typeof vn ? (0x0,
                      Z['$P'])(vn) : 'number' == typeof vn ? (0x0,
                      Z['lW'])(vn) : vn instanceof Array ? (0x0,
                      Z['LH'])(vn) : void Y['kg']['warn']('');
                  }
                  ;
              if ('object' == typeof v6 && (undefined !== v6['r'] || undefined !== v6['red'])) {
                  const vA = new D['t'](v6);
                  return vn=>vA;
              }
              if ('object' == typeof v6 && v6['stops']) {
                  const vn = new V['NB'](v6,Z['$k']);
                  return vk=>vn['getRule'](vk['properties'][vn['fieldName']])['stop'];
              }
              Y['kg']['error']('' + typeof v6);
          }
          function G(v5) {
              const v6 = (0x0,
              Z['it'])(v5);
              if ('string' == typeof v6) {
                  if (v6['startsWith'](W['v']['fieldPropertiesIndicator'])) {
                      const v7 = v6['substr'](0x1);
                      return v8=>B(v8, v7);
                  }
                  return v8=>v6;
              }
              if (v6 instanceof HTMLImageElement || v6 instanceof HTMLVideoElement || v6 instanceof HTMLCanvasElement)
                  return v8=>v6;
              if ('function' == typeof v6)
                  return v6;
              if ('object' == typeof v6 && v6['stops']) {
                  const v8 = new V['NB'](v6);
                  return v9=>v8['getRule'](v9['properties'][v8['fieldName']])['stop'];
              }
              Y['kg']['error']('' + typeof v6);
          }
          class N extends Z['Uw'] {
              ['_createCacheId'](v5) {
                  if ((0x0,
                  X['ri'])(v5))
                      return v5['id'] || (v5['id'] = (0x0,
                      X['hQ'])());
              }
          }
          class M extends N {
              constructor(v5) {
                  super(v5),
                  v5['data'] || Y['kg']['error'](''),
                  this['_update'](v5, true);
              }
              ['_update'](v5, v6) {
                  v6 ? (this['size'] = C((0x0,
                  X['En'])(v5['size'], M['DefaultOptions']['size'])),
                  this['data'] = G(v5['data']),
                  this['visible'] = J((0x0,
                  X['En'])(v5['visible'], M['DefaultOptions']['visible'])),
                  this['avoidCollison'] = J((0x0,
                  X['En'])(v5['avoidCollison'], M['DefaultOptions']['avoidCollison'])),
                  this['shadowOffset'] = C((0x0,
                  X['En'])(v5['shadowOffset'], M['DefaultOptions']['shadowOffset'])),
                  this['shadowBlur'] = U((0x0,
                  X['En'])(v5['shadowBlur'], M['DefaultOptions']['shadowBlur'])),
                  this['heightMode'] = (0x0,
                  X['En'])(v5['heightMode'], M['DefaultOptions']['heightMode']),
                  this['depthTest'] = J((0x0,
                  X['En'])(v5['depthTest'], M['DefaultOptions']['depthTest'])),
                  this['offset'] = C((0x0,
                  X['En'])(v5['offset'], M['DefaultOptions']['offset'])),
                  this['eyeOffset'] = C((0x0,
                  X['En'])(v5['eyeOffset'], M['DefaultOptions']['eyeOffset'])),
                  this['sizeInMeters'] = J((0x0,
                  X['En'])(v5['sizeInMeters'], M['DefaultOptions']['sizeInMeters']))) : (this['size'] = (0x0,
                  X['Rf'])(v5['size'], this['size'], C),
                  this['data'] = (0x0,
                  X['Rf'])(v5['data'], this['data'], G),
                  this['visible'] = (0x0,
                  X['Rf'])(v5['visible'], this['visible'], J),
                  this['avoidCollison'] = (0x0,
                  X['Rf'])(v5['avoidCollison'], this['avoidCollison'], J),
                  this['shadowOffset'] = (0x0,
                  X['Rf'])(v5['shadowOffset'], this['shadowOffset'], C),
                  this['shadowBlur'] = (0x0,
                  X['Rf'])(v5['shadowBlur'], this['shadowBlur'], U),
                  this['heightMode'] = (0x0,
                  X['Rf'])(v5['heightMode'], this['heightMode']),
                  this['depthTest'] = (0x0,
                  X['Rf'])(v5['depthTest'], this['depthTest'], J),
                  this['offset'] = (0x0,
                  X['Rf'])(v5['offset'], this['offset'], C),
                  this['eyeOffset'] = (0x0,
                  X['Rf'])(v5['eyeOffset'], this['eyeOffset'], C),
                  this['sizeInMeters'] = (0x0,
                  X['Rf'])(v5['sizeInMeters'], this['sizeInMeters'], J)),
                  this['angle'] = (0x0,
                  X['Rf'])(v5['angle'], this['angle'], U),
                  this['shadowColor'] = (0x0,
                  X['Rf'])(v5['shadowColor'], this['shadowColor'], O),
                  this['color'] = (0x0,
                  X['Rf'])(v5['color'], this['color'], O);
              }
          }
          M['DefaultOptions'] = {
              'data': undefined,
              'size': [0x20, 0x20],
              'visible': true,
              'avoidCollison': false,
              'shadowBlur': 0x5,
              'shadowOffset': [0x5, 0x5],
              'heightMode': 'none',
              'depthTest': true,
              'offset': [0x0, 0x0],
              'eyeOffset': [0x0, 0x0, 0x0],
              'sizeInMeters': false
          };
          class z extends N {
              constructor(v5) {
                  super(v5),
                  v5 && v5['data'] || Y['kg']['error']('data'),
                  this['_update'](v5, true);
              }
              ['_update'](v5, v6) {
                  v6 ? (this['data'] = q(v5['data']),
                  this['font'] = q((0x0,
                  X['En'])(v5['font'], z['DefaultOptions']['font'])),
                  this['color'] = O((0x0,
                  X['En'])(v5['color'], z['DefaultOptions']['color'])),
                  this['visible'] = J((0x0,
                  X['En'])(v5['visible'], z['DefaultOptions']['visible'])),
                  this['avoidCollison'] = J((0x0,
                  X['En'])(v5['avoidCollison'], z['DefaultOptions']['avoidCollison'])),
                  this['collisionExtendSize'] = C((0x0,
                  X['En'])(v5['collisionExtendSize'], z['DefaultOptions']['collisionExtendSize'])),
                  this['backHeight'] = U((0x0,
                  X['En'])(v5['backHeight'], z['DefaultOptions']['backHeight'])),
                  this['backPadding'] = C((0x0,
                  X['En'])(v5['backPadding'], z['DefaultOptions']['backPadding'])),
                  this['strokeWidth'] = U((0x0,
                  X['En'])(v5['strokeWidth'], z['DefaultOptions']['strokeWidth'])),
                  this['backStrokeWidth'] = U((0x0,
                  X['En'])(v5['backStrokeWidth'], z['DefaultOptions']['backStrokeWidth'])),
                  this['align'] = q((0x0,
                  X['En'])(v5['align'], z['DefaultOptions']['align'])),
                  this['baseline'] = q((0x0,
                  X['En'])(v5['baseline'], z['DefaultOptions']['baseline'])),
                  this['backShadowBlur'] = U((0x0,
                  X['En'])(v5['backShadowBlur'], z['DefaultOptions']['backShadowBlur'])),
                  this['backShadowOffset'] = C((0x0,
                  X['En'])(v5['backShadowOffset'], z['DefaultOptions']['backShadowOffset'])),
                  this['shadowOffset'] = C((0x0,
                  X['En'])(v5['shadowOffset'], z['DefaultOptions']['shadowOffset'])),
                  this['shadowBlur'] = U((0x0,
                  X['En'])(v5['shadowBlur'], z['DefaultOptions']['shadowBlur'])),
                  this['backRoundRadius'] = U((0x0,
                  X['En'])(v5['backRoundRadius'], z['DefaultOptions']['backRoundRadius'])),
                  this['heightMode'] = (0x0,
                  X['En'])(v5['heightMode'], z['DefaultOptions']['heightMode']),
                  this['forceImage'] = J((0x0,
                  X['En'])(v5['forceImage'], z['DefaultOptions']['forceImage'])),
                  this['depthTest'] = J((0x0,
                  X['En'])(v5['depthTest'], z['DefaultOptions']['depthTest'])),
                  this['eyeOffset'] = C((0x0,
                  X['En'])(v5['eyeOffset'], z['DefaultOptions']['eyeOffset']))) : (this['data'] = (0x0,
                  X['Rf'])(v5['data'], this['data'], q),
                  this['font'] = (0x0,
                  X['Rf'])(v5['font'], this['font'], q),
                  this['color'] = (0x0,
                  X['Rf'])(v5['color'], this['color'], O),
                  this['visible'] = (0x0,
                  X['Rf'])(v5['visible'], this['visible'], J),
                  this['avoidCollison'] = (0x0,
                  X['Rf'])(v5['avoidCollison'], this['avoidCollison'], J),
                  this['collisionExtendSize'] = (0x0,
                  X['Rf'])(v5['collisionExtendSize'], this['collisionExtendSize'], C),
                  this['backHeight'] = (0x0,
                  X['Rf'])(v5['backHeight'], this['backHeight'], U),
                  this['backPadding'] = (0x0,
                  X['Rf'])(v5['backPadding'], this['backPadding'], C),
                  this['strokeWidth'] = (0x0,
                  X['Rf'])(v5['strokeWidth'], this['strokeWidth'], U),
                  this['backStrokeWidth'] = (0x0,
                  X['Rf'])(v5['backStrokeWidth'], this['backStrokeWidth'], U),
                  this['align'] = (0x0,
                  X['Rf'])(v5['align'], this['align'], q),
                  this['baseline'] = (0x0,
                  X['Rf'])(v5['baseline'], this['baseline'], q),
                  this['backShadowOffset'] = (0x0,
                  X['Rf'])(v5['backShadowOffset'], this['backShadowOffset'], C),
                  this['backShadowBlur'] = (0x0,
                  X['Rf'])(v5['backShadowBlur'], this['backShadowBlur'], U),
                  this['shadowOffset'] = (0x0,
                  X['Rf'])(v5['shadowOffset'], this['shadowOffset'], C),
                  this['shadowBlur'] = (0x0,
                  X['Rf'])(v5['shadowBlur'], this['shadowBlur'], U),
                  this['backRoundRadius'] = (0x0,
                  X['Rf'])(v5['backRoundRadius'], this['backRoundRadius'], U),
                  this['heightMode'] = (0x0,
                  X['Rf'])(v5['heightMode'], this['heightMode']),
                  this['forceImage'] = (0x0,
                  X['Rf'])(v5['forceImage'], this['forceImage'], J),
                  this['depthTest'] = (0x0,
                  X['Rf'])(v5['depthTest'], this['depthTest'], J),
                  this['eyeOffset'] = (0x0,
                  X['Rf'])(v5['eyeOffset'], this['eyeOffset'], C)),
                  this['angle'] = (0x0,
                  X['Rf'])(v5['angle'], this['angle'], U),
                  this['strokeColor'] = (0x0,
                  X['Rf'])(v5['strokeColor'], this['strokeColor'], O),
                  this['backColor'] = (0x0,
                  X['Rf'])(v5['backColor'], this['backColor'], O),
                  this['backCircle'] = (0x0,
                  X['Rf'])(v5['backCircle'], this['backCircle'], J),
                  this['offset'] = (0x0,
                  X['Rf'])(v5['offset'], this['offset'], C),
                  this['backStrokeColor'] = (0x0,
                  X['Rf'])(v5['backStrokeColor'], this['backStrokeColor'], O),
                  this['backRoundRect'] = (0x0,
                  X['Rf'])(v5['backRoundRect'], this['backRoundRect'], J),
                  this['backShadowColor'] = (0x0,
                  X['Rf'])(v5['backShadowColor'], this['backShadowColor'], O),
                  this['backStrokeDashArray'] = (0x0,
                  X['Rf'])(v5['backStrokeDashArray'], this['backStrokeDashArray'], C),
                  this['shadowColor'] = (0x0,
                  X['Rf'])(v5['shadowColor'], this['shadowColor'], O),
                  this['backWidth'] = (0x0,
                  X['Rf'])(v5['backWidth'], this['backWidth'], U),
                  this['forceImageSize'] = (0x0,
                  X['Rf'])(v5['forceImageSize'], this['forceImageSize'], C);
              }
          }
          z['DefaultOptions'] = {
              'data': undefined,
              'font': '12px\x20',
              'color': 'black',
              'visible': true,
              'avoidCollison': false,
              'collisionExtendSize': [0x0, 0x0],
              'backHeight': 0xe,
              'backPadding': [0x5, 0x4],
              'strokeWidth': 0x1,
              'backStrokeWidth': 0x1,
              'align': 'center',
              'baseline': 'middle',
              'backShadowBlur': 0x6,
              'backShadowOffset': [0x3, 0x3],
              'shadowBlur': 0x6,
              'shadowOffset': [0x3, 0x3],
              'backRoundRadius': 0x6,
              'heightMode': 'none',
              'forceImage': false,
              'depthTest': true,
              'eyeOffset': [0x0, 0x0, 0x0]
          };
          class Q extends N {
              constructor(v5) {
                  super(v5),
                  v5 || Y['kg']['error'](''),
                  this['_update'](v5, true);
              }
              ['_update'](v5, v6) {
                  v5['image'] && (this['image'] && !v6 ? this['image']['update'](v5['image']) : this['image'] = new M(v5['image'])),
                  v5['text'] && (this['text'] && !v6 ? this['text']['update'](v5['text']) : this['text'] = new z(v5['text']));
              }
          }
          class L extends N {
              constructor(v5) {
                  super(v5),
                  v5 || Y['kg']['error'](''),
                  this['_update'](v5, true);
              }
              ['_update'](v5, v6) {
                  v6 ? (this['color'] = O((0x0,
                  X['En'])(v5['color'], L['DefaultOptions']['color'])),
                  this['visible'] = J((0x0,
                  X['En'])(v5['visible'], L['DefaultOptions']['visible'])),
                  this['shadowOffset'] = C((0x0,
                  X['En'])(v5['shadowOffset'], L['DefaultOptions']['shadowOffset'])),
                  this['shadowBlur'] = U((0x0,
                  X['En'])(v5['shadowBlur'], L['DefaultOptions']['shadowBlur'])),
                  this['usePositionHeight'] = J((0x0,
                  X['En'])(v5['usePositionHeight'], L['DefaultOptions']['usePositionHeight'])),
                  this['height'] = U((0x0,
                  X['En'])(v5['height'], L['DefaultOptions']['height'])),
                  this['zoomMin'] = U((0x0,
                  X['En'])(v5['zoomMin'], L['DefaultOptions']['zoomMin'])),
                  this['zoomMax'] = U((0x0,
                  X['En'])(v5['zoomMax'], L['DefaultOptions']['zoomMax'])),
                  this['heightOffset'] = U((0x0,
                  X['En'])(v5['heightOffset'], L['DefaultOptions']['heightOffset'])),
                  this['heightMin'] = U((0x0,
                  X['En'])(v5['heightMin'], L['DefaultOptions']['heightMin'])),
                  this['heightMax'] = U((0x0,
                  X['En'])(v5['heightMax'], L['DefaultOptions']['heightMax']))) : (this['color'] = (0x0,
                  X['Rf'])(v5['color'], this['color'], O),
                  this['visible'] = (0x0,
                  X['Rf'])(v5['visible'], this['visible'], J),
                  this['shadowOffset'] = (0x0,
                  X['Rf'])(v5['shadowOffset'], this['shadowOffset'], C),
                  this['shadowBlur'] = (0x0,
                  X['Rf'])(v5['shadowBlur'], this['shadowBlur'], U),
                  this['usePositionHeight'] = (0x0,
                  X['Rf'])(v5['usePositionHeight'], this['usePositionHeight'], J),
                  this['height'] = (0x0,
                  X['Rf'])(v5['height'], this['height'], U),
                  this['zoomMin'] = (0x0,
                  X['Rf'])(v5['zoomMin'], this['zoomMin'], U),
                  this['zoomMax'] = (0x0,
                  X['Rf'])(v5['zoomMax'], this['zoomMax'], U),
                  this['heightOffset'] = (0x0,
                  X['Rf'])(v5['heightOffset'], this['heightOffset'], U),
                  this['heightMin'] = (0x0,
                  X['Rf'])(v5['heightMin'], this['heightMin'], U),
                  this['heightMax'] = (0x0,
                  X['Rf'])(v5['heightMax'], this['heightMax'], U)),
                  this['shadowColor'] = (0x0,
                  X['Rf'])(v5['shadowColor'], this['shadowColor'], O);
              }
          }
          L['DefaultOptions'] = {
              'color': 'rgba(22,7,201,0.7)',
              'visible': true,
              'shadowOffset': [0xa, 0xa],
              'shadowBlur': 0xa,
              'usePositionHeight': false,
              'height': 0x0,
              'zoomMin': 0x0,
              'zoomMax': 0x64,
              'heightOffset': 0xa,
              'heightMin': 0x0,
              'heightMax': 0x1 / 0x0
          };
          class R extends L {
              constructor(v5) {
                  super(v5),
                  this['_update'](v5, true);
              }
              ['updateLabels'](v5) {
                  const v6 = [];
                  if (v5['label'] && v5['label']['length'] > 0x0) {
                      for (const v7 of v5['label'])
                          v6['push'](new Q(v7));
                  }
                  this['label'] = v6;
              }
              ['_update'](v5, v6) {
                  super['_update'](v5, v6),
                  v6 ? (this['size'] = U((0x0,
                  X['En'])(v5['size'], R['DefaultOptions']['size'])),
                  this['fill'] = J((0x0,
                  X['En'])(v5['fill'], R['DefaultOptions']['fill'])),
                  this['strokeWidth'] = U((0x0,
                  X['En'])(v5['strokeWidth'], R['DefaultOptions']['strokeWidth'])),
                  this['collisionBuffer'] = C((0x0,
                  X['En'])(v5['collisionBuffer'], R['DefaultOptions']['collisionBuffer']))) : (this['size'] = (0x0,
                  X['Rf'])(v5['size'], this['size'], U),
                  this['fill'] = (0x0,
                  X['Rf'])(v5['fill'], this['fill'], J),
                  this['strokeWidth'] = (0x0,
                  X['Rf'])(v5['strokeWidth'], this['strokeWidth'], U),
                  this['collisionBuffer'] = (0x0,
                  X['Rf'])(v5['collisionBuffer'], this['collisionBuffer'], C)),
                  this['strokeColor'] = (0x0,
                  X['Rf'])(v5['strokeColor'], this['strokeColor'], O),
                  this['strokeDashArray'] = (0x0,
                  X['Rf'])(v5['strokeDashArray'], this['strokeDashArray'], C),
                  this['avoidCollison'] = (0x0,
                  X['Rf'])(v5['avoidCollison'], this['avoidCollison'], J),
                  this['updateLabels'](v5);
              }
          }
          R['DefaultOptions'] = {
              'color': 'rgba(22,7,201,0.7)',
              'visible': true,
              'size': 0x5,
              'fill': true,
              'strokeWidth': 0x1,
              'shadowOffset': [0x5, 0x5],
              'shadowBlur': 0xa,
              'collisionBuffer': [0x0, 0x0]
          };
          class v0 extends L {
              constructor(v5) {
                  super(v5),
                  this['_update'](v5, true);
              }
              ['_update'](v5, v6) {
                  super['_update'](v5, v6),
                  v6 ? (this['width'] = U((0x0,
                  X['En'])(v5['width'], v0['DefaultOptions']['width'])),
                  this['labelDistance'] = U((0x0,
                  X['En'])(v5['labelDistance'], v0['DefaultOptions']['labelDistance'])),
                  this['labelDistance3D'] = U((0x0,
                  X['En'])(v5['labelDistance3D'], v0['DefaultOptions']['labelDistance3D'])),
                  this['labelAutoFlip'] = J((0x0,
                  X['En'])(v5['labelAutoFlip'], v0['DefaultOptions']['labelAutoFlip']))) : (this['width'] = (0x0,
                  X['Rf'])(v5['width'], this['width'], U),
                  this['labelDistance'] = (0x0,
                  X['Rf'])(v5['labelDistance'], this['labelDistance'], U),
                  this['labelDistance3D'] = (0x0,
                  X['Rf'])(v5['labelDistance3D'], this['labelDistance3D'], U),
                  this['labelAutoFlip'] = (0x0,
                  X['Rf'])(v5['labelAutoFlip'], this['labelAutoFlip'], J)),
                  this['dashArray'] = (0x0,
                  X['Rf'])(v5['dashArray'], this['dashArray'], C),
                  this['alwaysDrawFirstLabel'] = (0x0,
                  X['Rf'])(v5['alwaysDrawFirstLabel'], this['alwaysDrawFirstLabel'], J),
                  this['lineJoin'] = (0x0,
                  X['Rf'])(v5['lineJoin'], this['lineJoin'], q),
                  this['lineCap'] = (0x0,
                  X['Rf'])(v5['lineCap'], this['lineCap'], q);
                  const v7 = [];
                  if (v5['label'] && v5['label']['length'] > 0x0) {
                      for (const v8 of v5['label'])
                          v7['push'](new Q(v8));
                  }
                  this['label'] = v7;
              }
          }
          v0['DefaultOptions'] = {
              'color': 'rgba(22,7,201,0.7)',
              'visible': true,
              'width': 0x1,
              'labelDistance': 0xc8,
              'labelDistance3D': 0x186a0,
              'labelAutoFlip': true
          };
          class v1 extends L {
              constructor(v5) {
                  super(v5),
                  this['_update'](v5, true);
              }
              ['updateLabels'](v5) {
                  const v6 = [];
                  if (v5['label'] && v5['label']['length'] > 0x0) {
                      for (const v7 of v5['label'])
                          v6['push'](new Q(v7));
                  }
                  this['label'] = v6;
              }
              ['updateLineStyle'](v5) {
                  this['lineStyle'] = v5['lineStyle'] && new v0(v5['lineStyle']);
              }
              ['_update'](v5, v6) {
                  super['_update'](v5, v6),
                  this['fill'] = v6 ? J((0x0,
                  X['En'])(v5['fill'], v1['DefaultOptions']['fill'])) : (0x0,
                  X['Rf'])(v5['fill'], this['fill'], J),
                  this['fillImage'] = (0x0,
                  X['Rf'])(v5['fillImage'], this['fillImage'], G),
                  this['updateLineStyle'](v5),
                  this['updateLabels'](v5);
              }
          }
          v1['DefaultOptions'] = {
              'color': 'rgba(22,7,201,0.7)',
              'visible': true,
              'fill': true
          };
          class v2 extends N {
              constructor(v5) {
                  super(v5),
                  this['styleName'] = 'featureStyle',
                  this['_update'](v5, true);
              }
              ['_update'](v5, v6) {
                  v5 && (v5['point'] && (this['point'] && !v6 ? this['point']['update'](v5['point']) : this['point'] = new R(v5['point'])),
                  v5['polyline'] && (this['polyline'] && !v6 ? this['polyline']['update'](v5['polyline']) : this['polyline'] = new v0(v5['polyline'])),
                  v5['polygon'] && (this['polygon'] && !v6 ? this['polygon']['update'](v5['polygon']) : this['polygon'] = new v1(v5['polygon'])),
                  this['globalOpacity'] = v6 ? U((0x0,
                  X['En'])(v5['globalOpacity'], v2['DefaultOptions']['globalOpacity'])) : (0x0,
                  X['Rf'])(v5['globalOpacity'], this['globalOpacity'], U));
              }
          }
          function v3(v5) {
              const v6 = (0x0,
              Z['it'])(v5);
              if (v6 instanceof Array)
                  return ()=>v6;
              if ('function' == typeof v6)
                  return v6;
              if ('object' == typeof v6 && v6['stops']) {
                  const v7 = new V['NB'](v6);
                  return ()=>v7['getVals']();
              }
              if ('string' == typeof v5)
                  return ()=>v5['split'](',')['map'](v8=>parseFloat(v8));
              Y['kg']['error']('' + typeof v6);
          }
          v2['DefaultOptions'] = {
              'globalOpacity': 0x1
          };
          class v4 extends v2 {
              constructor(v5) {
                  v5['analysisValues'] ? super(v5) : Y['kg']['error']('analysisValues', true);
              }
              ['_update'](v5, v6) {
                  v6 ? (this['analysisValues'] = v3(v5['analysisValues']),
                  this['withShaded'] = (0x0,
                  X['En'])(v5['withShaded'], v4['DefaultOptions']['withShaded'])) : (this['analysisValues'] = (0x0,
                  X['Rf'])(v5['analysisValues'], this['analysisValues'], v3),
                  this['withShaded'] = (0x0,
                  X['Rf'])(v5['withShaded'], this['withShaded'])),
                  this['interpField'] = (0x0,
                  X['Rf'])(v5['interpField'], this['interpField']),
                  this['interpGridOptions'] = (0x0,
                  X['Rf'])(v5['interpGridOptions'], this['interpGridOptions']),
                  this['interpGridOptions'] && (0x0,
                  j['T'])(this['interpGridOptions']),
                  this['undef'] = (0x0,
                  X['Rf'])(v5['undef'], this['undef']),
                  super['_update'](v5, v6);
              }
          }
          v4['DefaultOptions'] = Object['assign'](Object['assign']({}, v2['DefaultOptions']), {
              'withShaded': true,
              'analysisValues': undefined
          });
      }
      ,
      0x240: (l,K,b)=>{
          'use strict';
          b['d'](K, {
              'T': ()=>H,
              'Z': ()=>p
          });
          var c = b(0x1);
          function H(F) {
              let y = {
                  'start': F['xStart'],
                  'end': F['xEnd'],
                  'delta': F['xDelta'],
                  'size': F['xSize']
              };
              x(y),
              F['xStart'] = y['start'],
              F['xEnd'] = y['end'],
              F['xDelta'] = y['delta'],
              F['xSize'] = y['size'];
              let w = {
                  'start': F['yStart'],
                  'end': F['yEnd'],
                  'delta': F['yDelta'],
                  'size': F['ySize']
              };
              x(w),
              F['yStart'] = w['start'],
              F['yEnd'] = w['end'],
              F['yDelta'] = w['delta'],
              F['ySize'] = w['size'],
              F['zValues'] || (F['zValues'] = [0x0]),
              F['tCount'] = (0x0,
              c['En'])(F['tCount'], 0x1);
          }
          function x(F) {
              let y = new Error('--from\x20ensureOneDim');
              if (undefined !== F['start']) {
                  if (undefined === F['end']) {
                      if (undefined === F['start'] || !F['delta'] || !F['size'])
                          throw y;
                      F['end'] = F['start'] + F['delta'] * (F['size'] - 0x1);
                  }
                  if (!F['size']) {
                      if (undefined === F['start'] || undefined === F['end'] || !F['delta'])
                          throw y;
                      F['size'] = Math['floor']((F['end'] - F['start']) / F['delta']) + 0x1;
                  }
                  if (!F['delta']) {
                      if (undefined === F['start'] || undefined === F['end'] || !F['size'])
                          throw y;
                      F['delta'] = (F['end'] - F['start']) / (F['size'] - 0x1);
                  }
              } else {
                  if (!F['delta'] || undefined === F['end'] || !F['size'])
                      throw y;
                  F['start'] = F['end'] - F['delta'] * (F['size'] - 0x1);
              }
          }
          function p(F, y=0x6) {
              var w, h;
              return {
                  'minLat': parseFloat(Math['min'](F['yStart'], F['yEnd'])['toFixed'](y)),
                  'maxLat': parseFloat(Math['max'](F['yStart'], F['yEnd'])['toFixed'](y)),
                  'minLon': parseFloat(Math['min'](F['xStart'], F['xEnd'])['toFixed'](y)),
                  'maxLon': parseFloat(Math['max'](F['xStart'], F['xEnd'])['toFixed'](y)),
                  'minHeight': (null === (w = F['zValues']) || undefined === w ? undefined : w['length']) > 0x0 ? Math['min'](F['zValues'][0x0], F['zValues'][F['zValues']['length'] - 0x1]) : 0x0,
                  'maxHeight': (null === (h = F['zValues']) || undefined === h ? undefined : h['length']) > 0x0 ? Math['max'](F['zValues'][0x0], F['zValues'][F['zValues']['length'] - 0x1]) : 0x0
              };
          }
      }
      ,
      0x338: (K,b,c)=>{
          'use strict';
          c['d'](b, {
              'K': ()=>h,
              'P': ()=>w
          });
          var H = c(0x39b)
            , x = c(0x95)
            , p = c(0x1)
            , F = c(0x60);
          const y = ((0x0,
          x['Tz'])(),
          Y=>new ArrayBuffer(Y));
          class w {
              get['raw']() {
                  return this['_raw'];
              }
              set['raw'](Y) {
                  this['_raw'] = Y;
              }
              get['maxMin']() {
                  return this['_maxMin'] || (this['_maxMin'] = (0x0,
                  p['pj'])(this)),
                  this['_maxMin'];
              }
              constructor(Y, T, X, E, f, W=0x0, I=0x1, j=0x0, D=true) {
                  this['dataType'] = Y,
                  this['xSize'] = T,
                  this['ySize'] = X,
                  this['algo'] = W,
                  this['dataScale'] = I,
                  this['dataOffset'] = j,
                  this['_useAccurateUndef'] = true,
                  this['setTypeLen'](),
                  E ? this['setRaw'](E) : D && this['setRaw'](T * X),
                  this['undef'] = f,
                  this['setReadAndWriteFunc']();
              }
              ['setReadAndWriteFunc']() {
                  switch (this['algo']) {
                  case undefined:
                  case null:
                  case 0x0:
                      this['readFunc'] = Y=>Y,
                      this['writeFunc'] = Y=>Y;
                      break;
                  case 0x1:
                      this['readFunc'] = Y=>Y * this['dataScale'] + this['dataOffset'],
                      this['writeFunc'] = Y=>(Y - this['dataOffset']) / this['dataScale'];
                      break;
                  case 0x2:
                      this['readFunc'] = Y=>(Y + this['dataOffset']) * this['dataScale'],
                      this['writeFunc'] = Y=>Y / this['dataScale'] - this['dataOffset'];
                      break;
                  default:
                      throw new Error('');
                  }
              }
              get['undef']() {
                  return this['_undef'];
              }
              get['useAccurateUndef']() {
                  return this['_useAccurateUndef'];
              }
              set['useAccurateUndef'](Y) {
                  this['_useAccurateUndef'] !== Y && (this['_useAccurateUndef'] = Y,
                  this['setUndefFunc'](this['_undef']));
              }
              set['undef'](Y) {
                  this['_undef'] = Y,
                  this['setUndefFunc'](Y);
              }
              ['getBuffer']() {
                  return this['raw']['buffer'];
              }
              ['setUndefFunc'](Y) {
                  this['useAccurateUndef'] ? this['isUndef'] = T=>T === Y : this['isUndef'] = undefined === Y ? ()=>false : Y > 0x0 ? T=>T >= Y : T=>T <= Y;
              }
              ['setRaw'](Y) {
                  const T = this['xSize'] * this['ySize'];
                  if (Y instanceof ArrayBuffer) {
                      let X;
                      const E = y(T * this['typeLen']);
                      switch (this['dataType']) {
                      case F['U']['UInt8']:
                          X = new Uint8Array(Y),
                          this['raw'] = new Uint8Array(E);
                          break;
                      case F['U']['Int8']:
                          X = new Int8Array(Y),
                          this['raw'] = new Int8Array(E);
                          break;
                      case F['U']['UInt16']:
                          X = new Uint16Array(Y),
                          this['raw'] = new Uint16Array(E);
                          break;
                      case F['U']['Int16']:
                          this['raw'] = new Int16Array(E),
                          X = new Int16Array(Y);
                          break;
                      case F['U']['UInt32']:
                          X = new Uint32Array(Y),
                          this['raw'] = new Uint32Array(E);
                          break;
                      case F['U']['Int32']:
                          X = new Int32Array(Y),
                          this['raw'] = new Int32Array(E);
                          break;
                      case F['U']['Float32']:
                          X = new Float32Array(Y),
                          this['raw'] = new Float32Array(E);
                          break;
                      case F['U']['Float64']:
                          X = new Float64Array(Y),
                          this['raw'] = new Float64Array(E);
                          break;
                      default:
                          throw new Error('not\x20supported\x20grid\x20data\x20type\x20' + this['dataType']);
                      }
                      this['raw']['set'](X),
                      X = undefined;
                  } else {
                      const f = y(T * this['typeLen']);
                      this['raw'] = (0x0,
                      p['cM'])(this['dataType'], f),
                      Y && Y['length'] && (Y[0x0]instanceof Array && (Y = (0x0,
                      p['LG'])(Y)),
                      this['raw']['set'](Y));
                  }
              }
              ['setTypeLen']() {
                  switch (this['dataType']) {
                  case F['U']['UInt8']:
                  case F['U']['Int8']:
                      this['typeLen'] = 0x1;
                      break;
                  case F['U']['UInt16']:
                  case F['U']['Int16']:
                      this['typeLen'] = 0x2;
                      break;
                  case F['U']['Float64']:
                      this['typeLen'] = 0x8;
                      break;
                  default:
                      this['typeLen'] = 0x4;
                  }
              }
              ['write1D'](Y, T) {
                  return this['isUndef'](T) || (T = this['writeFunc'](T)),
                  this['raw'][Y] = T,
                  this;
              }
              ['read1D'](Y) {
                  let T = this['raw'][Y];
                  return this['isUndef'](T) ? T : this['readFunc'](T);
              }
              ['write2D'](Y, T, X) {
                  let E = this['getPos'](Y, T);
                  return this['write1D'](E, X);
              }
              ['read2D'](Y, T) {
                  let X = this['getPos'](Y, T);
                  return this['read1D'](X);
              }
              ['toNumberArr'](Y=false) {
                  let T = [];
                  return Y ? this['forEachYx']((X,E,f)=>{
                      let W = (this['ySize'] - E - 0x1) * this['xSize'] + f;
                      T[W] = X;
                  }
                  ) : this['forEachRealValue'](X=>{
                      T['push'](X);
                  }
                  ),
                  T;
              }
              ['forEach'](Y) {
                  for (let T = 0x0; T < this['raw']['length']; T++)
                      Y(this['raw'][T], T, this['raw']);
              }
              ['forEachRealValue'](Y) {
                  for (let T = 0x0; T < this['raw']['length']; T++)
                      Y(this['read1D'](T), T, this['raw']);
              }
              ['forEachYx'](Y) {
                  for (let T = 0x0; T < this['ySize']; T++)
                      for (let X = 0x0; X < this['xSize']; X++)
                          Y(this['read2D'](T, X), T, X);
              }
              ['getYxArr']() {
                  let Y = [];
                  for (let T = 0x0; T < this['ySize']; T++) {
                      Y[T] = [];
                      for (let X = 0x0; X < this['xSize']; X++)
                          Y[T][X] = this['read2D'](T, X);
                  }
                  return Y;
              }
              ['update'](Y) {
                  Y instanceof Array && Y[0x0]instanceof Array && (Y = (0x0,
                  p['LG'])(Y)),
                  this['setRaw'](Y);
              }
              ['getPos'](Y, T) {
                  return Y * this['xSize'] + T;
              }
              ['flipY'](Y=true) {
                  let T = this['raw'];
                  const X = this['raw'];
                  if (Y) {
                      const f = y(this['ySize'] * this['xSize'] * this['typeLen']);
                      T = (0x0,
                      p['cM'])(this['dataType'], f);
                  } else
                      this['setRaw'](undefined),
                      T = this['raw'];
                  let E = 0x0;
                  for (let W = 0x0; W < this['ySize']; W++) {
                      const I = (this['ySize'] - W - 0x1) * this['xSize'];
                      T['set'](X['slice'](I, I + this['xSize']), E),
                      E += this['xSize'];
                  }
                  return T;
              }
              ['updateMaxMin'](Y=false) {
                  return this['_maxMin'] && !Y ? this['_maxMin'] : (this['_maxMin'] = undefined,
                  this['maxMin']);
              }
          }
          class h extends w {
              constructor(Y, T, X, E, f=false, W=0x0, I=0x1, j=0x0, D=F['U']['UInt8']) {
                  super(D, Y, T, undefined, E, W, I, j, false),
                  this['xSize'] = Y,
                  this['ySize'] = T,
                  this['autoLoad'] = f,
                  this['algo'] = W,
                  this['dataScale'] = I,
                  this['dataOffset'] = j,
                  this['dataType'] = D,
                  this['_decoded'] = false,
                  this['imageSource'] = X;
              }
              get['raw']() {
                  return this['_decoded'] || (this['autoLoad'] ? this['loadImageSource']() : H['kg']['error']('')),
                  this['_raw'];
              }
              ['loadImageSource']() {
                  if (this['_decoded'])
                      return;
                  const Y = performance['now']()
                    , T = this['imageSource']
                    , X = document['createElement']('canvas');
                  let E, f;
                  X['width'] = this['xSize'],
                  X['height'] = this['ySize'],
                  T instanceof HTMLVideoElement ? (E = T['videoWidth'],
                  f = T['videoHeight']) : (E = T['width'],
                  f = T['height']),
                  this['xSize'] !== E && console['warn']('xSizegrid\x20x\x20' + this['xSize'] + ',img\x20width\x20' + E),
                  this['ySize'] !== f && console['warn']('ySizegrid\x20y\x20' + this['ySize'] + ',img\x20height\x20' + f);
                  const W = X['getContext']('2d');
                  W['drawImage'](T, 0x0, 0x0, E, f, 0x0, 0x0, this['xSize'], this['ySize']);
                  const I = W['getImageData'](0x0, 0x0, X['width'], X['height'])['data'];
                  let j;
                  if (this['dataType'] === F['U']['UInt8']) {
                      j = new Uint8Array(X['width'] * X['height']);
                      let D = 0x0;
                      for (let V = 0x0; V < I['length']; V += 0x4)
                          j[D] = I[V],
                          D++;
                  } else {
                      if (this['dataType'] === F['U']['Float32'])
                          j = new Float32Array(I['buffer']);
                      else {
                          if (this['dataType'] === F['U']['UInt16']) {
                              let Z = 0x0;
                              j = new Uint16Array(X['width'] * X['height']);
                              for (let B = 0x0; B < I['length']; B += 0x4)
                                  j[Z++] = 0xff * I[B] + I[B + 0x1];
                          } else
                              H['kg']['error']('');
                      }
                  }
                  return this['_raw'] = j,
                  this['_decoded'] = true,
                  h['ReplaceImageAfterDecode'] && (this['imageSource'] = X),
                  H['kg']['debug']('decode\x20grid\x20data\x20costs\x20' + (performance['now']() - Y) + 'ms'),
                  X;
              }
          }
          h['ReplaceImageAfterDecode'] = false;
      }
      ,
      0x35a: (K,H,F)=>{
          'use strict';
          F['d'](H, {
              '$n': ()=>G,
              'IW': ()=>v6,
              'Lh': ()=>T,
              'Rd': ()=>v2,
              'S2': ()=>v8,
              'SR': ()=>v4,
              'Xm': ()=>N,
              'Yv': ()=>v7,
              '_E': ()=>v1,
              'ce': ()=>v3,
              'hM': ()=>z,
              'lj': ()=>v0,
              'm3': ()=>J,
              'm_': ()=>Q,
              'sC': ()=>L,
              'sW': ()=>Y,
              'uI': ()=>M,
              'vS': ()=>X,
              'we': ()=>v5
          });
          var Y, T, X, W = F(0x39b), j = F(0x1), D = F(0x19d), V = F(0x219), Z = F(0x1de), B = F(0x260), U = F(0x133);
          function q(v9) {
              return new B['NB']({
                  'stops': [{
                      'value': 0x0,
                      'stop': v9
                  }],
                  'fieldName': '0'
              });
          }
          function J(v9) {
              let vv = (0x0,
              U['it'])(v9);
              return 'string' == typeof vv && (vv = parseFloat(vv),
              undefined === vv && W['kg']['error']('' + vv + '')),
              'number' == typeof vv ? q(vv) : vv instanceof B['NB'] ? vv : 'object' == typeof vv && vv['stops'] ? new B['NB'](vv,vA=>(vA['stop'] = parseFloat(vA['stop']),
              vA)) : void W['kg']['error']('' + typeof vv);
          }
          class G extends V['W6'] {
              ['_createCacheId'](v9) {
                  return '0';
              }
          }
          class N extends G {
              constructor(v9) {
                  super(v9),
                  (0x0,
                  j['ri'])(v9['colorScale']) || W['kg']['error']('BitmapColorScalecolorScale'),
                  this['_update'](v9, true);
              }
              ['_update'](v9, vv) {
                  this['min'] = (0x0,
                  j['Rf'])(v9['min'], this['min']),
                  this['max'] = (0x0,
                  j['Rf'])(v9['max'], this['max']),
                  this['colorScale'] = (0x0,
                  j['Rf'])(v9['colorScale'], this['colorScale'], v2);
              }
              static['createColorScale'](v9, vv, vA, vn, vk=0x1) {
                  const vl = document['createElement']('canvas');
                  if (vl['width'] = v9,
                  vl['height'] = vk || 0x1,
                  !vn) {
                      vn = [];
                      const vi = 0x1 / vA['length'];
                      vi >= 0x1 && W['kg']['error'](''),
                      vA['forEach']((vb,ve)=>{
                          vn['push'](vi * (ve + 0x1));
                      }
                      );
                  }
                  const vK = vl['getContext']('2d');
                  if (vv) {
                      const vb = vK['createLinearGradient'](0x0, 0x0, v9, 0x0);
                      for (let ve = 0x0; ve < vA['length']; ve++) {
                          const vc = M(vA[ve])
                            , vH = vn[ve];
                          vb['addColorStop'](vH, vc['rgbaString']());
                      }
                      vK['fillStyle'] = vb,
                      vK['fillRect'](0x0, 0x0, v9, vk);
                  } else {
                      let vt = 0x0;
                      for (let vx = 0x0; vx < vA['length']; vx++) {
                          const vp = M(vA[vx])
                            , vF = vn[vx];
                          vK['fillStyle'] = vp['rgbaString']();
                          let vy = parseInt((vF * v9)['toFixed'](0x1));
                          0x0 === vy && (vy = 0x1),
                          vK['fillRect'](vt, 0x0, vy - vt, vk),
                          vt = vy;
                      }
                  }
                  return vl;
              }
              static['create'](v9, vv, vA, vn, vk, vl, vK=0x1) {
                  return new N({
                      'min': v9,
                      'max': vv,
                      'colorScale': N['createColorScale'](vA, vn, vk, vl, vK)
                  });
              }
              static['createFromStopRules'](v9, vv, vA, vn, vk, vl=0x1) {
                  vk <= 0x0 && (vk = v9['stops']['length'] + vk - 0x1);
                  const vK = v9['stops'][vn]['value']
                    , vi = v9['stops'][vk]['value']
                    , vb = vi - vK
                    , ve = []
                    , vc = [];
                  for (let vH = vn; vH <= vk; vH++) {
                      const vt = v9['stops'][vH]
                        , vx = vt['stop']
                        , vp = (vt['value'] - vK) / vb;
                      ve['push'](vx),
                      vc['push'](vp);
                  }
                  return N['create'](vK, vi, vv, vA, ve, vc, vl);
              }
              static['copyFromStopRules'](v9, vv, vA, vn, vk, vl, vK, vi, vb, ve=0x1) {
                  vK <= 0x0 && (vK = v9['stops']['length'] + vK - 0x1);
                  const vc = vi ? vA - vv : vK - vl
                    , vH = []
                    , vt = [];
                  for (let vx = vl; vx <= vK; vx++) {
                      const vp = v9['stops'][vx]
                        , vF = vp['stop']
                        , vy = vi ? (vp['value'] - vv) / vc : vx / vc;
                      vH['push'](vF),
                      vt['push'](vy);
                  }
                  return N['create'](vv, vA, vn, vk, vH, vb || vt, ve);
              }
          }
          function M(v9) {
              const vv = (0x0,
              U['it'])(v9);
              return 'string' == typeof vv ? (0x0,
              U['$P'])(vv) : 'number' == typeof vv ? (0x0,
              U['lW'])(vv) : vv instanceof Z['t'] ? vv : vv instanceof Array ? (0x0,
              U['LH'])(vv) : 'object' != typeof vv || undefined === vv['r'] && undefined === vv['red'] ? void W['kg']['error']('' + typeof vv) : new Z['t'](vv);
          }
          function z(v9) {
              const vv = M(v9);
              return null == vv ? undefined : vv['glNumberArray']();
          }
          function Q(v9) {
              const vv = (0x0,
              U['it'])(v9);
              return 'string' == typeof vv ? q((0x0,
              U['$P'])(vv)) : 'number' == typeof vv ? q((0x0,
              U['lW'])(vv)) : vv instanceof Z['t'] ? q(vv) : vv instanceof Array ? q((0x0,
              U['LH'])(vv)) : 'object' != typeof vv || undefined === vv['r'] && undefined === vv['red'] ? v9 instanceof B['NB'] ? v9 : 'object' == typeof vv && vv['stops'] ? new B['NB'](vv,U['$k']) : void W['kg']['error']('' + typeof vv) : q(new Z['t'](vv));
          }
          function L(v9) {
              const vv = (0x0,
              U['it'])(v9);
              return vv instanceof N ? vv : vv['colorScale'] ? new N(vv) : void W['kg']['error']('GL');
          }
          function R(v9) {
              if ('number' == typeof v9)
                  return v9 > 0x4 && W['kg']['error']('' + v9),
                  v9;
              if ('string' == typeof v9) {
                  switch (v9['toLowerCase']()) {
                  case 'shaded1':
                      return Y['shaded1'];
                  case 'pixel2':
                      return Y['pixel2'];
                  case 'bitmap':
                      return Y['bitmap'];
                  case 'none':
                      return Y['none'];
                  case 'shaded2':
                      return Y['shaded2'];
                  }
                  return Y['pixel1'];
              }
              W['kg']['error']('' + v9);
          }
          !function(v9) {
              v9[v9['none'] = -0x1] = 'none',
              v9[v9['bitmap'] = 0x0] = 'bitmap',
              v9[v9['pixel1'] = 0x1] = 'pixel1',
              v9[v9['pixel2'] = 0x2] = 'pixel2',
              v9[v9['shaded1'] = 0x4] = 'shaded1',
              v9[v9['shaded2'] = 0x3] = 'shaded2';
          }(Y || (Y = {}));
          class v0 extends G {
              constructor(v9) {
                  super(v9),
                  v9['fillColor'] || v9['colorScale'] || W['kg']['error']('fillColorcolorScale'),
                  this['_update'](v9, true);
              }
              ['getPlaneOptions'](v9, vv) {
                  return super['getPlaneOptions'](v9, false);
              }
              ['_update'](v9, vv) {
                  vv ? (this['pixelRatio'] = (0x0,
                  j['En'])(v9['pixelRatio'], v0['DefaultOptions']['pixelRatio']),
                  this['fillMode'] = R((0x0,
                  j['En'])(v9['fillMode'], v0['DefaultOptions']['fillMode'])),
                  this['lineWidth'] = (0x0,
                  j['En'])(v9['lineWidth'], v0['DefaultOptions']['lineWidth']),
                  this['fillModeForLine'] = R((0x0,
                  j['En'])(v9['fillModeForLine'], v1['DefaultOptions']['fillModeForLine'])),
                  this['globalOpacity'] = (0x0,
                  j['En'])(v9['globalOpacity'], v0['DefaultOptions']['globalOpacity']),
                  this['optimizedInterp'] = (0x0,
                  j['En'])(v9['optimizedInterp'], v0['DefaultOptions']['optimizedInterp'])) : (this['pixelRatio'] = (0x0,
                  j['Rf'])(v9['pixelRatio'], this['pixelRatio']),
                  this['fillMode'] = (0x0,
                  j['Rf'])(v9['fillMode'], this['fillMode'], R),
                  this['lineWidth'] = (0x0,
                  j['Rf'])(v9['lineWidth'], this['lineWidth']),
                  this['fillModeForLine'] = (0x0,
                  j['Rf'])(v9['fillModeForLine'], this['fillModeForLine'], R),
                  this['globalOpacity'] = (0x0,
                  j['Rf'])(v9['globalOpacity'], this['globalOpacity']),
                  this['optimizedInterp'] = (0x0,
                  j['Rf'])(v9['optimizedInterp'], this['optimizedInterp'])),
                  this['fillColor'] = (0x0,
                  j['Rf'])(v9['fillColor'], this['fillColor'], Q),
                  this['lineColor'] = (0x0,
                  j['Rf'])(v9['lineColor'], this['lineColor'], z),
                  this['showLine'] = (0x0,
                  j['Rf'])(v9['showLine'], this['showLine']),
                  this['colorScale'] = (0x0,
                  j['Rf'])(v9['colorScale'], this['colorScale'], L),
                  this['showRelief'] = (0x0,
                  j['Rf'])(v9['showRelief'], this['showRelief']),
                  v9['maskLineStyle'] && (this['maskLineStyle'] && !vv ? this['maskLineStyle']['update'](v9['maskLineStyle']) : this['maskLineStyle'] = new D['Xx'](v9['maskLineStyle']));
              }
          }
          v0['DefaultOptions'] = {
              'pixelRatio': 0.3,
              'fillMode': Y['pixel1'],
              'lineWidth': 1.5,
              'fillColor': undefined,
              'fillModeForLine': Y['shaded1'],
              'globalOpacity': 0x1,
              'optimizedInterp': true
          };
          class v1 extends v0 {
              constructor(v9) {
                  super(v9);
              }
              ['_update'](v9, vv) {
                  super['_update'](v9, vv),
                  vv ? (this['flat'] = (0x0,
                  j['En'])(v9['flat'], v1['DefaultOptions']['flat']),
                  this['diffuse'] = M((0x0,
                  j['En'])(v9['diffuse'], v1['DefaultOptions']['diffuse'])),
                  this['emission'] = M((0x0,
                  j['En'])(v9['emission'], v1['DefaultOptions']['emission'])),
                  this['specular'] = (0x0,
                  j['En'])(v9['specular'], v1['DefaultOptions']['specular']),
                  this['shininess'] = (0x0,
                  j['En'])(v9['shininess'], v1['DefaultOptions']['shininess']),
                  this['extrudeScale'] = (0x0,
                  j['En'])(v9['extrudeScale'], v1['DefaultOptions']['extrudeScale']),
                  this['extrudeOffset'] = (0x0,
                  j['En'])(v9['extrudeOffset'], v1['DefaultOptions']['extrudeOffset']),
                  this['zScale'] = (0x0,
                  j['En'])(v9['zScale'], v1['DefaultOptions']['zScale']),
                  this['noHeight'] = (0x0,
                  j['En'])(v9['noHeight'], v1['DefaultOptions']['noHeight']),
                  this['depthTest'] = (0x0,
                  j['En'])(v9['depthTest'], v1['DefaultOptions']['depthTest']),
                  this['opaque'] = (0x0,
                  j['En'])(v9['opaque'], v1['DefaultOptions']['opaque']),
                  this['height'] = (0x0,
                  j['En'])(v9['height'], v1['DefaultOptions']['height']),
                  this['discardColor'] = z((0x0,
                  j['En'])(v9['discardColor'], v1['DefaultOptions']['discardColor']))) : (this['flat'] = (0x0,
                  j['Rf'])(v9['flat'], this['flat']),
                  this['diffuse'] = (0x0,
                  j['Rf'])(v9['diffuse'], this['diffuse'], M),
                  this['emission'] = (0x0,
                  j['Rf'])(v9['emission'], this['emission'], M),
                  this['specular'] = (0x0,
                  j['Rf'])(v9['specular'], this['specular']),
                  this['shininess'] = (0x0,
                  j['Rf'])(v9['shininess'], this['shininess']),
                  this['extrudeScale'] = (0x0,
                  j['Rf'])(v9['extrudeScale'], this['extrudeScale']),
                  this['extrudeOffset'] = (0x0,
                  j['Rf'])(v9['extrudeOffset'], this['extrudeOffset']),
                  this['zScale'] = (0x0,
                  j['Rf'])(v9['zScale'], this['zScale']),
                  this['noHeight'] = (0x0,
                  j['Rf'])(v9['noHeight'], this['noHeight']),
                  this['depthTest'] = (0x0,
                  j['Rf'])(v9['depthTest'], this['depthTest']),
                  this['opaque'] = (0x0,
                  j['Rf'])(v9['opaque'], this['opaque']),
                  this['height'] = (0x0,
                  j['Rf'])(v9['height'], this['height']),
                  this['discardColor'] = (0x0,
                  j['Rf'])(v9['discardColor'], this['discardColor'], z));
              }
          }
          function v2(v9) {
              if ('string' == typeof v9 && !v9['length'] || !(0x0,
              j['ri'])(v9))
                  return;
              const vv = (0x0,
              U['it'])(v9);
              if (vv instanceof HTMLImageElement || vv instanceof HTMLVideoElement || vv instanceof HTMLCanvasElement)
                  return vv;
              W['kg']['error']('' + typeof vv);
          }
          function v3(v9) {
              const vv = (0x0,
              U['it'])(v9);
              return vv instanceof Array ? vv : 'number' == typeof vv || 'string' == typeof vv ? [vv] : void W['kg']['error']('' + typeof vv);
          }
          v1['DefaultOptions'] = Object['assign'](Object['assign']({}, v0['DefaultOptions']), {
              'extrudeScale': 0x1,
              'extrudeOffset': 0x0,
              'zScale': 0x1,
              'noHeight': false,
              'depthTest': true,
              'opaque': false,
              'height': 0x0,
              'discardColor': [0xff, 0xff, 0xff, 0x0],
              'flat': true,
              'diffuse': [0x0, 0x0, 0x0],
              'emission': [0x0, 0x0, 0x0],
              'specular': 0.2,
              'shininess': 0x5
          }),
          function(v9) {
              v9[v9['none'] = 0x0] = 'none',
              v9[v9['fast'] = 0x1] = 'fast',
              v9[v9['smooth'] = 0x2] = 'smooth';
          }(T || (T = {}));
          class v4 extends G {
              constructor(v9) {
                  super(v9),
                  this['_update'](v9, true);
              }
              ['_update'](v9, vv) {
                  vv ? (this['color'] = Q((0x0,
                  j['En'])(v9['color'], v4['DefaultOptions']['color'])),
                  this['dropRate'] = (0x0,
                  j['En'])(v9['dropRate'], v4['DefaultOptions']['dropRate']),
                  this['fadeRate'] = (0x0,
                  j['En'])(v9['fadeRate'], v4['DefaultOptions']['fadeRate']),
                  this['speedFactor'] = (0x0,
                  j['En'])(v9['speedFactor'], v4['DefaultOptions']['speedFactor']),
                  this['usePoint'] = (0x0,
                  j['En'])(v9['usePoint'], v4['DefaultOptions']['usePoint']),
                  this['minOpacity'] = (0x0,
                  j['En'])(v9['minOpacity'], v4['DefaultOptions']['minOpacity']),
                  this['pointSize'] = (0x0,
                  j['En'])(v9['pointSize'], v4['DefaultOptions']['pointSize']),
                  this['minSpeed'] = (0x0,
                  j['En'])(v9['minSpeed'], v4['DefaultOptions']['minSpeed']),
                  this['fadeSpeedMax'] = (0x0,
                  j['En'])(v9['fadeSpeedMax'], v4['DefaultOptions']['fadeSpeedMax']),
                  this['speedFitZoom'] = (0x0,
                  j['En'])(v9['speedFitZoom'], v4['DefaultOptions']['speedFitZoom']),
                  this['countFitZoom'] = (0x0,
                  j['En'])(v9['countFitZoom'], v4['DefaultOptions']['countFitZoom']),
                  this['interpMethod'] = (0x0,
                  j['En'])(v9['interpMethod'], v4['DefaultOptions']['interpMethod']),
                  this['interpSmoothFactor'] = (0x0,
                  j['En'])(v9['interpSmoothFactor'], v4['DefaultOptions']['interpSmoothFactor']),
                  this['pointDropPosY'] = (0x0,
                  j['En'])(v9['pointDropPosY'], v4['DefaultOptions']['pointDropPosY']),
                  this['count'] = (0x0,
                  j['En'])(v9['count'], v4['DefaultOptions']['count']),
                  this['lineMaxDistance'] = (0x0,
                  j['En'])(v9['lineMaxDistance'], v4['DefaultOptions']['lineMaxDistance']),
                  this['showPixel'] = (0x0,
                  j['En'])(v9['showPixel'], v4['DefaultOptions']['showPixel']),
                  this['pixelOptions'] = (0x0,
                  j['En'])(v9['pixelOptions'], v4['DefaultOptions']['pixelOptions'])) : (this['color'] = (0x0,
                  j['Rf'])(v9['color'], this['color'], Q),
                  this['dropRate'] = (0x0,
                  j['Rf'])(v9['dropRate'], this['dropRate']),
                  this['fadeRate'] = (0x0,
                  j['Rf'])(v9['fadeRate'], this['fadeRate']),
                  this['speedFactor'] = (0x0,
                  j['Rf'])(v9['speedFactor'], this['speedFactor']),
                  this['usePoint'] = (0x0,
                  j['Rf'])(v9['usePoint'], this['usePoint']),
                  this['minOpacity'] = (0x0,
                  j['Rf'])(v9['minOpacity'], this['minOpacity']),
                  this['pointSize'] = (0x0,
                  j['Rf'])(v9['pointSize'], this['pointSize']),
                  this['minSpeed'] = (0x0,
                  j['Rf'])(v9['minSpeed'], this['minSpeed']),
                  this['fadeSpeedMax'] = (0x0,
                  j['Rf'])(v9['fadeSpeedMax'], this['fadeSpeedMax']),
                  this['speedFitZoom'] = (0x0,
                  j['Rf'])(v9['speedFitZoom'], this['speedFitZoom']),
                  this['countFitZoom'] = (0x0,
                  j['Rf'])(v9['countFitZoom'], this['countFitZoom']),
                  this['interpMethod'] = (0x0,
                  j['Rf'])(v9['interpMethod'], this['interpMethod']),
                  this['interpSmoothFactor'] = (0x0,
                  j['Rf'])(v9['interpSmoothFactor'], this['interpSmoothFactor']),
                  this['pointDropPosY'] = (0x0,
                  j['Rf'])(v9['pointDropPosY'], this['pointDropPosY']),
                  this['count'] = (0x0,
                  j['Rf'])(v9['count'], this['count']),
                  this['lineMaxDistance'] = (0x0,
                  j['Rf'])(v9['lineMaxDistance'], this['lineMaxDistance']),
                  this['showPixel'] = (0x0,
                  j['Rf'])(v9['showPixel'], this['showPixel']),
                  this['pixelOptions'] = (0x0,
                  j['Rf'])(v9['pixelOptions'], this['pixelOptions'])),
                  this['texture'] = (0x0,
                  j['Rf'])(v9['texture'], this['texture'], v2),
                  this['mixColor'] = (0x0,
                  j['Rf'])(v9['mixColor'], this['mixColor']),
                  this['fadeWithSpeed'] = (0x0,
                  j['Rf'])(v9['fadeWithSpeed'], this['fadeWithSpeed']),
                  this['particleRegion'] = (0x0,
                  j['Rf'])(v9['particleRegion'], this['particleRegion']);
              }
          }
          v4['DefaultOptions'] = {
              'color': Z['m']['beige'],
              'dropRate': 0.003,
              'fadeRate': 0.996,
              'speedFactor': 0x1,
              'usePoint': true,
              'minOpacity': 0.5,
              'pointSize': 0x1,
              'minSpeed': 0x0,
              'fadeSpeedMax': 0x14,
              'speedFitZoom': true,
              'countFitZoom': true,
              'interpMethod': T['fast'],
              'interpSmoothFactor': 0.8,
              'pointDropPosY': 0x1,
              'count': 0x40,
              'lineMaxDistance': 0xa,
              'showPixel': false,
              'pixelOptions': {
                  'fillColor': 'white'
              }
          };
          class v5 extends v4 {
              constructor(v9) {
                  super(v9);
              }
              ['_update'](v9, vv) {
                  super['_update'](v9, vv),
                  vv ? (this['zScale'] = (0x0,
                  j['En'])(v9['zScale'], v5['DefaultOptions']['zScale']),
                  this['zIndex'] = (0x0,
                  j['En'])(v9['zIndex'], v5['DefaultOptions']['zIndex']),
                  this['hgtOffset'] = (0x0,
                  j['En'])(v9['hgtOffset'], v5['DefaultOptions']['hgtOffset']),
                  this['zSpeedFactor'] = (0x0,
                  j['En'])(v9['zSpeedFactor'], v5['DefaultOptions']['zSpeedFactor']),
                  this['onlyZ'] = (0x0,
                  j['En'])(v9['onlyZ'], v5['DefaultOptions']['onlyZ']),
                  this['colorWith'] = (0x0,
                  j['En'])(v9['colorWith'], v5['DefaultOptions']['colorWith'])) : (this['zScale'] = (0x0,
                  j['Rf'])(v9['zScale'], this['zScale']),
                  this['zIndex'] = (0x0,
                  j['Rf'])(v9['zIndex'], this['zIndex']),
                  this['hgtOffset'] = (0x0,
                  j['Rf'])(v9['hgtOffset'], this['hgtOffset']),
                  this['zSpeedFactor'] = (0x0,
                  j['Rf'])(v9['zSpeedFactor'], this['zSpeedFactor']),
                  this['onlyZ'] = (0x0,
                  j['Rf'])(v9['onlyZ'], this['onlyZ']),
                  this['colorWith'] = (0x0,
                  j['Rf'])(v9['colorWith'], this['colorWith']));
              }
          }
          v5['DefaultOptions'] = Object['assign'](Object['assign']({}, v4['DefaultOptions']), {
              'zScale': 0x1,
              'zIndex': 0x0,
              'hgtOffset': 0x0,
              'zSpeedFactor': 0x1,
              'onlyZ': false,
              'colorWith': 'uv'
          });
          class v6 extends G {
              constructor(v9) {
                  super(v9),
                  v9['color'] || W['kg']['error'](''),
                  this['_update'](v9, true);
              }
              ['_update'](v9, vv) {
                  vv ? (this['color'] = Q(v9['color']),
                  this['zScale'] = (0x0,
                  j['En'])(v9['zScale'], v6['DefaultOptions']['zScale']),
                  this['samplingRate'] = (0x0,
                  j['En'])(v9['samplingRate'], v6['DefaultOptions']['samplingRate']),
                  this['opaque'] = (0x0,
                  j['En'])(v9['opaque'], v6['DefaultOptions']['opaque'])) : (this['color'] = (0x0,
                  j['Rf'])(v9['color'], this['color'], Q),
                  this['zScale'] = (0x0,
                  j['Rf'])(v9['zScale'], this['zScale']),
                  this['samplingRate'] = (0x0,
                  j['Rf'])(v9['samplingRate'], v6['DefaultOptions']['samplingRate']),
                  this['opaque'] = (0x0,
                  j['Rf'])(v9['opaque'], this['opaque'])),
                  this['visibleExtent'] = (0x0,
                  j['Rf'])(v9['visibleExtent'], this['visibleExtent']);
              }
          }
          v6['DefaultOptions'] = {
              'color': undefined,
              'zScale': 0x1,
              'samplingRate': 0x1,
              'opaque': false
          },
          function(v9) {
              v9[v9['none'] = 0x0] = 'none',
              v9[v9['rect'] = 0x1] = 'rect',
              v9[v9['tilt'] = 0x2] = 'tilt';
          }(X || (X = {}));
          class v7 extends G {
              constructor(v9) {
                  super(v9),
                  v9['fillColor'] || v9['colorScale'] || W['kg']['error']('fillColorcolorScale'),
                  this['_update'](v9, true);
              }
              ['_update'](v9, vv) {
                  vv ? (this['flat'] = (0x0,
                  j['En'])(v9['flat'], v7['DefaultOptions']['flat']),
                  this['diffuse'] = M((0x0,
                  j['En'])(v9['diffuse'], v7['DefaultOptions']['diffuse'])),
                  this['emission'] = M((0x0,
                  j['En'])(v9['emission'], v7['DefaultOptions']['emission'])),
                  this['globalOpacity'] = (0x0,
                  j['En'])(v9['globalOpacity'], v7['DefaultOptions']['globalOpacity']),
                  this['specular'] = (0x0,
                  j['En'])(v9['specular'], v7['DefaultOptions']['specular']),
                  this['shininess'] = (0x0,
                  j['En'])(v9['shininess'], v7['DefaultOptions']['shininess']),
                  this['fillMode'] = R((0x0,
                  j['En'])(v9['fillMode'], v7['DefaultOptions']['fillMode'])),
                  this['opaque'] = (0x0,
                  j['En'])(v9['opaque'], v7['DefaultOptions']['opaque']),
                  this['zScale'] = (0x0,
                  j['En'])(v9['zScale'], v7['DefaultOptions']['zScale']),
                  this['depthTest'] = (0x0,
                  j['En'])(v9['depthTest'], v7['DefaultOptions']['depthTest']),
                  this['sectionMode'] = (0x0,
                  j['En'])(v9['sectionMode'], v7['DefaultOptions']['sectionMode'])) : (this['flat'] = (0x0,
                  j['Rf'])(v9['flat'], this['flat']),
                  this['diffuse'] = (0x0,
                  j['Rf'])(v9['diffuse'], this['diffuse'], M),
                  this['emission'] = (0x0,
                  j['Rf'])(v9['emission'], this['emission'], M),
                  this['globalOpacity'] = (0x0,
                  j['Rf'])(v9['globalOpacity'], this['globalOpacity']),
                  this['specular'] = (0x0,
                  j['Rf'])(v9['specular'], this['specular']),
                  this['shininess'] = (0x0,
                  j['Rf'])(v9['shininess'], this['shininess']),
                  this['fillMode'] = (0x0,
                  j['Rf'])(v9['fillMode'], this['fillMode'], R),
                  this['opaque'] = (0x0,
                  j['Rf'])(v9['opaque'], this['opaque']),
                  this['zScale'] = (0x0,
                  j['Rf'])(v9['zScale'], this['zScale']),
                  this['depthTest'] = (0x0,
                  j['Rf'])(v9['depthTest'], this['depthTest']),
                  this['sectionMode'] = (0x0,
                  j['Rf'])(v9['sectionMode'], this['sectionMode'])),
                  this['fillColor'] = (0x0,
                  j['Rf'])(v9['fillColor'], this['fillColor'], Q),
                  this['colorScale'] = (0x0,
                  j['Rf'])(v9['colorScale'], this['colorScale'], L),
                  this['section'] = (0x0,
                  j['Rf'])(v9['section'], this['section']);
              }
          }
          v7['DefaultOptions'] = {
              'flat': false,
              'diffuse': [0x0, 0x0, 0x0],
              'emission': [0x0, 0x0, 0x0],
              'globalOpacity': 0x1,
              'specular': 0x0,
              'shininess': 0x1,
              'fillMode': Y['pixel1'],
              'opaque': true,
              'zScale': 0x1,
              'depthTest': true,
              'sectionMode': X['none']
          };
          class v8 extends v7 {
              constructor(v9) {
                  super(v9);
              }
              ['_update'](v9, vv) {
                  super['_update'](v9, vv),
                  vv ? (this['baseSpeed'] = (0x0,
                  j['En'])(v9['baseSpeed'], v8['DefaultOptions']['baseSpeed']),
                  this['headRadius'] = (0x0,
                  j['En'])(v9['headRadius'], v8['DefaultOptions']['headRadius']),
                  this['headLength'] = (0x0,
                  j['En'])(v9['headLength'], v8['DefaultOptions']['headLength']),
                  this['headSegments'] = (0x0,
                  j['En'])(v9['headSegments'], v8['DefaultOptions']['headSegments']),
                  this['bodyTopRadius'] = (0x0,
                  j['En'])(v9['bodyTopRadius'], v8['DefaultOptions']['bodyTopRadius']),
                  this['bodyBottomRadius'] = (0x0,
                  j['En'])(v9['bodyBottomRadius'], v8['DefaultOptions']['bodyBottomRadius']),
                  this['bodyLength'] = (0x0,
                  j['En'])(v9['bodyLength'], v8['DefaultOptions']['bodyLength']),
                  this['bodySegments'] = (0x0,
                  j['En'])(v9['bodySegments'], v8['DefaultOptions']['bodySegments']),
                  this['shapeNeedsUpdate'] = (0x0,
                  j['En'])(v9['shapeNeedsUpdate'], v8['DefaultOptions']['shapeNeedsUpdate']),
                  this['maxCount'] = (0x0,
                  j['En'])(v9['maxCount'], v8['DefaultOptions']['maxCount']),
                  this['shapeScale'] = (0x0,
                  j['En'])(v9['shapeScale'], v8['DefaultOptions']['shapeScale']),
                  this['verticalDataScale'] = (0x0,
                  j['En'])(v9['verticalDataScale'], v8['DefaultOptions']['verticalDataScale']),
                  this['flipArrow'] = (0x0,
                  j['En'])(v9['flipArrow'], v8['DefaultOptions']['flipArrow'])) : (this['baseSpeed'] = (0x0,
                  j['Rf'])(v9['baseSpeed'], this['baseSpeed']),
                  this['headRadius'] = (0x0,
                  j['Rf'])(v9['headRadius'], this['headRadius']),
                  this['headLength'] = (0x0,
                  j['Rf'])(v9['headLength'], this['headLength']),
                  this['headSegments'] = (0x0,
                  j['Rf'])(v9['headSegments'], this['headSegments']),
                  this['bodyTopRadius'] = (0x0,
                  j['Rf'])(v9['bodyTopRadius'], this['bodyTopRadius']),
                  this['bodyBottomRadius'] = (0x0,
                  j['Rf'])(v9['bodyBottomRadius'], this['bodyBottomRadius']),
                  this['bodyLength'] = (0x0,
                  j['Rf'])(v9['bodyLength'], this['bodyLength']),
                  this['bodySegments'] = (0x0,
                  j['Rf'])(v9['bodySegments'], this['bodySegments']),
                  this['shapeNeedsUpdate'] = (0x0,
                  j['Rf'])(v9['shapeNeedsUpdate'], this['shapeNeedsUpdate']),
                  this['maxCount'] = (0x0,
                  j['Rf'])(v9['maxCount'], this['maxCount']),
                  this['shapeScale'] = (0x0,
                  j['Rf'])(v9['shapeScale'], this['shapeScale']),
                  this['verticalDataScale'] = (0x0,
                  j['Rf'])(v9['verticalDataScale'], this['verticalDataScale']),
                  this['flipArrow'] = (0x0,
                  j['Rf'])(v9['flipArrow'], this['flipArrow'])),
                  this['speed'] = (0x0,
                  j['Rf'])(v9['speed'], this['speed'], D['JW']),
                  this['angle'] = (0x0,
                  j['Rf'])(v9['angle'], this['angle'], D['JW']),
                  this['height'] = (0x0,
                  j['Rf'])(v9['height'], this['height'], D['JW']),
                  this['gridPreferSD'] = (0x0,
                  j['Rf'])(v9['gridPreferSD'], this['gridPreferSD']);
              }
          }
          v8['DefaultOptions'] = Object['assign'](Object['assign']({}, v7['DefaultOptions']), {
              'baseSpeed': 0x5,
              'headRadius': 0xbb8,
              'headLength': 0x1388,
              'headSegments': 0x1e,
              'bodyTopRadius': 0x3e8,
              'bodyBottomRadius': 0x3e8,
              'bodyLength': 0x2710,
              'bodySegments': 0x1e,
              'maxCount': 0x1f4,
              'shapeNeedsUpdate': false,
              'shapeScale': 0x1,
              'verticalDataScale': 0x1,
              'flipArrow': true
          });
      }
      ,
      0x219: (K,b,H)=>{
          'use strict';
          H['d'](b, {
              '$f': ()=>U,
              'CN': ()=>Z,
              'Dg': ()=>W,
              'UZ': ()=>D,
              'W6': ()=>B,
              'dl': ()=>q,
              'no': ()=>I,
              'se': ()=>j,
              'vX': ()=>V,
              'x1': ()=>S
          });
          var x = H(0x39b)
            , F = H(0xfb)
            , w = H(0x1)
            , Y = H(0x346)
            , T = H(0x1de)
            , X = H(0x260)
            , E = H(0x133);
          function W(J) {
              let C = (0x0,
              E['it'])(J);
              if ('number' == typeof C)
                  return O=>C;
              if ('function' == typeof C)
                  return C;
              if ('object' == typeof C && C['stops']) {
                  const O = new X['NB'](C,N=>(N['stop'] = parseFloat(N['stop']),
                  N));
                  let G = parseInt(O['fieldName']) || 0x0;
                  return (N,P)=>O['getRule'](P[G])['stop'];
              }
              if ('string' == typeof C) {
                  if (0x0 === C['trim']()['length'])
                      return N=>N;
                  if (C['startsWith'](Y['v']['fieldPropertiesIndicator']) || C['startsWith'](Y['v']['fieldLoaderIndicator'])) {
                      let N = 0x0;
                      if (C['indexOf']('|') > 0x0) {
                          const P = C['split']('|');
                          N = parseInt(P[0x1]) || 0x0,
                          C = P[0x0];
                      }
                      if (C['indexOf'](Y['v']['fieldLoaderIndicator']) < 0x0)
                          return (M,z)=>z[N];
                      {
                          const M = C['split'](Y['v']['fieldLoaderIndicator'])
                            , z = M[0x1]['split']('?')
                            , Q = (0x0,
                          F['nA'])(z[0x0]);
                          if (!Q)
                              return x['kg']['warn']('' + M[0x0] + 'loader'),
                              (L,R)=>R[N];
                          if (z['length'] > 0x1) {
                              const L = (0x0,
                              E['vl'])(z[0x1]);
                              return (R,v0)=>Q(v0[N], L);
                          }
                          return (R,v0)=>Q(v0[N], undefined);
                      }
                  }
                  {
                      const R = parseFloat(C);
                      return undefined === R && x['kg']['error']('' + C + ''),
                      v0=>R;
                  }
              }
              x['kg']['error']('' + typeof C);
          }
          function I(J) {
              let C = (0x0,
              E['it'])(J);
              if ('function' == typeof C)
                  return C;
              if ('object' == typeof C && C['stops']) {
                  const O = new X['NB'](C,N=>(N['stop']['toString'] && N['stop']['toString'](),
                  N));
                  let G = parseInt(O['fieldName']) || 0x0;
                  return (N,P)=>O['getRule'](P[G])['stop'];
              }
              if (undefined === C)
                  return (N,P)=>N['toString']();
              if ('string' == typeof C) {
                  if (0x0 === C['trim']()['length'])
                      return (N,P)=>N['toString']();
                  if (C['startsWith'](Y['v']['fieldPropertiesIndicator']) || C['startsWith'](Y['v']['fieldLoaderIndicator'])) {
                      let N = 0x0;
                      if (C['indexOf']('|') > 0x0) {
                          const P = C['split']('|');
                          N = parseInt(P[0x1]) || 0x0,
                          C = P[0x0];
                      }
                      if (C['indexOf'](Y['v']['fieldLoaderIndicator']) < 0x0)
                          return (M,z)=>z[N]['toString']();
                      {
                          const M = C['split'](Y['v']['fieldLoaderIndicator'])
                            , z = M[0x1]['split']('?')
                            , Q = (0x0,
                          F['nA'])(z[0x0]);
                          if (!Q)
                              return x['kg']['warn']('' + M[0x0] + 'loader'),
                              (L,R)=>R[N]['toString']();
                          if (z['length'] > 0x1) {
                              const L = (0x0,
                              E['vl'])(z[0x1]);
                              return (R,v0)=>Q(v0[N], L);
                          }
                          return (R,v0)=>Q(v0[N]);
                      }
                  }
                  return (R,v0)=>C;
              }
              x['kg']['error']('' + typeof C);
          }
          function j(J) {
              const C = (0x0,
              E['it'])(J);
              if ('number' == typeof C) {
                  const O = 0x0 !== C;
                  return G=>O;
              }
              if ('boolean' == typeof C)
                  return G=>C;
              if ('function' == typeof C)
                  return C;
              if ('object' == typeof C && C['stops']) {
                  const G = new X['NB'](C);
                  let N = parseInt(G['fieldName']) || 0x0;
                  return (P,M)=>G['getRule'](M[N])['stop'];
              }
              if ('string' == typeof C) {
                  const P = '0' !== C && 'false' !== C['toLowerCase']();
                  return M=>P;
              }
              x['kg']['error']('' + typeof C);
          }
          function D(J) {
              const C = (0x0,
              E['it'])(J);
              if (C instanceof Array)
                  return O=>C;
              if ('function' == typeof C)
                  return C;
              if ('object' == typeof C && C['stops']) {
                  const O = new X['NB'](C);
                  let G = parseInt(O['fieldName']) || 0x0;
                  return (N,P)=>O['getRule'](P[G])['stop'];
              }
              x['kg']['error']('' + typeof C);
          }
          function V(J) {
              const C = (0x0,
              E['it'])(J);
              if ('string' == typeof C) {
                  const O = (0x0,
                  E['$P'])(C);
                  return G=>O;
              }
              if ('number' == typeof C) {
                  const G = (0x0,
                  E['lW'])(C);
                  return N=>G;
              }
              if (C instanceof T['t'])
                  return N=>C;
              if (C instanceof Array) {
                  const N = new T['t']({
                      'r': C[0x0],
                      'g': C[0x1],
                      'b': C[0x2],
                      'a': 0x3 === C['length'] ? 0x1 : C[0x3]
                  });
                  return P=>N;
              }
              if ('function' == typeof C)
                  return (P,M)=>{
                      const z = C(P, M);
                      return z instanceof T['t'] ? z : 'string' == typeof z ? (0x0,
                      E['$P'])(z) : 'number' == typeof z ? (0x0,
                      E['lW'])(z) : z instanceof Array ? (0x0,
                      E['LH'])(z) : void x['kg']['error']('');
                  }
                  ;
              if ('object' == typeof C && (undefined !== C['r'] || undefined !== C['red'])) {
                  const P = new T['t'](C);
                  return M=>P;
              }
              if ('object' == typeof C && C['stops']) {
                  const M = new X['NB'](C,E['$k']);
                  let z = parseInt(M['fieldName']) || 0x0;
                  return (Q,L)=>M['getRule'](L[z])['stop'];
              }
              x['kg']['error']('' + typeof C);
          }
          function Z(J) {
              const C = (0x0,
              E['it'])(J);
              if ('string' == typeof C)
                  return O=>C;
              if (C instanceof HTMLImageElement || C instanceof HTMLVideoElement || C instanceof HTMLCanvasElement)
                  return O=>C;
              if ('function' == typeof C)
                  return C;
              if ('object' == typeof C && C['stops']) {
                  const O = new X['NB'](C);
                  let G = parseInt(O['fieldName']) || 0x0;
                  return (N,P)=>O['getRule'](P[G])['stop'];
              }
              x['kg']['error']('' + typeof C);
          }
          class B extends E['Uw'] {
              constructor() {
                  super(...arguments),
                  this['styleName'] = 'gridStyle';
              }
              ['_createCacheId'](J) {
                  if (undefined !== J && !isNaN(J))
                      return J['toString']();
              }
          }
          class S extends B {
              constructor(J) {
                  super(J),
                  this['_update'](J, true);
              }
              ['_update'](J, C) {
                  C ? (this['data'] = I(J['data']),
                  this['font'] = I((0x0,
                  w['En'])(J['font'], S['DefaultOptions']['font'])),
                  this['color'] = V((0x0,
                  w['En'])(J['color'], S['DefaultOptions']['color'])),
                  this['visible'] = j((0x0,
                  w['En'])(J['visible'], S['DefaultOptions']['visible'])),
                  this['backHeight'] = W((0x0,
                  w['En'])(J['backHeight'], S['DefaultOptions']['backHeight'])),
                  this['backPadding'] = D((0x0,
                  w['En'])(J['backPadding'], S['DefaultOptions']['backPadding'])),
                  this['strokeWidth'] = W((0x0,
                  w['En'])(J['strokeWidth'], S['DefaultOptions']['strokeWidth'])),
                  this['backStrokeWidth'] = W((0x0,
                  w['En'])(J['backStrokeWidth'], S['DefaultOptions']['backStrokeWidth'])),
                  this['align'] = I((0x0,
                  w['En'])(J['align'], S['DefaultOptions']['align'])),
                  this['baseline'] = I((0x0,
                  w['En'])(J['baseline'], S['DefaultOptions']['baseline'])),
                  this['backShadowBlur'] = W((0x0,
                  w['En'])(J['backShadowBlur'], S['DefaultOptions']['backShadowBlur'])),
                  this['backShadowOffset'] = D((0x0,
                  w['En'])(J['backShadowOffset'], S['DefaultOptions']['backShadowOffset'])),
                  this['shadowOffset'] = D((0x0,
                  w['En'])(J['shadowOffset'], S['DefaultOptions']['shadowOffset'])),
                  this['shadowBlur'] = W((0x0,
                  w['En'])(J['shadowBlur'], S['DefaultOptions']['shadowBlur'])),
                  this['backRoundRadius'] = W((0x0,
                  w['En'])(J['backRoundRadius'], S['DefaultOptions']['backRoundRadius'])),
                  this['zoomMin'] = W((0x0,
                  w['En'])(J['zoomMin'], S['DefaultOptions']['zoomMin'])),
                  this['zoomMax'] = W((0x0,
                  w['En'])(J['zoomMax'], S['DefaultOptions']['zoomMax']))) : (this['data'] = (0x0,
                  w['Rf'])(J['data'], this['data'], I),
                  this['font'] = (0x0,
                  w['Rf'])(J['font'], this['font'], I),
                  this['color'] = (0x0,
                  w['Rf'])(J['color'], this['color'], V),
                  this['visible'] = (0x0,
                  w['Rf'])(J['visible'], this['visible'], j),
                  this['backHeight'] = (0x0,
                  w['Rf'])(J['backHeight'], this['backHeight'], W),
                  this['backPadding'] = (0x0,
                  w['Rf'])(J['backPadding'], this['backPadding'], D),
                  this['strokeWidth'] = (0x0,
                  w['Rf'])(J['strokeWidth'], this['strokeWidth'], W),
                  this['backStrokeWidth'] = (0x0,
                  w['Rf'])(J['backStrokeWidth'], this['backStrokeWidth'], W),
                  this['align'] = (0x0,
                  w['Rf'])(J['align'], this['align'], I),
                  this['baseline'] = (0x0,
                  w['Rf'])(J['baseline'], this['baseline'], I),
                  this['backShadowOffset'] = (0x0,
                  w['Rf'])(J['backShadowOffset'], this['backShadowOffset'], D),
                  this['backShadowBlur'] = (0x0,
                  w['Rf'])(J['backShadowBlur'], this['backShadowBlur'], W),
                  this['shadowOffset'] = (0x0,
                  w['Rf'])(J['shadowOffset'], this['shadowOffset'], D),
                  this['shadowBlur'] = (0x0,
                  w['Rf'])(J['shadowBlur'], this['shadowBlur'], W),
                  this['backRoundRadius'] = (0x0,
                  w['Rf'])(J['backRoundRadius'], this['backRoundRadius'], W),
                  this['zoomMin'] = (0x0,
                  w['Rf'])(J['zoomMin'], this['zoomMin'], W),
                  this['zoomMax'] = (0x0,
                  w['Rf'])(J['zoomMax'], this['zoomMax'], W)),
                  this['angle'] = (0x0,
                  w['Rf'])(J['angle'], this['angle'], W),
                  this['strokeColor'] = (0x0,
                  w['Rf'])(J['strokeColor'], this['strokeColor'], V),
                  this['backColor'] = (0x0,
                  w['Rf'])(J['backColor'], this['backColor'], V),
                  this['backCircle'] = (0x0,
                  w['Rf'])(J['backCircle'], this['backCircle'], j),
                  this['offset'] = (0x0,
                  w['Rf'])(J['offset'], this['offset'], D),
                  this['backStrokeColor'] = (0x0,
                  w['Rf'])(J['backStrokeColor'], this['backStrokeColor'], V),
                  this['backRoundRect'] = (0x0,
                  w['Rf'])(J['backRoundRect'], this['backRoundRect'], j),
                  this['backShadowColor'] = (0x0,
                  w['Rf'])(J['backShadowColor'], this['backShadowColor'], V),
                  this['backStrokeDashArray'] = (0x0,
                  w['Rf'])(J['backStrokeDashArray'], this['backStrokeDashArray'], D),
                  this['shadowColor'] = (0x0,
                  w['Rf'])(J['shadowColor'], this['shadowColor'], V);
              }
          }
          S['DefaultOptions'] = {
              'data': undefined,
              'font': '12px\x20',
              'color': 'black',
              'visible': true,
              'backHeight': 0xe,
              'backPadding': [0x3, 0x2],
              'strokeWidth': 0x1,
              'backStrokeWidth': 0x1,
              'align': 'center',
              'baseline': 'middle',
              'backShadowBlur': 0x6,
              'backShadowOffset': [0x3, 0x3],
              'shadowBlur': 0x6,
              'shadowOffset': [0x3, 0x3],
              'backRoundRadius': 0x6,
              'zoomMin': 0x0,
              'zoomMax': 0x19
          };
          class U extends B {
              constructor(J) {
                  super(J),
                  J['data'] || x['kg']['error'](''),
                  this['_update'](J, true);
              }
              ['_update'](J, C) {
                  C ? (this['size'] = D((0x0,
                  w['En'])(J['size'], U['DefaultOptions']['size'])),
                  this['data'] = Z(J['data']),
                  this['visible'] = j((0x0,
                  w['En'])(J['visible'], U['DefaultOptions']['visible'])),
                  this['shadowOffset'] = D((0x0,
                  w['En'])(J['shadowOffset'], U['DefaultOptions']['shadowOffset'])),
                  this['shadowBlur'] = W((0x0,
                  w['En'])(J['shadowBlur'], U['DefaultOptions']['shadowBlur'])),
                  this['zoomMin'] = W((0x0,
                  w['En'])(J['zoomMin'], U['DefaultOptions']['zoomMin'])),
                  this['zoomMax'] = W((0x0,
                  w['En'])(J['zoomMax'], U['DefaultOptions']['zoomMax']))) : (this['size'] = (0x0,
                  w['Rf'])(J['size'], this['size'], D),
                  this['data'] = (0x0,
                  w['Rf'])(J['data'], this['data'], Z),
                  this['visible'] = (0x0,
                  w['Rf'])(J['visible'], this['visible'], j),
                  this['shadowOffset'] = (0x0,
                  w['Rf'])(J['shadowOffset'], this['shadowOffset'], D),
                  this['shadowBlur'] = (0x0,
                  w['Rf'])(J['shadowBlur'], this['shadowBlur'], W),
                  this['zoomMin'] = (0x0,
                  w['Rf'])(J['zoomMin'], this['zoomMin'], W),
                  this['zoomMax'] = (0x0,
                  w['Rf'])(J['zoomMax'], this['zoomMax'], W)),
                  this['angle'] = (0x0,
                  w['Rf'])(J['angle'], this['angle'], W),
                  this['offset'] = (0x0,
                  w['Rf'])(J['offset'], this['offset'], D),
                  this['shadowColor'] = (0x0,
                  w['Rf'])(J['shadowColor'], this['shadowColor'], V),
                  this['color'] = (0x0,
                  w['Rf'])(J['color'], this['color'], V);
              }
          }
          U['DefaultOptions'] = {
              'data': undefined,
              'size': [0x20, 0x20],
              'visible': true,
              'shadowBlur': 0x5,
              'shadowOffset': [0x5, 0x5],
              'zoomMin': 0x0,
              'zoomMax': 0x19
          };
          class q extends B {
              constructor(J) {
                  super(J),
                  this['_update'](J, true);
              }
              ['_update'](J, C) {
                  C ? (this['interval'] = (0x0,
                  w['En'])(J['interval'], q['DefaultOptions']['interval']),
                  this['pos'] = (0x0,
                  w['En'])(J['pos'], q['DefaultOptions']['pos'])) : (J['interval'] && (this['interval'] = J['interval']),
                  this['pos'] = (0x0,
                  w['Rf'])(J['pos'], this['pos'])),
                  J['image'] && (C ? this['image'] = J['image'] && new U(J['image']) : this['image']['update'](J['image'])),
                  J['text'] && (C ? this['text'] = J['text'] && new S(J['text']) : this['text']['update'](J['text']));
              }
          }
          q['DefaultOptions'] = {
              'interval': [0x32, 0x32],
              'pos': [0.5, 0.5]
          };
      }
      ,
      0x313: (K,b,H)=>{
          'use strict';
          H['d'](b, {
              'K9': ()=>Z,
              'dO': ()=>V,
              'uD': ()=>D,
              'xS': ()=>X
          });
          var x = H(0x39b)
            , F = H(0x1)
            , y = H(0x346)
            , w = H(0x35a)
            , Y = H(0x260)
            , T = function(B, S, U, q) {
              return new (U || (U = Promise))(function(J, C) {
                  function O(P) {
                      try {
                          N(q['next'](P));
                      } catch (M) {
                          C(M);
                      }
                  }
                  function G(P) {
                      try {
                          N(q['throw'](P));
                      } catch (M) {
                          C(M);
                      }
                  }
                  function N(P) {
                      var M;
                      P['done'] ? J(P['value']) : (M = P['value'],
                      M instanceof U ? M : new U(function(z) {
                          z(M);
                      }
                      ))['then'](O, G);
                  }
                  N((q = q['apply'](B, S || []))['next']());
              }
              );
          };
          const X = {
              '3gauss': '3gauss',
              '3saw': '3saw',
              'BkBlAqGrYeOrReViWh200': 'BkBlAqGrYeOrReViWh200',
              'BlAqGrYeOrRe': 'BlAqGrYeOrRe',
              'BlAqGrYeOrReVi200': 'BlAqGrYeOrReVi200',
              'BlGrYeOrReVi200': 'BlGrYeOrReVi200',
              'BlRe': 'BlRe',
              'BlWhRe': 'BlWhRe',
              'BlueDarkOrange18': 'BlueDarkOrange18',
              'BlueDarkRed18': 'BlueDarkRed18',
              'BlueGreen14': 'BlueGreen14',
              'BlueRed': 'BlueRed',
              'BlueRedGray': 'BlueRedGray',
              'BlueWhiteOrangeRed': 'BlueWhiteOrangeRed',
              'BlueYellowRed': 'BlueYellowRed',
              'BrownBlue12': 'BrownBlue12',
              'Cat12': 'Cat12',
              'GHRSST_anomaly': 'GHRSST_anomaly',
              'GMT_cool': 'GMT_cool',
              'GMT_copper': 'GMT_copper',
              'GMT_drywet': 'GMT_drywet',
              'GMT_gebco': 'GMT_gebco',
              'GMT_globe': 'GMT_globe',
              'GMT_gray': 'GMT_gray',
              'GMT_haxby': 'GMT_haxby',
              'GMT_hot': 'GMT_hot',
              'GMT_jet': 'GMT_jet',
              'GMT_nighttime': 'GMT_nighttime',
              'GMT_no_green': 'GMT_no_green',
              'GMT_ocean': 'GMT_ocean',
              'GMT_paired': 'GMT_paired',
              'GMT_panoply': 'GMT_panoply',
              'GMT_polar': 'GMT_polar',
              'GMT_red2green': 'GMT_red2green',
              'GMT_relief': 'GMT_relief',
              'GMT_relief_oceanonly': 'GMT_relief_oceanonly',
              'GMT_seis': 'GMT_seis',
              'GMT_split': 'GMT_split',
              'GMT_topo': 'GMT_topo',
              'GMT_wysiwyg': 'GMT_wysiwyg',
              'GMT_wysiwygcont': 'GMT_wysiwygcont',
              'GrayWhiteGray': 'GrayWhiteGray',
              'GreenMagenta16': 'GreenMagenta16',
              'GreenYellow': 'GreenYellow',
              'MPL_Accent': 'MPL_Accent',
              'MPL_Blues': 'MPL_Blues',
              'MPL_BrBG': 'MPL_BrBG',
              'MPL_BuGn': 'MPL_BuGn',
              'MPL_BuPu': 'MPL_BuPu',
              'MPL_Dark2': 'MPL_Dark2',
              'MPL_GnBu': 'MPL_GnBu',
              'MPL_Greens': 'MPL_Greens',
              'MPL_Greys': 'MPL_Greys',
              'MPL_OrRd': 'MPL_OrRd',
              'MPL_Oranges': 'MPL_Oranges',
              'MPL_PRGn': 'MPL_PRGn',
              'MPL_Paired': 'MPL_Paired',
              'MPL_Pastel1': 'MPL_Pastel1',
              'MPL_Pastel2': 'MPL_Pastel2',
              'MPL_PiYG': 'MPL_PiYG',
              'MPL_PuBu': 'MPL_PuBu',
              'MPL_PuBuGn': 'MPL_PuBuGn',
              'MPL_PuOr': 'MPL_PuOr',
              'MPL_PuRd': 'MPL_PuRd',
              'MPL_Purples': 'MPL_Purples',
              'MPL_RdBu': 'MPL_RdBu',
              'MPL_RdGy': 'MPL_RdGy',
              'MPL_RdPu': 'MPL_RdPu',
              'MPL_RdYlBu': 'MPL_RdYlBu',
              'MPL_RdYlGn': 'MPL_RdYlGn',
              'MPL_Reds': 'MPL_Reds',
              'MPL_Set1': 'MPL_Set1',
              'MPL_Set2': 'MPL_Set2',
              'MPL_Set3': 'MPL_Set3',
              'MPL_Spectral': 'MPL_Spectral',
              'MPL_StepSeq': 'MPL_StepSeq',
              'MPL_YlGn': 'MPL_YlGn',
              'MPL_YlGnBu': 'MPL_YlGnBu',
              'MPL_YlOrBr': 'MPL_YlOrBr',
              'MPL_YlOrRd': 'MPL_YlOrRd',
              'MPL_afmhot': 'MPL_afmhot',
              'MPL_autumn': 'MPL_autumn',
              'MPL_bone': 'MPL_bone',
              'MPL_brg': 'MPL_brg',
              'MPL_bwr': 'MPL_bwr',
              'MPL_cool': 'MPL_cool',
              'MPL_coolwarm': 'MPL_coolwarm',
              'MPL_copper': 'MPL_copper',
              'MPL_cubehelix': 'MPL_cubehelix',
              'MPL_flag': 'MPL_flag',
              'MPL_gist_earth': 'MPL_gist_earth',
              'MPL_gist_gray': 'MPL_gist_gray',
              'MPL_gist_heat': 'MPL_gist_heat',
              'MPL_gist_ncar': 'MPL_gist_ncar',
              'MPL_gist_rainbow': 'MPL_gist_rainbow',
              'MPL_gist_stern': 'MPL_gist_stern',
              'MPL_gist_yarg': 'MPL_gist_yarg',
              'MPL_gnuplot': 'MPL_gnuplot',
              'MPL_gnuplot2': 'MPL_gnuplot2',
              'MPL_hot': 'MPL_hot',
              'MPL_hsv': 'MPL_hsv',
              'MPL_jet': 'MPL_jet',
              'MPL_ocean': 'MPL_ocean',
              'MPL_pink': 'MPL_pink',
              'MPL_prism': 'MPL_prism',
              'MPL_rainbow': 'MPL_rainbow',
              'MPL_s3pcpn': 'MPL_s3pcpn',
              'MPL_s3pcpn_l': 'MPL_s3pcpn_l',
              'MPL_seismic': 'MPL_seismic',
              'MPL_spring': 'MPL_spring',
              'MPL_sstanom': 'MPL_sstanom',
              'MPL_summer': 'MPL_summer',
              'MPL_terrain': 'MPL_terrain',
              'MPL_winter': 'MPL_winter',
              'NCV_banded': 'NCV_banded',
              'NCV_blu_red': 'NCV_blu_red',
              'NCV_blue_red': 'NCV_blue_red',
              'NCV_bright': 'NCV_bright',
              'NCV_gebco': 'NCV_gebco',
              'NCV_jaisnd': 'NCV_jaisnd',
              'NCV_jet': 'NCV_jet',
              'NCV_manga': 'NCV_manga',
              'NCV_rainbow2': 'NCV_rainbow2',
              'NCV_roullet': 'NCV_roullet',
              'OceanLakeLandSnow': 'OceanLakeLandSnow',
              'SVG_Gallet13': 'SVG_Gallet13',
              'SVG_Lindaa06': 'SVG_Lindaa06',
              'SVG_Lindaa07': 'SVG_Lindaa07',
              'SVG_bhw3_22': 'SVG_bhw3_22',
              'SVG_es_landscape_79': 'SVG_es_landscape_79',
              'SVG_feb_sunrise': 'SVG_feb_sunrise',
              'SVG_foggy_sunrise': 'SVG_foggy_sunrise',
              'SVG_fs2006': 'SVG_fs2006',
              'StepSeq25': 'StepSeq25',
              'ViBlGrWhYeOrRe': 'ViBlGrWhYeOrRe',
              'WhBlGrYeRe': 'WhBlGrYeRe',
              'WhBlReWh': 'WhBlReWh',
              'WhViBlGrYeOrRe': 'WhViBlGrYeOrRe',
              'WhViBlGrYeOrReWh': 'WhViBlGrYeOrReWh',
              'WhiteBlue': 'WhiteBlue',
              'WhiteBlueGreenYellowRed': 'WhiteBlueGreenYellowRed',
              'WhiteGreen': 'WhiteGreen',
              'WhiteYellowOrangeRed': 'WhiteYellowOrangeRed',
              'amwg': 'amwg',
              'amwg256': 'amwg256',
              'amwg_blueyellowred': 'amwg_blueyellowred',
              'cb_9step': 'cb_9step',
              'cb_rainbow': 'cb_rainbow',
              'cb_rainbow_inv': 'cb_rainbow_inv',
              'cmp_b2r': 'cmp_b2r',
              'cmp_flux': 'cmp_flux',
              'cmp_haxby': 'cmp_haxby',
              'cosam': 'cosam',
              'cosam12': 'cosam12',
              'cyclic': 'cyclic',
              'default': 'default',
              'detail': 'detail',
              'example': 'example',
              'extrema': 'extrema',
              'grads_default': 'grads_default',
              'grads_rainbow': 'grads_rainbow',
              'gscyclic': 'gscyclic',
              'gsdtol': 'gsdtol',
              'gsltod': 'gsltod',
              'gui_default': 'gui_default',
              'helix': 'helix',
              'helix1': 'helix1',
              'hlu_default': 'hlu_default',
              'hotcold_18lev': 'hotcold_18lev',
              'hotcolr_19lev': 'hotcolr_19lev',
              'hotres': 'hotres',
              'matlab_hot': 'matlab_hot',
              'matlab_hsv': 'matlab_hsv',
              'matlab_jet': 'matlab_jet',
              'matlab_lines': 'matlab_lines',
              'mch_default': 'mch_default',
              'ncl_default': 'ncl_default',
              'ncview_default': 'ncview_default',
              'nice_gfdl': 'nice_gfdl',
              'nrl_sirkes': 'nrl_sirkes',
              'nrl_sirkes_nowhite': 'nrl_sirkes_nowhite',
              'perc2_9lev': 'perc2_9lev',
              'percent_11lev': 'percent_11lev',
              'posneg_1': 'posneg_1',
              'posneg_2': 'posneg_2',
              'prcp_1': 'prcp_1',
              'prcp_2': 'prcp_2',
              'prcp_3': 'prcp_3',
              'precip2_15lev': 'precip2_15lev',
              'precip2_17lev': 'precip2_17lev',
              'precip3_16lev': 'precip3_16lev',
              'precip4_11lev': 'precip4_11lev',
              'precip4_diff_19lev': 'precip4_diff_19lev',
              'precip_11lev': 'precip_11lev',
              'precip_diff_12lev': 'precip_diff_12lev',
              'precip_diff_1lev': 'precip_diff_1lev',
              'psgcap': 'psgcap',
              'radar': 'radar',
              'radar_1': 'radar_1',
              'rainbow+gray': 'rainbow+gray',
              'rainbow+white+gray': 'rainbow+white+gray',
              'rainbow+white': 'rainbow+white',
              'rainbow': 'rainbow',
              'rh_19lev': 'rh_19lev',
              'seaice_1': 'seaice_1',
              'seaice_2': 'seaice_2',
              'so4_21': 'so4_21',
              'so4_23': 'so4_23',
              'spread_15lev': 'spread_15lev',
              'sunshine_9lev': 'sunshine_9lev',
              'sunshine_diff_12lev': 'sunshine_diff_12lev',
              't2m_29lev': 't2m_29lev',
              'tbrAvg1': 'tbrAvg1',
              'tbrStd1': 'tbrStd1',
              'tbrVar1': 'tbrVar1',
              'tbr_240-300': 'tbr_240-300',
              'tbr_stdev_0-30': 'tbr_stdev_0-30',
              'tbr_var_0-500': 'tbr_var_0-500',
              'temp1': 'temp1',
              'temp_19lev': 'temp_19lev',
              'temp_diff_18lev': 'temp_diff_18lev',
              'temp_diff_1lev': 'temp_diff_1lev',
              'testcmap': 'testcmap',
              'thelix': 'thelix',
              'topo_15lev': 'topo_15lev',
              'uniform': 'uniform',
              'wgne15': 'wgne15',
              'wh-bl-gr-ye-re': 'wh-bl-gr-ye-re',
              'wind_17lev': 'wind_17lev',
              'wxpEnIR': 'wxpEnIR'
          }
            , E = {}
            , W = {};
          function I(B, S) {
              let U = 'linear-gradient(90deg,';
              const q = [];
              return B['forEach']((J,C)=>{
                  const O = J['split'](/\s+/);
                  if (0x0 === O[0x0]['trim']()['length'] && O['shift'](),
                  isNaN(parseFloat(O[0x0])) || O['length'] < 0x3)
                      return void x['kg']['debug']('skip\x20line\x20' + J);
                  const G = parseFloat(O[0x0])
                    , N = parseFloat(O[0x1])
                    , P = parseFloat(O[0x2]);
                  let M;
                  M = G <= 0x1 && N <= 0x1 && P <= 0x1 ? 'rgb(' + (0xff * G)['toFixed'](0x0) + ',' + (0xff * N)['toFixed'](0x0) + ',' + (0xff * P)['toFixed'](0x0) + ')' : 'rgb(' + O[0x0] + ',' + O[0x1] + ',' + O[0x2] + ')',
                  U += M + '\x20' + C / (B['length'] - 0x1) * 0x64 + '%,',
                  q['push'](M);
              }
              ),
              B = q,
              U = U['substring'](0x0, U['length'] - 0x1) + ')',
              W[S] = {
                  'colors': B,
                  'cssColor': U
              },
              {
                  'colors': B,
                  'cssColor': U
              };
          }
          function j(B) {
              return T(this, undefined, undefined, function*() {
                  if (W[B])
                      return W[B];
                  const S = y['v']['defaultLegendPath']['endsWith']('/') ? y['v']['defaultLegendPath'] : y['v']['defaultLegendPath'] + '/';
                  let U = (yield(yield fetch(S + '/' + B + '.rgb')['catch'](()=>{}
                  ))['text']())['split']('\x0a');
                  if (!U)
                      throw new Error('');
                  return I(U, B);
              });
          }
          function D(B, S, U, q=0x0, J, C) {
              return T(this, undefined, undefined, function*() {
                  if ((0x0,
                  F['ri'])(S) && (0x0,
                  F['ri'])(U)) {
                      (0x0,
                      F['ri'])(J) || (x['kg']['warn'](''),
                      J = 'field' + (0x0,
                      F['hQ'])());
                      try {
                          const {colors: O, cssColor: G} = yield j(B)
                            , N = {
                              'stops': [],
                              'fieldName': J
                          };
                          C && (N['action'] = C);
                          let P = 0x0;
                          for (let M = 0x0; M < O['length']; M += q + 0x1) {
                              const z = S + (U - S) * P / (O['length'] - 0x1);
                              N['stops']['push']({
                                  'stop': O[M],
                                  'value': z
                              }),
                              P++;
                          }
                          return {
                              'stopRules': new Y['NB'](N),
                              'css': G
                          };
                      } catch (Q) {
                          return void x['kg']['error']('' + Q, false);
                      }
                  } else
                      x['kg']['warn']('');
              });
          }
          function V(B, S, U, q) {
              const J = B + '_' + (q ? '1' : '0');
              if (E[J]) {
                  const C = new w['Xm']({
                      'min': S,
                      'max': U,
                      'colorScale': E[J]['canvas']
                  });
                  return C['css'] = W[B]['cssColor'],
                  C;
              }
              try {
                  const {colors: O, cssColor: G} = function(M) {
                      if (W[M])
                          return W[M];
                      const z = y['v']['defaultLegendPath']['endsWith']('/') ? y['v']['defaultLegendPath'] : y['v']['defaultLegendPath'] + '/'
                        , Q = new XMLHttpRequest();
                      return Q['open']('GET', z + '/' + M + '.rgb', false),
                      Q['send'](null),
                      0xc8 !== Q['status'] ? void x['kg']['error']('' + z) : I(Q['responseText']['split']('\x0a'), M);
                  }(B)
                    , N = w['Xm']['createColorScale'](O['length'] > 0xc8 ? 0x200 : 0x100, q, O, undefined, 0xf)
                    , P = new w['Xm']({
                      'colorScale': N,
                      'min': S,
                      'max': U
                  });
                  return P['css'] = G,
                  E[J] = {
                      'canvas': N
                  },
                  P;
              } catch (M) {
                  return void x['kg']['error']('' + M, false);
              }
          }
          function Z(B, S, U, q) {
              return T(this, undefined, undefined, function*() {
                  const J = B + '_' + (q ? '1' : '0');
                  if (E[J]) {
                      const C = new w['Xm']({
                          'min': S,
                          'max': U,
                          'colorScale': E[J]['canvas']
                      });
                      return C['css'] = W[B]['cssColor'],
                      C;
                  }
                  try {
                      const {colors: O, cssColor: G} = yield j(B)
                        , N = w['Xm']['createColorScale'](O['length'] > 0xc8 ? 0x200 : 0x100, q, O, undefined, 0xf)
                        , P = new w['Xm']({
                          'colorScale': N,
                          'min': S,
                          'max': U
                      });
                      return P['css'] = G,
                      E[J] = {
                          'canvas': N
                      },
                      P;
                  } catch (M) {
                      return void x['kg']['error']('' + M, false);
                  }
              });
          }
      }
      ,
      0x1de: (l,K,b)=>{
          'use strict';
          b['d'](K, {
              'm': ()=>H,
              't': ()=>x
          });
          var c = {};
          const H = {
              'transparent': [0x0, 0x0, 0x0, 0x0],
              'aliceblue': [0xf0, 0xf8, 0xff],
              'antiquewhite': [0xfa, 0xeb, 0xd7],
              'aqua': [0x0, 0xff, 0xff],
              'aquamarine': [0x7f, 0xff, 0xd4],
              'azure': [0xf0, 0xff, 0xff],
              'beige': [0xf5, 0xf5, 0xdc],
              'bisque': [0xff, 0xe4, 0xc4],
              'black': [0x0, 0x0, 0x0],
              'blanchedalmond': [0xff, 0xeb, 0xcd],
              'blue': [0x0, 0x0, 0xff],
              'blueviolet': [0x8a, 0x2b, 0xe2],
              'brown': [0xa5, 0x2a, 0x2a],
              'burlywood': [0xde, 0xb8, 0x87],
              'cadetblue': [0x5f, 0x9e, 0xa0],
              'chartreuse': [0x7f, 0xff, 0x0],
              'chocolate': [0xd2, 0x69, 0x1e],
              'coral': [0xff, 0x7f, 0x50],
              'cornflowerblue': [0x64, 0x95, 0xed],
              'cornsilk': [0xff, 0xf8, 0xdc],
              'crimson': [0xdc, 0x14, 0x3c],
              'cyan': [0x0, 0xff, 0xff],
              'darkblue': [0x0, 0x0, 0x8b],
              'darkcyan': [0x0, 0x8b, 0x8b],
              'darkgoldenrod': [0xb8, 0x86, 0xb],
              'darkgray': [0xa9, 0xa9, 0xa9],
              'darkgreen': [0x0, 0x64, 0x0],
              'darkgrey': [0xa9, 0xa9, 0xa9],
              'darkkhaki': [0xbd, 0xb7, 0x6b],
              'darkmagenta': [0x8b, 0x0, 0x8b],
              'darkolivegreen': [0x55, 0x6b, 0x2f],
              'darkorange': [0xff, 0x8c, 0x0],
              'darkorchid': [0x99, 0x32, 0xcc],
              'darkred': [0x8b, 0x0, 0x0],
              'darksalmon': [0xe9, 0x96, 0x7a],
              'darkseagreen': [0x8f, 0xbc, 0x8f],
              'darkslateblue': [0x48, 0x3d, 0x8b],
              'darkslategray': [0x2f, 0x4f, 0x4f],
              'darkslategrey': [0x2f, 0x4f, 0x4f],
              'darkturquoise': [0x0, 0xce, 0xd1],
              'darkviolet': [0x94, 0x0, 0xd3],
              'deeppink': [0xff, 0x14, 0x93],
              'deepskyblue': [0x0, 0xbf, 0xff],
              'dimgray': [0x69, 0x69, 0x69],
              'dimgrey': [0x69, 0x69, 0x69],
              'dodgerblue': [0x1e, 0x90, 0xff],
              'firebrick': [0xb2, 0x22, 0x22],
              'floralwhite': [0xff, 0xfa, 0xf0],
              'forestgreen': [0x22, 0x8b, 0x22],
              'fuchsia': [0xff, 0x0, 0xff],
              'gainsboro': [0xdc, 0xdc, 0xdc],
              'ghostwhite': [0xf8, 0xf8, 0xff],
              'gold': [0xff, 0xd7, 0x0],
              'goldenrod': [0xda, 0xa5, 0x20],
              'gray': [0x80, 0x80, 0x80],
              'green': [0x0, 0x80, 0x0],
              'greenyellow': [0xad, 0xff, 0x2f],
              'grey': [0x80, 0x80, 0x80],
              'honeydew': [0xf0, 0xff, 0xf0],
              'hotpink': [0xff, 0x69, 0xb4],
              'indianred': [0xcd, 0x5c, 0x5c],
              'indigo': [0x4b, 0x0, 0x82],
              'ivory': [0xff, 0xff, 0xf0],
              'khaki': [0xf0, 0xe6, 0x8c],
              'lavender': [0xe6, 0xe6, 0xfa],
              'lavenderblush': [0xff, 0xf0, 0xf5],
              'lawngreen': [0x7c, 0xfc, 0x0],
              'lemonchiffon': [0xff, 0xfa, 0xcd],
              'lightblue': [0xad, 0xd8, 0xe6],
              'lightcoral': [0xf0, 0x80, 0x80],
              'lightcyan': [0xe0, 0xff, 0xff],
              'lightgoldenrodyellow': [0xfa, 0xfa, 0xd2],
              'lightgray': [0xd3, 0xd3, 0xd3],
              'lightgreen': [0x90, 0xee, 0x90],
              'lightgrey': [0xd3, 0xd3, 0xd3],
              'lightpink': [0xff, 0xb6, 0xc1],
              'lightsalmon': [0xff, 0xa0, 0x7a],
              'lightseagreen': [0x20, 0xb2, 0xaa],
              'lightskyblue': [0x87, 0xce, 0xfa],
              'lightslategray': [0x77, 0x88, 0x99],
              'lightslategrey': [0x77, 0x88, 0x99],
              'lightsteelblue': [0xb0, 0xc4, 0xde],
              'lightyellow': [0xff, 0xff, 0xe0],
              'lime': [0x0, 0xff, 0x0],
              'limegreen': [0x32, 0xcd, 0x32],
              'linen': [0xfa, 0xf0, 0xe6],
              'magenta': [0xff, 0x0, 0xff],
              'maroon': [0x80, 0x0, 0x0],
              'mediumaquamarine': [0x66, 0xcd, 0xaa],
              'mediumblue': [0x0, 0x0, 0xcd],
              'mediumorchid': [0xba, 0x55, 0xd3],
              'mediumpurple': [0x93, 0x70, 0xdb],
              'mediumseagreen': [0x3c, 0xb3, 0x71],
              'mediumslateblue': [0x7b, 0x68, 0xee],
              'mediumspringgreen': [0x0, 0xfa, 0x9a],
              'mediumturquoise': [0x48, 0xd1, 0xcc],
              'mediumvioletred': [0xc7, 0x15, 0x85],
              'midnightblue': [0x19, 0x19, 0x70],
              'mintcream': [0xf5, 0xff, 0xfa],
              'mistyrose': [0xff, 0xe4, 0xe1],
              'moccasin': [0xff, 0xe4, 0xb5],
              'navajowhite': [0xff, 0xde, 0xad],
              'navy': [0x0, 0x0, 0x80],
              'oldlace': [0xfd, 0xf5, 0xe6],
              'olive': [0x80, 0x80, 0x0],
              'olivedrab': [0x6b, 0x8e, 0x23],
              'orange': [0xff, 0xa5, 0x0],
              'orangered': [0xff, 0x45, 0x0],
              'orchid': [0xda, 0x70, 0xd6],
              'palegoldenrod': [0xee, 0xe8, 0xaa],
              'palegreen': [0x98, 0xfb, 0x98],
              'paleturquoise': [0xaf, 0xee, 0xee],
              'palevioletred': [0xdb, 0x70, 0x93],
              'papayawhip': [0xff, 0xef, 0xd5],
              'peachpuff': [0xff, 0xda, 0xb9],
              'peru': [0xcd, 0x85, 0x3f],
              'pink': [0xff, 0xc0, 0xcb],
              'plum': [0xdd, 0xa0, 0xdd],
              'powderblue': [0xb0, 0xe0, 0xe6],
              'purple': [0x80, 0x0, 0x80],
              'rebeccapurple': [0x66, 0x33, 0x99],
              'red': [0xff, 0x0, 0x0],
              'rosybrown': [0xbc, 0x8f, 0x8f],
              'royalblue': [0x41, 0x69, 0xe1],
              'saddlebrown': [0x8b, 0x45, 0x13],
              'salmon': [0xfa, 0x80, 0x72],
              'sandybrown': [0xf4, 0xa4, 0x60],
              'seagreen': [0x2e, 0x8b, 0x57],
              'seashell': [0xff, 0xf5, 0xee],
              'sienna': [0xa0, 0x52, 0x2d],
              'silver': [0xc0, 0xc0, 0xc0],
              'skyblue': [0x87, 0xce, 0xeb],
              'slateblue': [0x6a, 0x5a, 0xcd],
              'slategray': [0x70, 0x80, 0x90],
              'slategrey': [0x70, 0x80, 0x90],
              'snow': [0xff, 0xfa, 0xfa],
              'springgreen': [0x0, 0xff, 0x7f],
              'steelblue': [0x46, 0x82, 0xb4],
              'tan': [0xd2, 0xb4, 0x8c],
              'teal': [0x0, 0x80, 0x80],
              'thistle': [0xd8, 0xbf, 0xd8],
              'tomato': [0xff, 0x63, 0x47],
              'turquoise': [0x40, 0xe0, 0xd0],
              'violet': [0xee, 0x82, 0xee],
              'wheat': [0xf5, 0xde, 0xb3],
              'white': [0xff, 0xff, 0xff],
              'whitesmoke': [0xf5, 0xf5, 0xf5],
              'yellow': [0xff, 0xff, 0x0],
              'yellowgreen': [0x9a, 0xcd, 0x32]
          };
          c['clamp'] = function(p, F, y) {
              return p = undefined === p ? 0x0 : p,
              F = undefined !== F ? F : 0x0,
              y = undefined !== y ? y : 0x1,
              Math['max'](F, Math['min'](y, p));
          }
          ,
          c['rgbToHsv'] = function(p) {
              var F = {}
                , y = Number(undefined === p['r'] ? 0x0 : p['r']) / 0xff
                , w = Number(undefined === p['g'] ? 0x0 : p['g']) / 0xff
                , h = Number(undefined === p['b'] ? 0x0 : p['b']) / 0xff
                , u = Math['max'](y, w, h)
                , Y = Math['min'](y, w, h)
                , T = u - Y;
              return F['v'] = u,
              0x0 === F['v'] ? (F['h'] = 0x0,
              F['s'] = 0x0) : (F['s'] = (u - Y) / u,
              0x0 === F['s'] ? F['h'] = 0x0 : (F['h'] = u === y ? (w - h) / T : u === w ? 0x2 + (h - y) / T : 0x4 + (y - w) / T,
              F['h'] *= 0x3c,
              F['h'] < 0x0 && (F['h'] += 0x168))),
              F;
          }
          ,
          c['hsvToRgb'] = function(p) {
              var F = {
                  'r': 0x0,
                  'g': 0x0,
                  'b': 0x0
              }
                , y = c['clamp'](p['h'] || p['hue'], 0x0, 0x168)
                , w = c['clamp'](p['s'] || p['saturation'], 0x0, 0x1)
                , h = c['clamp'](p['v'] || p['value'])
                , Y = w * h
                , T = y / 0x3c
                , X = Y * (0x1 - Math['abs'](T % 0x2 - 0x1));
              T < 0x1 ? (F['r'] = Y,
              F['g'] = X) : T < 0x2 ? (F['r'] = X,
              F['g'] = Y) : T < 0x3 ? (F['g'] = Y,
              F['b'] = X) : T < 0x4 ? (F['g'] = X,
              F['b'] = Y) : T < 0x5 ? (F['r'] = X,
              F['b'] = Y) : (F['r'] = Y,
              F['b'] = X);
              var E = h - Y;
              return F['r'] += E,
              F['g'] += E,
              F['b'] += E,
              F['r'] *= 0xff,
              F['g'] *= 0xff,
              F['b'] *= 0xff,
              F;
          }
          ,
          c['rgbToHsl'] = function(p) {
              var F = c['rgbToHsv'](p)
                , y = {};
              return y['h'] = F['h'],
              y['l'] = (0x2 - F['s']) * F['v'],
              y['s'] = F['s'] * F['v'],
              y['s'] /= y['l'] <= 0x1 ? y['l'] : 0x2 - y['l'],
              y['l'] /= 0x2,
              isNaN(y['s']) && (y['s'] = 0x0),
              y;
          }
          ,
          c['hslToRgb'] = function(p) {
              var F = c['clamp'](p['h'] || p['hue'], 0x0, 0x168)
                , y = c['clamp'](p['s'] || p['saturation'])
                , w = c['clamp'](p['l'] || p['lightness'])
                , h = {};
              return h['h'] = F,
              y *= w < 0.5 ? w : 0x1 - w,
              h['s'] = 0x2 * y / (w + y),
              h['v'] = w + y,
              c['hsvToRgb'](h);
          }
          ,
          c['rgbToLab'] = function(p) {
              var F, y;
              for (y in p = {
                  'r': p['r'] / 0xff,
                  'g': p['g'] / 0xff,
                  'b': p['b'] / 0xff
              })
                  p['hasOwnProperty'](y) && (p[y] > 0.04045 ? p[y] = Math['pow']((p[y] + 0.055) / 1.055, 2.4) : p[y] /= 12.92,
                  p[y] = 0x64 * p[y]);
              F = {
                  'x': 0.4124 * p['r'] + 0.3576 * p['g'] + 0.1805 * p['b'],
                  'y': 0.2126 * p['r'] + 0.7152 * p['g'] + 0.0722 * p['b'],
                  'z': 0.0193 * p['r'] + 0.1192 * p['g'] + 0.9505 * p['b']
              };
              var w = {}
                , h = {
                  'x': 95.047,
                  'y': 0x64,
                  'z': 108.883
              };
              for (y in F)
                  F['hasOwnProperty'](y) && (w[y] = F[y] / h[y],
                  w[y] > 0.008856 ? w[y] = Math['pow'](w[y], 0x1 / 0x3) : w[y] = 7.787 * w[y] + 0x10 / 0x74);
              return {
                  'l': 0x74 * w['y'] - 0x10,
                  'a': 0x1f4 * (w['x'] - w['y']),
                  'b': 0xc8 * (w['y'] - w['z'])
              };
          }
          ,
          c['labToRgb'] = function(p) {
              var F = {}
                , y = {};
              for (var w in (F['y'] = ((p['l'] || p['L']) + 0x10) / 0x74,
              F['x'] = p['a'] / 0x1f4 + F['y'],
              F['z'] = F['y'] - p['b'] / 0xc8,
              F))
                  F['hasOwnProperty'](w) && (Math['pow'](F[w], 0x3) > 0.008856 ? F[w] = Math['pow'](F[w], 0x3) : F[w] = (F[w] - 0x10 / 0x74) / 7.787);
              return F['x'] *= 95.047 / 0x64,
              F['y'] *= 0x1,
              F['z'] *= 1.08883,
              y['r'] = 3.2406 * F['x'] + -1.5372 * F['y'] + -0.4986 * F['z'],
              y['g'] = -0.9689 * F['x'] + 1.8758 * F['y'] + 0.0415 * F['z'],
              y['b'] = 0.0557 * F['x'] + -0.204 * F['y'] + 1.057 * F['z'],
              y['r'] > 0.0031308 ? y['r'] = 1.055 * Math['pow'](y['r'], 0x1 / 2.4) - 0.055 : y['r'] *= 12.92,
              y['g'] > 0.0031308 ? y['g'] = 1.055 * Math['pow'](y['g'], 0x1 / 2.4) - 0.055 : y['g'] *= 12.92,
              y['b'] > 0.0031308 ? y['b'] = 1.055 * Math['pow'](y['b'], 0x1 / 2.4) - 0.055 : y['b'] *= 12.92,
              y['r'] = c['clamp'](0xff * y['r'], 0x0, 0xff),
              y['g'] = c['clamp'](0xff * y['g'], 0x0, 0xff),
              y['b'] = c['clamp'](0xff * y['b'], 0x0, 0xff),
              y;
          }
          ,
          c['parseCss'] = function(p) {
              var F = {};
              if (p['match'](/^#[0-9a-f]{3}$/i))
                  return F = {
                      'r': 0x11 * parseInt(p['charAt'](0x1), 0x10),
                      'g': 0x11 * parseInt(p['charAt'](0x2), 0x10),
                      'b': 0x11 * parseInt(p['charAt'](0x3), 0x10)
                  },
                  c['normalize'](F);
              if (p['match'](/^#[0-9a-f]{6}$/i))
                  return F = {
                      'r': parseInt(p['slice'](0x1, 0x3), 0x10),
                      'g': parseInt(p['slice'](0x3, 0x5), 0x10),
                      'b': parseInt(p['slice'](0x5, 0x7), 0x10)
                  },
                  c['normalize'](F);
              var y = p['match'](/^rgb\(\s*([0-9]+),\s*([0-9]+),\s*([0-9]+)\s*\)$/i);
              if (y)
                  return F = {
                      'r': parseInt(y[0x1], 0xa),
                      'g': parseInt(y[0x2], 0xa),
                      'b': parseInt(y[0x3], 0xa)
                  },
                  c['normalize'](F);
              var w = p['match'](/^rgba\(\s*([0-9]+),\s*([0-9]+),\s*([0-9]+),\s*([0-9\.]+)\s*\)$/i);
              if (w)
                  return F = {
                      'r': parseInt(w[0x1], 0xa),
                      'g': parseInt(w[0x2], 0xa),
                      'b': parseInt(w[0x3], 0xa),
                      'a': parseFloat(w[0x4])
                  },
                  c['normalize'](F);
              throw new TypeError(p + '\x20is\x20not\x20a\x20valid\x20CSS\x20string\x20for\x20Spectra.');
          }
          ,
          c['parsePredefinedColor'] = function(p) {
              return new x(H[p]);
          }
          ,
          c['normalize'] = function(p) {
              p['a'] = undefined === p['a'] ? 0x1 : p['a'];
              var F = p;
              return undefined !== F['hsv'] ? (F = c['hsvToRgb'](F['hsv']))['a'] = p['a'] : undefined !== F['hsl'] ? (F = c['hslToRgb'](F['hsl']))['a'] = p['a'] : undefined !== F['css'] ? F = c['parseCss'](F['css']) : undefined !== F['lab'] && ((F = c['labToRgb'](F['lab']))['a'] = p['a']),
              F['r'] = F['red'] || F['r'],
              F['g'] = F['green'] || F['g'],
              F['b'] = F['blue'] || F['b'],
              F['a'] = F['alpha'] || F['a'],
              F['r'] = c['clamp'](F['r'], 0x0, 0xff),
              F['g'] = c['clamp'](F['g'], 0x0, 0xff),
              F['b'] = c['clamp'](F['b'], 0x0, 0xff),
              F['a'] = c['clamp'](F['a'], 0x0, 0x1),
              F['r1'] = F['r'] / 0xff,
              F['g1'] = F['g'] / 0xff,
              F['Array2DGridDataProvider'] = F['b'] / 0xff,
              F;
          }
          ;
          class x {
              constructor(p) {
                  var F, y, w, h;
                  if (null == p)
                      throw new TypeError('Spectra\x20argument\x20must\x20be\x20defined.');
                  if (this['toString'] = this['rgbaString'],
                  this['toJSON'] = this['rgbaString'],
                  p instanceof x) {
                      for (const u in p)
                          this[u] = p[u];
                  } else {
                      if (p instanceof Array) {
                          const Y = {
                              'r': p[0x0],
                              'g': p[0x1],
                              'b': p[0x2],
                              'a': p['length'] > 0x3 ? p[0x3] : 0x1
                          };
                          this['color'] = c['normalize'](Y);
                      } else {
                          if ('object' == typeof p) {
                              if (undefined !== p['r'] || undefined !== p['red'])
                                  this['color'] = c['normalize']({
                                      'r': null !== (F = p['r']) && undefined !== F ? F : p['red'],
                                      'g': null !== (y = p['g']) && undefined !== y ? y : p['green'],
                                      'b': null !== (w = p['b']) && undefined !== w ? w : p['blue'],
                                      'a': null !== (h = p['a']) && undefined !== h ? h : p['alpha']
                                  });
                              else {
                                  if (undefined !== p['v'] || undefined !== p['value'])
                                      this['color'] = c['normalize']({
                                          'hsv': p,
                                          'a': p['a']
                                      });
                                  else {
                                      if (undefined === p['l'] && undefined === p['lightness'] || undefined === p['s'] && undefined === p['saturation']) {
                                          if (undefined === p['l'] && undefined === p['L'] || undefined === p['a'])
                                              throw new TypeError('Spectra\x20argument\x20' + p + '\x20is\x20invalid.');
                                          this['color'] = c['normalize']({
                                              'lab': p,
                                              'a': p['a'] || p['alpha']
                                          });
                                      } else
                                          this['color'] = c['normalize']({
                                              'hsl': p,
                                              'a': p['a'] || p['alpha']
                                          });
                                  }
                              }
                          } else {
                              if ('string' != typeof p)
                                  throw new TypeError('Spectra\x20argument\x20' + p + '\x20is\x20invalid.');
                              if (p['toLowerCase']()in H)
                                  return c['parsePredefinedColor'](p);
                              this['color'] = c['normalize']({
                                  'css': p
                              });
                          }
                      }
                  }
              }
              ['red'](p) {
                  var F = this['color'];
                  return arguments['length'] ? (F['r'] = p,
                  this['color'] = c['normalize'](F),
                  this) : Math['round'](F['r']);
              }
              ['green'](p) {
                  var F = this['color'];
                  return arguments['length'] ? (F['g'] = p,
                  this['color'] = c['normalize'](F),
                  this) : Math['round'](F['g']);
              }
              ['blue'](p) {
                  var F = this['color'];
                  return arguments['length'] ? (F['b'] = p,
                  this['color'] = c['normalize'](F),
                  this) : Math['round'](F['b']);
              }
              ['hue'](p) {
                  var F = c['rgbToHsv'](this['color']);
                  return arguments['length'] ? (F['h'] = p,
                  this['color'] = c['normalize']({
                      'hsv': F,
                      'a': this['color']['a']
                  }),
                  this) : Math['round'](F['h']);
              }
              ['saturationv'](p) {
                  var F = c['rgbToHsv'](this['color']);
                  return arguments['length'] ? (F['s'] = p,
                  this['color'] = c['normalize']({
                      'hsv': F,
                      'a': this['color']['a']
                  }),
                  this) : F['s'];
              }
              ['value'](p) {
                  var F = c['rgbToHsv'](this['color']);
                  return arguments['length'] ? (F['v'] = p,
                  this['color'] = c['normalize']({
                      'hsv': F,
                      'a': this['color']['a']
                  }),
                  this) : F['v'];
              }
              ['saturation'](p) {
                  var F = c['rgbToHsl'](this['color']);
                  return arguments['length'] ? (F['s'] = p,
                  this['color'] = c['normalize']({
                      'hsl': F,
                      'a': this['color']['a']
                  }),
                  this) : F['s'];
              }
              ['lightness'](p) {
                  var F = c['rgbToHsl'](this['color']);
                  return arguments['length'] ? (F['l'] = p,
                  this['color'] = c['normalize']({
                      'hsl': F,
                      'a': this['color']['a']
                  }),
                  this) : F['l'];
              }
              ['alpha'](p) {
                  var F = this['color'];
                  return arguments['length'] ? (F['a'] = p,
                  this) : F['a'];
              }
              ['hexNumber']() {
                  return '0x' + ('0' + this['red']()['toString'](0x10))['slice'](-0x2) + ('0' + this['green']()['toString'](0x10))['slice'](-0x2) + ('0' + this['blue']()['toString'](0x10))['slice'](-0x2);
              }
              ['hexWidthAlpha']() {
                  var p = ('0' + Math['round'](0xff * this['alpha']())['toString'](0x10))['slice'](-0x2);
                  return this['hex']() + p;
              }
              ['hex']() {
                  return '#' + ('0' + this['red']()['toString'](0x10))['slice'](-0x2) + ('0' + this['green']()['toString'](0x10))['slice'](-0x2) + ('0' + this['blue']()['toString'](0x10))['slice'](-0x2);
              }
              ['rgbaString']() {
                  var p, F;
                  return 'rgba(' + this['red']() + ',' + this['green']() + ',' + this['blue']() + ',' + (null === (F = (p = this['alpha']())['toFixed']) || undefined === F ? undefined : F['call'](p, 0x2)) + ')';
              }
              ['hslString']() {
                  return 'hsl(' + this['hue']() + ',' + this['saturation']() + ',' + Math['round'](0x64 * this['lightness']()) / 0x64 + ')';
              }
              ['hslaString']() {
                  return 'hsla(' + this['hue']() + ',' + this['saturation']() + ',' + Math['round'](0x64 * this['lightness']()) / 0x64 + ',' + this['alpha']() + ')';
              }
              ['rgbNumber']() {
                  return this['red']() << 0x10 | this['green']() << 0x8 | this['blue']();
              }
              ['labObject']() {
                  return c['rgbToLab'](this['color']);
              }
              ['glNumberArray']() {
                  return [this['color']['r1'], this['color']['g1'], this['color']['Array2DGridDataProvider'], this['alpha']()];
              }
              ['getColor']() {
                  return this['color'];
              }
              ['equals'](p) {
                  var F = p;
                  return arguments['length'] < 0x1 ? this === F : this['near'](F, 0x0);
              }
              ['near'](p, F) {
                  var y = this
                    , w = p
                    , h = (F = Math['abs'](undefined === F ? 0x0 : F)) / 0x64 * 0xff;
                  return Math['abs'](w['red']() - y['red']()) <= h && Math['abs'](w['green']() - y['green']()) <= h && Math['abs'](w['blue']() - y['blue']()) <= h && Math['abs'](w['alpha']() - y['alpha']()) <= F / 0x64;
              }
              ['complement']() {
                  var p = new x(this['color']);
                  return p['hue']((p['hue']() + 0xb4) % 0x168),
                  p;
              }
              ['negate']() {
                  var p = new x(this['color']);
                  return p['red'](0xff - p['red']()),
                  p['green'](0xff - p['green']()),
                  p['blue'](0xff - p['blue']()),
                  p;
              }
              ['lighten'](p) {
                  var F = new x(this['color'])
                    , y = c['clamp'](F['lightness']() + p / 0x64, 0x0, 0x1);
                  return F['lightness'](y),
                  F;
              }
              ['darken'](p) {
                  return this['lighten'](-p);
              }
              ['randomColorRange'](p) {
                  var F = (0x2 * Math['random']() - 0x1) * p
                    , y = new x(this['color']);
                  return y['lighten'](F);
              }
              ['saturate'](p) {
                  var F = p / 0x64
                    , y = new x(this['color']);
                  return y['saturation'](y['saturation']() + F),
                  y;
              }
              ['desaturate'](p) {
                  var F = p / 0x64
                    , y = new x(this['color']);
                  return y['saturation'](y['saturation']() - F),
                  y;
              }
              ['fadeIn'](p) {
                  var F = p / 0x64
                    , y = new x(this['color']);
                  return y['alpha'](y['alpha']() + F),
                  y;
              }
              ['fadeOut'](p) {
                  var F = p / 0x64
                    , y = new x(this['color']);
                  return y['alpha'](y['alpha']() - F),
                  y;
              }
              ['luma']() {
                  return 0.2126 * this['red']() + 0.7152 * this['green']() + 0.0722 * this['blue']();
              }
              ['grayscale']() {
                  return this['desaturate'](0x64);
              }
              ['isDark']() {
                  return (0x12b * this['red']() + 0x24b * this['green']() + 0x90 * this['blue']()) / 0x3e8 < 131.5;
              }
              ['isLight']() {
                  return !this['isDark']();
              }
              ['mix'](p, F) {
                  p = new x(p);
                  var y = arguments['length'] < 0x2 ? 0.5 : F / 0x64;
                  return new x({
                      'r': this['red']() * (0x1 - y) + p['red']() * y,
                      'g': this['green']() * (0x1 - y) + p['green']() * y,
                      'b': this['blue']() * (0x1 - y) + p['blue']() * y,
                      'a': this['alpha']() * (0x1 - y) + p['alpha']() * y
                  });
              }
              ['contrast'](p) {
                  return p = new x(p),
                  (Math['max'](this['red'](), p['red']()) - Math['min'](this['red'](), p['red']()) + Math['max'](this['green'](), p['green']()) - Math['min'](this['green'](), p['green']()) + Math['max'](this['blue'](), p['blue']()) - Math['min'](this['blue'](), p['blue']())) / 0x2fd;
              }
              ['gradient'](p, F) {
                  p = new x(p);
                  for (var y = [], w = this['red'](), Y = this['green'](), T = this['blue'](), X = (p['red']() - this['red']()) / (F - 0x1), E = (p['green']() - this['green']()) / (F - 0x1), f = (p['blue']() - this['blue']()) / (F - 0x1), W = 0x0; W < F; W++)
                      y['push'](new x({
                          'r': w,
                          'g': Y,
                          'b': T
                      })),
                      w += X,
                      Y += E,
                      T += f;
                  return y;
              }
              ['harmony'](p, F) {
                  F = 'number' == typeof F ? Math['abs'](parseInt(F, 0xa)) : 0x0;
                  var y = []
                    , w = c['rgbToHsv'](this['color'])
                    , h = [0x0, 0xb4];
                  switch (p) {
                  case 'analogous':
                      h = [0x0, 0x1e, 0x3c];
                      break;
                  case 'triad':
                      h = [0x0, 0x78, 0xf0];
                      break;
                  case 'split-complementary':
                      h = [0x0, 0x96, 0xd2];
                      break;
                  case 'rectangle':
                      h = [0x0, 0x3c, 0xb4, 0xf0];
                      break;
                  case 'square':
                      h = [0x0, 0x5a, 0xb4, 0x10e];
                      break;
                  case 'complementary':
                      h = [0x0, 0xb4];
                  }
                  for (var Y = h['length'], T = h[F % Y], X = 0x0; X < Y; X++)
                      y['push'](new x({
                          'h': (w['h'] + h[X] - T) % 0x168,
                          's': w['s'],
                          'v': w['v'],
                          'a': this['color']['a']
                      }));
                  return y;
              }
              static['random']() {
                  return new x({
                      'r': Math['floor'](0xff * Math['random']()),
                      'g': Math['floor'](0xff * Math['random']()),
                      'b': Math['floor'](0xff * Math['random']())
                  });
              }
          }
      }
      ,
      0x260: (K,b,c)=>{
          'use strict';
          c['d'](b, {
              'DY': ()=>H,
              'Mg': ()=>x,
              'NB': ()=>T
          });
          var H, x, p = c(0x39b), F = c(0xfb), y = c(0x1), w = c(0x346), Y = c(0x133);
          !function(X) {
              X['greater'] = 'greater',
              X['less'] = 'less',
              X['inside'] = 'inside',
              X['outside'] = 'outside';
          }(H || (H = {})),
          function(X) {
              X['class'] = 'class',
              X['less'] = 'less',
              X['less_and_equal'] = 'less_and_equal',
              X['greater'] = 'greater',
              X['greater_and_equal'] = 'greater_and_equal',
              X['unique'] = 'unique',
              X['equal'] = 'equal';
          }(x || (x = {}));
          class T {
              constructor(X, E) {
                  this['options'] = X,
                  this['stopConverter'] = E,
                  X['fieldName'] && X['stops'] || (p['kg']['warn'](''),
                  p['kg']['error'](X)),
                  this['options']instanceof T && (this['options'] = {
                      'stops': this['options']['stops'],
                      'fieldName': this['options']['fieldName'],
                      'action': this['options']['action']
                  }),
                  this['options']['action'] === x['unique'] || this['options']['action'] === x['equal'] ? (this['getCurrentRule'] = this['_getUniqueCurrentRule'],
                  this['getPreRule'] = this['_getUniquePreRule'],
                  this['getNextRule'] = this['_getUniqueNextRule'],
                  this['getRuleIndex'] = this['_getUniqueRuleIndex'],
                  this['getDesc'] = this['_getUniqueDesc']) : this['options']['action'] === x['greater'] ? (this['getCurrentRule'] = this['_getGreaterCurrentRule'],
                  this['getPreRule'] = this['_getGreaterPreRule'],
                  this['getNextRule'] = this['_getGreaterNextRule'],
                  this['getRuleIndex'] = this['_getGreaterRuleIndex'],
                  this['getDesc'] = this['_getGreaterDesc']) : this['options']['action'] === x['greater_and_equal'] ? (this['getCurrentRule'] = this['_getGreaterAndEqualCurrentRule'],
                  this['getPreRule'] = this['_getGreaterAndEqualPreRule'],
                  this['getNextRule'] = this['_getGreaterAndEqualNextRule'],
                  this['getRuleIndex'] = this['_getGreaterAndEqualRuleIndex'],
                  this['getDesc'] = this['_getGreaterAndEqualDesc']) : this['options']['action'] === x['less'] ? (this['getCurrentRule'] = this['_getLessCurrentRule'],
                  this['getPreRule'] = this['_getLessPreRule'],
                  this['getNextRule'] = this['_getLessNextRule'],
                  this['getRuleIndex'] = this['_getLessRuleIndex'],
                  this['getDesc'] = this['_getLessDesc']) : (this['getCurrentRule'] = this['_getClassCurrentRule'],
                  this['getPreRule'] = this['_getClassPreRule'],
                  this['getNextRule'] = this['_getClassNextRule'],
                  this['getRuleIndex'] = this['_getClassRuleIndex'],
                  this['getDesc'] = this['_getClassDesc']),
                  this['originalOptions'] = JSON['parse'](JSON['stringify'](this['options'])),
                  (0x0,
                  y['Ov'])(this, this['options']),
                  this['action'] || (this['action'] = x['class']),
                  this['deserialize']();
              }
              ['deserialize']() {
                  let X = 0x0;
                  for (const E of this['stops']) {
                      if ('string' == typeof E['stop'] && E['stop']['trim']()['indexOf'](w['v']['fieldLoaderIndicator']) > 0x0) {
                          const f = E['stop']['split'](w['v']['fieldLoaderIndicator'])
                            , W = f[0x0]
                            , I = f[0x1]['split']('?')
                            , j = (0x0,
                          F['nA'])(I[0x0]);
                          let D;
                          j || (console['warn']('loader' + f[0x1]),
                          E['stop'] = W),
                          I['length'] > 0x1 && (D = (0x0,
                          Y['vl'])(I[0x1]));
                          const V = j(W, D);
                          null == V && p['kg']['warn']('stop\x20ruleloader'),
                          E['stop'] = V;
                      }
                      E['stop'] = this['stopConverter'] ? this['stopConverter'](E)['stop'] : E['stop'],
                      E['idx'] = X++;
                  }
              }
              static['updateStopValuesByMaxMin'](X, E, f, W=0x1, I=0x0, j=-0x1) {
                  if (j = X['length'] - 0x1 + j,
                  E = parseFloat(E),
                  f = parseFloat(f),
                  !(0x0,
                  y['ri'])(E) || !(0x0,
                  y['ri'])(f))
                      return void p['kg']['warn']('');
                  const D = parseFloat((0x1 * (f - E) / (j - I))['toFixed'](W));
                  for (let V = I; V < j; V++)
                      X[V]['value'] = E + parseFloat(((V - I) * D)['toFixed'](W));
                  X[j]['value'] = f;
              }
              ['updateValuesByMaxMin'](X, E, f=0x1, W=0x0, I=-0x1) {
                  T['updateStopValuesByMaxMin'](this['stops'], X, E, f, W, I);
              }
              ['getRule'](X, E='current') {
                  if (!this['stops'] || 0x0 === this['stops']['length'])
                      throw new Error('');
                  return 'next' === E ? this['getNextRule'](X) : 'pre' === E ? this['getPreRule'](X) : this['getCurrentRule'](X);
              }
              ['getVal'](X, E) {
                  let f = {}
                    , W = E(X)
                    , I = 0x0;
                  for (let j of this['stops']) {
                      if (W === E(j['stop']))
                          break;
                      I++;
                  }
                  return 0x0 === I ? f['max'] = this['stops'][0x0] : I >= this['stops']['length'] - 0x1 ? f['min'] = this['stops'][this['stops']['length'] - 0x1] : (f['min'] = this['stops'][I - 0x1],
                  f['max'] = this['stops'][I]),
                  f;
              }
              ['getVals']() {
                  return this['stops']['map'](X=>X['value']);
              }
              ['getStops']() {
                  return this['stops']['map'](X=>X['stop']);
              }
              ['clone'](X=false, E=false) {
                  const f = E ? this['originalOptions'] : this['options'];
                  return new T(X ? JSON['parse'](JSON['stringify'](f)) : f);
              }
              ['reset']() {
                  (0x0,
                  y['Ov'])(this, this['originalOptions']),
                  this['deserialize']();
              }
              ['setOpacityByIndex'](X, E, f, W) {
                  if (X < 0x0 || X >= this['stops']['length'])
                      return void p['kg']['warn']('stop');
                  if (W = (0x0,
                  y['En'])(W, this['stops']['length'] - 0x1),
                  f = (0x0,
                  y['En'])(f, 0x0),
                  (0x0,
                  y['ri'])(W) && (W < 0x0 || W >= this['stops']['length']))
                      return void p['kg']['warn']('stop');
                  if (X > W)
                      return void p['kg']['warn']('');
                  const I = (j,D)=>{
                      for (let V = j; V <= D; V++)
                          this['stops'][V]['stop']['alpha'](f);
                  }
                  ;
                  E === H['greater'] ? I(X, this['stops']['length'] - 0x1) : E === H['less'] ? I(0x0, X - 0x1) : E === H['inside'] ? I(X + 0x1, W) : (I(0x0, X - 0x1),
                  I(W, this['stops']['length'] - 0x1));
              }
              ['_getUniqueCurrentRule'](X) {
                  for (let E of this['stops'])
                      if (X == E['value'])
                          return E;
                  return this['stops'][this['stops']['length'] - 0x1];
              }
              ['_getUniquePreRule'](X) {
                  for (let E = 0x0; E < this['stops']['length']; E++) {
                      let f = this['stops'][E];
                      if (X == f['value'])
                          return 0x0 === E ? f : this['stops'][E - 0x1];
                  }
                  return this['stops'][this['stops']['length'] - 0x1];
              }
              ['_getUniqueNextRule'](X) {
                  for (let E = 0x0; E < this['stops']['length']; E++) {
                      let f = this['stops'][E];
                      if (X == f['value'])
                          return E === this['stops']['length'] - 0x1 ? f : this['stops'][E + 0x1];
                  }
                  return this['stops'][this['stops']['length'] - 0x1];
              }
              ['_getUniqueRuleIndex'](X) {
                  for (let E = 0x0; E < this['stops']['length']; E++)
                      if (X == this['stops'][E]['value'])
                          return E;
                  return this['stops']['length'] - 0x1;
              }
              ['_getUniqueDesc'](X) {
                  return this['getCurrentRule'](X)['value']['toString']();
              }
              ['_getClassCurrentRule'](X) {
                  for (let E of this['stops'])
                      if (X <= E['value'])
                          return E;
                  return this['stops'][this['stops']['length'] - 0x1];
              }
              ['_getClassPreRule'](X) {
                  for (let E = 0x0; E < this['stops']['length']; E++) {
                      let f = this['stops'][E];
                      if (X <= f['value'])
                          return 0x0 === E ? f : this['stops'][E - 0x1];
                  }
                  return this['stops'][this['stops']['length'] - 0x1];
              }
              ['_getClassNextRule'](X) {
                  for (let E = 0x0; E < this['stops']['length']; E++) {
                      let f = this['stops'][E];
                      if (X <= f['value'])
                          return E === this['stops']['length'] - 0x1 ? f : this['stops'][E + 0x1];
                  }
                  return this['stops'][this['stops']['length'] - 0x1];
              }
              ['_getClassRuleIndex'](X) {
                  for (let E = 0x0; E < this['stops']['length']; E++)
                      if (X <= this['stops'][E]['value'])
                          return E;
                  return this['stops']['length'] - 0x1;
              }
              ['_getClassDesc'](X) {
                  let E = this['getPreRule'](X);
                  if (!E || E['value'] === X)
                      return '<=' + X;
                  let f = this['getNextRule'](X);
                  return f && f['value'] !== X ? E['value'] + '-' + X : '>' + E['value'];
              }
              ['_getGreaterCurrentRule'](X) {
                  for (let E = this['stops']['length'] - 0x1; E >= 0x0; E--)
                      if (X > this['stops'][E]['value'])
                          return this['stops'][E];
                  return this['stops'][this['stops']['length'] - 0x1];
              }
              ['_getGreaterPreRule'](X) {
                  for (let E = this['stops']['length'] - 0x1; E >= 0x0; E--) {
                      let f = this['stops'][E];
                      if (X > f['value'])
                          return 0x0 === E ? f : this['stops'][E - 0x1];
                  }
                  return this['stops'][this['stops']['length'] - 0x1];
              }
              ['_getGreaterNextRule'](X) {
                  for (let E = this['stops']['length'] - 0x1; E >= 0x0; E--) {
                      let f = this['stops'][E];
                      if (X > f['value'])
                          return E === this['stops']['length'] - 0x1 ? f : this['stops'][E + 0x1];
                  }
                  return this['stops'][this['stops']['length'] - 0x1];
              }
              ['_getGreaterRuleIndex'](X) {
                  for (let E = this['stops']['length'] - 0x1; E >= 0x0; E--)
                      if (X > this['stops'][E]['value'])
                          return E;
                  return 0x0;
              }
              ['_getGreaterDesc'](X) {
                  let E = this['getNextRule'](X);
                  return E && E['value'] !== X ? X + '-' + E['value'] : '>' + X;
              }
              ['_getGreaterAndEqualCurrentRule'](X) {
                  for (let E = this['stops']['length'] - 0x1; E >= 0x0; E--)
                      if (X >= this['stops'][E]['value'])
                          return this['stops'][E];
                  return this['stops'][this['stops']['length'] - 0x1];
              }
              ['_getGreaterAndEqualPreRule'](X) {
                  for (let E = this['stops']['length'] - 0x1; E >= 0x0; E--) {
                      let f = this['stops'][E];
                      if (X >= f['value'])
                          return 0x0 === E ? f : this['stops'][E - 0x1];
                  }
                  return this['stops'][this['stops']['length'] - 0x1];
              }
              ['_getGreaterAndEqualNextRule'](X) {
                  for (let E = this['stops']['length'] - 0x1; E >= 0x0; E--) {
                      let f = this['stops'][E];
                      if (X >= f['value'])
                          return E === this['stops']['length'] - 0x1 ? f : this['stops'][E + 0x1];
                  }
                  return this['stops'][this['stops']['length'] - 0x1];
              }
              ['_getGreaterAndEqualRuleIndex'](X) {
                  for (let E = this['stops']['length'] - 0x1; E >= 0x0; E--)
                      if (X >= this['stops'][E]['value'])
                          return E;
                  return 0x0;
              }
              ['_getGreaterAndEqualDesc'](X) {
                  let E = this['getNextRule'](X);
                  return E && E['value'] !== X ? X + '-' + E['value'] : '>=' + X;
              }
              ['_getLessCurrentRule'](X) {
                  for (let E of this['stops'])
                      if (X < E['value'])
                          return E;
                  return this['stops'][this['stops']['length'] - 0x1];
              }
              ['_getLessPreRule'](X) {
                  for (let E = 0x0; E < this['stops']['length']; E++) {
                      let f = this['stops'][E];
                      if (X < f['value'])
                          return 0x0 === E ? f : this['stops'][E - 0x1];
                  }
                  return this['stops'][this['stops']['length'] - 0x1];
              }
              ['_getLessNextRule'](X) {
                  for (let E = 0x0; E < this['stops']['length']; E++) {
                      let f = this['stops'][E];
                      if (X < f['value'])
                          return E === this['stops']['length'] - 0x1 ? f : this['stops'][E + 0x1];
                  }
                  return this['stops'][this['stops']['length'] - 0x1];
              }
              ['_getLessRuleIndex'](X) {
                  for (let E = 0x0; E < this['stops']['length']; E++)
                      if (X < this['stops'][E]['value'])
                          return E;
                  return this['stops']['length'] - 0x1;
              }
              ['_getLessDesc'](X) {
                  let E = this['getPreRule'](X);
                  if (!E || E['value'] === X)
                      return '<' + X;
                  let f = this['getNextRule'](X);
                  return f && f['value'] !== X ? E['value'] + '-' + X : '>' + E['value'];
              }
          }
      }
      ,
      0x133: (l,K,i)=>{
          'use strict';
          i['d'](K, {
              '$P': ()=>F,
              '$k': ()=>s,
              'LH': ()=>r,
              'Uw': ()=>w,
              'it': ()=>p,
              'lW': ()=>y,
              'vl': ()=>x
          });
          var b = i(0x39b)
            , e = i(0x13c)
            , c = i(0xfb)
            , H = i(0x346)
            , t = i(0x1de);
          function x(h, u='&', Y='=') {
              const T = {};
              if (!h || 0x0 === h['trim']()['length'])
                  return T;
              const X = h['split'](u)
                , E = [];
              for (var f = 0x0; f < X['length']; f++) {
                  var W = X[f]['indexOf'](Y);
                  let I, j;
                  -0x1 == W ? (I = X[f],
                  j = undefined) : (I = X[f]['substring'](0x0, W),
                  j = X[f]['substring'](W + 0x1)),
                  T[I] = j,
                  E['push'](I);
              }
              return T['__order'] = E,
              T;
          }
          function p(h) {
              var u;
              if (null != h) {
                  if ('string' == typeof h) {
                      if (h = h['trim'](),
                      0x0 === h['length'] || h['startsWith'](H['v']['fieldPropertiesIndicator']) || h['startsWith'](H['v']['fieldLoaderIndicator']))
                          return h;
                      if (h['indexOf'](H['v']['fieldLoaderIndicator']) > 0x0) {
                          const Y = h['split'](H['v']['fieldLoaderIndicator'])
                            , T = Y[0x1]['split']('?')
                            , X = (0x0,
                          c['nA'])(T[0x0]);
                          if (X) {
                              if (T['length'] > 0x1) {
                                  const E = x(T[0x1]);
                                  h = X(Y[0x0], E);
                              } else
                                  h = X(Y[0x0], {});
                          } else
                              b['kg']['warn']('' + Y[0x0] + 'loader'),
                              h = Y[0x0];
                      } else
                          e['Zc']['hasResource'](h) && (h = null === (u = e['Zc']['getResource'](h)) || undefined === u ? undefined : u['instance']);
                      if ('string' == typeof h && h['trim']()['startsWith'](H['v']['functionIndicator'])) {
                          h = h['trim']();
                          const f = eval(h['substring'](H['v']['functionIndicator']['length']));
                          return 'function' == typeof f ? (...W)=>f(...W) : h;
                      }
                      return h;
                  }
                  return h;
              }
              b['kg']['warn']('');
          }
          const F = h=>h['startsWith']('0x') ? (h = '#' + h['slice'](0x2),
          new t['t'](h)) : new t['t'](h)
            , y = h=>{
              const u = '#' + h['toString'](0x10);
              return F(u);
          }
            , r = h=>0x3 === h['length'] ? new t['t']({
              'r': h[0x0],
              'g': h[0x1],
              'b': h[0x2]
          }) : new t['t']({
              'r': h[0x0],
              'g': h[0x1],
              'b': h[0x2],
              'a': h[0x3]
          });
          class w {
              constructor(h) {
                  this['sourceOptions'] = h,
                  this['_cache'] = {},
                  this['styleName'] = 'qeStyle';
              }
              ['isStyle']() {
                  return true;
              }
              ['getPublicKeys']() {
                  const h = Object['keys'](this)
                    , u = [];
                  for (const Y of h)
                      Y['startsWith']('_') || u['push'](Y);
                  return u;
              }
              ['clearCaches']() {
                  this['_cache'] = {};
                  const h = this['getPublicKeys']();
                  for (const u of h) {
                      if ('string' != typeof u) {
                          b['kg']['warn']('key');
                          continue;
                      }
                      const Y = this[u]
                        , T = X=>{
                          if (undefined !== X && null != X) {
                              if (X['isStyle'] && X['isStyle']())
                                  X['clearCaches'] && X['clearCaches']();
                              else {
                                  if (X instanceof Array) {
                                      for (const E of X)
                                          T(E);
                                  }
                              }
                          }
                      }
                      ;
                      T(Y);
                  }
              }
              ['update'](h, u=false) {
                  if (this['_cache'] = {},
                  u) {
                      const T = this['getPublicKeys']();
                      for (const X of T)
                          this[X] = undefined;
                      return void this['_update'](h, true);
                  }
                  const Y = Object['assign']({}, h);
                  for (const E of Object['keys'](h))
                      undefined === h[E] && this[E] && (this[E] = undefined,
                      delete Y[E]);
                  this['_update'](Y, false);
              }
              ['getPlaneOptions'](h, u=true, Y) {
                  const T = this['_createCacheId'](h);
                  if (u && undefined !== this['_cache'][T])
                      return this['_cache'][T];
                  const X = {}
                    , E = this['getPublicKeys']();
                  for (const f of E) {
                      if ('string' != typeof f) {
                          b['kg']['warn']('key');
                          continue;
                      }
                      const W = this[f]
                        , I = j=>{
                          if (undefined !== j && null != j) {
                              if (j['isStyle'] && j['isStyle']())
                                  return j['getPlaneOptions'](h, u, Y);
                              if (j instanceof Array) {
                                  const D = [];
                                  for (const V of j)
                                      D['push'](I(V));
                                  return D;
                              }
                              return 'function' == typeof j ? j(h, Y) : j;
                          }
                      }
                      ;
                      X[f] = I(W);
                  }
                  return u && T && (this['_cache'][T] = X),
                  X;
              }
          }
          const s = h=>(h['stop']instanceof t['t'] || ('string' == typeof h['stop'] ? h['stop'] = F(h['stop']) : 'number' == typeof h['stop'] ? h['stop'] = y(h['stop']) : h['stop']instanceof Array ? h['stop'] = r(h['stop']) : 'object' != typeof h['stop'] || undefined === h['stop']['r'] && undefined === h['stop']['red'] ? b['kg']['error']('' + h['stop']) : h['stop'] = new t['t'](h['stop'])),
          h);
      }
      ,
      0x60: (l,K,i)=>{
          'use strict';
          var b;
          i['d'](K, {
              'U': ()=>b
          }),
          function(c) {
              c[c['Int8'] = 0x0] = 'Int8',
              c[c['UInt8'] = 0x1] = 'UInt8',
              c[c['Int16'] = 0x2] = 'Int16',
              c[c['UInt16'] = 0x3] = 'UInt16',
              c[c['Int32'] = 0x4] = 'Int32',
              c[c['UInt32'] = 0x5] = 'UInt32',
              c[c['Float32'] = 0x6] = 'Float32',
              c[c['Float64'] = 0x7] = 'Float64';
          }(b || (b = {}));
      }
      ,
      0x24d: (l,K,b)=>{
          'use strict';
          b['d'](K, {
              'r': ()=>x
          });
          var c = b(0x393)
            , H = b(0x1);
          class x extends c['c'] {
              constructor(p) {
                  super(),
                  this['eventNames'] = {
                      'tChanged': 'tChanged',
                      'zChanged': 'zChanged',
                      'tzChanged': 'tzChanged',
                      'iTChanged': 'iTChanged',
                      'iZChanged': 'iZChanged',
                      'iTZChanged': 'iTZChanged',
                      'activeTZDataUpated': 'activeTZDataUpated'
                  },
                  this['meta'] = {},
                  this['_currentTIdx'] = 0x0,
                  this['_currentZIdx'] = 0x0,
                  this['grids'] = [],
                  this['options'] = (0x0,
                  H['Ov'])(this['options'], p, {
                      'maxTimeCount': 0x0
                  });
              }
              ['addGridTo'](p, F, y, w, h, u) {
                  F = parseInt(F),
                  y = parseInt(y);
                  const Y = this['getIntTIdx']()
                    , T = this['getIntZIdx']();
                  return u[F] = u[F] || [],
                  u[F][y] = p,
                  this['gridOptions']['tCount'] = u['length'],
                  (0x0,
                  H['ri'])(w) && this['gridOptions']['zValues'] && (this['gridOptions']['zValues'][y] = w),
                  F === Y && y === T ? this['fire'](this['eventNames']['activeTZDataUpated'], {
                      'firer': this,
                      'msg': this
                  }) : h && (this['lock'](),
                  this['currentTIdx'] = F,
                  this['currentZIdx'] = y,
                  this['unlock']()),
                  this;
              }
              get['currentTIdx']() {
                  return this['_currentTIdx'];
              }
              set['currentTIdx'](p) {
                  if (this['grids'] && p >= this['grids']['length'])
                      return;
                  if (p === this['currentTIdx'])
                      return;
                  const F = this['getIntTIdx']();
                  this['_currentTIdx'] = p,
                  F !== this['getIntTIdx']() ? (this['fire'](this['eventNames']['iTChanged'], {
                      'firer': this,
                      'msg': this
                  }),
                  this['fire'](this['eventNames']['iTZChanged'], {
                      'firer': this,
                      'msg': this
                  })) : (this['fire'](this['eventNames']['tChanged'], {
                      'firer': this,
                      'msg': this
                  }),
                  this['fire'](this['eventNames']['tzChanged'], {
                      'firer': this,
                      'msg': this
                  }));
              }
              get['currentZIdx']() {
                  return this['_currentZIdx'];
              }
              set['currentZIdx'](p) {
                  var F;
                  if (this['grids'] && p >= (null === (F = this['grids'][this['getIntTIdx']()]) || undefined === F ? undefined : F['length']))
                      return;
                  if (p === this['currentZIdx'])
                      return;
                  const y = this['getIntZIdx']();
                  this['_currentZIdx'] = p,
                  y !== this['getIntZIdx']() ? (this['fire'](this['eventNames']['iZChanged'], {
                      'firer': this,
                      'msg': this
                  }),
                  this['fire'](this['eventNames']['iTZChanged'], {
                      'firer': this,
                      'msg': this
                  })) : (this['fire'](this['eventNames']['zChanged'], {
                      'firer': this,
                      'msg': this
                  }),
                  this['fire'](this['eventNames']['tzChanged'], {
                      'firer': this,
                      'msg': this
                  }));
              }
              ['centerLon']() {
                  return (this['gridOptions']['xStart'] + this['gridOptions']['xEnd']) / 0x2;
              }
              ['centerLat']() {
                  return (this['gridOptions']['yStart'] + this['gridOptions']['yEnd']) / 0x2;
              }
              ['centerZ']() {
                  var p, F, y;
                  return (null === (p = this['gridOptions']) || undefined === p ? undefined : p['zValues']['length']) > 0x1 ? (this['gridOptions']['zValues'][0x0] + this['gridOptions']['zValues'][this['gridOptions']['zValues']['length'] - 0x1]) / 0x2 : null !== (y = null === (F = this['gridOptions']) || undefined === F ? undefined : F['zValues'][0x0]) && undefined !== y ? y : 0x0;
              }
              ['center']() {
                  return {
                      'lon': this['centerLon'](),
                      'lat': this['centerLat'](),
                      'z': this['centerZ']()
                  };
              }
              ['getGrid'](p, F) {
                  var y, w;
                  return undefined === p && (p = this['getIntTIdx']()),
                  undefined === F && (F = this['getIntZIdx']()),
                  null === (w = null === (y = this['grids']) || undefined === y ? undefined : y[p]) || undefined === w ? undefined : w[F];
              }
              ['allGrids']() {
                  return this['grids'];
              }
              ['updateGrid'](p, F, y, w, h) {
                  return this['addGridTo'](p, F, y, w, h, this['allGrids']());
              }
              ['getIntTIdx']() {
                  return parseInt(this['_currentTIdx']);
              }
              ['getIntZIdx']() {
                  return parseInt(this['_currentZIdx']);
              }
              ['onTChanged'](p) {
                  return this['on'](this['eventNames']['tChanged'], p),
                  this;
              }
              ['onZChanged'](p) {
                  return this['on'](this['eventNames']['zChanged'], p),
                  this;
              }
              ['onTZChanged'](p) {
                  return this['on'](this['eventNames']['tzChanged'], p),
                  this;
              }
              ['onIntTChanged'](p) {
                  return this['on'](this['eventNames']['iTChanged'], p),
                  this;
              }
              ['onIntZChanged'](p) {
                  return this['on'](this['eventNames']['iZChanged'], p),
                  this;
              }
              ['onIntTZChanged'](p) {
                  return this['on'](this['eventNames']['iTZChanged'], p),
                  this;
              }
              ['offTChanged'](p) {
                  return this['off'](this['eventNames']['tChanged'], p),
                  this;
              }
              ['offZChanged'](p) {
                  return this['off'](this['eventNames']['zChanged'], p),
                  this;
              }
              ['offTZChanged'](p) {
                  return this['off'](this['eventNames']['tzChanged'], p),
                  this;
              }
              ['offIntTChanged'](p) {
                  return this['off'](this['eventNames']['iTChanged'], p),
                  this;
              }
              ['offIntZChanged'](p) {
                  return this['off'](this['eventNames']['iZChanged'], p),
                  this;
              }
              ['offIntTZChanged'](p) {
                  return this['off'](this['eventNames']['iTZChanged'], p),
                  this;
              }
              ['onActiveGridUpdated'](p) {
                  return this['on'](this['eventNames']['activeTZDataUpated'], p),
                  this;
              }
              ['offActiveGridUpdated'](p) {
                  return this['off'](this['eventNames']['activeTZDataUpated'], p),
                  this;
              }
              ['pickValue'](p, F, y, w) {
                  const h = this['getGrid'](y, w);
                  if (!h)
                      return;
                  const u = (0x0,
                  H['tr'])(this['gridOptions']['xStart'], this['gridOptions']['xDelta'], p)
                    , Y = (0x0,
                  H['tr'])(this['gridOptions']['yStart'], this['gridOptions']['yDelta'], F);
                  return h['read2D'](Y, u);
              }
          }
      }
      ,
      0x1ca: (l,K,b)=>{
          'use strict';
          b['d'](K, {
              'o': ()=>H
          });
          var c = b(0x24d);
          class H extends c['r'] {
              constructor(x, p) {
                  var F;
                  super(p),
                  this['grids'] = x || [],
                  this['gridOptions'] = this['options']['gridOptions'],
                  this['meta'] = null !== (F = this['options']['meta']) && undefined !== F ? F : {};
              }
          }
      }
      ,
      0x11d: (l,K,i)=>{
          'use strict';
          i['d'](K, {
              'Bn': ()=>j,
              'b_': ()=>W,
              'cF': ()=>I,
              'ko': ()=>f
          });
          var b = ['byte', 'int', 'uint', 'int16', 'uint16', 'int32', 'uint32', 'float32', 'float64', 'string', 'url', 'alias']
            , e = ['Sequence', 'Structure', 'Dataset']
            , c = '(\x5c\x5c=|\x5c\x5c\x5c]|[^\x5c]=])+'
            , H = '\x5cd+'
            , t = '\x5cw+'
            , x = '(\x5c\x5c;|\x5c\x5c\x5c[|[^\x5c[;])+'
            , p = '(\x5c\x5c;|[^;])+'
            , F = '(\x5c\x5c;|[^;])+'
            , y = '\x22.*?[^\x5c\x5c]\x22|[^;,]+'
            , r = '\x5cw+'
            , w = '(\x5c\x5c\x5cs|[^\x5cs])+'
            , s = '(\x5c\x5c{|[^{])+'
            , h = '(\x5c\x5c{|[^{])+'
            , u = '\x22.*?[^\x5c\x5c]\x22|[^;,]+'
            , Y = '\x22(\x5c\x5c\x5c\x5c|\x5c\x5c\x22|[^\x22])*\x22'
            , T = '\x5cw+'
            , X = '\x22.*?[^\x5c\x5c]\x22|[^;,]+';
          function E(D) {
              return eval('(' + D + ')');
          }
          class f {
              constructor(D) {
                  this['type'] = D,
                  this['attributes'] = {};
              }
          }
          class W {
              constructor(D) {
                  this['stream'] = D;
              }
              ['peek'](D) {
                  var V = new RegExp('^' + D,'i')
                    , Z = this['stream']['match'](V);
                  return Z ? Z[0x0] : '';
              }
              ['consume'](D) {
                  var V = new RegExp('^' + D,'i')
                    , Z = this['stream']['match'](V);
                  if (Z)
                      return this['stream'] = this['stream']['substr'](Z[0x0]['length'])['trimStart'](),
                      Z[0x0];
                  throw new Error('Unable\x20to\x20parse\x20stream:\x20' + this['stream']['substr'](0x0, 0xa));
              }
          }
          class I extends W {
              ['parse']() {
                  return this['_dataset']();
              }
              ['_dataset']() {
                  var D = new f('Dataset');
                  for (this['consume']('dataset'),
                  this['consume']('{'); !this['peek']('}'); ) {
                      var V = this['_declaration']();
                      D[V['name']] = V;
                  }
                  return this['consume']('}'),
                  D['id'] = D['name'] = this['consume'](p)['trim'](),
                  this['consume'](';'),
                  function Z(B, S) {
                      for (var U in B) {
                          var d = B[U];
                          d['type'] && (d['id'] = d['name'],
                          S && (d['id'] = B['id'] + '.' + d['id']),
                          Z(d, true));
                      }
                  }(D, false),
                  D;
              }
              ['_declaration']() {
                  switch (this['peek'](t)['toLowerCase']()) {
                  case 'grid':
                      return this['_grid']();
                  case 'structure':
                      return this['_structure']('Structure');
                  case 'sequence':
                      return this['_structure']('Sequence');
                  default:
                      return this['_base_declaration']();
                  }
              }
              ['_base_declaration']() {
                  var D = new f();
                  for (D['type'] = this['consume'](t)['trim'](),
                  D['name'] = this['consume'](x)['trim'](),
                  D['dimensions'] = [],
                  D['shape'] = []; !this['peek'](';'); ) {
                      this['consume']('\x5c[');
                      var V = this['consume'](c)['trim']();
                      this['peek']('=') && (D['dimensions']['push'](V),
                      this['consume']('='),
                      V = this['consume'](H)['trim']()),
                      D['shape']['push'](parseInt(V)),
                      this['consume']('\x5c]');
                  }
                  return this['consume'](';'),
                  D;
              }
              ['_grid']() {
                  var D = new f('Grid');
                  for (this['consume']('grid'),
                  this['consume']('{'),
                  this['consume']('array'),
                  this['consume'](':'),
                  D['array'] = this['_base_declaration'](),
                  this['consume']('maps'),
                  this['consume'](':'),
                  D['maps'] = {}; !this['peek']('}'); ) {
                      var V = this['_base_declaration']();
                      D['maps'][V['name']] = V;
                  }
                  return this['consume']('}'),
                  D['name'] = this['_name'](),
                  D;
              }
              ['_structure'](D) {
                  var V = new f(D);
                  for (this['consume'](D),
                  this['consume']('{'); !this['peek']('}'); ) {
                      var Z = this['_declaration']();
                      V[Z['name']] = Z;
                  }
                  return this['consume']('}'),
                  V['name'] = this['_name'](),
                  V;
              }
              ['_name']() {
                  var D = this['consume'](F)['trim']();
                  return this['consume'](';'),
                  D;
              }
          }
          class j extends W {
              constructor(D, V) {
                  super(D),
                  this['dataset'] = V;
              }
              ['parse']() {
                  for (this['_target'] = this['dataset'],
                  this['consume']('attributes'),
                  this['consume']('{'); !this['peek']('}'); )
                      this['_attr_container']();
                  return this['consume']('}'),
                  this['dataset'];
              }
              ['_attr_container']() {
                  if (-0x1 !== b['indexOf'](this['peek'](T)['toLowerCase']())) {
                      if (this['_attribute'](this['_target']['attributes']),
                      'Grid' === this['_target']['type']) {
                          for (var D in this['_target']['maps'])
                              if (this['dataset'][D]) {
                                  var V = this['_target']['maps'][D];
                                  for (var Z in V['attributes'])
                                      this['dataset'][D]['attributes'][Z] = V['attributes'][Z];
                              }
                      }
                  } else
                      this['_container']();
              }
              ['_container']() {
                  var D, V = this['consume'](s)['trim']();
                  if (this['consume']('{'),
                  V['indexOf']('.') > -0x1) {
                      var Z = V['split']('.');
                      D = this['_target'];
                      for (var B = 0x0; B < Z['length']; B++)
                          this['_target'] = this['_target'][Z[B]];
                      for (; !this['peek']('}'); )
                          this['_attr_container']();
                      this['consume']('}'),
                      this['_target'] = D;
                  } else {
                      if (e['includes'](this['_target']['type']) && this['_target'][V]) {
                          for (D = this['_target'],
                          this['_target'] = D[V]; !this['peek']('}'); )
                              this['_attr_container']();
                          this['consume']('}'),
                          this['_target'] = D;
                      } else
                          this['_target']['attributes'][V] = this['_metadata'](),
                          this['consume']('}');
                  }
              }
              ['_metadata']() {
                  for (var D = {}; !this['peek']('}'); )
                      if (b['includes'](this['peek'](T)['toLowerCase']()))
                          this['_attribute'](D);
                      else {
                          var V = this['consume'](h)['trim']();
                          this['consume']('{'),
                          D[V] = this['_metadata'](),
                          this['consume']('}');
                      }
                  return D;
              }
              ['_attribute'](D) {
                  for (var V, Z = this['consume'](r)['trim'](), B = this['consume'](w)['trim'](), S = []; !this['peek'](';'); ) {
                      if ('string' === Z['toLowerCase']())
                          V = (V = this['consume'](Y)['trim']())['substr'](0x1, V['length'] - 0x2);
                      else {
                          if ('url' === Z['toLowerCase']())
                              V = this['consume'](X)['trim']();
                          else {
                              if ('alias' === Z['toLowerCase']()) {
                                  var U, d;
                                  (V = this['consume'](y)['trim']())['match'](/^\\./) ? (d = V['substring'](0x1)['split']('.'),
                                  U = this['dataset']) : (d = V['split']('.'),
                                  U = this['_target']);
                                  for (var q = 0x0; q < d['length']; q++) {
                                      var J = d[q];
                                      V = U = U[J] ? U[J] : U['array']['name'] === J ? U['array'] : U['maps'][J] ? U['maps'][J] : U['attributes'][J];
                                  }
                              } else
                                  V = 'nan' === (V = this['consume'](u)['trim']())['toLowerCase']() ? NaN : 'inf' === V['toLowerCase']() ? 0x1 / 0x0 : '-inf' === V['toLowerCase']() ? -0x1 / 0x0 : E(V);
                          }
                      }
                      S['push'](V),
                      this['peek'](',') && this['consume'](',');
                  }
                  this['consume'](';'),
                  0x1 === S['length'] && (S = S[0x0]),
                  D[B] = S;
              }
          }
      }
      ,
      0x39b: (l,K,b)=>{
          'use strict';
          b['d'](K, {
              '$V': ()=>H,
              'kg': ()=>x,
              'qr': ()=>p
          });
          var c = b(0x346);
          class H {
              ['error'](F, y=true, w=undefined, h=undefined) {
                  h && h(F);
                  const u = w && w['name'] ? '[' + w['name'] + ']' : '';
                  if ('object' == typeof F ? console['log'](F) : console['error']('%c[error]' + u + '\x20' + F, H['DefaultStyles']['errorStyle']),
                  y)
                      throw new Error(F);
              }
              ['warn'](F, y=undefined, w=undefined) {
                  w && w(F);
                  const h = y && y['name'] ? '[' + y['name'] + ']' : '';
                  console['warn']('%c[warn]' + h + '\x20' + F, H['DefaultStyles']['warnStyle']);
              }
              ['log'](F, y=undefined, w=undefined) {
                  w && w(F);
                  const h = y && y['name'] ? '[' + y['name'] + ']' : '';
                  'object' == typeof F ? (console['log']('%c[info]', H['DefaultStyles']['logStyle']),
                  console['log'](F)) : console['log']('%c[info]' + h + '\x20' + F, H['DefaultStyles']['logStyle']);
              }
              ['debug'](F, y=undefined, w=undefined) {
                  w && w(F);
                  const h = y && y['name'] ? '[' + y['name'] + ']' : ''
                    , u = '[debug][' + new Date()['toLocaleString']() + ']';
                  'object' == typeof F ? (console['log']('' + u),
                  console['log'](F)) : console['log']('' + u + h + '\x20' + F);
              }
              ['note'](F, y=undefined, w=undefined) {
                  w && w(F);
                  const h = y && y['name'] ? '[' + y['name'] + ']' : ''
                    , u = '[note][' + new Date()['toLocaleString']() + ']';
                  'object' == typeof F ? (console['log']('%c' + u),
                  console['log'](F)) : console['log']('%c' + u + h + '\x20******' + F + '******', H['DefaultStyles']['noteStyle']);
              }
              ['custom'](F, y, w=undefined, h=undefined) {
                  h && h(F);
                  const u = w && w['name'] ? '[' + w['name'] + ']' : ''
                    , Y = '[custom][' + new Date()['toLocaleString']() + ']';
                  'object' == typeof F ? (console['log']('%c' + Y, y || 'color:black'),
                  console['log'](F)) : console['log']('%c' + Y + u + '\x20' + F, y || 'color:black');
              }
          }
          H['DefaultStyles'] = {
              'logStyle': 'color:blue',
              'warnStyle': 'color:orange',
              'errorStyle': 'color:red',
              'noteStyle': 'color:green;font:bold'
          };
          const x = new H()
            , p = ()=>{
              c['v']['Debug'] || (x['debug'] = (F,y=undefined)=>{}
              );
          }
          ;
      }
      ,
      0x13c: (K,H,x)=>{
          'use strict';
          x['d'](H, {
              'GB': ()=>U,
              'I$': ()=>S,
              'MM': ()=>V,
              'Xf': ()=>Z,
              'Zc': ()=>G,
              'gD': ()=>J,
              'pQ': ()=>B,
              'qg': ()=>q,
              'xR': ()=>C,
              'zc': ()=>O
          });
          var F = x(0x346)
            , Y = x(0x393)
            , T = x(0x19d)
            , X = x(0x260)
            , E = x(0x1)
            , W = x(0x39b)
            , I = x(0x17a)
            , j = x['n'](I)
            , D = function(N, P, M, z) {
              return new (M || (M = Promise))(function(Q, L) {
                  function R(v2) {
                      try {
                          v1(z['next'](v2));
                      } catch (v3) {
                          L(v3);
                      }
                  }
                  function v0(v2) {
                      try {
                          v1(z['throw'](v2));
                      } catch (v3) {
                          L(v3);
                      }
                  }
                  function v1(v2) {
                      var v3;
                      v2['done'] ? Q(v2['value']) : (v3 = v2['value'],
                      v3 instanceof M ? v3 : new M(function(v4) {
                          v4(v3);
                      }
                      ))['then'](R, v0);
                  }
                  v1((z = z['apply'](N, P || []))['next']());
              }
              );
          };
          const V = {
              'images': 'images',
              'stopRules': 'stopRules',
              'featureStyles': 'featureStyles',
              'gridStyles': 'gridStyles',
              'jsonFiles': 'jsonFiles',
              'rawFiles': 'rawFiles',
              'texts': 'texts',
              'colorScales': 'colorScales'
          }
            , Z = N=>D(undefined, undefined, undefined, function*() {
              let {resourceType: P, requestInfo: M, init: z, key: Q} = N;
              const L = {
                  'source': N,
                  'resourceType': P
              };
              return N instanceof HTMLImageElement || N instanceof HTMLCanvasElement || N instanceof HTMLVideoElement ? (L['instance'] = N,
              Promise['resolve'](L)) : new Promise((R,v0)=>{
                  if ('string' == typeof M) {
                      const v1 = document['createElement']('img');
                      v1['crossOrigin'] = '',
                      v1['onload'] = ()=>{
                          L['instance'] = v1,
                          R(L);
                      }
                      ,
                      v1['onerror'] = v2=>{
                          v0(v2);
                      }
                      ,
                      v1['src'] = M;
                  } else
                      W['kg']['error']('' + M, true, undefined, v0);
              }
              );
          })
            , B = (N,P,M,z=true)=>D(undefined, undefined, undefined, function*() {
              let {resourceType: Q, requestInfo: L, init: R, key: v0} = N;
              const v1 = {
                  'source': N,
                  'resourceType': Q
              };
              return P(L) ? (v1['instance'] = L,
              W['kg']['warn']('' + v0),
              Promise['resolve'](v1)) : M(L) ? (v1['instance'] = L,
              Promise['resolve'](v1)) : fetch(L)['then'](v2=>'string' == typeof L && L['endsWith']('zip') || L instanceof Request && L['url']['endsWith']('zip') ? v2['arrayBuffer']()['then'](v3=>new (j())()['loadAsync'](v3)['then'](v4=>D(undefined, undefined, undefined, function*() {
                  Object['keys'](v4['files'])['length'];
                  for (let v5 in v4['files']) {
                      let v6 = v5;
                      if (!(v6['indexOf']('MACOSX') >= 0x0))
                          return v4['files'][v6]['async'](z ? 'text' : 'arraybuffer')['then'](v7=>Promise['resolve'](z ? JSON['parse'](v7) : v7));
                  }
              }))['catch'](W['kg']['debug']))['catch'](W['kg']['debug']) : z ? v2['json']() : v2['arrayBuffer']())['then'](v2=>(v1['instance'] = v2,
              Promise['resolve'](v1)))['catch'](W['kg']['debug']);
          })
            , S = N=>D(undefined, undefined, undefined, function*() {
              return B(N, P=>false, P=>'object' == typeof P);
          })
            , U = N=>D(undefined, undefined, undefined, function*() {
              return B(N, P=>P instanceof ArrayBuffer, P=>false, false);
          })
            , q = N=>D(undefined, undefined, undefined, function*() {
              return B(N, P=>P instanceof X['NB'], P=>'object' == typeof P && P['stops']);
          })
            , J = N=>D(undefined, undefined, undefined, function*() {
              return B(N, P=>P instanceof T['sC'], P=>'object' == typeof P && (P['point'] || P['polygon'] || P['polyline'] || 0x0 === Object['keys'](P)['length']));
          })
            , C = N=>D(undefined, undefined, undefined, function*() {
              return B(N, P=>'gridStyle' === (null == P ? undefined : P['styleName']), P=>'object' == typeof P);
          });
          class O extends Y['c'] {
              constructor() {
                  super(...arguments),
                  this['registerCreator'] = O['registerCreator'],
                  this['creators'] = O['creators'],
                  this['resources'] = {};
              }
              static['registerCreator'](N, P) {
                  O['creators'][N] && W['kg']['warn']('' + N + ''),
                  O['creators'][N] = P;
              }
              get['allResources']() {
                  return this['resources'];
              }
              ['addResource'](N, P, M=false) {
                  if (!N || !this['hasResource'](N) || M) {
                      if (P && P['instance'] && P['resourceType'] || W['kg']['error'](''),
                      this['hasResource'](N)) {
                          const z = this['getResource'](N);
                          this['resources'][N] = P,
                          this['fire'](O['EventTypes']['resUpdated'], {
                              'firer': this,
                              'msg': {
                                  'oldResource': z,
                                  'newResource': P
                              }
                          }),
                          this['fire'](O['EventTypes']['resUpdated'] + ':' + N, {
                              'firer': this,
                              'msg': {
                                  'oldResource': z,
                                  'newResource': P
                              }
                          })
                          // W['kg']['debug']('' + N + '');
                      } else
                          this['resources'][N] = P,
                          this['fire'](O['EventTypes']['resAdd'], {
                              'firer': this,
                              'msg': P
                          }),
                          this['fire'](O['EventTypes']['resAdd'] + ':' + N, {
                              'firer': this,
                              'msg': P
                          });
                      this['fire'](O['EventTypes']['resLoaded'], {
                          'firer': this,
                          'msg': P
                      }),
                      this['fire'](O['EventTypes']['resLoaded'] + ':' + N, {
                          'firer': this,
                          'msg': P
                      })
                      // W['kg']['debug']('' + N + '');
                  }
              }
              ['loadResource'](N, P=false) {
                  return D(this, undefined, undefined, function*() {
                      if (N['key'] && this['hasResource'](N['key']) && !P)
                          return Promise['resolve'](this['getResource'](N['key']));
                      const M = this['creators'][N['resourceType']];
                      if (!M)
                          return W['kg']['error']('' + N['resourceType'] + ''),
                          Promise['reject']('' + N['resourceType'] + '');
                      'string' == typeof N['requestInfo'] && (N['requestInfo']['startsWith']('http') || N['requestInfo']['startsWith']('/') || (N['requestInfo'] = F['v']['resourcePath'] + '/' + N['requestInfo']));
                      const z = yield M(N)['catch'](W['kg']['debug']);
                      if (!z)
                          throw W['kg']['error'](''),
                          '';
                      return z['resourceType'] || (z['resourceType'] = N['resourceType']),
                      this['addResource'](N['key'], z, P),
                      z;
                  });
              }
              ['loadResources'](N) {
                  return D(this, undefined, undefined, function*() {
                      if (!N || 0x0 === N['length'])
                          return Promise['resolve']([]);
                      const P = [];
                      for (const M of N) {
                          const z = yield this['loadResource'](M)['catch'](W['kg']['debug']);
                          P['push'](z);
                      }
                      return Promise['resolve'](P);
                  });
              }
              ['loadResourceFromConfig'](N, P=false) {
                  return D(this, undefined, undefined, function*() {
                      if (!N || 0x0 === Object['keys'](N)['length'])
                          return Promise['resolve']([]);
                      const M = (v7,v8)=>D(this, undefined, undefined, function*() {
                          if (!v7)
                              return Promise['resolve']([]);
                          const v9 = [];
                          for (const vv in v7) {
                              const vA = v7[vv]
                                , vn = {
                                  'resourceType': v8,
                                  'requestInfo': vA,
                                  'key': vv
                              }
                                , vk = yield this['loadResource'](vn, P)['catch'](W['kg']['debug']);
                              v9['push'](vk);
                          }
                          return Promise['resolve'](v9);
                      })
                        , z = Object['assign']({}, N)
                        , Q = N
                        , L = [];
                      if (Q['texts'])
                          for (const v7 in Q['texts']) {
                              const v8 = {
                                  'resourceType': V['texts'],
                                  'source': {
                                      'resourceType': V['texts'],
                                      'requestInfo': undefined,
                                      'key': v7
                                  },
                                  'instance': Q['texts'][v7]
                              };
                              this['addResource'](v7, v8, true),
                              L['push'](v8);
                          }
                      const R = yield M(Q['jsonFiles'], V['jsonFiles'])['catch'](W['kg']['debug']);
                      delete z['jsonFiles'];
                      const v0 = yield M(Q['rawFiles'], V['rawFiles'])['catch'](W['kg']['debug']);
                      delete z['rawObjs'];
                      const v1 = yield M(Q['images'], V['images'])['catch'](W['kg']['debug']);
                      delete z['images'];
                      const v2 = yield M(Q['colorScales'], V['colorScales'])['catch'](W['kg']['debug']);
                      delete z['colorScales'];
                      const v3 = yield M(Q['stopRules'], V['stopRules'])['catch'](W['kg']['debug']);
                      delete z['stopRules'];
                      const v4 = yield M(Q['featureStyles'], V['featureStyles'])['catch'](W['kg']['debug']);
                      delete z['featureStyles'];
                      const v5 = yield M(Q['gridStyles'], V['gridStyles'])['catch'](W['kg']['debug']);
                      delete z['gridStyles'];
                      const v6 = [...L, ...R, ...v0, ...v1, ...v3, ...v4, ...v5, ...v2];
                      for (const v9 in z) {
                          const vv = yield M(z[v9], v9)['catch'](W['kg']['debug']);
                          v6['push'](...vv);
                      }
                      return v6;
                  });
              }
              ['loadResourceFromConfigPath'](N, P, M=false) {
                  return D(this, undefined, undefined, function*() {
                      return 'string' == typeof N && (N['startsWith']('http') || N['startsWith']('/') || (N = F['v']['resourcePath'] + '/' + N)),
                      (0x0,
                      E['TN'])(N, P)['then'](z=>z['json']())['then'](z=>this['loadResourceFromConfig'](z, M))['catch'](W['kg']['debug']);
                  });
              }
              ['getResource'](N) {
                  return this['resources'][N] ? this['resources'][N] : (W['kg']['warn']('ID' + N + ''),
                  {
                      'instance': undefined
                  });
              }
              ['removeResource'](N) {
                  const P = this['resources'][N]
                    , M = delete this['resources'][N];
                  return P && this['fire'](O['EventTypes']['resRemoved'], {
                      'firer': this,
                      'msg': P
                  }),
                  M;
              }
              ['hasResource'](N) {
                  return undefined !== this['resources'][N];
              }
              ['whenResourceAdded'](N, P) {
                  let M = this['getResource'](N);
                  if (M)
                      return Promise['resolve'](M);
                  this['on'](O['EventTypes']['resLoaded'] + ':' + N, z=>{
                      P(z['msg']);
                  }
                  );
              }
              ['whenResourceUpdated'](N, P) {
                  this['on'](O['EventTypes']['resUpdated'] + ':' + N, M=>{
                      P(M['msg']['oldResource'], M['msg']['newResource']);
                  }
                  );
              }
              ['whenResourceLoaded'](N, P) {
                  this['on'](O['EventTypes']['resLoaded'] + ':' + N, M=>{
                      P(M['msg']);
                  }
                  );
              }
              ['whenResourceRemoved'](N, P) {
                  this['on'](O['EventTypes']['resRemoved'] + ':' + N, M=>{
                      P(M['msg']);
                  }
                  );
              }
          }
          O['creators'] = {},
          O['EventTypes'] = {
              'resAdd': 'res:add',
              'resRemoved': 'res:remove',
              'resUpdated': 'res:update',
              'resLoaded': 'res:load'
          },
          O['registerCreator'](V['images'], Z),
          O['registerCreator'](V['stopRules'], q),
          O['registerCreator'](V['featureStyles'], J),
          O['registerCreator'](V['gridStyles'], C),
          O['registerCreator'](V['jsonFiles'], S),
          O['registerCreator'](V['rawFiles'], U),
          O['registerCreator'](V['colorScales'], Z);
          const G = new O();
      }
      ,
      0x95: (K,H,F)=>{
          'use strict';
          F['d'](H, {
              'Ao': ()=>G,
              'H$': ()=>Q,
              'Tz': ()=>v2,
              'fV': ()=>M,
              'jr': ()=>L,
              'lS': ()=>v3,
              'sU': ()=>v4,
              'tq': ()=>R
          });
          var Y = F(0x39b)
            , T = F(0x1)
            , X = function(v5, v6, v7, v8) {
              return new (v7 || (v7 = Promise))(function(v9, vv) {
                  function vA(vl) {
                      try {
                          vk(v8['next'](vl));
                      } catch (vK) {
                          vv(vK);
                      }
                  }
                  function vn(vl) {
                      try {
                          vk(v8['throw'](vl));
                      } catch (vK) {
                          vv(vK);
                      }
                  }
                  function vk(vl) {
                      var vK;
                      vl['done'] ? v9(vl['value']) : (vK = vl['value'],
                      vK instanceof v7 ? vK : new v7(function(vi) {
                          vi(vK);
                      }
                      ))['then'](vA, vn);
                  }
                  vk((v8 = v8['apply'](v5, v6 || []))['next']());
              }
              );
          };
          let W = undefined !== window['orientation']
            , j = false;
          class D {
              constructor(v5, v6, v7) {
                  this['name'] = v5,
                  this['version'] = v6,
                  this['os'] = v7,
                  this['type'] = 'browser';
              }
          }
          class V {
              constructor(v5) {
                  this['version'] = v5,
                  this['type'] = 'node',
                  this['name'] = 'node',
                  this['os'] = process['platform'];
              }
          }
          class Z {
              constructor(v5, v6, v7, v8) {
                  this['name'] = v5,
                  this['version'] = v6,
                  this['os'] = v7,
                  this['bot'] = v8,
                  this['type'] = 'bot-device';
              }
          }
          class B {
              constructor() {
                  this['type'] = 'bot',
                  this['bot'] = true,
                  this['name'] = 'bot',
                  this['version'] = null,
                  this['os'] = null;
              }
          }
          class U {
              constructor() {
                  this['type'] = 'react-native',
                  this['name'] = 'react-native',
                  this['version'] = null,
                  this['os'] = null;
              }
          }
          const q = /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/
            , J = 0x3
            , C = [['aol', /AOLShield\/([0-9\._]+)/], ['edge', /Edge\/([0-9\._]+)/], ['edge-ios', /EdgiOS\/([0-9\._]+)/], ['yandexbrowser', /YaBrowser\/([0-9\._]+)/], ['kakaotalk', /KAKAOTALK\s([0-9\.]+)/], ['samsung', /SamsungBrowser\/([0-9\.]+)/], ['silk', /\bSilk\/([0-9._-]+)\b/], ['miui', /MiuiBrowser\/([0-9\.]+)$/], ['beaker', /BeakerBrowser\/([0-9\.]+)/], ['edge-chromium', /Edg\/([0-9\.]+)/], ['chromium-webview', /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/], ['chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/], ['phantomjs', /PhantomJS\/([0-9\.]+)(:?\s|$)/], ['crios', /CriOS\/([0-9\.]+)(:?\s|$)/], ['firefox', /Firefox\/([0-9\.]+)(?:\s|$)/], ['fxios', /FxiOS\/([0-9\.]+)/], ['opera-mini', /Opera Mini.*Version\/([0-9\.]+)/], ['opera', /Opera\/([0-9\.]+)(?:\s|$)/], ['opera', /OPR\/([0-9\.]+)(:?\s|$)/], ['ie', /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/], ['ie', /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/], ['ie', /MSIE\s(7\.0)/], ['bb10', /BB10;\sTouch.*Version\/([0-9\.]+)/], ['android', /Android\s([0-9\.]+)/], ['ios', /Version\/([0-9\._]+).*Mobile.*Safari.*/], ['safari', /Version\/([0-9\._]+).*Safari/], ['facebook', /FBAV\/([0-9\.]+)/], ['instagram', /Instagram\s([0-9\.]+)/], ['ios-webview', /AppleWebKit\/([0-9\.]+).*Mobile/], ['ios-webview', /AppleWebKit\/([0-9\.]+).*Gecko\)$/], ['searchbot', /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/]]
            , O = [['iOS', /iP(hone|od|ad)/], ['Android\x20OS', /Android/], ['BlackBerry\x20OS', /BlackBerry|BB10/], ['Windows\x20Mobile', /IEMobile/], ['Amazon\x20OS', /Kindle/], ['Windows\x203.11', /Win16/], ['Windows\x2095', /(Windows 95)|(Win95)|(Windows_95)/], ['Windows\x2098', /(Windows 98)|(Win98)/], ['Windows\x202000', /(Windows NT 5.0)|(Windows 2000)/], ['Windows\x20XP', /(Windows NT 5.1)|(Windows XP)/], ['Windows\x20Server\x202003', /(Windows NT 5.2)/], ['Windows\x20Vista', /(Windows NT 6.0)/], ['Windows\x207', /(Windows NT 6.1)/], ['Windows\x208', /(Windows NT 6.2)/], ['Windows\x208.1', /(Windows NT 6.3)/], ['Windows\x2010', /(Windows NT 10.0)/], ['Windows\x2011', /(Windows NT 11.0)/], ['Windows\x20ME', /Windows ME/], ['Open\x20BSD', /OpenBSD/], ['Sun\x20OS', /SunOS/], ['Chrome\x20OS', /CrOS/], ['Linux', /(Linux)|(X11)/], ['Mac\x20OS', /(Mac_PowerPC)|(Macintosh)/], ['QNX', /QNX/], ['BeOS', /BeOS/], ['OS/2', /OS\/2/]];
          function G(v5) {
              return v5 ? N(v5) : 'undefined' == typeof document && 'undefined' != typeof navigator && 'ReactNative' === navigator['product'] ? new U() : 'undefined' != typeof navigator ? N(navigator['userAgent']) : 'undefined' != typeof process && process['version'] ? new V(process['version']['slice'](0x1)) : null;
          }
          function N(v5) {
              const v6 = function(vk) {
                  return '' !== vk && C['reduce']((vl,[vK,vi])=>{
                      if (vl)
                          return vl;
                      const vb = vi['exec'](vk);
                      return !!vb && [vK, vb];
                  }
                  , false);
              }(v5);
              if (!v6)
                  return null;
              const [v7,v8] = v6;
              if ('searchbot' === v7)
                  return new B();
              let v9 = v8[0x1] && v8[0x1]['split'](/[._]/)['slice'](0x0, 0x3);
              v9 ? v9['length'] < J && (v9 = [...v9, ...z(J - v9['length'])]) : v9 = [];
              const vv = v9['join']('.')
                , vA = M(v5)
                , vn = q['exec'](v5);
              return vn && vn[0x1] ? new Z(v7,vv,vA,vn[0x1]) : new D(v7,v9['join']('.'),vA);
          }
          function M(v5) {
              for (let v6 = 0x0, v7 = O['length']; v6 < v7; v6++) {
                  const [v8,v9] = O[v6];
                  if (v9['exec'](v5))
                      return v8;
              }
              return null;
          }
          function z(v5) {
              const v6 = [];
              for (let v7 = 0x0; v7 < v5; v7++)
                  v6['push']('0');
              return v6;
          }
          function Q() {
              const v5 = G()
                , v6 = v5['name'] && v5['name']['toLowerCase']();
              let v7 = v5['version'] || '00';
              const v8 = parseFloat(v7['slice'](0x0, 0x2));
              return !!(v6 && (v6['indexOf']('chrome') >= 0x0 || v6['indexOf']('chromium') >= 0x0) && v8 > 0x3c);
          }
          function L(v5) {
              var v6, v7 = document['createElement']('img');
              Object['defineProperty'](v7, 'id', {
                  'get': function() {
                      v6 = 'on';
                  }
              }),
              requestAnimationFrame(function v8() {
                  v6 = 'off',
                  requestAnimationFrame(v8),
                  'on' === v6 && (location['href'] = v5 || 'http://www.mlogcn.com');
              });
          }
          const R = v2;
          let v0, v1;
          function v2(v5=true) {
              if (j)
                  return true;
              const v6 = function() {
                  var v7 = new Object()
                    , v8 = location['search']['substring'](0x1);
                  if (!v8 || 0x0 === v8['trim']()['length']) {
                      const vl = location['hash']['indexOf']('?');
                      v8 = location['hash']['substring'](vl + 0x1);
                  }
                  for (var v9 = v8['split']('&'), vv = 0x0; vv < v9['length']; vv++) {
                      var vA = v9[vv]['indexOf']('=');
                      if (-0x1 != vA) {
                          var vn = v9[vv]['substring'](0x0, vA)
                            , vk = v9[vv]['substring'](vA + 0x1);
                          v7[vn] = unescape(vk);
                      }
                  }
                  return v7;
              }();
              return !(!window['force_mobile'] && 'true' != v6['mobile']) || (v5 ? ((0x0,
              T['ri'])(v0) || (v0 = function() {
                  var v7;
                  let v8 = false;
                  var v9;
                  return v9 = navigator['userAgent'] || navigator['vendor'] || window['opera'],
                  (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i['test'](v9) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|FeatureDataProviderBase|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i['test'](v9['substr'](0x0, 0x4))) && (v8 = true),
                  v8 || (null === (v7 = navigator['userAgent']) || undefined === v7 ? undefined : v7['toLowerCase']()['indexOf']('mobile')) >= 0x0;
              }()),
              v0) : W);
          }
          function v3() {
              try {
                  const v5 = document['createElement']('canvas');
                  if ((0x0,
                  T['ri'])(v5['getContext']('webgl2')))
                      return 0x2;
                  const v6 = v5['getContext']('webgl');
                  return (0x0,
                  T['ri'])(v6) || Y['kg']['error']('WebGL'),
                  v6['getExtension']('OES_texture_float') || Y['kg']['warn']('WebGL1floatbyte'),
                  0x1;
              } catch (v7) {
                  Y['kg']['error']('WebGL');
              }
          }
          function v4() {
              return X(this, undefined, undefined, function*() {
                  return (0x0,
                  T['ri'])(v1) ? v1 : new Promise((v5,v6)=>{
                      const v7 = new Image();
                      v7['src'] = 'data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA',
                      v7['onload'] = v7['onerror'] = ()=>{
                          v1 = 0x2 === v7['height'],
                          v5(v1);
                      }
                      ;
                  }
                  );
              });
          }
      }
      ,
      0xfb: (K,b,H)=>{
          'use strict';
          H['d'](b, {
              'EO': ()=>W,
              'OE': ()=>V,
              'Qs': ()=>I,
              'c0': ()=>Z,
              'ke': ()=>j,
              'nA': ()=>B,
              'y$': ()=>E
          });
          var x = H(0x35a)
            , F = H(0x313)
            , y = H(0x260)
            , w = H(0x133)
            , Y = H(0x39b)
            , T = H(0x13c)
            , X = H(0x1);
          function E(S) {
              if (undefined !== (S = parseFloat(S)) && S < 0x270f) {
                  ++S;
                  let U = Math['floor'](S / 0x14)
                    , q = Math['floor']((S - 0x14 * U) / 0x4)
                    , J = 0xa * U + 0x2 * q + Math['floor']((S - 0x14 * U - 0x4 * q) / 0x2);
                  if (0x0 === J)
                      return;
                  let C = J + 0x20;
                  return C > 0x3d && (C = 0x3d),
                  String['fromCharCode'](C);
              }
          }
          function W(S) {
              return undefined === (S = parseFloat(S)) || S < 0x270f && (S >= 0x64 && (S -= 0x64),
              S < 0x4 ? S = undefined : S += S < 0x42 ? 0x3d : S < 0x4e ? 0x5f : 0x60),
              S;
          }
          function I(S) {
              return undefined === (S = parseFloat(S)) ? S : S < 0x270f ? S * Math['PI'] / 0xb4 : undefined;
          }
          const j = {
              'wind': 'wind',
              'weather': 'weather',
              'degree2arc': 'degree2arc',
              'res': 'res',
              'anaVals': 'anaVals',
              'decimal': 'decimal',
              'subImage': 'subImage',
              'transform': 'transform',
              'cs': 'cs',
              'all': 'all'
          }
            , D = {
              'wind': E,
              'weather': W,
              'degree2arc': I,
              'res': (S,U)=>{
                  const q = T['Zc']['getResource'](S)['instance'];
                  if (q && q['stops'] && U) {
                      const J = Object['assign']({}, q);
                      return U['field'] && (J['fieldName'] = U['field']),
                      U['action'] && (J['action'] = U['action']),
                      J;
                  }
                  return q;
              }
              ,
              'anaVals': (S,U)=>{
                  var q;
                  const J = T['Zc']['getResource'](S)['instance'];
                  if (J) {
                      const C = new y['NB'](J)['getVals']();
                      if (U) {
                          const O = null !== (q = U['start']) && undefined !== q ? q : 0x0
                            , G = U['end'];
                          return C['slice'](O, G);
                      }
                      return C;
                  }
                  return Y['kg']['warn']('' + S + ''),
                  [];
              }
              ,
              'decimal': (S,U)=>{
                  const q = U && U['len'] || 0x1;
                  return parseFloat(S)['toFixed'](parseInt(q));
              }
              ,
              'subImage': (S,U)=>{
                  const q = S + '_sub_' + U['x'] + '_' + U['y'] + '_' + U['w'] + '_' + U['h'];
                  if (T['Zc']['hasResource'](q))
                      return T['Zc']['getResource'](q)['instance'];
                  const J = T['Zc']['getResource'](S)['instance'];
                  if (J && (J instanceof HTMLImageElement || J instanceof HTMLCanvasElement || J instanceof HTMLVideoElement)) {
                      const C = document['createElement']('canvas');
                      return C['width'] = U['w'],
                      C['height'] = U['h'],
                      C['getContext']('2d')['drawImage'](J, U['x'], U['y'], U['w'], U['h'], 0x0, 0x0, U['w'], U['h']),
                      T['Zc']['addResource'](q, {
                          'resourceType': T['MM']['images'],
                          'instance': C
                      }, false),
                      C;
                  }
                  return Y['kg']['warn']('' + S),
                  J;
              }
              ,
              'transform': (S,U)=>{
                  var q, J;
                  const C = null !== (q = U['scale']) && undefined !== q ? q : 0x1
                    , O = null !== (J = U['offset']) && undefined !== J ? J : 0x0;
                  return 0x0 == U['scaleFirst'] ? (S + O) * C : S * C + O;
              }
              ,
              'cs': (S,U)=>('string' == typeof S && (S = F['xS'][S] ? (0x0,
              F['dO'])(F['xS'][S], U['min'], U['max'], 'false' !== U['gradient']) : (0x0,
              w['it'])(S)),
              (0x0,
              X['ri'])(S['min']) && (0x0,
              X['ri'])(S['max']) && (0x0,
              X['ri'])(S['colorScale']) ? S : S['width'] && S['height'] ? new x['Xm']({
                  'colorScale': S,
                  'min': (0x0,
                  X['ri'])(U['min']) ? parseFloat(U['min']) : undefined,
                  'max': (0x0,
                  X['ri'])(U['max']) ? parseFloat(U['max']) : undefined
              }) : (Y['kg']['warn']('colorsacle!'),
              S)),
              'all': (S,U)=>{
                  const q = U['__order']
                    , J = {
                      'initial': S
                  };
                  return q['reduce']((C,O)=>{
                      if ('all' === (O = O['trim']()))
                          return Y['kg']['warn']('all\x20loader'),
                          C;
                      const G = B(O);
                      if (!(0x0,
                      X['ri'])(G))
                          return Y['kg']['warn']('loader\x20' + O + ''),
                          C;
                      const N = U[O];
                      if (!(0x0,
                      X['ri'])(N) || !N['trim']()['length'])
                          return G(C, J);
                      const P = (0x0,
                      w['vl'])(N, ',', ':')
                        , M = G(C, Object['assign'](Object['assign']({}, J), P));
                      return J[O] = M,
                      M;
                  }
                  , S);
              }
          };
          function V(S, U) {
              D[S] = U;
          }
          function Z(S, U) {
              for (const q of S)
                  V(q, U);
          }
          function B(S) {
              return D[S];
          }
      }
      ,
      0x1: (v0,v1,v2)=>{
          'use strict';
          v2['d'](v1, {
              'BR': ()=>vd,
              'f0': ()=>vM,
              'VS': ()=>An,
              'pj': ()=>A1,
              'U2': ()=>A3,
              'ZS': ()=>A4,
              'Ef': ()=>Al,
              'cM': ()=>A7,
              'f8': ()=>vp,
              'En': ()=>vt,
              'ri': ()=>vB,
              'GN': ()=>vm,
              'l7': ()=>vf,
              'vY': ()=>va,
              'p6': ()=>A0,
              'K0': ()=>vY,
              'j$': ()=>vu,
              'BG': ()=>A2,
              'tr': ()=>vD,
              'xA': ()=>vw,
              'lC': ()=>vh,
              'vi': ()=>vZ,
              'Fp': ()=>vV,
              'oT': ()=>vT,
              'C8': ()=>vy,
              'Q': ()=>vs,
              'Hn': ()=>vr,
              '$k': ()=>vj,
              'kJ': ()=>vP,
              'eP': ()=>vC,
              'J_': ()=>vo,
              'xb': ()=>vg,
              'mf': ()=>vq,
              'Ft': ()=>vN,
              'hj': ()=>vG,
              'Kn': ()=>vJ,
              'HD': ()=>vO,
              'JY': ()=>vz,
              'EX': ()=>A8,
              'd$': ()=>A6,
              've': ()=>AK,
              'Wd': ()=>vQ,
              'Tc': ()=>Ak,
              'ft': ()=>vR,
              'TN': ()=>vX,
              'wO': ()=>Av,
              'r_': ()=>AA,
              'Zu': ()=>A9,
              'XG': ()=>A5,
              'Ov': ()=>vx,
              'uw': ()=>vF,
              'nf': ()=>vI,
              'Rc': ()=>vW,
              'LG': ()=>vH,
              'hQ': ()=>vc,
              'Rf': ()=>Quadtree,
              '_6': ()=>vL
          });
          var v3 = v2(0x17a)
            , v4 = v2['n'](v3)
            , v5 = v2(0x338)
            , v6 = v2(0x240)
            , v7 = v2(0x1de)
            , v8 = v2(0x60)
            , v9 = v2(0x1ca)
            , vv = v2(0x39b)
            , vA = v2(0xcc)
            , vn = v2(0x4b);
          const vk = function(Ai, Ab, Ae) {
              undefined === Ae && (Ae = {});
              for (var Ac = Ae['steps'] || 0x40, AH = Ae['properties'] ? Ae['properties'] : !Array['isArray'](Ai) && 'Feature' === Ai['type'] && Ai['properties'] ? Ai['properties'] : {}, At = [], Ax = 0x0; Ax < Ac; Ax++)
                  At['push']((0x0,
                  vA['Z'])(Ai, Ab, -0x168 * Ax / Ac, Ae)['geometry']['coordinates']);
              return At['push'](At[0x0]),
              (0x0,
              vn['yu'])([At], AH);
          };
          function vl(Ai, Ab, Ae, Ac, AH) {
              undefined === AH && (AH = {});
              var At = AH['steps'] || 0x40
                , Ax = vK(Ae)
                , Ap = vK(Ac)
                , AF = Array['isArray'](Ai) || 'Feature' !== Ai['type'] ? {} : Ai['properties'];
              if (Ax === Ap)
                  return (0x0,
                  vn['Tu'])(vk(Ai, Ab, AH)['geometry']['coordinates'][0x0], AF);
              for (var Ay = Ax, Ar = Ax < Ap ? Ap : Ap + 0x168, Aw = Ay, As = [], Ah = 0x0; Aw < Ar; )
                  As['push']((0x0,
                  vA['Z'])(Ai, Ab, Aw, AH)['geometry']['coordinates']),
                  Aw = Ay + 0x168 * ++Ah / At;
              return Aw > Ar && As['push']((0x0,
              vA['Z'])(Ai, Ab, Ar, AH)['geometry']['coordinates']),
              (0x0,
              vn['Tu'])(As, AF);
          }
          function vK(Ai) {
              var Ab = Ai % 0x168;
              return Ab < 0x0 && (Ab += 0x168),
              Ab;
          }
          var vi = function(Ai, Ab, Ae, Ac) {
              return new (Ae || (Ae = Promise))(function(AH, At) {
                  function Ax(Ay) {
                      try {
                          AF(Ac['next'](Ay));
                      } catch (Ar) {
                          At(Ar);
                      }
                  }
                  function Ap(Ay) {
                      try {
                          AF(Ac['throw'](Ay));
                      } catch (Ar) {
                          At(Ar);
                      }
                  }
                  function AF(Ay) {
                      var Ar;
                      Ay['done'] ? AH(Ay['value']) : (Ar = Ay['value'],
                      Ar instanceof Ae ? Ar : new Ae(function(Aw) {
                          Aw(Ar);
                      }
                      ))['then'](Ax, Ap);
                  }
                  AF((Ac = Ac['apply'](Ai, Ab || []))['next']());
              }
              );
          };
          let vb = 0x0;
          function vc() {
              return 'qe_uid_' + vb++;
          }
          function vH(Ai) {
              let Ab = [];
              for (let Ae of Ai)
                  for (let Ac of Ae)
                      Ab['push'](Ac);
              return Ab;
          }
          function vt(Ai, Ab) {
              return null == Ai ? Ab : Ai;
          }
          function vx(Ai, Ab, Ae) {
              if (Ai = Ai || {},
              Ae) {
                  for (let Ac in Ae)
                      Ai[Ac] = Ae[Ac];
              }
              if (Ab) {
                  for (let AH in Ab)
                      Ai[AH] = Ab[AH];
              }
              return Ai;
          }
          function vp(Ai, Ab) {
              const Ae = (Ax,Ap,AF)=>{
                  const Ay = Ax[AF];
                  Ay instanceof Array ? (vB(Ap[AF]) || (Ap[AF] = []),
                  AH(Ay, Ap[AF])) : 'object' == typeof Ay ? (vB(Ap[AF]) || (Ap[AF] = {}),
                  Ac(Ay, Ap[AF])) : Ap[AF] = Ay;
              }
                , Ac = (Ax,Ap)=>{
                  const AF = Object['keys'](Ax);
                  for (const Ay of AF)
                      Ae(Ax, Ap, Ay);
              }
                , AH = (Ax,Ap)=>{
                  for (let AF = 0x0; AF < Ax['length']; AF++)
                      Ae(Ax, Ap, AF);
              }
              ;
              let At = Ab;
              return Ai instanceof Array ? (!At || At instanceof Array ? vB(At) || (At = []) : (vv['kg']['warn'](''),
              At = []),
              AH(Ai, At)) : 'object' == typeof Ai ? (At && 'object' != typeof At ? (vv['kg']['warn']('Object'),
              At = {}) : vB(At) || (At = {}),
              Ac(Ai, At)) : (At = Ai,
              vv['kg']['debug']('')),
              At;
          }
          function vF(Ai, Ab, Ae) {
              return Ai = Ai || {},
              Ae && (Ai = vp(Ae)),
              Ab && (Ai = vp(Ab, Ai)),
              Ai;
          }
          function vy(Ai) {
              let Ab = Math['sqrt'](Ai[0x0] * Ai[0x0] + Ai[0x1] * Ai[0x1])
                , Ae = 0x10e - 0xb4 * Math['atan2'](Ai[0x1], Ai[0x0]) / Math['PI'];
              return Ae %= 0x168,
              [Ab, Ae];
          }
          function vr(Ai) {
              let Ab = (0x10e - Ai[0x1]) * Math['PI'] / 0xb4;
              return [Ai[0x0] * Math['cos'](Ab), Ai[0x0] * Math['sin'](Ab)];
          }
          function vw(Ai) {
              return vi(this, undefined, undefined, function*() {
                  return vX(Ai)['then'](Ab=>Ab['json']())['catch'](vv['kg']['debug']);
              });
          }
          function vs(Ai, Ab=false) {
              return vi(this, undefined, undefined, function*() {
                  let Ae;
                  if (Ai['endsWith']('zip') || Ab)
                      Ae = (yield vu(Ai, undefined, 'text', true))[0x0];
                  else {
                      const Ac = yield vX(Ai);
                      Ae = yield Ac['text']();
                  }
                  return Ae;
              });
          }
          function vh(Ai) {
              return vi(this, undefined, undefined, function*() {
                  return vu(Ai, undefined, 'text', true)['then'](Ab=>JSON['parse'](Ab[0x0]))['catch'](vv['kg']['debug']);
              });
          }
          function vu(Ai, Ab, Ae='arraybuffer', Ac=false, AH) {
              return vi(this, undefined, undefined, function*() {
                  let At;
                  return At = 'function' == typeof Ae ? Ae : Ax=>Ae,
                  vT(Ai)['then'](Ax=>{
                      if (!Ai['endsWith']('zip') && !Ac)
                          return [Ax];
                      const Ap = [];
                      let AF = performance['now']();
                      return new (v4())()['loadAsync'](Ax)['then'](Ay=>vi(this, undefined, undefined, function*() {
                          const Ar = Object['keys'](Ay['files'])['length'];
                          for (let Aw in Ay['files']) {
                              let As = Aw;
                              if (As['indexOf']('MACOSX') >= 0x0)
                                  continue;
                              let Ah = Ay['files'][As];
                              Ab && !Ab(Ah) || (yield Ah['async'](At(Ah))['then'](Au=>{
                                  vv['kg']['debug']('unzip\x20' + As + '\x20costs\x20' + (performance['now']() - AF) + 'ms'),
                                  AF = performance['now'](),
                                  AH && AH(Au, Ah, Ar),
                                  Ap['push'](Au);
                              }
                              )['catch'](vv['kg']['debug']));
                          }
                          return Ap;
                      }))['catch'](vv['kg']['debug']);
                  }
                  )['catch'](vv['kg']['debug']);
              });
          }
          function vY(Ai, Ab, Ae, Ac='arraybuffer', AH=false) {
              return vi(this, undefined, undefined, function*() {
                  const At = [];
                  for (const Ax of Ai) {
                      const Ap = yield vu(Ax, Ae, Ac, AH)['catch'](vv['kg']['debug']);
                      Ab && Ab(Ap),
                      At['push'](...Ap);
                  }
                  return At;
              });
          }
          function vT(Ai) {
              return vi(this, undefined, undefined, function*() {
                  return vX(Ai)['then'](Ab=>Ab['arrayBuffer']())['catch'](vv['kg']['debug']);
              });
          }
          let vX = fetch['bind'](window);
          function Quadtree(Ai, Ab, Ae) {
              return null == Ai ? Ab : Ae ? Ae(Ai) : Ai;
          }
          function vf(Ai, ...Ab) {
              var Ae, Ac, AH, At;
              for (Ac = 0x1,
              AH = arguments['length']; Ac < AH; Ac++)
                  for (Ae in At = arguments[Ac])
                      Ai[Ae] = At[Ae];
              return Ai;
          }
          function vW(Ai) {
              return Ai['_qe_id'] = Ai['_leaflet_id'] || vc(),
              Ai['_qe_id'];
          }
          function vI(Ai) {
              return Ai['trim']()['split'](/\s+/);
          }
          function vj(Ai, Ab, Ae) {
              var Ac = ((0x2 * Ae - 0x1) / 0x1 + 0x1) / 0x2
                , AH = 0x1 - Ac
                , At = vt(Ai['a'], 0x1)
                , Ax = vt(Ab['a'], 0x1);
              return 0x0 === At && (At = 0.001),
              0x0 === Ax && (Ax = 0.001),
              {
                  'r': Math['round'](Ai['r'] * Ac + Ab['r'] * AH),
                  'g': Math['round'](Ai['g'] * Ac + Ab['g'] * AH),
                  'b': Math['round'](Ai['b'] * Ac + Ab['b'] * AH),
                  'a': At * Ac + Ax * AH
              };
          }
          function vD(Ai, Ab, Ae) {
              return Math['floor']((Ae - Ai) / Ab);
          }
          function vV(Ai, Ab) {
              return {
                  'x': Ai % Ab,
                  'y': Math['floor'](Ai / Ab)
              };
          }
          function vZ(Ai, Ab, Ae) {
              return Ab * Ae + Ai;
          }
          function vB(Ai) {
              return null != Ai && ('number' != typeof Ai || !isNaN(Ai));
          }
          Array['isArray'] || (Array['isArray'] = function(Ai) {
              return '[object\x20Array]' === Object['prototype']['toString']['call'](Ai);
          }
          ),
          'function' != typeof Object['assign'] && Object['defineProperty'](Object, 'assign', {
              'value': function(Ai, Ab) {
                  if (null == Ai)
                      throw new TypeError('Cannot\x20convert\x20undefined\x20or\x20null\x20to\x20object');
                  let Ae = Object(Ai);
                  for (let Ac = 0x1; Ac < arguments['length']; Ac++) {
                      const AH = arguments[Ac];
                      if (null != AH) {
                          for (let At in AH)
                              Object['prototype']['hasOwnProperty']['call'](AH, At) && (Ae[At] = AH[At]);
                      }
                  }
                  return Ae;
              },
              'writable': true,
              'configurable': true
          });
          const vS = Object['prototype']['hasOwnProperty']
            , vU = 'undefined' != typeof Symbol ? Symbol['toStringTag'] : undefined;
          function vd(Ai) {
              return Object['prototype']['toString']['call'](Ai)['slice'](0x8, -0x1)['toLowerCase']();
          }
          function vq(Ai) {
              if (!vJ(Ai))
                  return false;
              const Ab = function(Ae) {
                  if (null === Ae)
                      return undefined === Ae ? '[object\x20Undefined]' : '[object\x20Null]';
                  if (!vU || !(vU in Object(Ae)))
                      return toString['call'](Ae);
                  const Ac = vS['call'](Ae, vU)
                    , AH = Ae[vU];
                  let At = false;
                  try {
                      Ae[vU] = undefined,
                      At = true;
                  } catch (Ap) {}
                  const Ax = Object['prototype']['toString']['call'](Ae);
                  return At && (Ac ? Ae[vU] = AH : delete Ae[vU]),
                  Ax;
              }(Ai);
              return '[object\x20Function]' === Ab || '[object\x20AsyncFunction]' === Ab || '[object\x20GeneratorFunction]' === Ab || '[object\x20Proxy]' === Ab;
          }
          function vJ(Ai) {
              const Ab = typeof Ai;
              return null !== Ai && ('object' === Ab || 'function' === Ab);
          }
          function vo(Ai) {
              return '[object\x20Date]' === Object['prototype']['toString']['call'](Ai);
          }
          function vC(Ai) {
              return '[object\x20ArrayBuffer]' === Object['prototype']['toString']['call'](Ai);
          }
          function vO(Ai) {
              return null != Ai && ('string' == typeof Ai || null !== Ai['constructor'] && Ai['constructor'] === String);
          }
          function vG(Ai) {
              return '[object\x20Number]' === Object['prototype']['toString']['call'](Ai) && !isNaN(Ai);
          }
          function vg(Ai) {
              let Ab;
              for (Ab in Ai)
                  return false;
              return !Ab;
          }
          function vN(Ai) {
              return null == Ai;
          }
          function vP(Ai) {
              return Array['isArray'](Ai);
          }
          function vM(Ai, ...Ab) {
              return Object['assign'](Ai, ...Ab);
          }
          function va(Ai, Ab) {
              return Ai - Ab * Math['floor'](Ai / Ab);
          }
          function vz(Ai) {
              return null != Ai && ('number' != typeof Ai || !isNaN(Ai));
          }
          function vQ(Ai, Ab, Ae) {
              let Ac;
              const AH = At=>{
                  Ab && Ab(),
                  Ac ? clearTimeout(Ac) : Ae && Ae(),
                  Ac = setTimeout(()=>{
                      Ai(),
                      Ac = undefined;
                  }
                  , 0x12c);
              }
              ;
              return window['addEventListener']('resize', AH),
              {
                  'remove': ()=>window['removeEventListener']('resize', AH)
              };
          }
          function vm(Ai, Ab) {
              var Ae = document['createElement']('a');
              Ae['setAttribute']('href', Ai),
              Ae['setAttribute']('download', Ab),
              Ae['click']();
          }
          function vL(Ai) {
              return Ai < 0x0 ? Ai + 0x168 : Ai;
          }
          function vR(Ai, Ab, Ae, Ac) {
              if (0x0 === Ab['alpha']())
                  return Ai;
              var AH = ((0x2 * Ae - 0x1) / 0x1 + 0x1) / 0x2
                , At = 0x1 - AH;
              return new v7['t']({
                  'r': Math['round'](Ai['red']() * AH + Ab['red']() * At),
                  'g': Math['round'](Ai['green']() * AH + Ab['green']() * At),
                  'b': Math['round'](Ai['blue']() * AH + Ab['blue']() * At),
                  'a': Ac
              });
          }
          const A0 = (Ai,Ab)=>Ab['replace'](/\\?{.*?}/g, Ae=>{
              if (Ae['startsWith']('\x5c'))
                  return Ae['slice'](0x1);
              switch (Ae) {
              case '{yyyy}':
                  return '' + Ai['getFullYear']();
              case '{yy}':
                  return ('' + Ai['getFullYear']())['slice'](-0x2);
              case '{MM}':
                  return ('' + (Ai['getMonth']() + 0x1))['padStart'](0x2, '0');
              case '{dd}':
                  return ('' + Ai['getDate']())['padStart'](0x2, '0');
              case '{HH}':
                  return ('' + Ai['getHours']())['padStart'](0x2, '0');
              case '{mm}':
                  return ('' + Ai['getMinutes']())['padStart'](0x2, '0');
              case '{ss}':
                  return ('' + Ai['getSeconds']())['padStart'](0x2, '0');
              case '{SSS}':
                  return ('' + Ai['getMilliseconds']())['padStart'](0x3, '0');
              default:
                  return '';
              }
          }
          );
          function A1(Ai) {
              const Ab = performance['now']();
              let Ae = 0x1 / 0x0
                , Ac = -0x1 / 0x0;
              return Ai['forEachYx'](AH=>{
                  Ai['isUndef'](AH) || (AH < Ae && (Ae = AH),
                  AH > Ac && (Ac = AH));
              }
              ),
              vv['kg']['debug']('calc\x20max\x20min\x20costs\x20' + (performance['now']() - Ab) + 'ms'),
              {
                  'min': Ae,
                  'max': Ac
              };
          }
          function A2(Ai, Ab, Ae=true, Ac=true, AH) {
              let At = Ai['getGrid']()
                , Ax = -0xf423f
                , Ap = 0x0;
              const AF = (As,Ah)=>{
                  let Au = new v5['P'](At['dataType'],At['xSize'],At['ySize']);
                  Au['undef'] = At['undef'];
                  let AY = Ai['allGrids']()[AH || 0x0];
                  for (let AT = As; AT < Ah; AT++) {
                      let AX = AY[AT];
                      for (let AE = 0x0; AE < AX['raw']['length']; AE++) {
                          const Af = AX['read1D'](AE);
                          Af !== Au['undef'] && Au['raw'][AE] < Af && (Au['raw'][AE] = Af),
                          Ax < Af && (Ax = Af,
                          Ap = AE);
                      }
                  }
                  return -0xf423f === Ax && (Ax = Au['undef']),
                  new v9['o']([[Au]],{
                      'gridOptions': Ai['gridOptions']
                  });
              }
                , Ay = Ai['allGrids']()[0x0]['length'];
              let Ar, Aw;
              return Ae && (Ar = AF(Ab, Ay)),
              Ac && (Aw = AF(0x0, Ab + 0x1)),
              {
                  'upper': Ar,
                  'lower': Aw,
                  'maxPos': Ap,
                  'maxVal': Ax
              };
          }
          function A3(Ai, Ab, Ae, Ac, AH) {
              const At = Ae - Ab + 0x1
                , Ax = AH - Ac + 0x1
                , Ap = new v5['P'](Ai['dataType'],At,Ax,undefined,Ai['undef'],Ai['algo'],Ai['dataScale'],Ai['dataOffset'])
                , AF = [];
              for (let Ay = Ac; Ay <= AH; Ay++) {
                  const Ar = Ay * Ai['xSize'];
                  for (let Aw = Ab; Aw <= Ae; Aw++) {
                      const As = Ar + Aw
                        , Ah = Ai['raw'][As];
                      AF['push'](Ah);
                  }
              }
              return Ap['update'](AF),
              Ap;
          }
          function A4(Ai, Ab) {
              const Ae = (0x0,
              v6['Z'])(Ai['gridOptions']);
              if (Ab['maxLat'] > Ae['maxLat'] || Ab['minLat'] < Ae['minLat'] || Ab['maxLon'] > Ae['maxLon'] || Ab['minLon'] < Ae['minLon'])
                  return vv['kg']['warn'](''),
                  Ai;
              const Ac = Ai['gridOptions']['xDelta'] > 0x0 ? Ab['minLon'] : Ab['maxLon']
                , AH = Ai['gridOptions']['yDelta'] > 0x0 ? Ab['minLat'] : Ab['maxLat']
                , At = Ai['gridOptions']['xDelta'] > 0x0 ? Ab['maxLon'] : Ab['minLon']
                , Ax = Ai['gridOptions']['yDelta'] > 0x0 ? Ab['maxLat'] : Ab['minLat']
                , Ap = vD(Ai['gridOptions']['xStart'], Ai['gridOptions']['xDelta'], Ac)
                , AF = vD(Ai['gridOptions']['yStart'], Ai['gridOptions']['yDelta'], AH)
                , Ay = vD(Ai['gridOptions']['xStart'], Ai['gridOptions']['xDelta'], At)
                , Ar = vD(Ai['gridOptions']['yStart'], Ai['gridOptions']['yDelta'], Ax)
                , Aw = Ay - Ap + 0x1
                , As = Ar - AF + 0x1
                , Ah = {
                  'xStart': Ai['gridOptions']['xStart'] + Ap * Ai['gridOptions']['xDelta'],
                  'yStart': Ai['gridOptions']['yStart'] + AF * Ai['gridOptions']['yDelta'],
                  'xSize': Aw,
                  'ySize': As,
                  'xDelta': Ai['gridOptions']['xDelta'],
                  'yDelta': Ai['gridOptions']['yDelta']
              };
              (0x0,
              v6['T'])(Ah);
              const Au = Ai['allGrids']()
                , AY = Au['length'];
              if (0x0 === AY)
                  return console['warn'](''),
                  Ai;
              const AT = Au[0x0]['length']
                , AX = [];
              for (let AE = 0x0; AE < AY; AE++) {
                  const Af = [];
                  for (let AW = 0x0; AW < AT; AW++) {
                      const AI = A3(Ai['getGrid'](AE, AW), Ap, Ay, AF, Ar);
                      Af['push'](AI);
                  }
                  AX['push'](Af);
              }
              return new v9['o'](AX,{
                  'gridOptions': Ah
              });
          }
          function A5(Ai, Ab='grid.mesh') {
              const Ae = performance['now']()
                , Ac = new Float32Array(Ai['xSize'] * Ai['ySize']);
              for (let AF = 0x0; AF < Ac['length']; AF++)
                  Ac[AF] = AF;
              let AH = 0x0;
              const At = (Ai['xSize'] - 0x1) * (Ai['ySize'] - 0x1) * 0x6
                , Ax = new Uint32Array(At);
              for (let Ay = 0x0; Ay < Ai['xSize'] * Ai['ySize'] - Ai['xSize']; Ay++) {
                  if ((Ay + 0x1) % Ai['xSize'] == 0x0)
                      continue;
                  const Ar = Ay
                    , Aw = Ay + Ai['xSize']
                    , As = Aw + 0x1
                    , Ah = Ar + 0x1;
                  Ax[AH++] = Ar,
                  Ax[AH++] = Aw,
                  Ax[AH++] = As,
                  Ax[AH++] = Ar,
                  Ax[AH++] = As,
                  Ax[AH++] = Ah;
              }
              const Ap = new Blob([Ac, Ax]);
              vm(window['URL']['createObjectURL'](Ap), Ab),
              vv['kg']['debug']('cache\x20mesh\x20costs\x20' + (performance['now']() - Ae) + 'ms');
          }
          function A6(Ai, Ab) {
              return vi(this, undefined, undefined, function*() {
                  const Ae = yield(yield vX(Ab))['arrayBuffer']()
                    , Ac = Ai['xSize'] * Ai['ySize'] * 0x4;
                  return {
                      'ids': new Float32Array(Ae,0x0,Ac),
                      'indices': new Uint32Array(Ae,Ac)
                  };
              });
          }
          function A7(Ai, Ab) {
              switch (Ai) {
              case v8['U']['UInt8']:
                  return new Uint8Array(Ab);
              case v8['U']['Int8']:
                  return new Int8Array(Ab);
              case v8['U']['UInt16']:
                  return new Uint16Array(Ab);
              case v8['U']['Int16']:
                  return new Int16Array(Ab);
              case v8['U']['UInt32']:
                  return new Uint32Array(Ab);
              case v8['U']['Int32']:
                  return new Int32Array(Ab);
              case v8['U']['Float32']:
                  return new Float32Array(Ab);
              case v8['U']['Float64']:
                  return new Float64Array(Ab);
              default:
                  throw new Error('not\x20supported\x20grid\x20data\x20type\x20' + Ai);
              }
          }
          function A8(Ai) {
              return vi(this, undefined, undefined, function*() {
                  return new Promise((Ab,Ae)=>{
                      const Ac = Ai['length'];
                      let AH = 0x0;
                      const At = {}
                        , Ax = ()=>{
                          AH++,
                          AH === Ac && Ab(At);
                      }
                      ;
                      for (const Ap of Ai) {
                          const AF = new Image();
                          AF['onerror'] = ()=>{
                              At[Ap] = undefined,
                              Ax();
                          }
                          ,
                          AF['onload'] = ()=>{
                              At[Ap] = AF,
                              Ax();
                          }
                          ,
                          AF['src'] = Ap;
                      }
                  }
                  );
              });
          }
          function A9(Ai, Ab) {
              return Ai + Math['random']() * (Ab - Ai);
          }
          function Av(Ai, Ab=true) {
              const Ae = A9(Ai['minLon'], Ai['maxLon'])
                , Ac = A9(Ai['minLat'], Ai['maxLat']);
              return Ab ? vB(Ai['minHeight']) && vB(Ai['maxHeight']) ? [Ae, Ac, A9(Ai['minHeight'], Ai['maxHeight'])] : [Ae, Ac, 0x0] : [Ae, Ac];
          }
          function AA(Ai, Ab=true) {
              const Ae = Math['min'](Ai['xStart'], Ai['xEnd'])
                , Ac = Math['max'](Ai['xStart'], Ai['xEnd'])
                , AH = Math['min'](Ai['yStart'], Ai['yEnd'])
                , At = Math['max'](Ai['yStart'], Ai['yEnd'])
                , Ax = A9(Ae, Ac)
                , Ap = A9(AH, At);
              return Ab ? Ai['zValues']['length'] > 0x1 ? [Ax, Ap, A9(Ai['zValues'][0x0], Ai['zValues'][Ai['zValues']['length'] - 0x1])] : [Ax, Ap, 0x0] : [Ax, Ap];
          }
          function An(Ai, Ab, Ae, Ac) {
              const AH = Ac / 0x2
                , At = Ae / 0x2;
              return {
                  'minLat': Ai - AH,
                  'maxLat': Ai + AH,
                  'minLon': Ab - At,
                  'maxLon': Ab + At
              };
          }
          function Ak(Ai, Ab=1013.225) {
              return 0xad2b * (0x1 - Math['pow'](Ai / 1013.225, 0.1903));
          }
          function Al(Ai, Ab, Ae=[0x0, 0x2d, 0x5a, 0x87], Ac=undefined, AH=0x5a) {
              Ac || (Ac = Ab['map'](AF=>({
                  'distance': AF,
                  'angle': 0x5a,
                  'value': AF['toString']()
              }))),
              Ab = Ab['sort']((AF,Ay)=>AF - Ay),
              AH = Math['max'](AH, 0xa);
              const At = [];
              Ab['forEach'](AF=>{
                  const Ay = vk(Ai, AF, {
                      'units': 'kilometers',
                      'steps': AH
                  });
                  Ay['properties']['value'] = AF,
                  At['push'](Ay);
              }
              );
              const Ax = [];
              Ae['forEach'](AF=>{
                  const Ay = vl(Ai, Ab[Ab['length'] - 0x1], AF, AF + 0xa, {
                      'steps': AH,
                      'units': 'kilometers'
                  })
                    , Ar = vl(Ai, Ab[Ab['length'] - 0x1], AF + 0xb4, AF + 0xb4 + 0xa, {
                      'steps': AH,
                      'units': 'kilometers'
                  });
                  Ax['push']({
                      'type': 'Feature',
                      'geometry': {
                          'type': 'LineString',
                          'coordinates': [Ay['geometry']['coordinates'][0x0], Ar['geometry']['coordinates'][0x0]]
                      },
                      'properties': {
                          'value': AF
                      }
                  });
              }
              );
              const Ap = [];
              return Ac['forEach'](AF=>{
                  var Ay;
                  const Ar = vl(Ai, AF['distance'], AF['angle'], AF['angle'] + 0xa, {
                      'steps': AH,
                      'units': 'kilometers'
                  });
                  Ap['push']({
                      'type': 'Feature',
                      'geometry': {
                          'type': 'Point',
                          'coordinates': Ar['geometry']['coordinates'][0x0]
                      },
                      'properties': {
                          'value': null !== (Ay = AF['value']) && undefined !== Ay ? Ay : AF['distance'],
                          'distance': AF['distance'],
                          'angle': AF['angle']
                      }
                  });
              }
              ),
              {
                  'type': 'FeatureCollection',
                  'features': [...At, ...Ax, ...Ap]
              };
          }
          const AK = (Ai,Ab,Ae)=>vi(undefined, undefined, undefined, function*() {
              return new Promise((Ac,AH)=>{
                  try {
                      if (document['getElementById'](Ab)) {
                          if (window[Ae])
                              return Ac(null);
                          let At = 0x0;
                          const Ax = setInterval(()=>{
                              if (window[Ae] || !(At < 0x5))
                                  return At++,
                                  clearInterval(Ax),
                                  Ac(null);
                          }
                          , 0x1f4);
                      } else {
                          const Ap = document['createElement']('script');
                          Ap['setAttribute']('type', 'text/javascript'),
                          Ap['setAttribute']('id', Ab),
                          Ap['onload'] = Ac,
                          Ap['onerror'] = AH,
                          Ap['src'] = Ai,
                          Ap['async'] = true,
                          document['body']['appendChild'](Ap);
                      }
                  } catch (AF) {
                      AH(AF);
                  }
              }
              );
          });
      }
      ,
      0xcc: (l,K,b)=>{
          'use strict';
          b['d'](K, {
              'Z': ()=>x
          });
          var c = b(0x4b)
            , H = b(0x32b);
          function x(F, y, w, Y) {
              undefined === Y && (Y = {});
              var T = (0x0,
              H['c9'])(F)
                , X = (0x0,
              c['Ht'])(T[0x0])
                , E = (0x0,
              c['Ht'])(T[0x1])
                , W = (0x0,
              c['Ht'])(w)
                , I = (0x0,
              c['lF'])(y, Y['units'])
                , j = Math['asin'](Math['sin'](E) * Math['cos'](I) + Math['cos'](E) * Math['sin'](I) * Math['cos'](W))
                , D = X + Math['atan2'](Math['sin'](W) * Math['sin'](I) * Math['cos'](E), Math['cos'](I) - Math['sin'](E) * Math['sin'](j))
                , V = (0x0,
              c['vi'])(D)
                , Z = (0x0,
              c['vi'])(j);
              return (0x0,
              c['xm'])([V, Z], Y['properties']);
          }
      }
      ,
      0x4b: (K,b,H)=>{
          'use strict';
          H['d'](b, {
              'DL': ()=>T,
              'Ht': ()=>W,
              'Tu': ()=>Y,
              'lF': ()=>X,
              'vi': ()=>E,
              'xm': ()=>y,
              'yu': ()=>w,
              'zL': ()=>F
          });
          var x = 6371008.8
            , p = {
              'centimeters': 0x25f96350,
              'centimetres': 0x25f96350,
              'degrees': 57.22891354143274,
              'feet': 20902260.511392,
              'inches': 39.37 * x,
              'kilometers': 6371.0088,
              'kilometres': 6371.0088,
              'meters': x,
              'metres': x,
              'miles': 3958.761333810546,
              'millimeters': 0x17bbde120,
              'millimetres': 0x17bbde120,
              'nauticalmiles': x / 0x73c,
              'radians': 0x1,
              'yards': 6967335.223679999
          };
          function F(j, D, V) {
              undefined === V && (V = {});
              var Z = {
                  'type': 'Feature'
              };
              return (0x0 === V['id'] || V['id']) && (Z['id'] = V['id']),
              V['bbox'] && (Z['bbox'] = V['bbox']),
              Z['properties'] = D || {},
              Z['geometry'] = j,
              Z;
          }
          function y(j, D, V) {
              if (undefined === V && (V = {}),
              !j)
                  throw new Error('coordinates\x20is\x20required');
              if (!Array['isArray'](j))
                  throw new Error('coordinates\x20must\x20be\x20an\x20Array');
              if (j['length'] < 0x2)
                  throw new Error('coordinates\x20must\x20be\x20at\x20least\x202\x20numbers\x20long');
              if (!I(j[0x0]) || !I(j[0x1]))
                  throw new Error('coordinates\x20must\x20contain\x20numbers');
              return F({
                  'type': 'Point',
                  'coordinates': j
              }, D, V);
          }
          function w(j, D, V) {
              undefined === V && (V = {});
              for (var Z = 0x0, B = j; Z < B['length']; Z++) {
                  var S = B[Z];
                  if (S['length'] < 0x4)
                      throw new Error('Each\x20LinearRing\x20of\x20a\x20Polygon\x20must\x20have\x204\x20or\x20more\x20Positions.');
                  for (var U = 0x0; U < S[S['length'] - 0x1]['length']; U++)
                      if (S[S['length'] - 0x1][U] !== S[0x0][U])
                          throw new Error('First\x20and\x20last\x20Position\x20are\x20not\x20equivalent.');
              }
              return F({
                  'type': 'Polygon',
                  'coordinates': j
              }, D, V);
          }
          function Y(j, D, V) {
              if (undefined === V && (V = {}),
              j['length'] < 0x2)
                  throw new Error('coordinates\x20must\x20be\x20an\x20array\x20of\x20two\x20or\x20more\x20positions');
              return F({
                  'type': 'LineString',
                  'coordinates': j
              }, D, V);
          }
          function T(j, D) {
              undefined === D && (D = 'kilometers');
              var V = p[D];
              if (!V)
                  throw new Error(D + '\x20units\x20is\x20invalid');
              return j * V;
          }
          function X(j, D) {
              undefined === D && (D = 'kilometers');
              var V = p[D];
              if (!V)
                  throw new Error(D + '\x20units\x20is\x20invalid');
              return j / V;
          }
          function E(j) {
              return j % (0x2 * Math['PI']) * 0xb4 / Math['PI'];
          }
          function W(j) {
              return j % 0x168 * Math['PI'] / 0xb4;
          }
          function I(j) {
              return !isNaN(j) && null !== j && !Array['isArray'](j);
          }
      }
      ,
      0x32b: (l,K,b)=>{
          'use strict';
          function c(x) {
              if (!x)
                  throw new Error('coord\x20is\x20required');
              if (!Array['isArray'](x)) {
                  if ('Feature' === x['type'] && null !== x['geometry'] && 'Point' === x['geometry']['type'])
                      return x['geometry']['coordinates'];
                  if ('Point' === x['type'])
                      return x['coordinates'];
              }
              if (Array['isArray'](x) && x['length'] >= 0x2 && !Array['isArray'](x[0x0]) && !Array['isArray'](x[0x1]))
                  return x;
              throw new Error('coord\x20must\x20be\x20GeoJSON\x20Point\x20or\x20an\x20Array\x20of\x20numbers');
          }
          function H(x) {
              return 'Feature' === x['type'] ? x['geometry'] : x;
          }
          b['d'](K, {
              'c9': ()=>c,
              'wA': ()=>H
          }),
          b(0x4b);
      }
  }
    , A = {};
  function n(l) {
      var K = A[l];
      if (undefined !== K)
          return K['exports'];
      var i = A[l] = {
          'exports': {}
      };
      return v[l](i, i['exports'], n),
      i['exports'];
  }
  n['n'] = l=>{
      var K = l && l['__esModule'] ? ()=>l['default'] : ()=>l;
      return n['d'](K, {
          'a': K
      }),
      K;
  }
  ,
  n['d'] = (l,K)=>{
      for (var i in K)
          n['o'](K, i) && !n['o'](l, i) && Object['defineProperty'](l, i, {
              'enumerable': true,
              'get': K[i]
          });
  }
  ,
  n['o'] = (l,K)=>Object['prototype']['hasOwnProperty']['call'](l, K),
  n['r'] = l=>{
      'undefined' != typeof Symbol && Symbol['toStringTag'] && Object['defineProperty'](l, Symbol['toStringTag'], {
          'value': 'Module'
      }),
      Object['defineProperty'](l, '__esModule', {
          'value': true
      });
  }
  ;
  var k = {};
  return (()=>{
      'use strict';
      n['r'](k),
      n['d'](k, {
          'Array2DGridDataProvider': ()=>Array2DGridDataProvider,
          'BinaryGridDataProvider': ()=>BinaryGridDataProvider,
          'BinaryReader': ()=>BinaryReader,
          'BitmapColorScaleGL': ()=>iS['Xm'],
          'CSStyle': ()=>iB['NX'],
          'CSStyle3D': ()=>CSStyle3D,
          'CimissGridDataProvider': ()=>CimissGridDataProvider,
          'CimissStationFeatureProvider': ()=>CimissStationFeatureProvider,
          'CollisionDetectMode': ()=>CollisionDetectMode,
          'CollisonDetector': ()=>CollisonDetector,
          'DAPParserType': ()=>e1['ko'],
          'DAPService': ()=>DAPService,
          'DASParser': ()=>e1['Bn'],
          'DDSParser': ()=>e1['cF'],
          'DODSUnpacker': ()=>DODSUnpacker,
          'DataAnimationService': ()=>DataAnimationService,
          'DataAnimationType': ()=>DataAnimationType,
          'Evented': ()=>iT['c'],
          'FeatureBaseClass': ()=>iB['rJ'],
          'FeatureBooleanField2FeatureBooleanFunc': ()=>iB['pd'],
          'FeatureColorField2FeatureColorFunc': ()=>iB['Jf'],
          'FeatureDataProviderBase': ()=>FeatureDataProviderBase,
          'FeatureImageField2FeatureImageFunc': ()=>iB['cQ'],
          'FeatureImageStyle': ()=>iB['Tw'],
          'FeatureLabelStyle': ()=>iB['PE'],
          'FeatureLabelStyle3D': ()=>FeatureLabelStyle3D,
          'FeatureNumberArrayField2FeatureNumberArrayFunc': ()=>iB['q$'],
          'FeatureNumberField2FeatureNumberFunc': ()=>iB['JW'],
          'FeatureStringField2FeatureStringFunc': ()=>iB['Fj'],
          'FeatureStyle': ()=>iB['sC'],
          'FeatureStyle3D': ()=>FeatureStyle3D,
          'FeatureTextStyle': ()=>iB['oL'],
          'FeatureVolumeStyle': ()=>FeatureVolumeStyle,
          'FrameDrawService': ()=>FrameDrawService,
          'GeoJSONFeatureProvider': ()=>GeoJSONFeatureProvider,
          'Geometry3DLayerStyle': ()=>iS['Yv'],
          'Geometry3DSectionMode': ()=>iS['vS'],
          'GeometryStyle': ()=>iB['CI'],
          'GrayImageGridData': ()=>KN['K'],
          'GrayImageGridDataProvider': ()=>GrayImageGridDataProvider,
          'GridBaseStyle': ()=>iU['W6'],
          'GridBooleanField2GridBooleanFunc': ()=>iU['se'],
          'GridColorField2GridColorFunc': ()=>iU['vX'],
          'GridData': ()=>KN['P'],
          'GridDataGLFillMode': ()=>iS['sW'],
          'GridDataProviderBase': ()=>Km['r'],
          'GridDataType': ()=>KP['U'],
          'GridGLBaseStyle': ()=>iS['$n'],
          'GridImageField2GridImageFunc': ()=>iU['CN'],
          'GridImageFieldGL2TexImage': ()=>iS['Rd'],
          'GridImageStyle': ()=>iU['$f'],
          'GridLabelStyle': ()=>iU['dl'],
          'GridNumberArrayField2GridNumberArrayFunc': ()=>iU['UZ'],
          'GridNumberArrayFieldGL2GridNumberArray': ()=>iS['ce'],
          'GridNumberField2GridNumberFunc': ()=>iU['Dg'],
          'GridStringField2GridStringFunc': ()=>iU['no'],
          'GridTextStyle': ()=>iU['x1'],
          'IDWScatterInterpolator': ()=>IDWScatterInterpolator,
          'LayerCreator': ()=>LayerCreator,
          'LegendService': ()=>LegendService,
          'LogService': ()=>v0['$V'],
          'MCBDefaults': ()=>MCBDefaults,
          'MapToolService': ()=>MapToolService,
          'MemoryGridDataProvider': ()=>iu['o'],
          'MemoryWindDataProvider': ()=>MemoryWindDataProvider,
          'MicapsDiamond131GridDataProvider': ()=>MicapsDiamond131GridDataProvider,
          'JsonGridDataProvider': ()=>JsonGridDataProvider,
          'MicapsDiamond14FeatureProvider': ()=>MicapsDiamond14FeatureProvider,
          'MicapsDiamond2WindGridProvider': ()=>MicapsDiamond2WindGridProvider,
          'MicapsDiamond4GridDataProvider': ()=>MicapsDiamond4GridDataProvider,
          'PixelLayerStyle': ()=>iS['lj'],
          'PixelLayerStyle3D': ()=>iS['_E'],
          'PlainNumberArrayField2PlainNumberArrayFunc': ()=>iB['M'],
          'PlotConstants': ()=>PlotConstants,
          'PlotLineBase': ()=>PlotLineBase,
          'PlotPointBase': ()=>PlotPointBase,
          'PlotPolygonBase': ()=>PlotPolygonBase,
          'PlotShapeBase': ()=>eA,
          'PlotTypes': ()=>eH,
          'PointArrayFeatureProvider': ()=>b4,
          'PointImageStyle3D': ()=>iP,
          'PointStyle': ()=>iB['SC'],
          'PointStyle3D': ()=>iO,
          'PolygonStyle': ()=>iB['_7'],
          'PolygonStyle3D': ()=>ig,
          'PolylineStyle': ()=>iB['Xx'],
          'PolylineStyle3D': ()=>PolylineStyle3D,
          'QEGridDataProvider': ()=>QEGridDataProvider,
          'Quadtree': ()=>Quadtree,
          'RandomFeatureProvider': ()=>bH,
          'ResourceService': ()=>iz['zc'],
          'SimpleDapInfoParser': ()=>e1['b_'],
          'Spectra': ()=>id['t'],
          'StopRuleActionMode': ()=>iR['Mg'],
          'StopRuleItemFilterMode': ()=>iR['DY'],
          'StopRules': ()=>iR['NB'],
          'StyleBaseClass': ()=>iq['Uw'],
          'TifGridDataProvider': ()=>bb,
          'TracingService': ()=>bL,
          'TypeOf': ()=>Kz['BR'],
          'VectorMapTool': ()=>VectorMapTool,
          'VectorMapToolPointerButtonType': ()=>c9,
          'VolumeLayerStyle': ()=>iS['IW'],
          'Wind3DLayerStyle': ()=>iS['we'],
          'WindArrowLayerStyle': ()=>iS['S2'],
          'WindInterpMethodType': ()=>iS['Lh'],
          'WindLayerStyle': ()=>iS['SR'],
          'addCustomImageTileRules': ()=>cX,
          'antiDebug': ()=>KL['jr'],
          'array2Spectra': ()=>iq['LH'],
          'assign': ()=>Kz['f0'],
          'auth': ()=>cB,
          'authInfo': ()=>cf,
          'bitmapColorScaleFieldGL2BitmapColorScaleGL': ()=>iS['sC'],
          'bufferExtent': ()=>Kz['VS'],
          'calcMaxMin': ()=>Kz['pj'],
          'clipGridData': ()=>Kz['U2'],
          'clipGridProvider': ()=>Kz['ZS'],
          'colorStopRuleItemConverter': ()=>iq['$k'],
          'consts': ()=>Kg['v'],
          'createBoxGeometry': ()=>cK,
          'createDrawPlot': ()=>createDrawPlot,
          'createGLTypedArray': ()=>createGLTypedArray,
          'createRadarRangeRingGeoJSON': ()=>Kz['Ef'],
          'createTypeArr': ()=>Kz['cM'],
          'deepCopyLiteral': ()=>Kz['f8'],
          'defaultLoaderNames': ()=>cF['ke'],
          'defaultVal': ()=>Kz['En'],
          'defined': ()=>Kz['ri'],
          'degreeToArc': ()=>cF['Qs'],
          'detectBrowser': ()=>KL['Ao'],
          'detectOS': ()=>KL['fV'],
          'downloadImage': ()=>Kz['GN'],
          'drawCustomGridSection': ()=>cx,
          'drawGridSection': ()=>cp,
          'drawRoundRect': ()=>cH,
          'earcut': ()=>v1,
          'earcutFlatten': ()=>vX,
          'ensureFloatString': ()=>ik,
          'ensureGridDataOptions': ()=>KM['T'],
          'extend': ()=>Kz['l7'],
          'featureStyleResourceCreator': ()=>iz['gD'],
          'floorMod': ()=>Kz['vY'],
          'formatDate': ()=>Kz['p6'],
          'getAlgoConstsAndUniforms': ()=>i7,
          'getBinaries': ()=>Kz['K0'],
          'getBinary': ()=>Kz['j$'],
          'getCR': ()=>Kz['BG'],
          'getFieldLoader': ()=>cF['nA'],
          'getGridPosIndex': ()=>Kz['tr'],
          'getHeightAlgoConstsAndUniforms': ()=>i6,
          'getHeightUniforms': ()=>iA,
          'getImageTileUrls': ()=>cE,
          'getJSON': ()=>Kz['xA'],
          'getJSONZip': ()=>Kz['lC'],
          'getPos1DFrom2D': ()=>Kz['vi'],
          'getPos2DFrom1D': ()=>Kz['Fp'],
          'getPredefinedBitmapScale': ()=>b0['K9'],
          'getPredefinedBitmapScaleSync': ()=>b0['dO'],
          'getPredefinedStopRules': ()=>b0['uD'],
          'getProperlyWebGLVersion': ()=>KL['lS'],
          'getQueryParams': ()=>iq['vl'],
          'getRGBA2FloatConsts': ()=>iK,
          'getRaw': ()=>Kz['oT'],
          'getSDFromUV': ()=>Kz['C8'],
          'getText': ()=>Kz['Q'],
          'getTiltPathOfGridDatas': ()=>cc,
          'getUVFromSD': ()=>Kz['Hn'],
          'glNames': ()=>ic,
          'gridColorFieldGL2StopRules': ()=>iS['m_'],
          'gridNumberFieldGL2GridNumberStopRules': ()=>iS['m3'],
          'gridOptionsToExtent': ()=>KM['Z'],
          'gridStaticColorFieldGL2NumberArray': ()=>iS['hM'],
          'gridStaticColorFieldGL2Spectra': ()=>iS['uI'],
          'gridStyleResourceCreator': ()=>iz['xR'],
          'imageResourceCreator': ()=>iz['Xf'],
          'init': ()=>cV,
          'injectBuiltInShaderFunctions': ()=>i5,
          'interpColor': ()=>Kz['$k'],
          'isArray': ()=>Kz['kJ'],
          'isArrayBuffer': ()=>Kz['eP'],
          'isDate': ()=>Kz['J_'],
          'isEmpty': ()=>Kz['xb'],
          'isFunction': ()=>Kz['mf'],
          'isMobile': ()=>KL['tq'],
          'isMoblie': ()=>KL['Tz'],
          'isNull': ()=>Kz['Ft'],
          'isNumber': ()=>Kz['hj'],
          'isObject': ()=>Kz['Kn'],
          'isString': ()=>Kz['HD'],
          'isSupportedBrowser': ()=>KL['H$'],
          'isValid': ()=>Kz['JY'],
          'jsonFileResourceCreator': ()=>iz['I$'],
          'layerCreator': ()=>iL,
          'loadAllImages': ()=>Kz['EX'],
          'loadGridMesh': ()=>Kz['d$'],
          'loadResourcesAndLayers': ()=>im,
          'loadScript': ()=>Kz['ve'],
          'logger': ()=>v0['kg'],
          'mcb': ()=>ij,
          'mergeShaderLib': ()=>iF,
          'number2Spectra': ()=>iq['lW'],
          'onWindowSizeChanged': ()=>Kz['Wd'],
          'p2h': ()=>Kz['Tc'],
          'pickColor': ()=>Kz['ft'],
          'preDeinfedImageTileTokens': ()=>cu,
          'predefinedColorNames': ()=>id['m'],
          'predefinedImageTiles': ()=>cY,
          'predefinedLegendNames': ()=>b0['xS'],
          'processFieldWithLoaders': ()=>iq['it'],
          'qeFetch': ()=>Kz['TN'],
          'qeGLFuncs': ()=>iy,
          'randomPointInExtent': ()=>Kz['wO'],
          'randomPointInGrid': ()=>Kz['r_'],
          'randomValueInRange': ()=>Kz['Zu'],
          'rawFileResourceCreator': ()=>iz['GB'],
          'registerDrawPlotCreator': ()=>c7,
          'registerFieldLoader': ()=>cF['OE'],
          'registerFieldLoaders': ()=>cF['c0'],
          'resourceCreatorBase': ()=>iz['pQ'],
          'resourceService': ()=>iz['Zc'],
          'resourceTypePreDefined': ()=>iz['MM'],
          'saveGridMesh': ()=>Kz['XG'],
          'scaleGridProvider': ()=>ix,
          'setAlgoUniforms': ()=>iv,
          'setDirectAlgoUniforms': ()=>i8,
          'setGLNames': ()=>iH,
          'setHeightAlgoUniforms': ()=>i9,
          'setOptions': ()=>Kz['Ov'],
          'setOptionsDeep': ()=>Kz['uw'],
          'setShaders': ()=>ih,
          'shaderLib': ()=>ip,
          'splitWords': ()=>Kz['nf'],
          'stamp': ()=>Kz['Rc'],
          'stopRuleResouceCreator': ()=>iz['qg'],
          'string2Spectra': ()=>iq['$P'],
          'supportWebP': ()=>KL['sU'],
          'toOneDim': ()=>Kz['LG'],
          'uid': ()=>Kz['hQ'],
          'updateLoggerDebugMode': ()=>v0['qr'],
          'whenValid': ()=>Kz['Rf'],
          'windSpeed2ttf': ()=>cF['y$'],
          'wrapLon': ()=>Kz['_6'],
          'ww2ttf': ()=>cF['EO']
      });
      var v0 = n(0x39b);
      function v1(cS, cU, cd) {
          cd = cd || 0x2;
          var cq, cJ, cC, cO, cG, cg, cN, cP = cU && cU['length'], cM = cP ? cU[0x0] * cd : cS['length'], cz = v2(cS, 0x0, cM, cd, true), cQ = [];
          if (!cz || cz['next'] === cz['prev'])
              return cQ;
          if (cP && (cz = function(cL, cR, H0, H1) {
              var H2, H3, H4, H5 = [];
              for (H2 = 0x0,
              H3 = cR['length']; H2 < H3; H2++)
                  (H4 = v2(cL, cR[H2] * H1, H2 < H3 - 0x1 ? cR[H2 + 0x1] * H1 : cL['length'], H1, false)) === H4['next'] && (H4['steiner'] = true),
                  H5['push'](vK(H4));
              for (H5['sort'](v9),
              H2 = 0x0; H2 < H5['length']; H2++)
                  vv(H5[H2], H0),
                  H0 = v3(H0, H0['next']);
              return H0;
          }(cS, cU, cz, cd)),
          cS['length'] > 0x50 * cd) {
              cq = cC = cS[0x0],
              cJ = cO = cS[0x1];
              for (var cm = cd; cm < cM; cm += cd)
                  (cG = cS[cm]) < cq && (cq = cG),
                  (cg = cS[cm + 0x1]) < cJ && (cJ = cg),
                  cG > cC && (cC = cG),
                  cg > cO && (cO = cg);
              cN = 0x0 !== (cN = Math['max'](cC - cq, cO - cJ)) ? 0x1 / cN : 0x0;
          }
          return v4(cz, cQ, cd, cq, cJ, cN),
          cQ;
      }
      function v2(cS, cU, cd, cq, cJ) {
          var cC, cO;
          if (cJ === function(cG, cg, cN, cP) {
              for (var cM = 0x0, cz = cg, cQ = cN - cP; cz < cN; cz += cP)
                  cM += (cG[cQ] - cG[cz]) * (cG[cz + 0x1] + cG[cQ + 0x1]),
                  cQ = cz;
              return cM;
          }(cS, cU, cd, cq) > 0x0) {
              for (cC = cU; cC < cd; cC += cq)
                  cO = vu(cC, cS[cC], cS[cC + 0x1], cO);
          } else {
              for (cC = cd - cq; cC >= cU; cC -= cq)
                  cO = vu(cC, cS[cC], cS[cC + 0x1], cO);
          }
          return cO && vx(cO, cO['next']) && (vY(cO),
          cO = cO['next']),
          cO;
      }
      function v3(cS, cU) {
          if (!cS)
              return cS;
          cU || (cU = cS);
          var cd, cq = cS;
          do {
              if (cd = false,
              cq['steiner'] || !vx(cq, cq['next']) && 0x0 !== vH(cq['prev'], cq, cq['next']))
                  cq = cq['next'];
              else {
                  if (vY(cq),
                  (cq = cU = cq['prev']) === cq['next'])
                      break;
                  cd = true;
              }
          } while (cd || cq !== cU);
          return cU;
      }
      function v4(cS, cU, cd, cq, cJ, cC, cO) {
          if (cS) {
              !cO && cC && function(cP, cM, cz, cQ) {
                  var cm = cP;
                  do {
                      null === cm['z'] && (cm['z'] = vk(cm['x'], cm['y'], cM, cz, cQ)),
                      cm['prevZ'] = cm['prev'],
                      cm['nextZ'] = cm['next'],
                      cm = cm['next'];
                  } while (cm !== cP);
                  cm['prevZ']['nextZ'] = null,
                  cm['prevZ'] = null,
                  function(cL) {
                      var cR, H0, H1, H2, H3, H4, H5, H6, H7 = 0x1;
                      do {
                          for (H0 = cL,
                          cL = null,
                          H3 = null,
                          H4 = 0x0; H0; ) {
                              for (H4++,
                              H1 = H0,
                              H5 = 0x0,
                              cR = 0x0; cR < H7 && (H5++,
                              H1 = H1['nextZ']); cR++)
                                  ;
                              for (H6 = H7; H5 > 0x0 || H6 > 0x0 && H1; )
                                  0x0 !== H5 && (0x0 === H6 || !H1 || H0['z'] <= H1['z']) ? (H2 = H0,
                                  H0 = H0['nextZ'],
                                  H5--) : (H2 = H1,
                                  H1 = H1['nextZ'],
                                  H6--),
                                  H3 ? H3['nextZ'] = H2 : cL = H2,
                                  H2['prevZ'] = H3,
                                  H3 = H2;
                              H0 = H1;
                          }
                          H3['nextZ'] = null,
                          H7 *= 0x2;
                      } while (H4 > 0x1);
                  }(cm);
              }(cS, cq, cJ, cC);
              for (var cG, cg, cN = cS; cS['prev'] !== cS['next']; )
                  if (cG = cS['prev'],
                  cg = cS['next'],
                  cC ? v6(cS, cq, cJ, cC) : v5(cS))
                      cU['push'](cG['i'] / cd),
                      cU['push'](cS['i'] / cd),
                      cU['push'](cg['i'] / cd),
                      vY(cS),
                      cS = cg['next'],
                      cN = cg['next'];
                  else {
                      if ((cS = cg) === cN) {
                          cO ? 0x1 === cO ? v4(cS = v7(v3(cS), cU, cd), cU, cd, cq, cJ, cC, 0x2) : 0x2 === cO && v8(cS, cU, cd, cq, cJ, cC) : v4(v3(cS), cU, cd, cq, cJ, cC, 0x1);
                          break;
                      }
                  }
          }
      }
      function v5(cS) {
          var cU = cS['prev']
            , cd = cS
            , cq = cS['next'];
          if (vH(cU, cd, cq) >= 0x0)
              return false;
          for (var cJ = cS['next']['next']; cJ !== cS['prev']; ) {
              if (vb(cU['x'], cU['y'], cd['x'], cd['y'], cq['x'], cq['y'], cJ['x'], cJ['y']) && vH(cJ['prev'], cJ, cJ['next']) >= 0x0)
                  return false;
              cJ = cJ['next'];
          }
          return true;
      }
      function v6(cS, cU, cd, cq) {
          var cJ = cS['prev']
            , cC = cS
            , cO = cS['next'];
          if (vH(cJ, cC, cO) >= 0x0)
              return false;
          for (var cG = cJ['x'] < cC['x'] ? cJ['x'] < cO['x'] ? cJ['x'] : cO['x'] : cC['x'] < cO['x'] ? cC['x'] : cO['x'], cg = cJ['y'] < cC['y'] ? cJ['y'] < cO['y'] ? cJ['y'] : cO['y'] : cC['y'] < cO['y'] ? cC['y'] : cO['y'], cN = cJ['x'] > cC['x'] ? cJ['x'] > cO['x'] ? cJ['x'] : cO['x'] : cC['x'] > cO['x'] ? cC['x'] : cO['x'], cP = cJ['y'] > cC['y'] ? cJ['y'] > cO['y'] ? cJ['y'] : cO['y'] : cC['y'] > cO['y'] ? cC['y'] : cO['y'], cM = vk(cG, cg, cU, cd, cq), cz = vk(cN, cP, cU, cd, cq), cQ = cS['prevZ'], cm = cS['nextZ']; cQ && cQ['z'] >= cM && cm && cm['z'] <= cz; ) {
              if (cQ !== cS['prev'] && cQ !== cS['next'] && vb(cJ['x'], cJ['y'], cC['x'], cC['y'], cO['x'], cO['y'], cQ['x'], cQ['y']) && vH(cQ['prev'], cQ, cQ['next']) >= 0x0)
                  return false;
              if (cQ = cQ['prevZ'],
              cm !== cS['prev'] && cm !== cS['next'] && vb(cJ['x'], cJ['y'], cC['x'], cC['y'], cO['x'], cO['y'], cm['x'], cm['y']) && vH(cm['prev'], cm, cm['next']) >= 0x0)
                  return false;
              cm = cm['nextZ'];
          }
          for (; cQ && cQ['z'] >= cM; ) {
              if (cQ !== cS['prev'] && cQ !== cS['next'] && vb(cJ['x'], cJ['y'], cC['x'], cC['y'], cO['x'], cO['y'], cQ['x'], cQ['y']) && vH(cQ['prev'], cQ, cQ['next']) >= 0x0)
                  return false;
              cQ = cQ['prevZ'];
          }
          for (; cm && cm['z'] <= cz; ) {
              if (cm !== cS['prev'] && cm !== cS['next'] && vb(cJ['x'], cJ['y'], cC['x'], cC['y'], cO['x'], cO['y'], cm['x'], cm['y']) && vH(cm['prev'], cm, cm['next']) >= 0x0)
                  return false;
              cm = cm['nextZ'];
          }
          return true;
      }
      function v7(cS, cU, cd) {
          var cq = cS;
          do {
              var cJ = cq['prev']
                , cC = cq['next']['next'];
              !vx(cJ, cC) && vp(cJ, cq, cq['next'], cC) && vw(cJ, cC) && vw(cC, cJ) && (cU['push'](cJ['i'] / cd),
              cU['push'](cq['i'] / cd),
              cU['push'](cC['i'] / cd),
              vY(cq),
              vY(cq['next']),
              cq = cS = cC),
              cq = cq['next'];
          } while (cq !== cS);
          return v3(cq);
      }
      function v8(cS, cU, cd, cq, cJ, cC) {
          var cO = cS;
          do {
              for (var cG = cO['next']['next']; cG !== cO['prev']; ) {
                  if (cO['i'] !== cG['i'] && vc(cO, cG)) {
                      var cg = vh(cO, cG);
                      return cO = v3(cO, cO['next']),
                      cg = v3(cg, cg['next']),
                      v4(cO, cU, cd, cq, cJ, cC),
                      void v4(cg, cU, cd, cq, cJ, cC);
                  }
                  cG = cG['next'];
              }
              cO = cO['next'];
          } while (cO !== cS);
      }
      function v9(cS, cU) {
          return cS['x'] - cU['x'];
      }
      function vv(cS, cU) {
          if (cU = function(cq, cJ) {
              var cC, cO = cJ, cG = cq['x'], cg = cq['y'], cN = -0x1 / 0x0;
              do {
                  if (cg <= cO['y'] && cg >= cO['next']['y'] && cO['next']['y'] !== cO['y']) {
                      var cP = cO['x'] + (cg - cO['y']) * (cO['next']['x'] - cO['x']) / (cO['next']['y'] - cO['y']);
                      if (cP <= cG && cP > cN) {
                          if (cN = cP,
                          cP === cG) {
                              if (cg === cO['y'])
                                  return cO;
                              if (cg === cO['next']['y'])
                                  return cO['next'];
                          }
                          cC = cO['x'] < cO['next']['x'] ? cO : cO['next'];
                      }
                  }
                  cO = cO['next'];
              } while (cO !== cJ);
              if (!cC)
                  return null;
              if (cG === cN)
                  return cC;
              var cM, cz = cC, cQ = cC['x'], cm = cC['y'], cL = 0x1 / 0x0;
              cO = cC;
              do {
                  cG >= cO['x'] && cO['x'] >= cQ && cG !== cO['x'] && vb(cg < cm ? cG : cN, cg, cQ, cm, cg < cm ? cN : cG, cg, cO['x'], cO['y']) && (cM = Math['abs'](cg - cO['y']) / (cG - cO['x']),
                  vw(cO, cq) && (cM < cL || cM === cL && (cO['x'] > cC['x'] || cO['x'] === cC['x'] && vA(cC, cO))) && (cC = cO,
                  cL = cM)),
                  cO = cO['next'];
              } while (cO !== cz);
              return cC;
          }(cS, cU),
          cU) {
              var cd = vh(cU, cS);
              v3(cU, cU['next']),
              v3(cd, cd['next']);
          }
      }
      function vA(cS, cU) {
          return vH(cS['prev'], cS, cU['prev']) < 0x0 && vH(cU['next'], cS, cS['next']) < 0x0;
      }
      function vk(cS, cU, cd, cq, cJ) {
          return (cS = 0x55555555 & ((cS = 0x33333333 & ((cS = 0xf0f0f0f & ((cS = 0xff00ff & ((cS = 0x7fff * (cS - cd) * cJ) | cS << 0x8)) | cS << 0x4)) | cS << 0x2)) | cS << 0x1)) | (cU = 0x55555555 & ((cU = 0x33333333 & ((cU = 0xf0f0f0f & ((cU = 0xff00ff & ((cU = 0x7fff * (cU - cq) * cJ) | cU << 0x8)) | cU << 0x4)) | cU << 0x2)) | cU << 0x1)) << 0x1;
      }
      function vK(cS) {
          var cU = cS
            , cd = cS;
          do {
              (cU['x'] < cd['x'] || cU['x'] === cd['x'] && cU['y'] < cd['y']) && (cd = cU),
              cU = cU['next'];
          } while (cU !== cS);
          return cd;
      }
      function vb(cS, cU, cd, cq, cJ, cC, cO, cG) {
          return (cJ - cO) * (cU - cG) - (cS - cO) * (cC - cG) >= 0x0 && (cS - cO) * (cq - cG) - (cd - cO) * (cU - cG) >= 0x0 && (cd - cO) * (cC - cG) - (cJ - cO) * (cq - cG) >= 0x0;
      }
      function vc(cS, cU) {
          return cS['next']['i'] !== cU['i'] && cS['prev']['i'] !== cU['i'] && !function(cd, cq) {
              var cJ = cd;
              do {
                  if (cJ['i'] !== cd['i'] && cJ['next']['i'] !== cd['i'] && cJ['i'] !== cq['i'] && cJ['next']['i'] !== cq['i'] && vp(cJ, cJ['next'], cd, cq))
                      return true;
                  cJ = cJ['next'];
              } while (cJ !== cd);
              return false;
          }(cS, cU) && (vw(cS, cU) && vw(cU, cS) && function(cd, cq) {
              var cJ = cd
                , cC = false
                , cO = (cd['x'] + cq['x']) / 0x2
                , cG = (cd['y'] + cq['y']) / 0x2;
              do {
                  cJ['y'] > cG != cJ['next']['y'] > cG && cJ['next']['y'] !== cJ['y'] && cO < (cJ['next']['x'] - cJ['x']) * (cG - cJ['y']) / (cJ['next']['y'] - cJ['y']) + cJ['x'] && (cC = !cC),
                  cJ = cJ['next'];
              } while (cJ !== cd);
              return cC;
          }(cS, cU) && (vH(cS['prev'], cS, cU['prev']) || vH(cS, cU['prev'], cU)) || vx(cS, cU) && vH(cS['prev'], cS, cS['next']) > 0x0 && vH(cU['prev'], cU, cU['next']) > 0x0);
      }
      function vH(cS, cU, cd) {
          return (cU['y'] - cS['y']) * (cd['x'] - cU['x']) - (cU['x'] - cS['x']) * (cd['y'] - cU['y']);
      }
      function vx(cS, cU) {
          return cS['x'] === cU['x'] && cS['y'] === cU['y'];
      }
      function vp(cS, cU, cd, cq) {
          var cJ = vy(vH(cS, cU, cd))
            , cC = vy(vH(cS, cU, cq))
            , cO = vy(vH(cd, cq, cS))
            , cG = vy(vH(cd, cq, cU));
          return cJ !== cC && cO !== cG || !(0x0 !== cJ || !vF(cS, cd, cU)) || !(0x0 !== cC || !vF(cS, cq, cU)) || !(0x0 !== cO || !vF(cd, cS, cq)) || !(0x0 !== cG || !vF(cd, cU, cq));
      }
      function vF(cS, cU, cd) {
          return cU['x'] <= Math['max'](cS['x'], cd['x']) && cU['x'] >= Math['min'](cS['x'], cd['x']) && cU['y'] <= Math['max'](cS['y'], cd['y']) && cU['y'] >= Math['min'](cS['y'], cd['y']);
      }
      function vy(cS) {
          return cS > 0x0 ? 0x1 : cS < 0x0 ? -0x1 : 0x0;
      }
      function vw(cS, cU) {
          return vH(cS['prev'], cS, cS['next']) < 0x0 ? vH(cS, cU, cS['next']) >= 0x0 && vH(cS, cS['prev'], cU) >= 0x0 : vH(cS, cU, cS['prev']) < 0x0 || vH(cS, cS['next'], cU) < 0x0;
      }
      function vh(cS, cU) {
          var cd = new vT(cS['i'],cS['x'],cS['y'])
            , cq = new vT(cU['i'],cU['x'],cU['y'])
            , cJ = cS['next']
            , cC = cU['prev'];
          return cS['next'] = cU,
          cU['prev'] = cS,
          cd['next'] = cJ,
          cJ['prev'] = cd,
          cq['next'] = cd,
          cd['prev'] = cq,
          cC['next'] = cq,
          cq['prev'] = cC,
          cq;
      }
      function vu(cS, cU, cd, cq) {
          var cJ = new vT(cS,cU,cd);
          return cq ? (cJ['next'] = cq['next'],
          cJ['prev'] = cq,
          cq['next']['prev'] = cJ,
          cq['next'] = cJ) : (cJ['prev'] = cJ,
          cJ['next'] = cJ),
          cJ;
      }
      function vY(cS) {
          cS['next']['prev'] = cS['prev'],
          cS['prev']['next'] = cS['next'],
          cS['prevZ'] && (cS['prevZ']['nextZ'] = cS['nextZ']),
          cS['nextZ'] && (cS['nextZ']['prevZ'] = cS['prevZ']);
      }
      function vT(cS, cU, cd) {
          this['i'] = cS,
          this['x'] = cU,
          this['y'] = cd,
          this['prev'] = null,
          this['next'] = null,
          this['z'] = null,
          this['prevZ'] = null,
          this['nextZ'] = null,
          this['steiner'] = false;
      }
      function vX(cS) {
          for (var cU = cS[0x0][0x0]['length'], cd = {
              'vertices': [],
              'holes': [],
              'dimensions': cU
          }, cq = 0x0, cJ = 0x0; cJ < cS['length']; cJ++) {
              for (var cC = 0x0; cC < cS[cJ]['length']; cC++)
                  for (var cO = 0x0; cO < cU; cO++)
                      cd['vertices']['push'](cS[cJ][cC][cO]);
              cJ > 0x0 && (cq += cS[cJ - 0x1]['length'],
              cd['holes']['push'](cq));
          }
          return cd;
      }
      class Quadtree {
          constructor(cS, cU, cd, cq) {
              this['max_objects'] = cU || 0xa,
              this['max_levels'] = cd || 0x4,
              this['level'] = cq || 0x0,
              this['bounds'] = cS,
              this['objects'] = [],
              this['nodes'] = [];
          }
          ['split']() {
              var cS = this['level'] + 0x1
                , cU = this['bounds']['width'] / 0x2
                , cd = this['bounds']['height'] / 0x2
                , cq = this['bounds']['x']
                , cJ = this['bounds']['y'];
              this['nodes'][0x0] = new Quadtree({
                  'x': cq + cU,
                  'y': cJ,
                  'width': cU,
                  'height': cd
              },this['max_objects'],this['max_levels'],cS),
              this['nodes'][0x1] = new Quadtree({
                  'x': cq,
                  'y': cJ,
                  'width': cU,
                  'height': cd
              },this['max_objects'],this['max_levels'],cS),
              this['nodes'][0x2] = new Quadtree({
                  'x': cq,
                  'y': cJ + cd,
                  'width': cU,
                  'height': cd
              },this['max_objects'],this['max_levels'],cS),
              this['nodes'][0x3] = new Quadtree({
                  'x': cq + cU,
                  'y': cJ + cd,
                  'width': cU,
                  'height': cd
              },this['max_objects'],this['max_levels'],cS);
          }
          ['getIndex'](cS) {
              var cU = []
                , cd = this['bounds']['x'] + this['bounds']['width'] / 0x2
                , cq = this['bounds']['y'] + this['bounds']['height'] / 0x2
                , cJ = cS['y'] < cq
                , cC = cS['x'] < cd
                , cO = cS['x'] + cS['width'] > cd
                , cG = cS['y'] + cS['height'] > cq;
              return cJ && cO && cU['push'](0x0),
              cC && cJ && cU['push'](0x1),
              cC && cG && cU['push'](0x2),
              cO && cG && cU['push'](0x3),
              cU;
          }
          ['insert'](cS) {
              var cU, cd = 0x0;
              if (this['nodes']['length']) {
                  for (cU = this['getIndex'](cS),
                  cd = 0x0; cd < cU['length']; cd++)
                      this['nodes'][cU[cd]]['insert'](cS);
              } else {
                  if (this['objects']['push'](cS),
                  this['objects']['length'] > this['max_objects'] && this['level'] < this['max_levels']) {
                      for (this['nodes']['length'] || this['split'](),
                      cd = 0x0; cd < this['objects']['length']; cd++) {
                          cU = this['getIndex'](this['objects'][cd]);
                          for (var cq = 0x0; cq < cU['length']; cq++)
                              this['nodes'][cU[cq]]['insert'](this['objects'][cd]);
                      }
                      this['objects'] = [];
                  }
              }
          }
          ['retrieve'](cS, cU=true) {
              var cd = this['getIndex'](cS)
                , cq = this['objects'];
              if (this['nodes']['length']) {
                  for (var cJ = 0x0; cJ < cd['length']; cJ++)
                      cq = cq['concat'](this['nodes'][cd[cJ]]['retrieve'](cS));
              }
              return cU || (cq = cq['filter'](function(cC, cO) {
                  return cq['indexOf'](cC) >= cO;
              })),
              cq;
          }
          ['clear']() {
              this['objects'] = [];
              for (var cS = 0x0; cS < this['nodes']['length']; cS++)
                  this['nodes']['length'] && this['nodes'][cS]['clear']();
              this['nodes'] = [];
          }
      }
      let vf = Float32Array;
      function vW(cS, cU, cd) {
          const cq = new vf(0x3);
          return cS && (cq[0x0] = cS),
          cU && (cq[0x1] = cU),
          cd && (cq[0x2] = cd),
          cq;
      }
      function vI(cS, cU, cd) {
          return (cd = cd || new vf(0x3))[0x0] = cS[0x0] + cU[0x0],
          cd[0x1] = cS[0x1] + cU[0x1],
          cd[0x2] = cS[0x2] + cU[0x2],
          cd;
      }
      let vj = Float32Array;
      function vD(cS, cU, cd) {
          cd = cd || vW();
          const cq = cU[0x0]
            , cJ = cU[0x1]
            , cC = cU[0x2]
            , cO = cq * cS[0x3] + cJ * cS[0x7] + cC * cS[0xb] + cS[0xf];
          return cd[0x0] = (cq * cS[0x0] + cJ * cS[0x4] + cC * cS[0x8] + cS[0xc]) / cO,
          cd[0x1] = (cq * cS[0x1] + cJ * cS[0x5] + cC * cS[0x9] + cS[0xd]) / cO,
          cd[0x2] = (cq * cS[0x2] + cJ * cS[0x6] + cC * cS[0xa] + cS[0xe]) / cO,
          cd;
      }
      function vV(cS, cU, cd) {
          cd = cd || vW();
          const cq = cU[0x0]
            , cJ = cU[0x1]
            , cC = cU[0x2];
          return cd[0x0] = cq * cS[0x0] + cJ * cS[0x4] + cC * cS[0x8],
          cd[0x1] = cq * cS[0x1] + cJ * cS[0x5] + cC * cS[0x9],
          cd[0x2] = cq * cS[0x2] + cJ * cS[0x6] + cC * cS[0xa],
          cd;
      }
      const vZ = 0x1400
        , vB = 0x1401
        , vS = 0x1402
        , vU = 0x1403
        , vd = 0x1404
        , vq = 0x1405
        , vJ = 0x1406
        , vC = {};
      {
          const cS = vC;
          cS[vZ] = Int8Array,
          cS[vB] = Uint8Array,
          cS[vS] = Int16Array,
          cS[vU] = Uint16Array,
          cS[vd] = Int32Array,
          cS[vq] = Uint32Array,
          cS[vJ] = Float32Array,
          cS[0x8033] = Uint16Array,
          cS[0x8034] = Uint16Array,
          cS[0x8363] = Uint16Array,
          cS[0x140b] = Uint16Array,
          cS[0x8368] = Uint32Array,
          cS[0x8c3b] = Uint32Array,
          cS[0x8c3e] = Uint32Array,
          cS[0x8dad] = Uint32Array,
          cS[0x84fa] = Uint32Array;
      }
      function vO(cU) {
          if (cU instanceof Int8Array)
              return vZ;
          if (cU instanceof Uint8Array)
              return vB;
          if (cU instanceof Uint8ClampedArray)
              return vB;
          if (cU instanceof Int16Array)
              return vS;
          if (cU instanceof Uint16Array)
              return vU;
          if (cU instanceof Int32Array)
              return vd;
          if (cU instanceof Uint32Array)
              return vq;
          if (cU instanceof Float32Array)
              return vJ;
          throw new Error('unsupported\x20typed\x20array\x20type');
      }
      function vG(cU) {
          if (cU === Int8Array)
              return vZ;
          if (cU === Uint8Array)
              return vB;
          if (cU === Uint8ClampedArray)
              return vB;
          if (cU === Int16Array)
              return vS;
          if (cU === Uint16Array)
              return vU;
          if (cU === Int32Array)
              return vd;
          if (cU === Uint32Array)
              return vq;
          if (cU === Float32Array)
              return vJ;
          throw new Error('unsupported\x20typed\x20array\x20type');
      }
      function vg(cU) {
          const cd = vC[cU];
          if (!cd)
              throw new Error('unknown\x20gl\x20type');
          return cd;
      }
      const vN = 'undefined' != typeof SharedArrayBuffer ? function(cU) {
          return cU && cU['buffer'] && (cU['buffer']instanceof ArrayBuffer || cU['buffer']instanceof SharedArrayBuffer);
      }
      : function(cU) {
          return cU && cU['buffer'] && cU['buffer']instanceof ArrayBuffer;
      }
      ;
      function vP(...cU) {
          console['error'](...cU);
      }
      function vM(...cU) {
          console['warn'](...cU);
      }
      const vz = new Map();
      function vQ(cU, cd) {
          if (!cU || 'object' != typeof cU)
              return false;
          let cq = vz['get'](cd);
          cq || (cq = new WeakMap(),
          vz['set'](cd, cq));
          let cJ = cq['get'](cU);
          if (undefined === cJ) {
              const cC = Object['prototype']['toString']['call'](cU);
              cJ = cC['substring'](0x8, cC['length'] - 0x1) === cd,
              cq['set'](cU, cJ);
          }
          return cJ;
      }
      function vm(cU, cd) {
          return 'undefined' != typeof WebGLTexture && vQ(cd, 'WebGLTexture');
      }
      const vL = 0x88e4
        , vR = 0x8892
        , A0 = 0x8893
        , A1 = 0x8764
        , A2 = 0x1400
        , A3 = 0x1401
        , A4 = 0x1402
        , A5 = 0x1403
        , A6 = 0x1404
        , A7 = 0x1405
        , A8 = 0x1406
        , A9 = {
          'attribPrefix': ''
      };
      function Av(cU, cd, cq, cJ) {
          if ('undefined' != typeof WebGLBuffer && vQ(cd, 'WebGLBuffer'))
              return cd;
          cq = cq || vR;
          const cC = cU['createBuffer']();
          return function(cO, cG, cg, cN, cP) {
              cO['bindBuffer'](cG, cg),
              cO['bufferData'](cG, cN, cP || vL);
          }(cU, cq, cC, cd, cJ),
          cC;
      }
      function AA(cU) {
          return 'indices' === cU;
      }
      function Ak(cU) {
          return cU['length'] ? cU : cU['data'];
      }
      const AK = /coord|texture/i
        , Ab = /color|colour/i;
      function Ac(cU, cd, cq) {
          return cU['numComponents'] || cU['size'] || function(cJ, cC) {
              let cO;
              if (cO = AK['test'](cJ) ? 0x2 : Ab['test'](cJ) ? 0x4 : 0x3,
              cC % cO > 0x0)
                  throw new Error('Can\x20not\x20guess\x20numComponents\x20for\x20attribute\x20\x27' + cJ + '\x27.\x20Tried\x20' + cO + '\x20but\x20' + cC + '\x20values\x20is\x20not\x20evenly\x20divisible\x20by\x20' + cO + '.\x20You\x20should\x20specify\x20it.');
              return cO;
          }(cd, cq || Ak(cU)['length']);
      }
      function AH(cU, cd) {
          if (vN(cU))
              return cU;
          if (vN(cU['data']))
              return cU['data'];
          Array['isArray'](cU) && (cU = {
              'data': cU
          });
          let cq = cU['type'] ? Ax(cU['type']) : undefined;
          return cq || (cq = AA(cd) ? Uint16Array : Float32Array),
          new cq(cU['data']);
      }
      function Ax(cU) {
          return 'number' == typeof cU ? vg(cU) : cU || Float32Array;
      }
      function Ap(cU, cd) {
          return {
              'buffer': cd['buffer'],
              'numValues': 0x18,
              'type': (cq = cd['type'],
              'number' == typeof cq ? cq : cq ? vG(cq) : A8),
              'arrayType': Ax(cd['type'])
          };
          var cq;
      }
      function AF(cU, cd) {
          const cq = cd['data'] || cd
            , cJ = Ax(cd['type'])
            , cC = cq * cJ['BYTES_PER_ELEMENT']
            , cO = cU['createBuffer']();
          return cU['bindBuffer'](vR, cO),
          cU['bufferData'](vR, cC, cd['drawType'] || vL),
          {
              'buffer': cO,
              'numValues': cq,
              'type': vG(cJ),
              'arrayType': cJ
          };
      }
      function Ay(cU, cd, cq) {
          const cJ = AH(cd, cq);
          return {
              'arrayType': cJ['constructor'],
              'buffer': Av(cU, cJ, undefined, cd['drawType']),
              'type': vO(cJ),
              'numValues': 0x0
          };
      }
      const Aw = ['position', 'positions', 'a_position'];
      function Ah(cU, cd, cq) {
          const cJ = function(cG, cg) {
              const cN = {};
              return Object['keys'](cg)['forEach'](function(cP) {
                  if (!AA(cP)) {
                      const cz = cg[cP]
                        , cQ = cz['attrib'] || cz['name'] || cz['attribName'] || A9['attribPrefix'] + cP;
                      if (cz['value']) {
                          if (!Array['isArray'](cz['value']) && !vN(cz['value']))
                              throw new Error('array.value\x20is\x20not\x20array\x20or\x20typedarray');
                          cN[cQ] = {
                              'value': cz['value']
                          };
                      } else {
                          let cm;
                          cm = cz['buffer'] && cz['buffer']instanceof WebGLBuffer ? Ap : 'number' == typeof cz || 'number' == typeof cz['data'] ? AF : Ay;
                          const {buffer: cL, type: cR, numValues: H0, arrayType: H1} = cm(cG, cz, cP)
                            , H2 = undefined !== cz['normalize'] ? cz['normalize'] : (cM = H1) === Int8Array || cM === Uint8Array
                            , H3 = Ac(cz, cP, H0);
                          cN[cQ] = {
                              'buffer': cL,
                              'numComponents': H3,
                              'type': cR,
                              'normalize': H2,
                              'stride': cz['stride'] || 0x0,
                              'offset': cz['offset'] || 0x0,
                              'divisor': undefined === cz['divisor'] ? undefined : cz['divisor'],
                              'drawType': cz['drawType']
                          };
                      }
                  }
                  var cM;
              }),
              cG['bindBuffer'](vR, null),
              cN;
          }(cU, cd)
            , cC = Object['assign']({}, cq || {});
          cC['attribs'] = Object['assign']({}, cq ? cq['attribs'] : {}, cJ);
          const cO = cd['indices'];
          if (cO) {
              const cG = AH(cO, 'indices');
              cC['indices'] = Av(cU, cG, A0),
              cC['numElements'] = cG['length'],
              cC['elementType'] = vO(cG);
          } else
              cC['numElements'] || (cC['numElements'] = function(cg, cN) {
                  let cP, cM;
                  for (cM = 0x0; cM < Aw['length'] && (cP = Aw[cM],
                  !(cP in cN)) && (cP = A9['attribPrefix'] + cP,
                  !(cP in cN)); ++cM)
                      ;
                  cM === Aw['length'] && (cP = Object['keys'](cN)[0x0]);
                  const cz = cN[cP];
                  if (!cz['buffer'])
                      return 0x1;
                  cg['bindBuffer'](vR, cz['buffer']);
                  const cQ = cg['getBufferParameter'](vR, A1);
                  var cm;
                  cg['bindBuffer'](vR, null);
                  const cL = cQ / ((cm = cz['type']) === A2 || cm === A3 ? 0x1 : cm === A4 || cm === A5 ? 0x2 : cm === A6 || cm === A7 || cm === A8 ? 0x4 : 0x0)
                    , cR = cz['numComponents'] || cz['size']
                    , H0 = cL / cR;
                  if (H0 % 0x1 != 0x0)
                      throw new Error('numComponents\x20' + cR + '\x20not\x20correct\x20for\x20length\x20' + length);
                  return H0;
              }(cU, cC['attribs']));
          return cC;
      }
      function Au(cU, cd) {
          const cq = {};
          return Object['keys'](cd)['forEach'](function(cJ) {
              cq[cJ] = function(cC, cO, cG) {
                  const cg = 'indices' === cG ? A0 : vR;
                  return Av(cC, AH(cO, cG), cg);
              }(cU, cd[cJ], cJ);
          }),
          cd['indices'] ? (cq['numElements'] = cd['indices']['length'],
          cq['elementType'] = vO(AH(cd['indices']))) : cq['numElements'] = function(cJ) {
              let cC, cO;
              for (cO = 0x0; cO < Aw['length'] && (cC = Aw[cO],
              !(cC in cJ)); ++cO)
                  ;
              cO === Aw['length'] && (cC = Object['keys'](cJ)[0x0]);
              const cG = cJ[cC]
                , cg = Ak(cG)['length'];
              if (undefined === cg)
                  return 0x1;
              const cN = Ac(cG, cC)
                , cP = cg / cN;
              if (cg % cN > 0x0)
                  throw new Error('numComponents\x20' + cN + '\x20not\x20correct\x20for\x20length\x20' + cg);
              return cP;
          }(cd),
          cq;
      }
      function AY(cU, cd, cq) {
          return function(cJ, cC) {
              let cO = 0x0;
              return cJ['push'] = function() {
                  for (let cG = 0x0; cG < arguments['length']; ++cG) {
                      const cg = arguments[cG];
                      if (cg instanceof Array || vN(cg)) {
                          for (let cN = 0x0; cN < cg['length']; ++cN)
                              cJ[cO++] = cg[cN];
                      } else
                          cJ[cO++] = cg;
                  }
              }
              ,
              cJ['reset'] = function(cG) {
                  cO = cG || 0x0;
              }
              ,
              cJ['numComponents'] = cC,
              Object['defineProperty'](cJ, 'numElements', {
                  'get': function() {
                      return this['length'] / this['numComponents'] | 0x0;
                  }
              }),
              cJ;
          }(new (cq || Float32Array)(cU * cd), cU);
      }
      function AT(cU, cd, cq) {
          const cJ = cU['length']
            , cC = new Float32Array(0x3);
          for (let cO = 0x0; cO < cJ; cO += 0x3)
              cq(cd, [cU[cO], cU[cO + 0x1], cU[cO + 0x2]], cC),
              cU[cO] = cC[0x0],
              cU[cO + 0x1] = cC[0x1],
              cU[cO + 0x2] = cC[0x2];
      }
      function AX(cU, cd, cq) {
          cq = cq || vW();
          const cJ = cd[0x0]
            , cC = cd[0x1]
            , cO = cd[0x2];
          return cq[0x0] = cJ * cU[0x0] + cC * cU[0x1] + cO * cU[0x2],
          cq[0x1] = cJ * cU[0x4] + cC * cU[0x5] + cO * cU[0x6],
          cq[0x2] = cJ * cU[0x8] + cC * cU[0x9] + cO * cU[0xa],
          cq;
      }
      function AE(cU, cd) {
          return AT(cU, function(cq, cJ) {
              cJ = cJ || new vj(0x10);
              const cC = cq[0x0]
                , cO = cq[0x1]
                , cG = cq[0x2]
                , cg = cq[0x3]
                , cN = cq[0x4]
                , cP = cq[0x5]
                , cM = cq[0x6]
                , cz = cq[0x7]
                , cQ = cq[0x8]
                , cm = cq[0x9]
                , cL = cq[0xa]
                , cR = cq[0xb]
                , H0 = cq[0xc]
                , H1 = cq[0xd]
                , H2 = cq[0xe]
                , H3 = cq[0xf]
                , H4 = cL * H3
                , H5 = H2 * cR
                , H6 = cM * H3
                , H7 = H2 * cz
                , H8 = cM * cR
                , H9 = cL * cz
                , Hv = cG * H3
                , HA = H2 * cg
                , Hk = cG * cR
                , Hl = cL * cg
                , HK = cG * cz
                , Hb = cM * cg
                , Hc = cQ * H1
                , HH = H0 * cm
                , Hx = cN * H1
                , Hp = H0 * cP
                , HF = cN * cm
                , Hy = cQ * cP
                , Hw = cC * H1
                , Hh = H0 * cO
                , Hu = cC * cm
                , HY = cQ * cO
                , HT = cC * cP
                , HX = cN * cO
                , HE = H4 * cP + H7 * cm + H8 * H1 - (H5 * cP + H6 * cm + H9 * H1)
                , Hf = H5 * cO + Hv * cm + Hl * H1 - (H4 * cO + HA * cm + Hk * H1)
                , HW = H6 * cO + HA * cP + HK * H1 - (H7 * cO + Hv * cP + Hb * H1)
                , HI = H9 * cO + Hk * cP + Hb * cm - (H8 * cO + Hl * cP + HK * cm)
                , Hj = 0x1 / (cC * HE + cN * Hf + cQ * HW + H0 * HI);
              return cJ[0x0] = Hj * HE,
              cJ[0x1] = Hj * Hf,
              cJ[0x2] = Hj * HW,
              cJ[0x3] = Hj * HI,
              cJ[0x4] = Hj * (H5 * cN + H6 * cQ + H9 * H0 - (H4 * cN + H7 * cQ + H8 * H0)),
              cJ[0x5] = Hj * (H4 * cC + HA * cQ + Hk * H0 - (H5 * cC + Hv * cQ + Hl * H0)),
              cJ[0x6] = Hj * (H7 * cC + Hv * cN + Hb * H0 - (H6 * cC + HA * cN + HK * H0)),
              cJ[0x7] = Hj * (H8 * cC + Hl * cN + HK * cQ - (H9 * cC + Hk * cN + Hb * cQ)),
              cJ[0x8] = Hj * (Hc * cz + Hp * cR + HF * H3 - (HH * cz + Hx * cR + Hy * H3)),
              cJ[0x9] = Hj * (HH * cg + Hw * cR + HY * H3 - (Hc * cg + Hh * cR + Hu * H3)),
              cJ[0xa] = Hj * (Hx * cg + Hh * cz + HT * H3 - (Hp * cg + Hw * cz + HX * H3)),
              cJ[0xb] = Hj * (Hy * cg + Hu * cz + HX * cR - (HF * cg + HY * cz + HT * cR)),
              cJ[0xc] = Hj * (Hx * cL + Hy * H2 + HH * cM - (HF * H2 + Hc * cM + Hp * cL)),
              cJ[0xd] = Hj * (Hu * H2 + Hc * cG + Hh * cL - (Hw * cL + HY * H2 + HH * cG)),
              cJ[0xe] = Hj * (Hw * cM + HX * H2 + Hp * cG - (HT * H2 + Hx * cG + Hh * cM)),
              cJ[0xf] = Hj * (HT * cL + HF * cG + HY * cM - (Hu * cM + HX * cL + Hy * cG)),
              cJ;
          }(cd), AX),
          cU;
      }
      function Af(cU, cd) {
          return Object['keys'](cU)['forEach'](function(cq) {
              const cJ = cU[cq];
              cq['indexOf']('pos') >= 0x0 ? function(cC, cO) {
                  AT(cC, cO, vD);
              }(cJ, cd) : cq['indexOf']('tan') >= 0x0 || cq['indexOf']('binorm') >= 0x0 ? function(cC, cO) {
                  AT(cC, cO, vV);
              }(cJ, cd) : cq['indexOf']('norm') >= 0x0 && AE(cJ, cd);
          }),
          cU;
      }
      function AW(cU, cd, cq) {
          return cU = cU || 0x2,
          {
              'position': {
                  'numComponents': 0x2,
                  'data': [(cd = cd || 0x0) + -0x1 * (cU *= 0.5), (cq = cq || 0x0) + -0x1 * cU, cd + 0x1 * cU, cq + -0x1 * cU, cd + -0x1 * cU, cq + 0x1 * cU, cd + 0x1 * cU, cq + 0x1 * cU]
              },
              'normal': [0x0, 0x0, 0x1, 0x0, 0x0, 0x1, 0x0, 0x0, 0x1, 0x0, 0x0, 0x1],
              'texcoord': [0x0, 0x0, 0x1, 0x0, 0x0, 0x1, 0x1, 0x1],
              'indices': [0x0, 0x1, 0x2, 0x2, 0x1, 0x3]
          };
      }
      function AI(cU, cd, cq, cJ, cC) {
          var cO;
          cU = cU || 0x1,
          cd = cd || 0x1,
          cq = cq || 0x1,
          cJ = cJ || 0x1,
          cC = cC || ((cO = cO || new vj(0x10))[0x0] = 0x1,
          cO[0x1] = 0x0,
          cO[0x2] = 0x0,
          cO[0x3] = 0x0,
          cO[0x4] = 0x0,
          cO[0x5] = 0x1,
          cO[0x6] = 0x0,
          cO[0x7] = 0x0,
          cO[0x8] = 0x0,
          cO[0x9] = 0x0,
          cO[0xa] = 0x1,
          cO[0xb] = 0x0,
          cO[0xc] = 0x0,
          cO[0xd] = 0x0,
          cO[0xe] = 0x0,
          cO[0xf] = 0x1,
          cO);
          const cG = (cq + 0x1) * (cJ + 0x1)
            , cg = AY(0x3, cG)
            , cN = AY(0x3, cG)
            , cP = AY(0x2, cG);
          for (let cQ = 0x0; cQ <= cJ; cQ++)
              for (let cm = 0x0; cm <= cq; cm++) {
                  const cL = cm / cq
                    , cR = cQ / cJ;
                  cg['push'](cU * cL - 0.5 * cU, 0x0, cd * cR - 0.5 * cd),
                  cN['push'](0x0, 0x1, 0x0),
                  cP['push'](cL, cR);
              }
          const cM = cq + 0x1
            , cz = AY(0x3, cq * cJ * 0x2, Uint16Array);
          for (let H0 = 0x0; H0 < cJ; H0++)
              for (let H1 = 0x0; H1 < cq; H1++)
                  cz['push']((H0 + 0x0) * cM + H1, (H0 + 0x1) * cM + H1, (H0 + 0x0) * cM + H1 + 0x1),
                  cz['push']((H0 + 0x1) * cM + H1, (H0 + 0x1) * cM + H1 + 0x1, (H0 + 0x0) * cM + H1 + 0x1);
          return Af({
              'position': cg,
              'normal': cN,
              'texcoord': cP,
              'indices': cz
          }, cC);
      }
      function Aj(cU, cd, cq, cJ, cC, cO, cG) {
          if (cd <= 0x0 || cq <= 0x0)
              throw new Error('subdivisionAxis\x20and\x20subdivisionHeight\x20must\x20be\x20>\x200');
          cJ = cJ || 0x0,
          cO = cO || 0x0;
          const cg = (cC = cC || Math['PI']) - cJ
            , cN = (cG = cG || 0x2 * Math['PI']) - cO
            , cP = (cd + 0x1) * (cq + 0x1)
            , cM = AY(0x3, cP)
            , cz = AY(0x3, cP)
            , cQ = AY(0x2, cP);
          for (let cR = 0x0; cR <= cq; cR++)
              for (let H0 = 0x0; H0 <= cd; H0++) {
                  const H1 = H0 / cd
                    , H2 = cR / cq
                    , H3 = cN * H1 + cO
                    , H4 = cg * H2 + cJ
                    , H5 = Math['sin'](H3)
                    , H6 = Math['cos'](H3)
                    , H7 = Math['sin'](H4)
                    , H8 = H6 * H7
                    , H9 = Math['cos'](H4)
                    , Hv = H5 * H7;
                  cM['push'](cU * H8, cU * H9, cU * Hv),
                  cz['push'](H8, H9, Hv),
                  cQ['push'](0x1 - H1, H2);
              }
          const cm = cd + 0x1
            , cL = AY(0x3, cd * cq * 0x2, Uint16Array);
          for (let HA = 0x0; HA < cd; HA++)
              for (let Hk = 0x0; Hk < cq; Hk++)
                  cL['push']((Hk + 0x0) * cm + HA, (Hk + 0x0) * cm + HA + 0x1, (Hk + 0x1) * cm + HA),
                  cL['push']((Hk + 0x1) * cm + HA, (Hk + 0x0) * cm + HA + 0x1, (Hk + 0x1) * cm + HA + 0x1);
          return {
              'position': cM,
              'normal': cz,
              'texcoord': cQ,
              'indices': cL
          };
      }
      const AD = [[0x3, 0x7, 0x5, 0x1], [0x6, 0x2, 0x0, 0x4], [0x6, 0x7, 0x3, 0x2], [0x0, 0x1, 0x5, 0x4], [0x7, 0x6, 0x4, 0x5], [0x2, 0x3, 0x1, 0x0]];
      function AV(cU) {
          const cd = (cU = cU || 0x1) / 0x2
            , cq = [[-cd, -cd, -cd], [+cd, -cd, -cd], [-cd, +cd, -cd], [+cd, +cd, -cd], [-cd, -cd, +cd], [+cd, -cd, +cd], [-cd, +cd, +cd], [+cd, +cd, +cd]]
            , cJ = [[0x1, 0x0, 0x0], [-0x1, 0x0, 0x0], [0x0, 0x1, 0x0], [0x0, -0x1, 0x0], [0x0, 0x0, 0x1], [0x0, 0x0, -0x1]]
            , cC = [[0x1, 0x0], [0x0, 0x0], [0x0, 0x1], [0x1, 0x1]]
            , cO = AY(0x3, 0x18)
            , cG = AY(0x3, 0x18)
            , cg = AY(0x2, 0x18)
            , cN = AY(0x3, 0xc, Uint16Array);
          for (let cP = 0x0; cP < 0x6; ++cP) {
              const cM = AD[cP];
              for (let cQ = 0x0; cQ < 0x4; ++cQ) {
                  const cm = cq[cM[cQ]]
                    , cL = cJ[cP]
                    , cR = cC[cQ];
                  cO['push'](cm),
                  cG['push'](cL),
                  cg['push'](cR);
              }
              const cz = 0x4 * cP;
              cN['push'](cz + 0x0, cz + 0x1, cz + 0x2),
              cN['push'](cz + 0x0, cz + 0x2, cz + 0x3);
          }
          return {
              'position': cO,
              'normal': cG,
              'texcoord': cg,
              'indices': cN
          };
      }
      function AZ(cU, cd, cq, cJ, cC, cO, cG) {
          if (cJ < 0x3)
              throw new Error('radialSubdivisions\x20must\x20be\x203\x20or\x20greater');
          if (cC < 0x1)
              throw new Error('verticalSubdivisions\x20must\x20be\x201\x20or\x20greater');
          const cg = undefined === cO || cO
            , cN = undefined === cG || cG
            , cP = (cg ? 0x2 : 0x0) + (cN ? 0x2 : 0x0)
            , cM = (cJ + 0x1) * (cC + 0x1 + cP)
            , cz = AY(0x3, cM)
            , cQ = AY(0x3, cM)
            , cm = AY(0x2, cM)
            , cL = AY(0x3, cJ * (cC + cP / 0x2) * 0x2, Uint16Array)
            , cR = cJ + 0x1
            , H0 = Math['atan2'](cU - cd, cq)
            , H1 = Math['cos'](H0)
            , H2 = Math['sin'](H0)
            , H3 = cC + (cN ? 0x2 : 0x0);
          for (let H4 = cg ? -0x2 : 0x0; H4 <= H3; ++H4) {
              let H5, H6 = H4 / cC, H7 = cq * H6;
              H4 < 0x0 ? (H7 = 0x0,
              H6 = 0x1,
              H5 = cU) : H4 > cC ? (H7 = cq,
              H6 = 0x1,
              H5 = cd) : H5 = cU + H4 / cC * (cd - cU),
              -0x2 !== H4 && H4 !== cC + 0x2 || (H5 = 0x0,
              H6 = 0x0),
              H7 -= cq / 0x2;
              for (let H8 = 0x0; H8 < cR; ++H8) {
                  const H9 = Math['sin'](H8 * Math['PI'] * 0x2 / cJ)
                    , Hv = Math['cos'](H8 * Math['PI'] * 0x2 / cJ);
                  cz['push'](H9 * H5, H7, Hv * H5),
                  H4 < 0x0 ? cQ['push'](0x0, -0x1, 0x0) : H4 > cC ? cQ['push'](0x0, 0x1, 0x0) : 0x0 === H5 ? cQ['push'](0x0, 0x0, 0x0) : cQ['push'](H9 * H1, H2, Hv * H1),
                  cm['push'](H8 / cJ, 0x1 - H6);
              }
          }
          for (let HA = 0x0; HA < cC + cP; ++HA)
              if (!(0x1 === HA && cg || HA === cC + cP - 0x2 && cN)) {
                  for (let Hk = 0x0; Hk < cJ; ++Hk)
                      cL['push'](cR * (HA + 0x0) + 0x0 + Hk, cR * (HA + 0x0) + 0x1 + Hk, cR * (HA + 0x1) + 0x1 + Hk),
                      cL['push'](cR * (HA + 0x0) + 0x0 + Hk, cR * (HA + 0x1) + 0x1 + Hk, cR * (HA + 0x1) + 0x0 + Hk);
              }
          return {
              'position': cz,
              'normal': cQ,
              'texcoord': cm,
              'indices': cL
          };
      }
      function AB(cU, cd) {
          cd = cd || [];
          const cq = [];
          for (let cJ = 0x0; cJ < cU['length']; cJ += 0x4) {
              const cC = cU[cJ]
                , cO = cU['slice'](cJ + 0x1, cJ + 0x4);
              cO['push']['apply'](cO, cd);
              for (let cG = 0x0; cG < cC; ++cG)
                  cq['push']['apply'](cq, cO);
          }
          return cq;
      }
      function AS() {
          const cU = [0x0, 0x0, 0x0, 0x0, 0x96, 0x0, 0x1e, 0x0, 0x0, 0x0, 0x96, 0x0, 0x1e, 0x96, 0x0, 0x1e, 0x0, 0x0, 0x1e, 0x0, 0x0, 0x1e, 0x1e, 0x0, 0x64, 0x0, 0x0, 0x1e, 0x1e, 0x0, 0x64, 0x1e, 0x0, 0x64, 0x0, 0x0, 0x1e, 0x3c, 0x0, 0x1e, 0x5a, 0x0, 0x43, 0x3c, 0x0, 0x1e, 0x5a, 0x0, 0x43, 0x5a, 0x0, 0x43, 0x3c, 0x0, 0x0, 0x0, 0x1e, 0x1e, 0x0, 0x1e, 0x0, 0x96, 0x1e, 0x0, 0x96, 0x1e, 0x1e, 0x0, 0x1e, 0x1e, 0x96, 0x1e, 0x1e, 0x0, 0x1e, 0x64, 0x0, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x64, 0x0, 0x1e, 0x64, 0x1e, 0x1e, 0x1e, 0x3c, 0x1e, 0x43, 0x3c, 0x1e, 0x1e, 0x5a, 0x1e, 0x1e, 0x5a, 0x1e, 0x43, 0x3c, 0x1e, 0x43, 0x5a, 0x1e, 0x0, 0x0, 0x0, 0x64, 0x0, 0x0, 0x64, 0x0, 0x1e, 0x0, 0x0, 0x0, 0x64, 0x0, 0x1e, 0x0, 0x0, 0x1e, 0x64, 0x0, 0x0, 0x64, 0x1e, 0x0, 0x64, 0x1e, 0x1e, 0x64, 0x0, 0x0, 0x64, 0x1e, 0x1e, 0x64, 0x0, 0x1e, 0x1e, 0x1e, 0x0, 0x1e, 0x1e, 0x1e, 0x64, 0x1e, 0x1e, 0x1e, 0x1e, 0x0, 0x64, 0x1e, 0x1e, 0x64, 0x1e, 0x0, 0x1e, 0x1e, 0x0, 0x1e, 0x3c, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x0, 0x1e, 0x3c, 0x0, 0x1e, 0x3c, 0x1e, 0x1e, 0x3c, 0x0, 0x43, 0x3c, 0x1e, 0x1e, 0x3c, 0x1e, 0x1e, 0x3c, 0x0, 0x43, 0x3c, 0x0, 0x43, 0x3c, 0x1e, 0x43, 0x3c, 0x0, 0x43, 0x5a, 0x1e, 0x43, 0x3c, 0x1e, 0x43, 0x3c, 0x0, 0x43, 0x5a, 0x0, 0x43, 0x5a, 0x1e, 0x1e, 0x5a, 0x0, 0x1e, 0x5a, 0x1e, 0x43, 0x5a, 0x1e, 0x1e, 0x5a, 0x0, 0x43, 0x5a, 0x1e, 0x43, 0x5a, 0x0, 0x1e, 0x5a, 0x0, 0x1e, 0x96, 0x1e, 0x1e, 0x5a, 0x1e, 0x1e, 0x5a, 0x0, 0x1e, 0x96, 0x0, 0x1e, 0x96, 0x1e, 0x0, 0x96, 0x0, 0x0, 0x96, 0x1e, 0x1e, 0x96, 0x1e, 0x0, 0x96, 0x0, 0x1e, 0x96, 0x1e, 0x1e, 0x96, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1e, 0x0, 0x96, 0x1e, 0x0, 0x0, 0x0, 0x0, 0x96, 0x1e, 0x0, 0x96, 0x0]
            , cd = AB([0x12, 0x0, 0x0, 0x1, 0x12, 0x0, 0x0, -0x1, 0x6, 0x0, 0x1, 0x0, 0x6, 0x1, 0x0, 0x0, 0x6, 0x0, -0x1, 0x0, 0x6, 0x1, 0x0, 0x0, 0x6, 0x0, 0x1, 0x0, 0x6, 0x1, 0x0, 0x0, 0x6, 0x0, -0x1, 0x0, 0x6, 0x1, 0x0, 0x0, 0x6, 0x0, -0x1, 0x0, 0x6, -0x1, 0x0, 0x0])
            , cq = AB([0x12, 0xc8, 0x46, 0x78, 0x12, 0x50, 0x46, 0xc8, 0x6, 0x46, 0xc8, 0xd2, 0x6, 0xc8, 0xc8, 0x46, 0x6, 0xd2, 0x64, 0x46, 0x6, 0xd2, 0xa0, 0x46, 0x6, 0x46, 0xb4, 0xd2, 0x6, 0x64, 0x46, 0xd2, 0x6, 0x4c, 0xd2, 0x64, 0x6, 0x8c, 0xd2, 0x50, 0x6, 0x5a, 0x82, 0x6e, 0x6, 0xa0, 0xa0, 0xdc], [0xff])
            , cJ = cU['length'] / 0x3
            , cC = {
              'position': AY(0x3, cJ),
              'texcoord': AY(0x2, cJ),
              'normal': AY(0x3, cJ),
              'color': AY(0x4, cJ, Uint8Array),
              'indices': AY(0x3, cJ / 0x3, Uint16Array)
          };
          cC['position']['push'](cU),
          cC['texcoord']['push']([0.22, 0.19, 0.22, 0.79, 0.34, 0.19, 0.22, 0.79, 0.34, 0.79, 0.34, 0.19, 0.34, 0.19, 0.34, 0.31, 0.62, 0.19, 0.34, 0.31, 0.62, 0.31, 0.62, 0.19, 0.34, 0.43, 0.34, 0.55, 0.49, 0.43, 0.34, 0.55, 0.49, 0.55, 0.49, 0.43, 0x0, 0x0, 0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x1, 0x0, 0x1, 0x1, 0x0, 0x0, 0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x1, 0x0, 0x1, 0x1, 0x0, 0x0, 0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x1, 0x0, 0x1, 0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x1, 0x0, 0x0, 0x1, 0x1, 0x0, 0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x1, 0x0, 0x0, 0x1, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x1, 0x1, 0x0, 0x0, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x1, 0x1, 0x0, 0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x1, 0x0, 0x0, 0x1, 0x1, 0x0, 0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x1, 0x0, 0x0, 0x1, 0x1, 0x0, 0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x1, 0x0, 0x0, 0x0, 0x1, 0x1, 0x1, 0x0, 0x0, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x1, 0x1, 0x0, 0x1, 0x0, 0x0, 0x1, 0x0, 0x1, 0x1, 0x0, 0x0, 0x0, 0x1, 0x1, 0x1, 0x0, 0x0, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x1, 0x0, 0x0, 0x1, 0x1, 0x1, 0x0]),
          cC['normal']['push'](cd),
          cC['color']['push'](cq);
          for (let cO = 0x0; cO < cJ; ++cO)
              cC['indices']['push'](cO);
          return cC;
      }
      function AU(cU, cd, cq, cJ, cC, cO, cG) {
          if (cC <= 0x0)
              throw new Error('subdivisionDown\x20must\x20be\x20>\x200');
          const cg = (cG = cG || 0x1) - (cO = cO || 0x0)
            , cN = 0x2 * (cC + 0x1) * 0x4
            , cP = AY(0x3, cN)
            , cM = AY(0x3, cN)
            , cz = AY(0x2, cN);
          function cQ(H1, H2, H3) {
              return H1 + (H2 - H1) * H3;
          }
          function cm(H1, H2, H3, H4, H5, H6) {
              for (let Hv = 0x0; Hv <= cC; Hv++) {
                  const HA = H2 / 0x1
                    , Hk = Hv / cC
                    , Hl = 0x2 * (HA - 0.5)
                    , HK = (cO + Hk * cg) * Math['PI']
                    , Hb = Math['sin'](HK)
                    , Hc = Math['cos'](HK)
                    , HH = cQ(cU, H1, Hb)
                    , Hx = Hl * cJ
                    , Hp = Hc * cU
                    , HF = Hb * HH;
                  cP['push'](Hx, Hp, HF);
                  const Hy = vI((H7 = [0x0, Hb, Hc],
                  H8 = H3,
                  (H9 = (H9 = undefined) || new vf(0x3))[0x0] = H7[0x0] * H8[0x0],
                  H9[0x1] = H7[0x1] * H8[0x1],
                  H9[0x2] = H7[0x2] * H8[0x2],
                  H9), H4);
                  cM['push'](Hy),
                  cz['push'](HA * H5 + H6, Hk);
              }
              var H7, H8, H9;
          }
          for (let H1 = 0x0; H1 < 0x2; H1++) {
              const H2 = 0x2 * (H1 / 0x1 - 0.5);
              cm(cd, H1, [0x1, 0x1, 0x1], [0x0, 0x0, 0x0], 0x1, 0x0),
              cm(cd, H1, [0x0, 0x0, 0x0], [H2, 0x0, 0x0], 0x0, 0x0),
              cm(cq, H1, [0x1, 0x1, 0x1], [0x0, 0x0, 0x0], 0x1, 0x0),
              cm(cq, H1, [0x0, 0x0, 0x0], [H2, 0x0, 0x0], 0x0, 0x1);
          }
          const cL = AY(0x3, 0x2 * cC * 0x4, Uint16Array);
          function cR(H3, H4) {
              for (let H5 = 0x0; H5 < cC; ++H5)
                  cL['push'](H3 + H5 + 0x0, H3 + H5 + 0x1, H4 + H5 + 0x0),
                  cL['push'](H3 + H5 + 0x1, H4 + H5 + 0x1, H4 + H5 + 0x0);
          }
          const H0 = cC + 0x1;
          return cR(0x0 * H0, 0x4 * H0),
          cR(0x5 * H0, 0x7 * H0),
          cR(0x6 * H0, 0x2 * H0),
          cR(0x3 * H0, 0x1 * H0),
          {
              'position': cP,
              'normal': cM,
              'texcoord': cz,
              'indices': cL
          };
      }
      function Ad(cU, cd, cq, cJ, cC, cO) {
          return AZ(cU, cU, cd, cq, cJ, cC, cO);
      }
      function Aq(cU, cd, cq, cJ, cC, cO) {
          if (cq < 0x3)
              throw new Error('radialSubdivisions\x20must\x20be\x203\x20or\x20greater');
          if (cJ < 0x3)
              throw new Error('verticalSubdivisions\x20must\x20be\x203\x20or\x20greater');
          cC = cC || 0x0;
          const cG = (cO = cO || 0x2 * Math['PI']) - cC
            , cg = cq + 0x1
            , cN = cJ + 0x1
            , cP = cg * cN
            , cM = AY(0x3, cP)
            , cz = AY(0x3, cP)
            , cQ = AY(0x2, cP)
            , cm = AY(0x3, cq * cJ * 0x2, Uint16Array);
          for (let cL = 0x0; cL < cN; ++cL) {
              const cR = cL / cJ
                , H0 = cR * Math['PI'] * 0x2
                , H1 = Math['sin'](H0)
                , H2 = cU + H1 * cd
                , H3 = Math['cos'](H0)
                , H4 = H3 * cd;
              for (let H5 = 0x0; H5 < cg; ++H5) {
                  const H6 = H5 / cq
                    , H7 = cC + H6 * cG
                    , H8 = Math['sin'](H7)
                    , H9 = Math['cos'](H7)
                    , Hv = H8 * H2
                    , HA = H9 * H2
                    , Hk = H8 * H1
                    , Hl = H9 * H1;
                  cM['push'](Hv, H4, HA),
                  cz['push'](Hk, H3, Hl),
                  cQ['push'](H6, 0x1 - cR);
              }
          }
          for (let HK = 0x0; HK < cJ; ++HK)
              for (let Hb = 0x0; Hb < cq; ++Hb) {
                  const Hc = 0x1 + Hb
                    , HH = 0x1 + HK;
                  cm['push'](cg * HK + Hb, cg * HH + Hb, cg * HK + Hc),
                  cm['push'](cg * HH + Hb, cg * HH + Hc, cg * HK + Hc);
              }
          return {
              'position': cM,
              'normal': cz,
              'texcoord': cQ,
              'indices': cm
          };
      }
      function AJ(cU, cd, cq, cJ, cC) {
          if (cd < 0x3)
              throw new Error('divisions\x20must\x20be\x20at\x20least\x203');
          cC = cC || 0x1,
          cJ = cJ || 0x0;
          const cO = (cd + 0x1) * ((cq = cq || 0x1) + 0x1)
            , cG = AY(0x3, cO)
            , cg = AY(0x3, cO)
            , cN = AY(0x2, cO)
            , cP = AY(0x3, cq * cd * 0x2, Uint16Array);
          let cM = 0x0;
          const cz = cU - cJ
            , cQ = cd + 0x1;
          for (let cm = 0x0; cm <= cq; ++cm) {
              const cL = cJ + cz * Math['pow'](cm / cq, cC);
              for (let cR = 0x0; cR <= cd; ++cR) {
                  const H0 = 0x2 * Math['PI'] * cR / cd
                    , H1 = cL * Math['cos'](H0)
                    , H2 = cL * Math['sin'](H0);
                  if (cG['push'](H1, 0x0, H2),
                  cg['push'](0x0, 0x1, 0x0),
                  cN['push'](0x1 - cR / cd, cm / cq),
                  cm > 0x0 && cR !== cd) {
                      const H3 = cM + (cR + 0x1)
                        , H4 = cM + cR
                        , H5 = cM + cR - cQ
                        , H6 = cM + (cR + 0x1) - cQ;
                      cP['push'](H3, H4, H5),
                      cP['push'](H3, H5, H6);
                  }
              }
              cM += cd + 0x1;
          }
          return {
              'position': cG,
              'normal': cg,
              'texcoord': cN,
              'indices': cP
          };
      }
      function AC(cU) {
          return function(cd) {
              return Au(cd, cU['apply'](this, Array['prototype']['slice']['call'](arguments, 0x1)));
          }
          ;
      }
      function AO(cU) {
          return function(cd) {
              return Ah(cd, cU['apply'](null, Array['prototype']['slice']['call'](arguments, 0x1)));
          }
          ;
      }
      function AG(cU) {
          return !!cU['texStorage2D'];
      }
      AO(AS),
      AC(AS),
      AO(AV),
      AC(AV),
      AO(AI),
      AC(AI),
      AO(Aj),
      AC(Aj),
      AO(AZ),
      AC(AZ),
      AO(AW),
      AC(AW),
      AO(AU),
      AC(AU),
      AO(Ad),
      AC(Ad),
      AO(Aq),
      AC(Aq),
      AO(AJ),
      AC(AJ);
      const Ag = function() {
          const cU = {}
            , cd = {};
          return function(cq, cJ) {
              return function(cC) {
                  const cO = cC['constructor']['name'];
                  if (!cU[cO]) {
                      for (const cG in cC)
                          if ('number' == typeof cC[cG]) {
                              const cg = cd[cC[cG]];
                              cd[cC[cG]] = cg ? cg + '\x20|\x20' + cG : cG;
                          }
                      cU[cO] = true;
                  }
              }(cq),
              cd[cJ] || ('number' == typeof cJ ? '0x' + cJ['toString'](0x10) : cJ);
          }
          ;
      }()
        , AN = {
          'textureColor': new Uint8Array([0x80, 0xc0, 0xff, 0xff]),
          'textureOptions': {},
          'crossOrigin': undefined
      }
        , AP = vN
        , AM = function() {
          let cU;
          return function() {
              return cU = cU || ('undefined' != typeof document && document['createElement'] ? document['createElement']('canvas')['getContext']('2d') : null),
              cU;
          }
          ;
      }()
        , Az = 0x1906
        , AQ = 0x1907
        , Am = 0x1908
        , AL = 0x1909
        , AR = 0x190a
        , n0 = 0x1902
        , n1 = 0x84f9
        , n2 = 0x812f
        , n3 = 0x2600
        , n4 = 0x2601
        , n5 = 0xde1
        , n6 = 0x8513
        , n7 = 0x806f
        , n8 = 0x8c1a
        , n9 = 0x8515
        , nv = 0x8516
        , nA = 0x8517
        , nk = 0x8518
        , nK = 0x8519
        , nb = 0x851a
        , nc = 0x2801
        , nH = 0x2800
        , nx = 0x2802
        , np = 0x2803
        , nF = 0x8072
        , ny = 0x813a
        , nw = 0x813b
        , nh = 0x813c
        , nu = 0x813d
        , nY = 0x884c
        , nT = 0x884d
        , nX = 0xcf5
        , nE = 0xcf2
        , nf = 0x806e
        , nW = 0xcf4
        , nI = 0xcf3
        , nj = 0x806d
        , nD = 0x9243
        , nV = 0x9241
        , nZ = 0x9240
        , nB = 0x8229
        , nS = 0x8f94
        , nU = 0x822d
        , nd = 0x822e
        , nq = 0x8232
        , nJ = 0x8231
        , nC = 0x823a
        , nO = 0x8239
        , nG = 0x823c
        , ng = 0x823b
        , nN = 0x822b
        , nP = 0x8f95
        , nM = 0x822f
        , nz = 0x8230
        , nQ = 0x8238
        , nm = 0x8237
        , nL = 0x8234
        , nR = 0x8233
        , k0 = 0x8236
        , k1 = 0x8235
        , k2 = 0x8051
        , k3 = 0x8c41
        , k4 = 0x8d62
        , k5 = 0x8f96
        , k6 = 0x8c3a
        , k7 = 0x8c3d
        , k8 = 0x881b
        , k9 = 0x8815
        , kv = 0x8d7d
        , kA = 0x8d8f
        , kk = 0x8d77
        , kK = 0x8d89
        , kb = 0x8d71
        , kc = 0x8d83
        , kH = 0x8058
        , kx = 0x8c43
        , kp = 0x8f97
        , kF = 0x8057
        , ky = 0x8056
        , kw = 0x8059
        , kh = 0x881a
        , ku = 0x8814
        , kY = 0x8d7c
        , kT = 0x8d8e
        , kX = 0x906f
        , kE = 0x8d76
        , kf = 0x8d88
        , kW = 0x8d82
        , kI = 0x8d70
        , kj = 0x81a5
        , kD = 0x81a6
        , kV = 0x8cac
        , kZ = 0x8cad
        , kB = 0x88f0
        , kS = 0x1400
        , kU = 0x1401
        , kd = 0x1402
        , kq = 0x1403
        , kJ = 0x1404
        , kC = 0x1405
        , kO = 0x1406
        , kG = 0x8033
        , kg = 0x8034
        , kN = 0x8363
        , kP = 0x140b
        , kM = 0x8d61
        , kz = 0x8368
        , kQ = 0x8c3b
        , km = 0x8c3e
        , kL = 0x8dad
        , kR = 0x84fa
        , l0 = 0x8227
        , l1 = 0x8228
        , l2 = 0x1903
        , l3 = 0x8d94
        , l4 = 0x8d98
        , l5 = 0x8d99;
      {
          const cU = {};
          cU[Az] = {
              'numColorComponents': 0x1
          },
          cU[AL] = {
              'numColorComponents': 0x1
          },
          cU[AR] = {
              'numColorComponents': 0x2
          },
          cU[AQ] = {
              'numColorComponents': 0x3
          },
          cU[Am] = {
              'numColorComponents': 0x4
          },
          cU[l2] = {
              'numColorComponents': 0x1
          },
          cU[l3] = {
              'numColorComponents': 0x1
          },
          cU[l0] = {
              'numColorComponents': 0x2
          },
          cU[l1] = {
              'numColorComponents': 0x2
          },
          cU[AQ] = {
              'numColorComponents': 0x3
          },
          cU[l4] = {
              'numColorComponents': 0x3
          },
          cU[Am] = {
              'numColorComponents': 0x4
          },
          cU[l5] = {
              'numColorComponents': 0x4
          },
          cU[n0] = {
              'numColorComponents': 0x1
          },
          cU[n1] = {
              'numColorComponents': 0x2
          };
      }
      let l6;
      function l7(cd) {
          if (!l6) {
              const cq = {};
              cq[Az] = {
                  'textureFormat': Az,
                  'colorRenderable': true,
                  'textureFilterable': true,
                  'bytesPerElement': [0x1, 0x2, 0x2, 0x4],
                  'type': [kU, kP, kM, kO]
              },
              cq[AL] = {
                  'textureFormat': AL,
                  'colorRenderable': true,
                  'textureFilterable': true,
                  'bytesPerElement': [0x1, 0x2, 0x2, 0x4],
                  'type': [kU, kP, kM, kO]
              },
              cq[AR] = {
                  'textureFormat': AR,
                  'colorRenderable': true,
                  'textureFilterable': true,
                  'bytesPerElement': [0x2, 0x4, 0x4, 0x8],
                  'type': [kU, kP, kM, kO]
              },
              cq[AQ] = {
                  'textureFormat': AQ,
                  'colorRenderable': true,
                  'textureFilterable': true,
                  'bytesPerElement': [0x3, 0x6, 0x6, 0xc, 0x2],
                  'type': [kU, kP, kM, kO, kN]
              },
              cq[Am] = {
                  'textureFormat': Am,
                  'colorRenderable': true,
                  'textureFilterable': true,
                  'bytesPerElement': [0x4, 0x8, 0x8, 0x10, 0x2, 0x2],
                  'type': [kU, kP, kM, kO, kG, kg]
              },
              cq[n0] = {
                  'textureFormat': n0,
                  'colorRenderable': true,
                  'textureFilterable': false,
                  'bytesPerElement': [0x2, 0x4],
                  'type': [kC, kq]
              },
              cq[nB] = {
                  'textureFormat': l2,
                  'colorRenderable': true,
                  'textureFilterable': true,
                  'bytesPerElement': [0x1],
                  'type': [kU]
              },
              cq[nS] = {
                  'textureFormat': l2,
                  'colorRenderable': false,
                  'textureFilterable': true,
                  'bytesPerElement': [0x1],
                  'type': [kS]
              },
              cq[nU] = {
                  'textureFormat': l2,
                  'colorRenderable': false,
                  'textureFilterable': true,
                  'bytesPerElement': [0x4, 0x2],
                  'type': [kO, kP]
              },
              cq[nd] = {
                  'textureFormat': l2,
                  'colorRenderable': false,
                  'textureFilterable': false,
                  'bytesPerElement': [0x4],
                  'type': [kO]
              },
              cq[nq] = {
                  'textureFormat': l3,
                  'colorRenderable': true,
                  'textureFilterable': false,
                  'bytesPerElement': [0x1],
                  'type': [kU]
              },
              cq[nJ] = {
                  'textureFormat': l3,
                  'colorRenderable': true,
                  'textureFilterable': false,
                  'bytesPerElement': [0x1],
                  'type': [kS]
              },
              cq[nL] = {
                  'textureFormat': l3,
                  'colorRenderable': true,
                  'textureFilterable': false,
                  'bytesPerElement': [0x2],
                  'type': [kq]
              },
              cq[nR] = {
                  'textureFormat': l3,
                  'colorRenderable': true,
                  'textureFilterable': false,
                  'bytesPerElement': [0x2],
                  'type': [kd]
              },
              cq[k0] = {
                  'textureFormat': l3,
                  'colorRenderable': true,
                  'textureFilterable': false,
                  'bytesPerElement': [0x4],
                  'type': [kC]
              },
              cq[k1] = {
                  'textureFormat': l3,
                  'colorRenderable': true,
                  'textureFilterable': false,
                  'bytesPerElement': [0x4],
                  'type': [kJ]
              },
              cq[nN] = {
                  'textureFormat': l0,
                  'colorRenderable': true,
                  'textureFilterable': true,
                  'bytesPerElement': [0x2],
                  'type': [kU]
              },
              cq[nP] = {
                  'textureFormat': l0,
                  'colorRenderable': false,
                  'textureFilterable': true,
                  'bytesPerElement': [0x2],
                  'type': [kS]
              },
              cq[nM] = {
                  'textureFormat': l0,
                  'colorRenderable': false,
                  'textureFilterable': true,
                  'bytesPerElement': [0x8, 0x4],
                  'type': [kO, kP]
              },
              cq[nz] = {
                  'textureFormat': l0,
                  'colorRenderable': false,
                  'textureFilterable': false,
                  'bytesPerElement': [0x8],
                  'type': [kO]
              },
              cq[nQ] = {
                  'textureFormat': l1,
                  'colorRenderable': true,
                  'textureFilterable': false,
                  'bytesPerElement': [0x2],
                  'type': [kU]
              },
              cq[nm] = {
                  'textureFormat': l1,
                  'colorRenderable': true,
                  'textureFilterable': false,
                  'bytesPerElement': [0x2],
                  'type': [kS]
              },
              cq[nC] = {
                  'textureFormat': l1,
                  'colorRenderable': true,
                  'textureFilterable': false,
                  'bytesPerElement': [0x4],
                  'type': [kq]
              },
              cq[nO] = {
                  'textureFormat': l1,
                  'colorRenderable': true,
                  'textureFilterable': false,
                  'bytesPerElement': [0x4],
                  'type': [kd]
              },
              cq[nG] = {
                  'textureFormat': l1,
                  'colorRenderable': true,
                  'textureFilterable': false,
                  'bytesPerElement': [0x8],
                  'type': [kC]
              },
              cq[ng] = {
                  'textureFormat': l1,
                  'colorRenderable': true,
                  'textureFilterable': false,
                  'bytesPerElement': [0x8],
                  'type': [kJ]
              },
              cq[k2] = {
                  'textureFormat': AQ,
                  'colorRenderable': true,
                  'textureFilterable': true,
                  'bytesPerElement': [0x3],
                  'type': [kU]
              },
              cq[k3] = {
                  'textureFormat': AQ,
                  'colorRenderable': false,
                  'textureFilterable': true,
                  'bytesPerElement': [0x3],
                  'type': [kU]
              },
              cq[k4] = {
                  'textureFormat': AQ,
                  'colorRenderable': true,
                  'textureFilterable': true,
                  'bytesPerElement': [0x3, 0x2],
                  'type': [kU, kN]
              },
              cq[k5] = {
                  'textureFormat': AQ,
                  'colorRenderable': false,
                  'textureFilterable': true,
                  'bytesPerElement': [0x3],
                  'type': [kS]
              },
              cq[k6] = {
                  'textureFormat': AQ,
                  'colorRenderable': false,
                  'textureFilterable': true,
                  'bytesPerElement': [0xc, 0x6, 0x4],
                  'type': [kO, kP, kQ]
              },
              cq[k7] = {
                  'textureFormat': AQ,
                  'colorRenderable': false,
                  'textureFilterable': true,
                  'bytesPerElement': [0xc, 0x6, 0x4],
                  'type': [kO, kP, km]
              },
              cq[k8] = {
                  'textureFormat': AQ,
                  'colorRenderable': false,
                  'textureFilterable': true,
                  'bytesPerElement': [0xc, 0x6],
                  'type': [kO, kP]
              },
              cq[k9] = {
                  'textureFormat': AQ,
                  'colorRenderable': false,
                  'textureFilterable': false,
                  'bytesPerElement': [0xc],
                  'type': [kO]
              },
              cq[kv] = {
                  'textureFormat': l4,
                  'colorRenderable': false,
                  'textureFilterable': false,
                  'bytesPerElement': [0x3],
                  'type': [kU]
              },
              cq[kA] = {
                  'textureFormat': l4,
                  'colorRenderable': false,
                  'textureFilterable': false,
                  'bytesPerElement': [0x3],
                  'type': [kS]
              },
              cq[kk] = {
                  'textureFormat': l4,
                  'colorRenderable': false,
                  'textureFilterable': false,
                  'bytesPerElement': [0x6],
                  'type': [kq]
              },
              cq[kK] = {
                  'textureFormat': l4,
                  'colorRenderable': false,
                  'textureFilterable': false,
                  'bytesPerElement': [0x6],
                  'type': [kd]
              },
              cq[kb] = {
                  'textureFormat': l4,
                  'colorRenderable': false,
                  'textureFilterable': false,
                  'bytesPerElement': [0xc],
                  'type': [kC]
              },
              cq[kc] = {
                  'textureFormat': l4,
                  'colorRenderable': false,
                  'textureFilterable': false,
                  'bytesPerElement': [0xc],
                  'type': [kJ]
              },
              cq[kH] = {
                  'textureFormat': Am,
                  'colorRenderable': true,
                  'textureFilterable': true,
                  'bytesPerElement': [0x4],
                  'type': [kU]
              },
              cq[kx] = {
                  'textureFormat': Am,
                  'colorRenderable': true,
                  'textureFilterable': true,
                  'bytesPerElement': [0x4],
                  'type': [kU]
              },
              cq[kp] = {
                  'textureFormat': Am,
                  'colorRenderable': false,
                  'textureFilterable': true,
                  'bytesPerElement': [0x4],
                  'type': [kS]
              },
              cq[kF] = {
                  'textureFormat': Am,
                  'colorRenderable': true,
                  'textureFilterable': true,
                  'bytesPerElement': [0x4, 0x2, 0x4],
                  'type': [kU, kg, kz]
              },
              cq[ky] = {
                  'textureFormat': Am,
                  'colorRenderable': true,
                  'textureFilterable': true,
                  'bytesPerElement': [0x4, 0x2],
                  'type': [kU, kG]
              },
              cq[kw] = {
                  'textureFormat': Am,
                  'colorRenderable': true,
                  'textureFilterable': true,
                  'bytesPerElement': [0x4],
                  'type': [kz]
              },
              cq[kh] = {
                  'textureFormat': Am,
                  'colorRenderable': false,
                  'textureFilterable': true,
                  'bytesPerElement': [0x10, 0x8],
                  'type': [kO, kP]
              },
              cq[ku] = {
                  'textureFormat': Am,
                  'colorRenderable': false,
                  'textureFilterable': false,
                  'bytesPerElement': [0x10],
                  'type': [kO]
              },
              cq[kY] = {
                  'textureFormat': l5,
                  'colorRenderable': true,
                  'textureFilterable': false,
                  'bytesPerElement': [0x4],
                  'type': [kU]
              },
              cq[kT] = {
                  'textureFormat': l5,
                  'colorRenderable': true,
                  'textureFilterable': false,
                  'bytesPerElement': [0x4],
                  'type': [kS]
              },
              cq[kX] = {
                  'textureFormat': l5,
                  'colorRenderable': true,
                  'textureFilterable': false,
                  'bytesPerElement': [0x4],
                  'type': [kz]
              },
              cq[kE] = {
                  'textureFormat': l5,
                  'colorRenderable': true,
                  'textureFilterable': false,
                  'bytesPerElement': [0x8],
                  'type': [kq]
              },
              cq[kf] = {
                  'textureFormat': l5,
                  'colorRenderable': true,
                  'textureFilterable': false,
                  'bytesPerElement': [0x8],
                  'type': [kd]
              },
              cq[kW] = {
                  'textureFormat': l5,
                  'colorRenderable': true,
                  'textureFilterable': false,
                  'bytesPerElement': [0x10],
                  'type': [kJ]
              },
              cq[kI] = {
                  'textureFormat': l5,
                  'colorRenderable': true,
                  'textureFilterable': false,
                  'bytesPerElement': [0x10],
                  'type': [kC]
              },
              cq[kj] = {
                  'textureFormat': n0,
                  'colorRenderable': true,
                  'textureFilterable': false,
                  'bytesPerElement': [0x2, 0x4],
                  'type': [kq, kC]
              },
              cq[kD] = {
                  'textureFormat': n0,
                  'colorRenderable': true,
                  'textureFilterable': false,
                  'bytesPerElement': [0x4],
                  'type': [kC]
              },
              cq[kV] = {
                  'textureFormat': n0,
                  'colorRenderable': true,
                  'textureFilterable': false,
                  'bytesPerElement': [0x4],
                  'type': [kO]
              },
              cq[kB] = {
                  'textureFormat': n1,
                  'colorRenderable': true,
                  'textureFilterable': false,
                  'bytesPerElement': [0x4],
                  'type': [kR]
              },
              cq[kZ] = {
                  'textureFormat': n1,
                  'colorRenderable': true,
                  'textureFilterable': false,
                  'bytesPerElement': [0x4],
                  'type': [kL]
              },
              Object['keys'](cq)['forEach'](function(cJ) {
                  const cC = cq[cJ];
                  cC['bytesPerElementMap'] = {},
                  cC['bytesPerElement']['forEach'](function(cO, cG) {
                      const cg = cC['type'][cG];
                      cC['bytesPerElementMap'][cg] = cO;
                  });
              }),
              l6 = cq;
          }
          return l6[cd];
      }
      function l8(cd) {
          const cq = l7(cd);
          if (!cq)
              throw 'unknown\x20internal\x20format';
          return {
              'format': cq['textureFormat'],
              'type': cq['type'][0x0]
          };
      }
      function l9(cd) {
          return 0x0 == (cd & cd - 0x1);
      }
      function lv(cd, cq, cJ, cC, cO) {
          if (cO % 0x1 != 0x0)
              throw 'can\x27t\x20guess\x20dimensions';
          if (cJ || cC) {
              if (cC) {
                  if (!cJ && (cJ = cO / cC) % 0x1)
                      throw 'can\x27t\x20guess\x20dimensions';
              } else {
                  if ((cC = cO / cJ) % 0x1)
                      throw 'can\x27t\x20guess\x20dimensions';
              }
          } else {
              const cG = Math['sqrt'](cO / (cq === n6 ? 0x6 : 0x1));
              cG % 0x1 == 0x0 ? (cJ = cG,
              cC = cG) : (cJ = cO,
              cC = 0x1);
          }
          return {
              'width': cJ,
              'height': cC
          };
      }
      function lA(cd, cq) {
          undefined !== cq['colorspaceConversion'] && cd['pixelStorei'](nD, cq['colorspaceConversion']),
          undefined !== cq['premultiplyAlpha'] && cd['pixelStorei'](nV, cq['premultiplyAlpha']),
          undefined !== cq['flipY'] && cd['pixelStorei'](nZ, cq['flipY']);
      }
      function lk(cd) {
          cd['pixelStorei'](nX, 0x4),
          AG(cd) && (cd['pixelStorei'](nE, 0x0),
          cd['pixelStorei'](nf, 0x0),
          cd['pixelStorei'](nW, 0x0),
          cd['pixelStorei'](nI, 0x0),
          cd['pixelStorei'](nj, 0x0));
      }
      function lK(cd, cq, cJ) {
          const cC = cJ['target'] || n5;
          cd['bindTexture'](cC, cq),
          function(cO, cG, cg, cN) {
              cN['minMag'] && (cg['call'](cO, cG, nc, cN['minMag']),
              cg['call'](cO, cG, nH, cN['minMag'])),
              cN['min'] && cg['call'](cO, cG, nc, cN['min']),
              cN['mag'] && cg['call'](cO, cG, nH, cN['mag']),
              cN['wrap'] && (cg['call'](cO, cG, nx, cN['wrap']),
              cg['call'](cO, cG, np, cN['wrap']),
              (cG === n7 || 'undefined' != typeof WebGLSampler && vQ(cG, 'WebGLSampler')) && cg['call'](cO, cG, nF, cN['wrap'])),
              cN['wrapR'] && cg['call'](cO, cG, nF, cN['wrapR']),
              cN['wrapS'] && cg['call'](cO, cG, nx, cN['wrapS']),
              cN['wrapT'] && cg['call'](cO, cG, np, cN['wrapT']),
              undefined !== cN['minLod'] && cg['call'](cO, cG, ny, cN['minLod']),
              undefined !== cN['maxLod'] && cg['call'](cO, cG, nw, cN['maxLod']),
              undefined !== cN['baseLevel'] && cg['call'](cO, cG, nh, cN['baseLevel']),
              undefined !== cN['maxLevel'] && cg['call'](cO, cG, nu, cN['maxLevel']),
              undefined !== cN['compareFunc'] && cg['call'](cO, cG, nT, cN['compareFunc']),
              undefined !== cN['compareMode'] && cg['call'](cO, cG, nY, cN['compareMode']);
          }(cd, cC, cd['texParameteri'], cJ);
      }
      function lb(cd, cq, cJ, cC, cO, cG) {
          cJ = cJ || AN['textureOptions'],
          cG = cG || Am;
          const cg = cJ['target'] || n5;
          if (cC = cC || cJ['width'],
          cO = cO || cJ['height'],
          cd['bindTexture'](cg, cq),
          function(cN, cP, cM, cz) {
              if (!AG(cN))
                  return l9(cP) && l9(cM);
              const cQ = l7(cz);
              if (!cQ)
                  throw 'unknown\x20internal\x20format';
              return cQ['colorRenderable'] && cQ['textureFilterable'];
          }(cd, cC, cO, cG))
              cd['generateMipmap'](cg);
          else {
              const cN = function(cP) {
                  const cM = l7(cP);
                  if (!cM)
                      throw 'unknown\x20internal\x20format';
                  return cM['textureFilterable'];
              }(cG) ? n4 : n3;
              cd['texParameteri'](cg, nc, cN),
              cd['texParameteri'](cg, nH, cN),
              cd['texParameteri'](cg, nx, n2),
              cd['texParameteri'](cg, np, n2);
          }
      }
      function lc(cd) {
          return true === cd['auto'] || undefined === cd['auto'] && undefined === cd['level'];
      }
      function lH(cd, cq) {
          return (cq = cq || {})['cubeFaceOrder'] || [n9, nv, nA, nk, nK, nb];
      }
      function lx(cd, cq) {
          const cJ = lH(0x0, cq)['map'](function(cC, cO) {
              return {
                  'face': cC,
                  'ndx': cO
              };
          });
          return cJ['sort'](function(cC, cO) {
              return cC['face'] - cO['face'];
          }),
          cJ;
      }
      function lp(cd, cq, cJ, cC) {
          const cO = (cC = cC || AN['textureOptions'])['target'] || n5
            , cG = cC['level'] || 0x0;
          let cg = cJ['width']
            , cN = cJ['height'];
          const cP = cC['internalFormat'] || cC['format'] || Am
            , cM = l8(cP)
            , cz = cC['format'] || cM['format']
            , cQ = cC['type'] || cM['type'];
          if (lA(cd, cC),
          cd['bindTexture'](cO, cq),
          cO === n6) {
              const cm = cJ['width']
                , cL = cJ['height'];
              let cR, H0;
              if (cm / 0x6 === cL)
                  cR = cL,
                  H0 = [0x0, 0x0, 0x1, 0x0, 0x2, 0x0, 0x3, 0x0, 0x4, 0x0, 0x5, 0x0];
              else {
                  if (cL / 0x6 === cm)
                      cR = cm,
                      H0 = [0x0, 0x0, 0x0, 0x1, 0x0, 0x2, 0x0, 0x3, 0x0, 0x4, 0x0, 0x5];
                  else {
                      if (cm / 0x3 == cL / 0x2)
                          cR = cm / 0x3,
                          H0 = [0x0, 0x0, 0x1, 0x0, 0x2, 0x0, 0x0, 0x1, 0x1, 0x1, 0x2, 0x1];
                      else {
                          if (cm / 0x2 != cL / 0x3)
                              throw 'can\x27t\x20figure\x20out\x20cube\x20map\x20from\x20element:\x20' + (cJ['src'] ? cJ['src'] : cJ['nodeName']);
                          cR = cm / 0x2,
                          H0 = [0x0, 0x0, 0x1, 0x0, 0x0, 0x1, 0x1, 0x1, 0x0, 0x2, 0x1, 0x2];
                      }
                  }
              }
              const H1 = AM();
              H1 ? (H1['canvas']['width'] = cR,
              H1['canvas']['height'] = cR,
              cg = cR,
              cN = cR,
              lx(0x0, cC)['forEach'](function(H2) {
                  const H3 = H0[0x2 * H2['ndx'] + 0x0] * cR
                    , H4 = H0[0x2 * H2['ndx'] + 0x1] * cR;
                  H1['drawImage'](cJ, H3, H4, cR, cR, 0x0, 0x0, cR, cR),
                  cd['texImage2D'](H2['face'], cG, cP, cz, cQ, H1['canvas']);
              }),
              H1['canvas']['width'] = 0x1,
              H1['canvas']['height'] = 0x1) : 'undefined' != typeof createImageBitmap && (cg = cR,
              cN = cR,
              lx(0x0, cC)['forEach'](function(H2) {
                  const H3 = H0[0x2 * H2['ndx'] + 0x0] * cR
                    , H4 = H0[0x2 * H2['ndx'] + 0x1] * cR;
                  cd['texImage2D'](H2['face'], cG, cP, cR, cR, 0x0, cz, cQ, null),
                  createImageBitmap(cJ, H3, H4, cR, cR, {
                      'premultiplyAlpha': 'none',
                      'colorSpaceConversion': 'none'
                  })['then'](function(H5) {
                      lA(cd, cC),
                      cd['bindTexture'](cO, cq),
                      cd['texImage2D'](H2['face'], cG, cP, cz, cQ, H5),
                      lc(cC) && lb(cd, cq, cC, cg, cN, cP);
                  });
              }));
          } else {
              if (cO === n7 || cO === n8) {
                  const H2 = Math['min'](cJ['width'], cJ['height'])
                    , H3 = Math['max'](cJ['width'], cJ['height'])
                    , H4 = H3 / H2;
                  if (H4 % 0x1 != 0x0)
                      throw 'can\x20not\x20compute\x203D\x20dimensions\x20of\x20element';
                  const H5 = cJ['width'] === H3 ? 0x1 : 0x0
                    , H6 = cJ['height'] === H3 ? 0x1 : 0x0;
                  cd['pixelStorei'](nX, 0x1),
                  cd['pixelStorei'](nE, cJ['width']),
                  cd['pixelStorei'](nf, 0x0),
                  cd['pixelStorei'](nj, 0x0),
                  cd['texImage3D'](cO, cG, cP, H2, H2, H2, 0x0, cz, cQ, null);
                  for (let H7 = 0x0; H7 < H4; ++H7) {
                      const H8 = H7 * H2 * H5
                        , H9 = H7 * H2 * H6;
                      cd['pixelStorei'](nW, H8),
                      cd['pixelStorei'](nI, H9),
                      cd['texSubImage3D'](cO, cG, 0x0, 0x0, H7, H2, H2, 0x1, cz, cQ, cJ);
                  }
                  lk(cd);
              } else
                  cd['texImage2D'](cO, cG, cP, cz, cQ, cJ);
          }
          lc(cC) && lb(cd, cq, cC, cg, cN, cP),
          lK(cd, cq, cC);
      }
      function lF() {}
      function ly(cd) {
          return 'undefined' != typeof ImageBitmap && cd instanceof ImageBitmap || 'undefined' != typeof ImageData && cd instanceof ImageData || 'undefined' != typeof HTMLElement && cd instanceof HTMLElement;
      }
      function lw(cd, cq, cJ) {
          return ly(cd) ? (setTimeout(function() {
              cJ(null, cd);
          }),
          cd) : function(cC, cO, cG) {
              let cg;
              if (cG = cG || lF,
              cO = undefined !== cO ? cO : AN['crossOrigin'],
              cO = function(cN, cP) {
                  return undefined !== cP || function(cM) {
                      if ('undefined' != typeof document) {
                          const cz = document['createElement']('a');
                          return cz['href'] = cM,
                          cz['hostname'] === location['hostname'] && cz['port'] === location['port'] && cz['protocol'] === location['protocol'];
                      }
                      {
                          const cQ = new URL(location['href'])['origin'];
                          return new URL(cM,location['href'])['origin'] === cQ;
                      }
                  }(cN) ? cP : 'anonymous';
              }(cC, cO),
              'undefined' != typeof Image) {
                  cg = new Image(),
                  undefined !== cO && (cg['crossOrigin'] = cO);
                  const cN = function() {
                      cg['removeEventListener']('error', cP),
                      cg['removeEventListener']('load', cM),
                      cg = null;
                  }
                    , cP = function() {
                      const cz = 'couldn\x27t\x20load\x20image:\x20' + cC;
                      vP(cz),
                      cG(cz, cg),
                      cN();
                  }
                    , cM = function() {
                      cG(null, cg),
                      cN();
                  };
                  return cg['addEventListener']('error', cP),
                  cg['addEventListener']('load', cM),
                  cg['src'] = cC,
                  cg;
              }
              if ('undefined' != typeof ImageBitmap) {
                  let cz, cQ;
                  const cm = function() {
                      cG(cz, cQ);
                  }
                    , cL = {};
                  cO && (cL['mode'] = 'cors'),
                  fetch(cC, cL)['then'](function(cR) {
                      if (!cR['ok'])
                          throw cR;
                      return cR['blob']();
                  })['then'](function(cR) {
                      return createImageBitmap(cR, {
                          'premultiplyAlpha': 'none',
                          'colorSpaceConversion': 'none'
                      });
                  })['then'](function(cR) {
                      cQ = cR,
                      setTimeout(cm);
                  })['catch'](function(cR) {
                      cz = cR,
                      setTimeout(cm);
                  }),
                  cg = null;
              }
              return cg;
          }(cd, cq, cJ);
      }
      function lh(cd, cq, cJ) {
          const cC = (cJ = cJ || AN['textureOptions'])['target'] || n5;
          if (cd['bindTexture'](cC, cq),
          false === cJ['color'])
              return;
          const cO = function(cG) {
              return cG = cG || AN['textureColor'],
              AP(cG) ? cG : new Uint8Array([0xff * cG[0x0], 0xff * cG[0x1], 0xff * cG[0x2], 0xff * cG[0x3]]);
          }(cJ['color']);
          if (cC === n6) {
              for (let cG = 0x0; cG < 0x6; ++cG)
                  cd['texImage2D'](n9 + cG, 0x0, Am, 0x1, 0x1, 0x0, Am, kU, cO);
          } else
              cC === n7 || cC === n8 ? cd['texImage3D'](cC, 0x0, Am, 0x1, 0x1, 0x1, 0x0, Am, kU, cO) : cd['texImage2D'](cC, 0x0, Am, 0x1, 0x1, 0x0, Am, kU, cO);
      }
      function lu(cd, cq, cJ, cC) {
          const cO = (cC = cC || AN['textureOptions'])['target'] || n5;
          cd['bindTexture'](cO, cq);
          let cG = cC['width']
            , cg = cC['height']
            , cN = cC['depth'];
          const cP = cC['level'] || 0x0
            , cM = cC['internalFormat'] || cC['format'] || Am
            , cz = l8(cM)
            , cQ = cC['format'] || cz['format']
            , cm = cC['type'] || function(H1, H2, H3) {
              return AP(H2) ? vO(H2) : H3 || kU;
          }(0x0, cJ, cz['type']);
          if (AP(cJ))
              cJ instanceof Uint8ClampedArray && (cJ = new Uint8Array(cJ['buffer']));
          else {
              const H1 = vg(cm);
              cJ = new H1(cJ);
          }
          const cL = function(H2, H3) {
              const H4 = l7(H2);
              if (!H4)
                  throw 'unknown\x20internal\x20format';
              const H5 = H4['bytesPerElementMap'][H3];
              if (undefined === H5)
                  throw 'unknown\x20internal\x20format';
              return H5;
          }(cM, cm)
            , cR = cJ['byteLength'] / cL;
          if (cR % 0x1)
              throw 'length\x20wrong\x20size\x20for\x20format:\x20' + Ag(cd, cQ);
          let H0;
          if (cO === n7 || cO === n8) {
              if (cG || cg || cN)
                  !cG || cg && cN ? !cg || cG && cN ? (H0 = lv(0x0, cO, cG, cg, cR / cN),
                  cG = H0['width'],
                  cg = H0['height']) : (H0 = lv(0x0, cO, cG, cN, cR / cg),
                  cG = H0['width'],
                  cN = H0['height']) : (H0 = lv(0x0, cO, cg, cN, cR / cG),
                  cg = H0['width'],
                  cN = H0['height']);
              else {
                  const H2 = Math['cbrt'](cR);
                  if (H2 % 0x1 != 0x0)
                      throw 'can\x27t\x20guess\x20cube\x20size\x20of\x20array\x20of\x20numElements:\x20' + cR;
                  cG = H2,
                  cg = H2,
                  cN = H2;
              }
          } else
              H0 = lv(0x0, cO, cG, cg, cR),
              cG = H0['width'],
              cg = H0['height'];
          if (lk(cd),
          cd['pixelStorei'](nX, cC['unpackAlignment'] || 0x1),
          lA(cd, cC),
          cO === n6) {
              const H3 = cR / 0x6 * (cL / cJ['BYTES_PER_ELEMENT']);
              lx(0x0, cC)['forEach'](H4=>{
                  const H5 = H3 * H4['ndx']
                    , H6 = cJ['subarray'](H5, H5 + H3);
                  cd['texImage2D'](H4['face'], cP, cM, cG, cg, 0x0, cQ, cm, H6);
              }
              );
          } else
              cO === n7 || cO === n8 ? cd['texImage3D'](cO, cP, cM, cG, cg, cN, 0x0, cQ, cm, cJ) : cd['texImage2D'](cO, cP, cM, cG, cg, 0x0, cQ, cm, cJ);
          return {
              'width': cG,
              'height': cg,
              'depth': cN,
              'type': cm
          };
      }
      function lY(cd, cq, cJ) {
          cJ = cJ || lF,
          cq = cq || AN['textureOptions'];
          const cC = cd['createTexture']()
            , cO = cq['target'] || n5;
          let cG = cq['width'] || 0x1
            , cg = cq['height'] || 0x1;
          const cN = cq['internalFormat'] || Am;
          cd['bindTexture'](cO, cC),
          cO === n6 && (cd['texParameteri'](cO, nx, n2),
          cd['texParameteri'](cO, np, n2));
          let cP = cq['src'];
          if (cP) {
              if ('function' == typeof cP && (cP = cP(cd, cq)),
              'string' == typeof cP)
                  !function(cM, cz, cQ, cm) {
                      cm = cm || lF,
                      cQ = cQ || AN['textureOptions'],
                      lh(cM, cz, cQ),
                      lw((cQ = Object['assign']({}, cQ))['src'], cQ['crossOrigin'], function(cL, cR) {
                          cL ? cm(cL, cz, cR) : (lp(cM, cz, cR, cQ),
                          cm(null, cz, cR));
                      });
                  }(cd, cC, cq, cJ);
              else {
                  if (AP(cP) || Array['isArray'](cP) && ('number' == typeof cP[0x0] || Array['isArray'](cP[0x0]) || AP(cP[0x0]))) {
                      const cM = lu(cd, cC, cP, cq);
                      cG = cM['width'],
                      cg = cM['height'];
                  } else
                      Array['isArray'](cP) && ('string' == typeof cP[0x0] || ly(cP[0x0])) ? cO === n6 ? function(cz, cQ, cm, cL) {
                          cL = cL || lF;
                          const cR = cm['src'];
                          if (0x6 !== cR['length'])
                              throw 'there\x20must\x20be\x206\x20urls\x20for\x20a\x20cubemap';
                          const H0 = cm['level'] || 0x0
                            , H1 = cm['internalFormat'] || cm['format'] || Am
                            , H2 = l8(H1)
                            , H3 = cm['format'] || H2['format']
                            , H4 = cm['type'] || kU
                            , H5 = cm['target'] || n5;
                          if (H5 !== n6)
                              throw 'target\x20must\x20be\x20TEXTURE_CUBE_MAP';
                          lh(cz, cQ, cm),
                          cm = Object['assign']({}, cm);
                          let H6 = 0x6;
                          const H7 = []
                            , H8 = lH(0x0, cm);
                          let H9;
                          H9 = cR['map'](function(Hv, HA) {
                              return lw(Hv, cm['crossOrigin'], (Hk = H8[HA],
                              function(Hl, HK) {
                                  --H6,
                                  Hl ? H7['push'](Hl) : HK['width'] !== HK['height'] ? H7['push']('cubemap\x20face\x20img\x20is\x20not\x20a\x20square:\x20' + HK['src']) : (lA(cz, cm),
                                  cz['bindTexture'](H5, cQ),
                                  0x5 === H6 ? lH()['forEach'](function(Hb) {
                                      cz['texImage2D'](Hb, H0, H1, H3, H4, HK);
                                  }) : cz['texImage2D'](Hk, H0, H1, H3, H4, HK),
                                  lc(cm) && cz['generateMipmap'](H5)),
                                  0x0 === H6 && cL(H7['length'] ? H7 : undefined, cQ, H9);
                              }
                              ));
                              var Hk;
                          });
                      }(cd, cC, cq, cJ) : function(cz, cQ, cm, cL) {
                          cL = cL || lF;
                          const cR = cm['src']
                            , H0 = cm['internalFormat'] || cm['format'] || Am
                            , H1 = l8(H0)
                            , H2 = cm['format'] || H1['format']
                            , H3 = cm['type'] || kU
                            , H4 = cm['target'] || n8;
                          if (H4 !== n7 && H4 !== n8)
                              throw 'target\x20must\x20be\x20TEXTURE_3D\x20or\x20TEXTURE_2D_ARRAY';
                          lh(cz, cQ, cm),
                          cm = Object['assign']({}, cm);
                          let H5 = cR['length'];
                          const H6 = [];
                          let H7;
                          const H8 = cm['level'] || 0x0;
                          let H9 = cm['width']
                            , Hv = cm['height'];
                          const HA = cR['length'];
                          let Hk = true;
                          H7 = cR['map'](function(Hl, HK) {
                              return lw(Hl, cm['crossOrigin'], (Hb = HK,
                              function(Hc, HH) {
                                  if (--H5,
                                  Hc)
                                      H6['push'](Hc);
                                  else {
                                      if (lA(cz, cm),
                                      cz['bindTexture'](H4, cQ),
                                      Hk) {
                                          Hk = false,
                                          H9 = cm['width'] || HH['width'],
                                          Hv = cm['height'] || HH['height'],
                                          cz['texImage3D'](H4, H8, H0, H9, Hv, HA, 0x0, H2, H3, null);
                                          for (let Hx = 0x0; Hx < HA; ++Hx)
                                              cz['texSubImage3D'](H4, H8, 0x0, 0x0, Hx, H9, Hv, 0x1, H2, H3, HH);
                                      } else {
                                          let Hp, HF = HH;
                                          HH['width'] === H9 && HH['height'] === Hv || (Hp = AM(),
                                          HF = Hp['canvas'],
                                          Hp['canvas']['width'] = H9,
                                          Hp['canvas']['height'] = Hv,
                                          Hp['drawImage'](HH, 0x0, 0x0, H9, Hv)),
                                          cz['texSubImage3D'](H4, H8, 0x0, 0x0, Hb, H9, Hv, 0x1, H2, H3, HF),
                                          Hp && HF === Hp['canvas'] && (Hp['canvas']['width'] = 0x0,
                                          Hp['canvas']['height'] = 0x0);
                                      }
                                      lc(cm) && cz['generateMipmap'](H4);
                                  }
                                  0x0 === H5 && cL(H6['length'] ? H6 : undefined, cQ, H7);
                              }
                              ));
                              var Hb;
                          });
                      }(cd, cC, cq, cJ) : (lp(cd, cC, cP, cq),
                      cG = cP['width'],
                      cg = cP['height']);
              }
          } else
              !function(cz, cQ, cm) {
                  const cL = cm['target'] || n5;
                  cz['bindTexture'](cL, cQ);
                  const cR = cm['level'] || 0x0
                    , H0 = cm['internalFormat'] || cm['format'] || Am
                    , H1 = l8(H0)
                    , H2 = cm['format'] || H1['format']
                    , H3 = cm['type'] || H1['type'];
                  if (lA(cz, cm),
                  cL === n6) {
                      for (let H4 = 0x0; H4 < 0x6; ++H4)
                          cz['texImage2D'](n9 + H4, cR, H0, cm['width'], cm['height'], 0x0, H2, H3, null);
                  } else
                      cL === n7 || cL === n8 ? cz['texImage3D'](cL, cR, H0, cm['width'], cm['height'], cm['depth'], 0x0, H2, H3, null) : cz['texImage2D'](cL, cR, H0, cm['width'], cm['height'], 0x0, H2, H3, null);
              }(cd, cC, cq);
          return lc(cq) && lb(cd, cC, cq, cG, cg, cN),
          lK(cd, cC, cq),
          cC;
      }
      const lT = vP;
      function lX(cd) {
          return 'undefined' != typeof document && document['getElementById'] ? document['getElementById'](cd) : null;
      }
      const lE = 0x84c0
        , lf = 0x8892
        , lW = 0x8b81
        , lI = 0x8b82
        , lj = 0x8b30
        , lD = 0x8b31
        , lV = 0x8c8d
        , lZ = 0x8b86
        , lB = 0x8b89
        , lS = 0x8c83
        , lU = 0x8a36
        , ld = 0x8a44
        , lq = 0x8a46
        , lJ = 0x8a40
        , lC = 0x8a43
        , lO = 0x1404
        , lG = 0xde1
        , lg = 0x8513
        , lN = 0x806f
        , lP = 0x8c1a
        , lM = {};
      function lz(cd, cq) {
          return lM[cq]['bindPoint'];
      }
      function lQ(cd, cq) {
          return function(cJ) {
              cd['uniform1i'](cq, cJ);
          }
          ;
      }
      function lm(cd, cq) {
          return function(cJ) {
              cd['uniform1iv'](cq, cJ);
          }
          ;
      }
      function lL(cd, cq) {
          return function(cJ) {
              cd['uniform2iv'](cq, cJ);
          }
          ;
      }
      function lR(cd, cq) {
          return function(cJ) {
              cd['uniform3iv'](cq, cJ);
          }
          ;
      }
      function K0(cd, cq) {
          return function(cJ) {
              cd['uniform4iv'](cq, cJ);
          }
          ;
      }
      function K1(cd, cq, cJ, cC) {
          const cO = lz(0x0, cq);
          return AG(cd) ? function(cG) {
              let cg, cN;
              !cG || vm(0x0, cG) ? (cg = cG,
              cN = null) : (cg = cG['texture'],
              cN = cG['sampler']),
              cd['uniform1i'](cC, cJ),
              cd['activeTexture'](lE + cJ),
              cd['bindTexture'](cO, cg),
              cd['bindSampler'](cJ, cN);
          }
          : function(cG) {
              cd['uniform1i'](cC, cJ),
              cd['activeTexture'](lE + cJ),
              cd['bindTexture'](cO, cG);
          }
          ;
      }
      function K2(cd, cq, cJ, cC, cO) {
          const cG = lz(0x0, cq)
            , cg = new Int32Array(cO);
          for (let cN = 0x0; cN < cO; ++cN)
              cg[cN] = cJ + cN;
          return AG(cd) ? function(cP) {
              cd['uniform1iv'](cC, cg),
              cP['forEach'](function(cM, cz) {
                  let cQ, cm;
                  cd['activeTexture'](lE + cg[cz]),
                  !cM || vm(0x0, cM) ? (cQ = cM,
                  cm = null) : (cQ = cM['texture'],
                  cm = cM['sampler']),
                  cd['bindSampler'](cJ, cm),
                  cd['bindTexture'](cG, cQ);
              });
          }
          : function(cP) {
              cd['uniform1iv'](cC, cg),
              cP['forEach'](function(cM, cz) {
                  cd['activeTexture'](lE + cg[cz]),
                  cd['bindTexture'](cG, cM);
              });
          }
          ;
      }
      function K3(cd, cq) {
          return function(cJ) {
              if (cJ['value'])
                  switch (cd['disableVertexAttribArray'](cq),
                  cJ['value']['length']) {
                  case 0x4:
                      cd['vertexAttrib4fv'](cq, cJ['value']);
                      break;
                  case 0x3:
                      cd['vertexAttrib3fv'](cq, cJ['value']);
                      break;
                  case 0x2:
                      cd['vertexAttrib2fv'](cq, cJ['value']);
                      break;
                  case 0x1:
                      cd['vertexAttrib1fv'](cq, cJ['value']);
                      break;
                  default:
                      throw new Error('the\x20length\x20of\x20a\x20float\x20constant\x20value\x20must\x20be\x20between\x201\x20and\x204!');
                  }
              else
                  cd['bindBuffer'](lf, cJ['buffer']),
                  cd['enableVertexAttribArray'](cq),
                  cd['vertexAttribPointer'](cq, cJ['numComponents'] || cJ['size'], cJ['type'] || 0x1406, cJ['normalize'] || false, cJ['stride'] || 0x0, cJ['offset'] || 0x0),
                  cd['vertexAttribDivisor'] && cd['vertexAttribDivisor'](cq, cJ['divisor'] || 0x0);
          }
          ;
      }
      function K4(cd, cq) {
          return function(cJ) {
              if (cJ['value']) {
                  if (cd['disableVertexAttribArray'](cq),
                  0x4 !== cJ['value']['length'])
                      throw new Error('The\x20length\x20of\x20an\x20integer\x20constant\x20value\x20must\x20be\x204!');
                  cd['vertexAttrib4iv'](cq, cJ['value']);
              } else
                  cd['bindBuffer'](lf, cJ['buffer']),
                  cd['enableVertexAttribArray'](cq),
                  cd['vertexAttribIPointer'](cq, cJ['numComponents'] || cJ['size'], cJ['type'] || lO, cJ['stride'] || 0x0, cJ['offset'] || 0x0),
                  cd['vertexAttribDivisor'] && cd['vertexAttribDivisor'](cq, cJ['divisor'] || 0x0);
          }
          ;
      }
      function K5(cd, cq) {
          return function(cJ) {
              if (cJ['value']) {
                  if (cd['disableVertexAttribArray'](cq),
                  0x4 !== cJ['value']['length'])
                      throw new Error('The\x20length\x20of\x20an\x20unsigned\x20integer\x20constant\x20value\x20must\x20be\x204!');
                  cd['vertexAttrib4uiv'](cq, cJ['value']);
              } else
                  cd['bindBuffer'](lf, cJ['buffer']),
                  cd['enableVertexAttribArray'](cq),
                  cd['vertexAttribIPointer'](cq, cJ['numComponents'] || cJ['size'], cJ['type'] || 0x1405, cJ['stride'] || 0x0, cJ['offset'] || 0x0),
                  cd['vertexAttribDivisor'] && cd['vertexAttribDivisor'](cq, cJ['divisor'] || 0x0);
          }
          ;
      }
      function K6(cd, cq, cJ) {
          const cC = cJ['size']
            , cO = cJ['count'];
          return function(cG) {
              cd['bindBuffer'](lf, cG['buffer']);
              const cg = cG['size'] || cG['numComponents'] || cC
                , cN = cg / cO
                , cP = cG['type'] || 0x1406
                , cM = lM[cP]['size'] * cg
                , cz = cG['normalize'] || false
                , cQ = cG['offset'] || 0x0
                , cm = cM / cO;
              for (let cL = 0x0; cL < cO; ++cL)
                  cd['enableVertexAttribArray'](cq + cL),
                  cd['vertexAttribPointer'](cq + cL, cN, cP, cz, cM, cQ + cm * cL),
                  cd['vertexAttribDivisor'] && cd['vertexAttribDivisor'](cq + cL, cG['divisor'] || 0x0);
          }
          ;
      }
      lM[0x1406] = {
          'Type': Float32Array,
          'size': 0x4,
          'setter': function(cd, cq) {
              return function(cJ) {
                  cd['uniform1f'](cq, cJ);
              }
              ;
          },
          'arraySetter': function(cd, cq) {
              return function(cJ) {
                  cd['uniform1fv'](cq, cJ);
              }
              ;
          }
      },
      lM[0x8b50] = {
          'Type': Float32Array,
          'size': 0x8,
          'setter': function(cd, cq) {
              return function(cJ) {
                  cd['uniform2fv'](cq, cJ);
              }
              ;
          },
          'cols': 0x2
      },
      lM[0x8b51] = {
          'Type': Float32Array,
          'size': 0xc,
          'setter': function(cd, cq) {
              return function(cJ) {
                  cd['uniform3fv'](cq, cJ);
              }
              ;
          },
          'cols': 0x3
      },
      lM[0x8b52] = {
          'Type': Float32Array,
          'size': 0x10,
          'setter': function(cd, cq) {
              return function(cJ) {
                  cd['uniform4fv'](cq, cJ);
              }
              ;
          },
          'cols': 0x4
      },
      lM[lO] = {
          'Type': Int32Array,
          'size': 0x4,
          'setter': lQ,
          'arraySetter': lm
      },
      lM[0x8b53] = {
          'Type': Int32Array,
          'size': 0x8,
          'setter': lL,
          'cols': 0x2
      },
      lM[0x8b54] = {
          'Type': Int32Array,
          'size': 0xc,
          'setter': lR,
          'cols': 0x3
      },
      lM[0x8b55] = {
          'Type': Int32Array,
          'size': 0x10,
          'setter': K0,
          'cols': 0x4
      },
      lM[0x1405] = {
          'Type': Uint32Array,
          'size': 0x4,
          'setter': function(cd, cq) {
              return function(cJ) {
                  cd['uniform1ui'](cq, cJ);
              }
              ;
          },
          'arraySetter': function(cd, cq) {
              return function(cJ) {
                  cd['uniform1uiv'](cq, cJ);
              }
              ;
          }
      },
      lM[0x8dc6] = {
          'Type': Uint32Array,
          'size': 0x8,
          'setter': function(cd, cq) {
              return function(cJ) {
                  cd['uniform2uiv'](cq, cJ);
              }
              ;
          },
          'cols': 0x2
      },
      lM[0x8dc7] = {
          'Type': Uint32Array,
          'size': 0xc,
          'setter': function(cd, cq) {
              return function(cJ) {
                  cd['uniform3uiv'](cq, cJ);
              }
              ;
          },
          'cols': 0x3
      },
      lM[0x8dc8] = {
          'Type': Uint32Array,
          'size': 0x10,
          'setter': function(cd, cq) {
              return function(cJ) {
                  cd['uniform4uiv'](cq, cJ);
              }
              ;
          },
          'cols': 0x4
      },
      lM[0x8b56] = {
          'Type': Uint32Array,
          'size': 0x4,
          'setter': lQ,
          'arraySetter': lm
      },
      lM[0x8b57] = {
          'Type': Uint32Array,
          'size': 0x8,
          'setter': lL,
          'cols': 0x2
      },
      lM[0x8b58] = {
          'Type': Uint32Array,
          'size': 0xc,
          'setter': lR,
          'cols': 0x3
      },
      lM[0x8b59] = {
          'Type': Uint32Array,
          'size': 0x10,
          'setter': K0,
          'cols': 0x4
      },
      lM[0x8b5a] = {
          'Type': Float32Array,
          'size': 0x20,
          'setter': function(cd, cq) {
              return function(cJ) {
                  cd['uniformMatrix2fv'](cq, false, cJ);
              }
              ;
          },
          'rows': 0x2,
          'cols': 0x2
      },
      lM[0x8b5b] = {
          'Type': Float32Array,
          'size': 0x30,
          'setter': function(cd, cq) {
              return function(cJ) {
                  cd['uniformMatrix3fv'](cq, false, cJ);
              }
              ;
          },
          'rows': 0x3,
          'cols': 0x3
      },
      lM[0x8b5c] = {
          'Type': Float32Array,
          'size': 0x40,
          'setter': function(cd, cq) {
              return function(cJ) {
                  cd['uniformMatrix4fv'](cq, false, cJ);
              }
              ;
          },
          'rows': 0x4,
          'cols': 0x4
      },
      lM[0x8b65] = {
          'Type': Float32Array,
          'size': 0x20,
          'setter': function(cd, cq) {
              return function(cJ) {
                  cd['uniformMatrix2x3fv'](cq, false, cJ);
              }
              ;
          },
          'rows': 0x2,
          'cols': 0x3
      },
      lM[0x8b66] = {
          'Type': Float32Array,
          'size': 0x20,
          'setter': function(cd, cq) {
              return function(cJ) {
                  cd['uniformMatrix2x4fv'](cq, false, cJ);
              }
              ;
          },
          'rows': 0x2,
          'cols': 0x4
      },
      lM[0x8b67] = {
          'Type': Float32Array,
          'size': 0x30,
          'setter': function(cd, cq) {
              return function(cJ) {
                  cd['uniformMatrix3x2fv'](cq, false, cJ);
              }
              ;
          },
          'rows': 0x3,
          'cols': 0x2
      },
      lM[0x8b68] = {
          'Type': Float32Array,
          'size': 0x30,
          'setter': function(cd, cq) {
              return function(cJ) {
                  cd['uniformMatrix3x4fv'](cq, false, cJ);
              }
              ;
          },
          'rows': 0x3,
          'cols': 0x4
      },
      lM[0x8b69] = {
          'Type': Float32Array,
          'size': 0x40,
          'setter': function(cd, cq) {
              return function(cJ) {
                  cd['uniformMatrix4x2fv'](cq, false, cJ);
              }
              ;
          },
          'rows': 0x4,
          'cols': 0x2
      },
      lM[0x8b6a] = {
          'Type': Float32Array,
          'size': 0x40,
          'setter': function(cd, cq) {
              return function(cJ) {
                  cd['uniformMatrix4x3fv'](cq, false, cJ);
              }
              ;
          },
          'rows': 0x4,
          'cols': 0x3
      },
      lM[0x8b5e] = {
          'Type': null,
          'size': 0x0,
          'setter': K1,
          'arraySetter': K2,
          'bindPoint': lG
      },
      lM[0x8b60] = {
          'Type': null,
          'size': 0x0,
          'setter': K1,
          'arraySetter': K2,
          'bindPoint': lg
      },
      lM[0x8b5f] = {
          'Type': null,
          'size': 0x0,
          'setter': K1,
          'arraySetter': K2,
          'bindPoint': lN
      },
      lM[0x8b62] = {
          'Type': null,
          'size': 0x0,
          'setter': K1,
          'arraySetter': K2,
          'bindPoint': lG
      },
      lM[0x8dc1] = {
          'Type': null,
          'size': 0x0,
          'setter': K1,
          'arraySetter': K2,
          'bindPoint': lP
      },
      lM[0x8dc4] = {
          'Type': null,
          'size': 0x0,
          'setter': K1,
          'arraySetter': K2,
          'bindPoint': lP
      },
      lM[0x8dc5] = {
          'Type': null,
          'size': 0x0,
          'setter': K1,
          'arraySetter': K2,
          'bindPoint': lg
      },
      lM[0x8dca] = {
          'Type': null,
          'size': 0x0,
          'setter': K1,
          'arraySetter': K2,
          'bindPoint': lG
      },
      lM[0x8dcb] = {
          'Type': null,
          'size': 0x0,
          'setter': K1,
          'arraySetter': K2,
          'bindPoint': lN
      },
      lM[0x8dcc] = {
          'Type': null,
          'size': 0x0,
          'setter': K1,
          'arraySetter': K2,
          'bindPoint': lg
      },
      lM[0x8dcf] = {
          'Type': null,
          'size': 0x0,
          'setter': K1,
          'arraySetter': K2,
          'bindPoint': lP
      },
      lM[0x8dd2] = {
          'Type': null,
          'size': 0x0,
          'setter': K1,
          'arraySetter': K2,
          'bindPoint': lG
      },
      lM[0x8dd3] = {
          'Type': null,
          'size': 0x0,
          'setter': K1,
          'arraySetter': K2,
          'bindPoint': lN
      },
      lM[0x8dd4] = {
          'Type': null,
          'size': 0x0,
          'setter': K1,
          'arraySetter': K2,
          'bindPoint': lg
      },
      lM[0x8dd7] = {
          'Type': null,
          'size': 0x0,
          'setter': K1,
          'arraySetter': K2,
          'bindPoint': lP
      };
      const K7 = {};
      K7[0x1406] = {
          'size': 0x4,
          'setter': K3
      },
      K7[0x8b50] = {
          'size': 0x8,
          'setter': K3
      },
      K7[0x8b51] = {
          'size': 0xc,
          'setter': K3
      },
      K7[0x8b52] = {
          'size': 0x10,
          'setter': K3
      },
      K7[lO] = {
          'size': 0x4,
          'setter': K4
      },
      K7[0x8b53] = {
          'size': 0x8,
          'setter': K4
      },
      K7[0x8b54] = {
          'size': 0xc,
          'setter': K4
      },
      K7[0x8b55] = {
          'size': 0x10,
          'setter': K4
      },
      K7[0x1405] = {
          'size': 0x4,
          'setter': K5
      },
      K7[0x8dc6] = {
          'size': 0x8,
          'setter': K5
      },
      K7[0x8dc7] = {
          'size': 0xc,
          'setter': K5
      },
      K7[0x8dc8] = {
          'size': 0x10,
          'setter': K5
      },
      K7[0x8b56] = {
          'size': 0x4,
          'setter': K4
      },
      K7[0x8b57] = {
          'size': 0x8,
          'setter': K4
      },
      K7[0x8b58] = {
          'size': 0xc,
          'setter': K4
      },
      K7[0x8b59] = {
          'size': 0x10,
          'setter': K4
      },
      K7[0x8b5a] = {
          'size': 0x4,
          'setter': K6,
          'count': 0x2
      },
      K7[0x8b5b] = {
          'size': 0x9,
          'setter': K6,
          'count': 0x3
      },
      K7[0x8b5c] = {
          'size': 0x10,
          'setter': K6,
          'count': 0x4
      };
      const K8 = /ERROR:\s*\d+:(\d+)/gi
        , K9 = /^[ \t]*\n/;
      function Kv(cd) {
          let cq = 0x0;
          return K9['test'](cd) && (cq = 0x1,
          cd = cd['replace'](K9, '')),
          {
              'lineOffset': cq,
              'shaderSource': cd
          };
      }
      function KA(cd, cq, cJ) {
          let cC, cO, cG;
          if ('function' == typeof cq && (cJ = cq,
          cq = undefined),
          'function' == typeof cd)
              cJ = cd,
              cd = undefined;
          else {
              if (cd && !Array['isArray'](cd)) {
                  const cM = cd;
                  cJ = cM['errorCallback'],
                  cd = cM['attribLocations'],
                  cC = cM['transformFeedbackVaryings'],
                  cO = cM['transformFeedbackMode'],
                  cG = cM['callback'];
              }
          }
          const cg = cJ || lT
            , cN = []
            , cP = {
              'errorCallback'(cz, ...cQ) {
                  cN['push'](cz),
                  cg(cz, ...cQ);
              },
              'transformFeedbackVaryings': cC,
              'transformFeedbackMode': cO,
              'callback': cG,
              'errors': cN
          };
          {
              let cz = {};
              Array['isArray'](cd) ? cd['forEach'](function(cQ, cm) {
                  cz[cQ] = cq ? cq[cm] : cm;
              }) : cz = cd || {},
              cP['attribLocations'] = cz;
          }
          return cP;
      }
      const Kk = ['VERTEX_SHADER', 'FRAGMENT_SHADER']
        , Kl = (cd=0x0)=>new Promise(cq=>setTimeout(cq, cd));
      function KK(cd, cq, cJ) {
          const cC = cd['createProgram']()
            , {attribLocations: cO, transformFeedbackVaryings: cG, transformFeedbackMode: cg} = KA(cJ);
          for (let cP = 0x0; cP < cq['length']; ++cP) {
              let cM = cq[cP];
              if ('string' == typeof cM) {
                  const cz = lX(cM)
                    , cQ = cz ? cz['text'] : cM;
                  let cm = cd[Kk[cP]];
                  cz && cz['type'] && (cm = ((cN = cz['type'])['indexOf']('frag') >= 0x0 ? lj : cN['indexOf']('vert') >= 0x0 ? lD : undefined) || cm),
                  cM = cd['createShader'](cm),
                  cd['shaderSource'](cM, Kv(cQ)['shaderSource']),
                  cd['compileShader'](cM),
                  cd['attachShader'](cC, cM);
              }
          }
          var cN;
          Object['entries'](cO)['forEach'](([cL,cR])=>cd['bindAttribLocation'](cC, cR, cL));
          {
              let cL = cG;
              cL && (cL['attribs'] && (cL = cL['attribs']),
              Array['isArray'](cL) || (cL = Object['keys'](cL)),
              cd['transformFeedbackVaryings'](cC, cL, cg || lV));
          }
          return cd['linkProgram'](cC),
          cC;
      }
      function Kb(cd, cq, cJ, cC, cO) {
          const cG = KA(cJ, cC, cO)
            , cg = new Set(cq)
            , cN = KK(cd, cq, cG);
          function cP(cM, cz) {
              const cQ = Kx(cM, cz, cG['errorCallback']);
              return cQ && function(cm, cL, cR) {
                  const H0 = cm['getAttachedShaders'](cL);
                  for (const H1 of H0)
                      cR['has'](H1) && cm['deleteShader'](H1);
                  cm['deleteProgram'](cL);
              }(cM, cz, cg),
              cQ;
          }
          if (!cG['callback'])
              return cP(cd, cN) ? undefined : cN;
          KH(cd, cN)['then'](()=>{
              const cM = cP(cd, cN);
              cG['callback'](cM, cM ? undefined : cN);
          }
          );
      }
      function Kc(cd) {
          return function(cq, cJ, ...cC) {
              return new Promise((cO,cG)=>{
                  const cg = KA(...cC);
                  cg['callback'] = (cN,cP)=>{
                      cN ? cG(cN) : cO(cP);
                  }
                  ,
                  cd(cq, cJ, cg);
              }
              );
          }
          ;
      }
      async function KH(cd, cq) {
          const cJ = cd['getExtension']('KHR_parallel_shader_compile')
            , cC = cJ ? (cG,cg)=>cG['getProgramParameter'](cg, cJ['COMPLETION_STATUS_KHR']) : ()=>true;
          let cO = 0x0;
          do {
              await Kl(cO),
              cO = 0x3e8 / 0x3c;
          } while (!cC(cd, cq));
      }
      function Kx(cd, cq, cJ) {
          if (cJ = cJ || lT,
          !cd['getProgramParameter'](cq, lI)) {
              const cC = cd['getProgramInfoLog'](cq);
              return cJ('Error\x20in\x20program\x20linking:\x20' + cC),
              cC + '\x0a' + cd['getAttachedShaders'](cq)['map'](cO=>function(cG, cg, cN, cP) {
                  if (cP = cP || lT,
                  !cG['getShaderParameter'](cN, lW)) {
                      const cM = cG['getShaderInfoLog'](cN)
                        , {lineOffset: cz, shaderSource: cQ} = Kv(cG['getShaderSource'](cN))
                        , cm = function(cL, cR='', H0=0x0) {
                          const H1 = [...cR['matchAll'](K8)]
                            , H2 = new Map(H1['map']((H3,H4)=>{
                              const H5 = parseInt(H3[0x1])
                                , H6 = H1[H4 + 0x1]
                                , H7 = H6 ? H6['index'] : cR['length'];
                              return [H5 - 0x1, cR['substring'](H3['index'], H7)];
                          }
                          ));
                          return cL['split']('\x0a')['map']((H3,H4)=>{
                              const H5 = H2['get'](H4);
                              return H4 + 0x1 + H0 + ':\x20' + H3 + (H5 ? '\x0a\x0a^^^\x20' + H5 : '');
                          }
                          )['join']('\x0a');
                      }(cQ, cM, cz) + '\x0aError\x20compiling\x20' + Ag(cG, cg) + ':\x20' + cM;
                      return cP(cm),
                      cm;
                  }
                  return '';
              }(cd, cd['getShaderParameter'](cO, cd['SHADER_TYPE']), cO, cJ))['filter'](cO=>cO)['join']('\x0a');
          }
      }
      function Kp(cd) {
          const cq = cd['name'];
          return cq['startsWith']('gl_') || cq['startsWith']('webgl_');
      }
      Kc(Kb),
      Kc(Kf);
      const KF = /(\.|\[|]|\w+)/g
        , Ky = cd=>cd >= '0' && cd <= '9';
      function Kw(cd, cq, cJ, cC) {
          const cO = cd['split'](KF)['filter'](cN=>'' !== cN);
          let cG = 0x0
            , cg = '';
          for (; ; ) {
              const cN = cO[cG++];
              cg += cN;
              const cP = Ky(cN[0x0])
                , cM = cP ? parseInt(cN) : cN;
              if (cP && (cg += cO[cG++]),
              cG === cO['length']) {
                  cJ[cM] = cq;
                  break;
              }
              {
                  const cz = cO[cG++]
                    , cQ = '[' === cz
                    , cm = cJ[cM] || (cQ ? [] : {});
                  cJ[cM] = cm,
                  cJ = cm,
                  cC[cg] = cC[cg] || function(cL) {
                      return function(cR) {
                          Ku(cL, cR);
                      }
                      ;
                  }(cm),
                  cg += cz;
              }
          }
      }
      function Kh(cd, cq) {
          let cJ = 0x0;
          function cC(cN, cP, cM) {
              const cz = cP['name']['endsWith']('[0]')
                , cQ = cP['type']
                , cm = lM[cQ];
              if (!cm)
                  throw new Error('unknown\x20type:\x200x' + cQ['toString'](0x10));
              let cL;
              if (cm['bindPoint']) {
                  const cR = cJ;
                  cJ += cP['size'],
                  cL = cz ? cm['arraySetter'](cd, cQ, cR, cM, cP['size']) : cm['setter'](cd, cQ, cR, cM, cP['size']);
              } else
                  cL = cm['arraySetter'] && cz ? cm['arraySetter'](cd, cM) : cm['setter'](cd, cM);
              return cL['location'] = cM,
              cL;
          }
          const cO = {}
            , cG = {}
            , cg = cd['getProgramParameter'](cq, lZ);
          for (let cN = 0x0; cN < cg; ++cN) {
              const cP = cd['getActiveUniform'](cq, cN);
              if (Kp(cP))
                  continue;
              let cM = cP['name'];
              cM['endsWith']('[0]') && (cM = cM['substr'](0x0, cM['length'] - 0x3));
              const cz = cd['getUniformLocation'](cq, cP['name']);
              if (cz) {
                  const cQ = cC(0x0, cP, cz);
                  cO[cM] = cQ,
                  Kw(cM, cQ, cG, cO);
              }
          }
          return cO;
      }
      function Ku(cd, cq) {
          for (const cJ in cq) {
              const cC = cd[cJ];
              'function' == typeof cC ? cC(cq[cJ]) : Ku(cd[cJ], cq[cJ]);
          }
      }
      function KY(cd, ...cq) {
          const cJ = cd['uniformSetters'] || cd
            , cC = cq['length'];
          for (let cO = 0x0; cO < cC; ++cO) {
              const cG = cq[cO];
              if (Array['isArray'](cG)) {
                  const cg = cG['length'];
                  for (let cN = 0x0; cN < cg; ++cN)
                      KY(cJ, cG[cN]);
              } else
                  for (const cP in cG) {
                      const cM = cJ[cP];
                      cM && cM(cG[cP]);
                  }
          }
      }
      function KT(cd, cq) {
          const cJ = {}
            , cC = cd['getProgramParameter'](cq, lB);
          for (let cO = 0x0; cO < cC; ++cO) {
              const cG = cd['getActiveAttrib'](cq, cO);
              if (Kp(cG))
                  continue;
              const cg = cd['getAttribLocation'](cq, cG['name'])
                , cN = K7[cG['type']]
                , cP = cN['setter'](cd, cg, cN);
              cP['location'] = cg,
              cJ[cG['name']] = cP;
          }
          return cJ;
      }
      function KX(cd, cq) {
          const cJ = {
              'program': cq,
              'uniformSetters': Kh(cd, cq),
              'attribSetters': KT(cd, cq)
          };
          return AG(cd) && (cJ['uniformBlockSpec'] = function(cC, cO) {
              const cG = cC['getProgramParameter'](cO, lZ)
                , cg = []
                , cN = [];
              for (let cz = 0x0; cz < cG; ++cz) {
                  cN['push'](cz),
                  cg['push']({});
                  const cQ = cC['getActiveUniform'](cO, cz);
                  cg[cz]['name'] = cQ['name'];
              }
              [['UNIFORM_TYPE', 'type'], ['UNIFORM_SIZE', 'size'], ['UNIFORM_BLOCK_INDEX', 'blockNdx'], ['UNIFORM_OFFSET', 'offset']]['forEach'](function(cm) {
                  const cL = cm[0x0]
                    , cR = cm[0x1];
                  cC['getActiveUniforms'](cO, cN, cC[cL])['forEach'](function(H0, H1) {
                      cg[H1][cR] = H0;
                  });
              });
              const cP = {}
                , cM = cC['getProgramParameter'](cO, lU);
              for (let cm = 0x0; cm < cM; ++cm) {
                  const cL = cC['getActiveUniformBlockName'](cO, cm)
                    , cR = {
                      'index': cC['getUniformBlockIndex'](cO, cL),
                      'usedByVertexShader': cC['getActiveUniformBlockParameter'](cO, cm, ld),
                      'usedByFragmentShader': cC['getActiveUniformBlockParameter'](cO, cm, lq),
                      'size': cC['getActiveUniformBlockParameter'](cO, cm, lJ),
                      'uniformIndices': cC['getActiveUniformBlockParameter'](cO, cm, lC)
                  };
                  cR['used'] = cR['usedByVertexShader'] || cR['usedByFragmentShader'],
                  cP[cL] = cR;
              }
              return {
                  'blockSpecs': cP,
                  'uniformData': cg
              };
          }(cd, cq),
          cJ['transformFeedbackInfo'] = function(cC, cO) {
              const cG = {}
                , cg = cC['getProgramParameter'](cO, lS);
              for (let cN = 0x0; cN < cg; ++cN) {
                  const cP = cC['getTransformFeedbackVarying'](cO, cN);
                  cG[cP['name']] = {
                      'index': cN,
                      'type': cP['type'],
                      'size': cP['size']
                  };
              }
              return cG;
          }(cd, cq)),
          cJ;
      }
      const KE = /\s|{|}|;/;
      function Kf(cd, cq, cJ, cC, cO) {
          const cG = KA(cJ, cC, cO)
            , cg = [];
          if (cq = cq['map'](function(cM) {
              if (!KE['test'](cM)) {
                  const cz = lX(cM);
                  if (cz)
                      cM = cz['text'];
                  else {
                      const cQ = 'no\x20element\x20with\x20id:\x20' + cM;
                      cG['errorCallback'](cQ),
                      cg['push'](cQ);
                  }
              }
              return cM;
          }),
          cg['length'])
              return function(cM, cz) {
                  return cM['errorCallback'](cz),
                  cM['callback'] && setTimeout(()=>{
                      cM['callback'](cz + '\x0a' + cM['errors']['join']('\x0a'));
                  }
                  ),
                  null;
              }(cG, '');
          const cN = cG['callback'];
          cN && (cG['callback'] = (cM,cz)=>{
              cN(cM, cM ? undefined : KX(cd, cz));
          }
          );
          const cP = function(cM, cz, cQ, cm, cL) {
              return Kb(cM, cz, cQ, cm, cL);
          }(cd, cq, cG);
          return cP ? KX(cd, cP) : null;
      }
      function KW(cd, cq, cJ, cC, cO) {
          for (const [cG,cg] of Object['entries'](cq)) {
              const cN = {
                  ...cO
              }
                , cP = cJ[cG];
              Array['isArray'](cP) || Object['assign'](cN, cP);
              const cM = Kx(cd, cg, cN['errorCallback']);
              if (cM) {
                  for (const cz of Object['values'](cq)) {
                      const cQ = cd['getAttachedShaders'](cz);
                      cd['deleteProgram'](cz);
                      for (const cm of cQ)
                          cC['has'](cm) || cd['deleteShader'](cm);
                  }
                  return cM;
              }
          }
      }
      function KI(cd, cq, cJ={}) {
          const cC = new Set()
            , cO = Object['fromEntries'](Object['entries'](cq)['map'](([cG,cg])=>{
              const cN = {
                  ...cJ
              }
                , cP = Array['isArray'](cg) ? cg : cg['shaders'];
              return Array['isArray'](cg) || Object['assign'](cN, cg),
              cP['forEach'](cC['add'], cC),
              [cG, KK(cd, cP, cN)];
          }
          ));
          if (!cJ['callback'])
              return KW(cd, cO, cq, cC, cJ) ? undefined : cO;
          (async function(cG, cg) {
              for (const cN of Object['values'](cg))
                  await KH(cG, cN);
          }(cd, cO)['then'](()=>{
              const cG = KW(cd, cO, cq, cC, cJ);
              cJ['callback'](cG, cG ? undefined : cO);
          }
          ));
      }
      Kc(KI),
      Kc(function(cd, cq, cJ) {
          function cC(cg, cN) {
              return Object['fromEntries'](Object['entries'](cN)['map'](([cP,cM])=>[cP, KX(cg, cM)]));
          }
          const cO = (cJ = KA(cJ))['callback'];
          cO && (cJ['callback'] = (cg,cN)=>{
              cO(cg, cg ? undefined : cC(cd, cN));
          }
          );
          const cG = KI(cd, cq, cJ);
          if (!cO && cG)
              return cC(cd, cG);
      });
      const Kj = 0x8d41
        , KD = 0x8ce0
        , KV = 0x8d00
        , KZ = 0x821a
        , KB = 0x812f
        , KS = 0x2601
        , KU = [{
          'format': 0x1908,
          'type': 0x1401,
          'min': KS,
          'wrap': KB
      }, {
          'format': 0x84f9
      }]
        , Kd = {};
      Kd[0x84f9] = KZ,
      Kd[0x1901] = 0x8d20,
      Kd[0x8d48] = 0x8d20,
      Kd[0x1902] = KV,
      Kd[0x81a5] = KV,
      Kd[0x81a6] = KV,
      Kd[0x8cac] = KV,
      Kd[0x88f0] = KZ,
      Kd[0x8cad] = KZ;
      const Kq = {
          0x8056: true,
          0x8057: true,
          0x8d62: true,
          0x84f9: true,
          0x81a5: true,
          0x1901: true,
          0x8d48: true
      };
      function KJ(cd, cq, cJ, cC) {
          const cO = 0x8d40
            , cG = cd['createFramebuffer']();
          cd['bindFramebuffer'](cO, cG),
          cJ = cJ || cd['drawingBufferWidth'],
          cC = cC || cd['drawingBufferHeight'];
          const cg = []
            , cN = {
              'framebuffer': cG,
              'attachments': [],
              'width': cJ,
              'height': cC
          };
          return (cq = cq || KU)['forEach'](function(cP, cM) {
              let cz = cP['attachment'];
              const cQ = cP['samples']
                , cm = cP['format'];
              let cL = cP['attachmentPoint'] || function(H0, H1) {
                  return Kd[H0] || Kd[H1];
              }(cm, cP['internalFormat']);
              if (cL || (cL = KD + cM),
              function(H0) {
                  return H0 >= KD && H0 < 0x8d00;
              }(cL) && cg['push'](cL),
              !cz) {
                  if (undefined !== cQ || function(H0) {
                      return Kq[H0];
                  }(cm))
                      cz = cd['createRenderbuffer'](),
                      cd['bindRenderbuffer'](Kj, cz),
                      cQ > 0x1 ? cd['renderbufferStorageMultisample'](Kj, cQ, cm, cJ, cC) : cd['renderbufferStorage'](Kj, cm, cJ, cC);
                  else {
                      const H0 = Object['assign']({}, cP);
                      H0['width'] = cJ,
                      H0['height'] = cC,
                      undefined === H0['auto'] && (H0['auto'] = false,
                      H0['min'] = H0['min'] || H0['minMag'] || KS,
                      H0['mag'] = H0['mag'] || H0['minMag'] || KS,
                      H0['wrapS'] = H0['wrapS'] || H0['wrap'] || KB,
                      H0['wrapT'] = H0['wrapT'] || H0['wrap'] || KB),
                      cz = lY(cd, H0);
                  }
              }
              if (cR = cz,
              'undefined' != typeof WebGLRenderbuffer && vQ(cR, 'WebGLRenderbuffer'))
                  cd['framebufferRenderbuffer'](cO, cL, Kj, cz);
              else {
                  if (!vm(0x0, cz))
                      throw new Error('unknown\x20attachment\x20type');
                  undefined !== cP['layer'] ? cd['framebufferTextureLayer'](cO, cL, cz, cP['level'] || 0x0, cP['layer']) : cd['framebufferTexture2D'](cO, cL, cP['target'] || 0xde1, cz, cP['level'] || 0x0);
              }
              var cR;
              cN['attachments']['push'](cz);
          }),
          cd['drawBuffers'] && cd['drawBuffers'](cg),
          cN;
      }
      const KC = /^(.*?)_/;
      function KO(cd, cq) {
          Ag(cd, 0x0);
          const cJ = cd['getExtension'](cq);
          if (cJ) {
              const cC = {}
                , cO = KC['exec'](cq)[0x1]
                , cG = '_' + cO;
              for (const cg in cJ) {
                  const cN = cJ[cg]
                    , cP = 'function' == typeof cN
                    , cM = cP ? cO : cG;
                  let cz = cg;
                  cg['endsWith'](cM) && (cz = cg['substring'](0x0, cg['length'] - cM['length'])),
                  undefined !== cd[cz] ? cP || cd[cz] === cN || vM(cz, cd[cz], cN, cg) : cP ? cd[cz] = function(cQ) {
                      return function() {
                          return cQ['apply'](cJ, arguments);
                      }
                      ;
                  }(cN) : (cd[cz] = cN,
                  cC[cz] = cN);
              }
              cC['constructor'] = {
                  'name': cJ['constructor']['name']
              },
              Ag(cC, 0x0);
          }
          return cJ;
      }
      const KG = ['ANGLE_instanced_arrays', 'EXT_blend_minmax', 'EXT_color_buffer_float', 'EXT_color_buffer_half_float', 'EXT_disjoint_timer_query', 'EXT_disjoint_timer_query_webgl2', 'EXT_frag_depth', 'EXT_sRGB', 'EXT_shader_texture_lod', 'EXT_texture_filter_anisotropic', 'OES_element_index_uint', 'OES_standard_derivatives', 'OES_texture_float', 'OES_texture_float_linear', 'OES_texture_half_float', 'OES_texture_half_float_linear', 'OES_vertex_array_object', 'WEBGL_color_buffer_float', 'WEBGL_compressed_texture_atc', 'WEBGL_compressed_texture_etc1', 'WEBGL_compressed_texture_pvrtc', 'WEBGL_compressed_texture_s3tc', 'WEBGL_compressed_texture_s3tc_srgb', 'WEBGL_depth_texture', 'WEBGL_draw_buffers'];
      var Kg = n(0x346)
        , KN = n(0x338)
        , KP = n(0x60)
        , KM = n(0x240)
        , Kz = n(0x1);
      class BinaryReader {
          constructor(cd, cq=true) {
              this['_buffer'] = cd,
              this['littleEndian'] = cq,
              this['_view'] = new DataView(cd),
              this['_offset'] = 0x0;
          }
          get['offset']() {
              return this['_offset'];
          }
          get['buffer']() {
              return this['_buffer'];
          }
          get['dataView']() {
              return this['_view'];
          }
          ['reset']() {
              this['_offset'] = 0x0;
          }
          ['seek'](cd) {
              this['_offset'] = cd;
          }
          ['skip'](cd) {
              this['_offset'] += cd;
          }
          ['readUint8']() {
              const cd = this['_view']['getUint8'](this['_offset']);
              return this['_offset'] += 0x1,
              cd;
          }
          ['readUint16']() {
              const cd = this['_view']['getUint16'](this['_offset'], this['littleEndian']);
              return this['_offset'] += 0x2,
              cd;
          }
          ['readUint32']() {
              const cd = this['_view']['getUint32'](this['_offset'], this['littleEndian']);
              return this['_offset'] += 0x4,
              cd;
          }
          ['readInt8']() {
              const cd = this['_view']['getInt8'](this['_offset']);
              return this['_offset'] += 0x1,
              cd;
          }
          ['readInt16']() {
              const cd = this['_view']['getInt16'](this['_offset'], this['littleEndian']);
              return this['_offset'] += 0x2,
              cd;
          }
          ['readInt32']() {
              const cd = this['_view']['getInt32'](this['_offset'], this['littleEndian']);
              return this['_offset'] += 0x4,
              cd;
          }
          ['readFloat32']() {
              const cd = this['_view']['getFloat32'](this['_offset'], this['littleEndian']);
              return this['_offset'] += 0x4,
              cd;
          }
          ['readFloat64']() {
              const cd = this['_view']['getFloat64'](this['_offset'], this['littleEndian']);
              return this['_offset'] += 0x8,
              cd;
          }
          ['readBuffer'](cd) {
              const cq = this['_buffer']['slice'](this['_offset'], this['_offset'] + cd);
              return this['_offset'] += cd,
              cq;
          }
          ['readString'](cd) {
              return String['fromCharCode']['apply'](null, new Uint8Array(this['readBuffer'](cd)));
          }
      }
      var Km = n(0x24d)
        , KL = n(0x95)
        , KR = function(cd, cq, cJ, cC) {
          return new (cJ || (cJ = Promise))(function(cO, cG) {
              function cg(cM) {
                  try {
                      cP(cC['next'](cM));
                  } catch (cz) {
                      cG(cz);
                  }
              }
              function cN(cM) {
                  try {
                      cP(cC['throw'](cM));
                  } catch (cz) {
                      cG(cz);
                  }
              }
              function cP(cM) {
                  var cz;
                  cM['done'] ? cO(cM['value']) : (cz = cM['value'],
                  cz instanceof cJ ? cz : new cJ(function(cQ) {
                      cQ(cz);
                  }
                  ))['then'](cg, cN);
              }
              cP((cC = cC['apply'](cd, cq || []))['next']());
          }
          );
      };
      class GrayImageGridDataProvider extends Km['r'] {
          constructor(cd, cq) {
              super(cq),
              this['options'] = {},
              this['options'] = (0x0,
              Kz['Ov'])(this['options'], cq),
              this['gridOptions'] = this['options']['gridOptions'],
              this['load'](cd);
          }
          ['load'](cd) {
              this['grids']['push']([new KN['K'](this['gridOptions']['xSize'],this['gridOptions']['ySize'],cd,this['options']['undef'],this['options']['autoLoadToMemory'],this['options']['algo'],this['options']['scale'],this['options']['offset'],this['options']['dataType'])]);
          }
          static['loadVideo'](cd) {
              return KR(this, undefined, undefined, function*() {
                  return new Promise((cq,cJ)=>{
                      const cC = document['createElement']('video');
                      cC['autoplay'] = true,
                      cC['loop'] = false,
                      cC['crossOrigin'] = 'anonymous',
                      cC['muted'] = true,
                      cC['setAttribute']('playsinline', ''),
                      cC['setAttribute']('webkit-playsinline', ''),
                      cC['oncanplay'] = cO=>{
                          cC['play']()['then'](cG=>{
                              cq(cC);
                          }
                          , cG=>{
                              cJ(cG);
                          }
                          )['catch'](v0['kg']['debug']);
                      }
                      ,
                      cC['addEventListener']('error', cO=>{
                          v0['kg']['debug'](cC['error']),
                          cJ(cO);
                      }
                      ),
                      cC['src'] = cd;
                  }
                  );
              });
          }
          static['loadImage'](cd) {
              return KR(this, undefined, undefined, function*() {
                  return new Promise((cq,cJ)=>{
                      const cC = new Image();
                      cC['crossOrigin'] = 'anonymous',
                      cC['onload'] = cO=>{
                          cq(cC);
                      }
                      ,
                      cC['onerror'] = cO=>{
                          cJ(cO);
                      }
                      ,
                      cC['src'] = cd;
                  }
                  );
              });
          }
          static['extractHeaderFromBuffer'](cd) {
              const cq = new BinaryReader(cd)
                , cJ = cq['readFloat32']()
                , cC = cq['readFloat32']()
                , cO = cq['readFloat32']()
                , cG = cq['readFloat32']()
                , cg = cq['readFloat32']()
                , cN = cq['readFloat32']()
                , cP = cq['readFloat32']()
                , cM = cq['readFloat32']()
                , cz = {
                  'gridOptions': {
                      'xStart': cC,
                      'yStart': cJ,
                      'xSize': cN,
                      'ySize': cg,
                      'xDelta': cG,
                      'yDelta': cO,
                      'tCount': 0x1,
                      'zValues': [0x0]
                  },
                  'dataType': 0x0 === cq['readUint8']() ? KP['U']['UInt8'] : KP['U']['UInt16'],
                  'scale': cP,
                  'offset': cM,
                  'algo': 0x1 === cP && 0x0 === cM ? 0x0 : 0x1,
                  'undef': cq['readFloat32']()
              };
              return (0x0,
              KM['T'])(cz['gridOptions']),
              {
                  'options': cz,
                  'data': cq['readBuffer'](cd['byteLength'] - cq['offset'] + 0x1)
              };
          }
          static['decodeWebp'](cd) {
              return KR(this, undefined, undefined, function*() {
                  return new Promise((cq,cJ)=>KR(this, undefined, undefined, function*() {
                      try {
                          const cC = performance['now']();
                          window['wasm_webp']({
                              'onRuntimeInitialized'() {}
                          })['then'](cO=>{
                              const cG = new Uint8Array(cd)
                                , cg = cO['decode'](cG, cG['length'], true);
                              cO['free'](),
                              cq(cg),
                              v0['kg']['debug']('decode\x20webp\x20cost\x20' + (performance['now']() - cC) + 'ms');
                          }
                          );
                      } catch (cO) {
                          v0['kg']['error'](cO),
                          cq(undefined);
                      }
                  }));
              });
          }
          static['fromBuffer'](cd, cq, cJ) {
              return KR(this, undefined, undefined, function*() {
                  if (cJ['withHeader']) {
                      const cG = this['extractHeaderFromBuffer'](cd);
                      cJ['gridOptions'] && (cG['options']['gridOptions'] = Object['assign'](Object['assign']({}, cG['options']['gridOptions']), cJ['gridOptions'])),
                      cJ = (0x0,
                      Kz['Ov'])({}, cJ, cG['options']),
                      cd = cG['data'],
                      delete cJ['withHeader'];
                  }
                  if (cJ['compatibleOldDevice'] && !(yield(0x0,
                  KL['sU'])())) {
                      if (v0['kg']['debug']('webp'),
                      'function' != typeof window['wasm_webp'])
                          try {
                              yield(0x0,
                              Kz['ve'])(Kg['v']['resourcePath'] + '/libs/webp/wasm_webp.min.js', 'dynamic_script_webp', 'wasm_webp');
                          } catch (cg) {
                              v0['kg']['error']('webp_wasm'),
                              v0['kg']['error'](cg);
                          }
                      if ('function' == typeof window['wasm_webp']) {
                          let cN = yield GrayImageGridDataProvider['decodeWebp'](cd);
                          if (cN) {
                              const cP = Object['assign']({}, cJ['gridOptions']);
                              if (cP['xSize'] > 0x400 || cP['ySize'] > 0x400) {
                                  let cQ, cm;
                                  cP['xSize'] > cP['ySize'] ? (cQ = 0x3f6,
                                  cm = parseInt(cQ * (0x1 * cP['ySize'] / cP['xSize']))) : (cm = 0x3f6,
                                  cQ = parseInt(cm * (0x1 * cP['xSize'] / cP['ySize'])));
                                  const cL = Math['max'](parseInt(cP['xSize'] / cQ), 0x1)
                                    , cR = Math['max'](parseInt(cP['ySize'] / cm), 0x1);
                                  cP['xDelta'] = cP['xDelta'] * cL,
                                  cP['yDelta'] = cP['yDelta'] * cR;
                                  const H0 = [];
                                  cQ = cm = 0x0;
                                  for (let H1 = 0x0; H1 < cP['ySize']; H1 += cR) {
                                      const H2 = H1 * cP['xSize'];
                                      cm++,
                                      cQ = 0x0;
                                      for (let H3 = 0x0; H3 < cP['xSize']; H3 += cL) {
                                          const H4 = 0x4 * (H2 + H3);
                                          H0['push'](cN[H4], cN[H4 + 0x1], cN[H4 + 0x2], cN[H4 + 0x3]),
                                          cQ++;
                                      }
                                  }
                                  cP['xSize'] = cQ,
                                  cP['ySize'] = cm,
                                  cP['xEnd'] = cP['yEnd'] = undefined,
                                  (0x0,
                                  KM['T'])(cP),
                                  cJ['gridOptions'] = cP,
                                  cN = new Uint8Array(H0);
                              }
                              const cM = document['createElement']('canvas');
                              cM['width'] = cJ['gridOptions']['xSize'],
                              cM['height'] = cJ['gridOptions']['ySize'];
                              const cz = new ImageData(new Uint8ClampedArray(cN),cM['width'],cM['height']);
                              return cM['getContext']('2d')['putImageData'](cz, 0x0, 0x0),
                              new GrayImageGridDataProvider(cM,cJ);
                          }
                      }
                  } else
                      (0x0,
                      KL['sU'])() || v0['kg']['warn']('IOS14');
                  const cC = new Blob([cd])
                    , cO = URL['createObjectURL'](cC);
                  return GrayImageGridDataProvider['fromURL'](cO, cq, cJ);
              });
          }
          static['fromURL'](cd, cq, cJ) {
              return KR(this, undefined, undefined, function*() {
                  if (cJ['withHeader']) {
                      const cO = yield(yield fetch(cd))['arrayBuffer']();
                      return GrayImageGridDataProvider['fromBuffer'](cO, cq, cJ);
                  }
                  let cC = this['loadImage'];
                  return cq && (cC = this['loadVideo']),
                  cC(cd)['then'](cG=>new GrayImageGridDataProvider(cG,cJ))['catch'](cG=>{}
                  );
              });
          }
      }
      function i1(cd) {
          return (cd = cd['replace'](/\/\/.*/g, ''))['replace'](/\/\*\*[\s\S]*?\*\//gm, function(cq) {
              for (var cJ = cq['match'](/\n/gm)['length'], cC = '', cO = 0x0; cO < cJ; ++cO)
                  cC += '\x0a';
              return cC;
          });
      }
      function i2(cd, cq, cJ) {
          for (var cC, cO = 0x0; cO < cJ['length']; ++cO)
              cJ[cO]['name'] === cd && (cC = cJ[cO]);
          return (0x0,
          Kz['ri'])(cC) || (cC = {
              'name': cd,
              'glslSource': cq = i1(cq),
              'dependsOn': [],
              'requiredBy': [],
              'evaluated': false
          },
          cJ['push'](cC)),
          cC;
      }
      function i3(cd, cq, cJ) {
          if (!cd['evaluated']) {
              cd['evaluated'] = true;
              var cC = cd['glslSource']['match'](/\bqe_[a-zA-Z0-9_]*/g);
              (0x0,
              Kz['ri'])(cC) && null !== cC && (cC = cC['filter'](function(cO, cG) {
                  return cC['indexOf'](cO) === cG;
              }))['forEach'](function(cO) {
                  if (cO !== cd['name'] && cJ['hasOwnProperty'](cO)) {
                      var cG = i2(cO, cJ[cO], cq);
                      cd['dependsOn']['push'](cG),
                      cG['requiredBy']['push'](cd),
                      i3(cG, cq, cJ);
                  }
              });
          }
      }
      function i4(cd, cq='main') {
          i1(cd);
          var cJ = []
            , cC = i2(cq, cd, cJ);
          i3(cC, cJ, ip),
          function(cg) {
              for (var cN = [], cP = []; cg['length'] > 0x0; ) {
                  var cM = cg['pop']();
                  cP['push'](cM),
                  0x0 === cM['requiredBy']['length'] && cN['push'](cM);
              }
              for (; cN['length'] > 0x0; ) {
                  var cz = cN['shift']();
                  cg['push'](cz);
                  for (var cQ = 0x0; cQ < cz['dependsOn']['length']; ++cQ) {
                      var cm = cz['dependsOn'][cQ]
                        , cL = cm['requiredBy']['indexOf'](cz);
                      cm['requiredBy']['splice'](cL, 0x1),
                      0x0 === cm['requiredBy']['length'] && cN['push'](cm);
                  }
              }
              for (var cR = [], H0 = 0x0; H0 < cP['length']; ++H0)
                  0x0 !== cP[H0]['requiredBy']['length'] && cR['push'](cP[H0]);
              if (0x0 !== cR['length']) {
                  for (var H1 = 'A\x20circular\x20dependency\x20was\x20found\x20in\x20the\x20following\x20built-in\x20functions/structs/constants:\x20\x0a', H2 = 0x0; H2 < cR['length']; ++H2)
                      H1 = H1 + cR[H2]['name'] + '\x0a';
                  throw new Error(H1);
              }
          }(cJ);
          for (var cO = '', cG = cJ['length'] - 0x1; cG >= 0x0; --cG)
              cO = cO + cJ[cG]['glslSource'] + '\x0a';
          return cO['replace'](cC['glslSource'], '');
      }
      function i5(cd, cq='$inject') {
          let cJ = cd;
          if (cd['indexOf']('qe_') >= 0x0) {
              const cC = i4(cd, 'main');
              cJ = cd['indexOf'](cq) >= 0x0 ? cd['replace'](cq, cC) : cd['replace'](/void\s+main\s*\(\s*\)\s*{/gm, function(cO, cG) {
                  return cC + '\x0a' + cO;
              });
          } else
              cJ = cd['replace'](cq, '');
          return cJ;
      }
      function i6(cd, cq=false) {
          let cJ = '';
          switch (cd['dataType'] === KP['U']['UInt8'] ? cJ += 'const\x20float\x20baseScaleH=255.;' : cJ += 'const\x20float\x20baseScaleH=1.;',
          cJ += cq ? '\x0a\x20\x20\x20\x20\x20\x20\x20\x20const\x20float\x20undefH=' + ik(undefined === cd['undef'] ? Kg['v']['defaultUndef'] : cd['undef']) + ';\x0a\x20\x20\x20\x20\x20\x20\x20\x20' : 'uniform\x20float\x20undefH;',
          cd['algo']) {
          case undefined:
          case null:
          case 0x0:
          case 0x1:
          case 0x2:
              cJ += '\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20dataOffsetH;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20dataScaleH;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20mediump\x20int\x20dataAlgoH;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20';
              break;
          default:
              v0['kg']['error']('', true);
          }
          return cd instanceof KN['K'] && (cd['dataType'] === KP['U']['UInt8'] ? cJ += '\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#define\x20IMAGE_SOURCE_H\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20' : cd['dataType'] === KP['U']['Float32'] ? cJ += '\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#define\x20IMAGE_SOURCE_FLOAT_H\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20' : cJ += '\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#define\x20IMAGE_SOURCE_USHORT_H\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20'),
          cJ;
      }
      function i7(cd, cq=false, cJ=true) {
          let cC = '';
          switch (cd['dataType'] === KP['U']['UInt8'] ? cC += 'const\x20float\x20baseScale=255.;' : cC += 'const\x20float\x20baseScale=1.;',
          cq && (cC += '\x0a\x20\x20\x20\x20\x20\x20\x20\x20const\x20float\x20undef=' + ik(undefined === cd['undef'] ? Kg['v']['defaultUndef'] : cd['undef']) + ';\x0a\x20\x20\x20\x20\x20\x20\x20\x20'),
          cd['algo']) {
          case undefined:
          case null:
          case 0x0:
          case 0x1:
          case 0x2:
              cC += '\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20dataOffset;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20dataScale;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20dataAlgo;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20';
              break;
          default:
              v0['kg']['error']('', true);
          }
          return cd instanceof KN['K'] && cJ && (cd['dataType'] === KP['U']['UInt8'] ? cC += '\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#define\x20IMAGE_SOURCE\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20' : cd['dataType'] === KP['U']['Float32'] ? cC += '\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#define\x20IMAGE_SOURCE_FLOAT\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20' : cC += '\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20#define\x20IMAGE_SOURCE_USHORT\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20'),
          cC;
      }
      function i8(cd, cq={}) {
          const cJ = (0x0,
          Kz['En'])(cd['undef'], 0xf423f);
          cq['undef'] = cJ;
          let cC = cd['algo'];
          switch ((null == cC || isNaN(cC)) && (cC = 0x0),
          cC = parseInt(cC['toString']()),
          cC) {
          case 0x0:
          case 0x1:
          case 0x2:
              cq['dataOffset'] = cd['dataOffset'],
              cq['dataScale'] = cd['dataScale'],
              cq['dataAlgo'] = cC;
          }
          return cq;
      }
      function i9(cd, cq={}) {
          const cJ = (0x0,
          Kz['En'])(cd['undef'], 0xf423f);
          cq['undefH'] = ()=>cJ;
          let cC = cd['algo'];
          switch ((null == cC || isNaN(cC)) && (cC = 0x0),
          cC = parseInt(cC['toString']()),
          cC) {
          case 0x0:
          case 0x1:
          case 0x2:
              cq['dataOffsetH'] = ()=>cd['dataOffset'],
              cq['dataScaleH'] = ()=>cd['dataScale'],
              cq['dataAlgoH'] = ()=>cC;
          }
          return cq;
      }
      function iv(cd, cq={}) {
          const cJ = (0x0,
          Kz['En'])(cd['undef'], 0xf423f);
          cq['undef'] = ()=>cJ;
          let cC = cd['algo'];
          switch ((null == cC || isNaN(cC)) && (cC = 0x0),
          cC = parseInt(cC['toString']()),
          cC) {
          case 0x0:
          case 0x1:
          case 0x2:
              cq['dataOffset'] = ()=>cd['dataOffset'],
              cq['dataScale'] = ()=>cd['dataScale'],
              cq['dataAlgo'] = ()=>cC;
          }
          return cq;
      }
      function iA() {
          return '\x0a\x20\x20\x20\x20uniform\x20float\x20currentHeight;\x0a\x20\x20\x20\x20uniform\x20float\x20preHeight;\x0a\x20\x20\x20\x20uniform\x20sampler2D\x20heightTexture;\x0a\x20\x20\x20\x20uniform\x20float\x20zScale;\x0a\x20\x20\x20\x20uniform\x20float\x20extrudeScale;\x0a\x20\x20\x20\x20uniform\x20float\x20extrudeOffset;\x0a\x20\x20\x20\x20uniform\x20bool\x20noHeight;\x0a\x20\x20\x20\x20';
      }
      function ik(cd) {
          return (cd = cd['toString'] && cd['toString']())['indexOf']('.') < 0x0 ? cd + '.' : cd;
      }
      function iK() {
          return '\x0a\x20\x20\x20\x20const\x20vec4\x20bitEnc\x20=\x20vec4(1.,255.,65025.,16581375.);\x0a\x20\x20\x20\x20const\x20vec4\x20bitDec\x20=\x201./bitEnc;\x0a\x20\x20\x20\x20';
      }
      function createGLTypedArray(cd, cq) {
          return cd === KP['U']['UInt8'] ? new Uint8Array(Uint8Array['BYTES_PER_ELEMENT'] * cq) : new Float32Array(Float32Array['BYTES_PER_ELEMENT'] * cq);
      }
      GrayImageGridDataProvider['qeName'] = 'g_gray';
      let ic = {
          'attrIn': 'in',
          'varIn': 'in',
          'varOut': 'out',
          'outColorDefine': 'out\x20vec4\x20qe_FragColor;',
          'outColorName': 'qe_FragColor',
          'textureFunc': 'texture',
          'header': '#version\x20300\x20es'
      };
      function iH() {
          Kg['v']['useWebGL2'] || (ic = {
              'attrIn': 'attribute',
              'varIn': 'varying',
              'varOut': 'varying',
              'outColorDefine': '',
              'outColorName': 'gl_FragColor',
              'textureFunc': 'texture2D',
              'header': ''
          });
      }
      function ix(cd, cq=0x3, cJ=0x1000) {
          if (cd['gridOptions']['xSize'] > cJ || cd['gridOptions']['ySize'] > cJ) {
              cd['gridOptions'] = Object['assign']({}, cd['gridOptions']);
              const cC = document['createElement']('canvas')
                , cO = cd['getGrid']()['imageSource'];
              cC['width'] = cO['width'] / cq,
              cC['height'] = cO['height'] / cq;
              const cG = {
                  'xStart': cd['gridOptions']['xStart'],
                  'xEnd': cd['gridOptions']['xEnd'],
                  'xSize': parseInt(cd['gridOptions']['xSize'] / cq),
                  'yStart': cd['gridOptions']['yStart'],
                  'yEnd': cd['gridOptions']['yEnd'],
                  'ySize': parseInt(cd['gridOptions']['ySize'] / cq)
              };
              return (0x0,
              KM['T'])(cG),
              cC['getContext']('2d')['drawImage'](cO, 0x0, 0x0, cO['width'], cO['height'], 0x0, 0x0, cC['width'], cC['height']),
              new GrayImageGridDataProvider(cC,Object['assign'](Object['assign']({}, cd['options']), {
                  'gridOptions': cG
              }));
          }
          return cd;
      }
      const ip = {};
      function iF(cd) {
          for (const cq in cd)
              ip[cq] && v0['kg']['warn']('shaderLibkey' + cq + '\x0a\x20' + cd[cq]),
              ip[cq] = cd[cq];
      }
      const iy = {
          'qe_getGridOneDimPos': 'qe_getGridOneDimPos',
          'qe_getLonLatTexPos': 'qe_getLonLatTexPos',
          'qe_isUndef': 'qe_isUndef',
          'qe_readGrid2DRawVal': 'qe_readGrid2DRawVal',
          'qe_readHeight2DRawVal': 'qe_readHeight2DRawVal',
          'qe_readGrid3DRawVal': 'qe_readGrid3DRawVal',
          'qe_readGridValByUV': 'qe_readGridValByUV',
          'qe_readHeightValByUV': 'qe_readHeightValByUV',
          'qe_readGridVal3DByUV': 'qe_readGridVal3DByUV',
          'qe_interpGridValByUV': 'qe_interpGridValByUV',
          'qe_interpGridVal3DByUV': 'qe_interpGridVal3DByUV',
          'qe_geo2cartesian': 'qe_geo2cartesian',
          'qe_deg2cartesian': 'qe_deg2cartesian',
          'qe_deg2cartesianV2': 'qe_deg2cartesianV2',
          'qe_cartesian2deg': 'qe_cartesian2deg',
          'qe_getColor': 'qe_getColor',
          'qe_interpColor': 'qe_interpColor',
          'qe_getColorByScale': 'qe_getColorByScale',
          'qe_getHeightByPreAndCurrent': 'qe_getHeightByPreAndCurrent',
          'qe_texture2DFloat': 'qe_texture2DFloat',
          'qe_idx2LonLat': 'qe_idx2LonLat',
          'qe_idx2LonLatTexPos': 'qe_idx2LonLatTexPos',
          'qe_rgba2float': 'qe_rgba2float',
          'qe_float2rgba': 'qe_float2rgba',
          'qe_maskout': 'qe_maskout',
          'qe_encodeFloat': 'qe_encodeFloat',
          'qe_geoDistance': 'qe_geoDistance',
          'qe_decodeFloat': 'qe_decodeFloat'
      };
      let iw = false;
      function ih() {
          iw || (ip[iy['qe_texture2DFloat']] = '\x0a\x20\x20\x20\x20float\x20qe_texture2DFloat(sampler2D\x20tex,vec2\x20uv){\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20' + (Kg['v']['useWebGL2'] ? 'texture2D(tex,uv).r' : 'texture2D(tex,uv).w') + ';\x0a\x20\x20\x20\x20}\x0a',
          ip[iy['qe_rgba2float']] = '\x0a\x20\x20\x20\x20float\x20qe_rgba2float\x20(vec4\x20v)\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20dot(v,\x20bitDec);\x0a\x20\x20\x20\x20}\x0a',
          ip[iy['qe_float2rgba']] = '\x0a\x20\x20\x20\x20vec4\x20qe_float2rgba(float\x20v){\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20enc\x20=\x20bitEnc\x20*\x20v;\x0a\x20\x20\x20\x20\x20\x20\x20\x20enc\x20=\x20fract(enc);\x0a\x20\x20\x20\x20\x20\x20\x20\x20enc\x20-=\x20enc.yzww\x20*\x20vec2(1./255.,\x200.).xxxy;\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20enc;\x0a\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x0a',
          ip[iy['qe_decodeFloat']] = '\x0a\x20\x20\x20\x20\x0a\x20\x20\x20\x20ivec4\x20decodeFloat_floatsToBytes(vec4\x20inputFloats,\x20bool\x20littleEndian)\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20ivec4\x20bytes\x20=\x20ivec4(inputFloats\x20*\x20255.0);\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20(\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20littleEndian\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20?\x20bytes.abgr\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20:\x20bytes\x0a\x20\x20\x20\x20\x20\x20\x20\x20);\x0a\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20//\x20Break\x20the\x20four\x20bytes\x20down\x20into\x20an\x20array\x20of\x2032\x20bits.\x0a\x20\x20\x20\x20\x20\x20void\x20decodeFloat_bytesToBits(const\x20in\x20ivec4\x20bytes,\x20out\x20bool\x20bits[32])\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20for\x20(int\x20channelIndex\x20=\x200;\x20channelIndex\x20<\x204;\x20++channelIndex)\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20acc\x20=\x20float(bytes[channelIndex]);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20for\x20(int\x20indexInByte\x20=\x207;\x20indexInByte\x20>=\x200;\x20--indexInByte)\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20powerOfTwo\x20=\x20exp2(float(indexInByte));\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20bool\x20bit\x20=\x20acc\x20>=\x20powerOfTwo;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20bits[channelIndex\x20*\x208\x20+\x20(7\x20-\x20indexInByte)]\x20=\x20bit;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20acc\x20=\x20mod(acc,\x20powerOfTwo);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20//\x20Compute\x20the\x20exponent\x20of\x20the\x2032-bit\x20float.\x0a\x20\x20\x20\x20\x20\x20float\x20getExponent(bool\x20bits[32])\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20const\x20int\x20startIndex\x20=\x201;\x0a\x20\x20\x20\x20\x20\x20\x20\x20const\x20int\x20bitStringLength\x20=\x208;\x0a\x20\x20\x20\x20\x20\x20\x20\x20const\x20int\x20endBeforeIndex\x20=\x20startIndex\x20+\x20bitStringLength;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20acc\x20=\x200.0;\x0a\x20\x20\x20\x20\x20\x20\x20\x20int\x20pow2\x20=\x20bitStringLength\x20-\x201;\x0a\x20\x20\x20\x20\x20\x20\x20\x20for\x20(int\x20bitIndex\x20=\x20startIndex;\x20bitIndex\x20<\x20endBeforeIndex;\x20++bitIndex)\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20acc\x20+=\x20float(bits[bitIndex])\x20*\x20exp2(float(pow2--));\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20acc;\x0a\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20//\x20Compute\x20the\x20mantissa\x20of\x20the\x2032-bit\x20float.\x0a\x20\x20\x20\x20\x20\x20float\x20decodeFloat_getMantissa(bool\x20bits[32],\x20bool\x20subnormal)\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20const\x20int\x20startIndex\x20=\x209;\x0a\x20\x20\x20\x20\x20\x20\x20\x20const\x20int\x20bitStringLength\x20=\x2023;\x0a\x20\x20\x20\x20\x20\x20\x20\x20const\x20int\x20endBeforeIndex\x20=\x20startIndex\x20+\x20bitStringLength;\x0a\x20\x20\x20\x20\x20\x20\x20\x20//\x20Leading/implicit/hidden\x20bit\x20convention:\x0a\x20\x20\x20\x20\x20\x20\x20\x20//\x20If\x20the\x20number\x20is\x20not\x20subnormal\x20(with\x20exponent\x200),\x20we\x20add\x20a\x20leading\x201\x20digit.\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20acc\x20=\x20float(!subnormal)\x20*\x20exp2(float(bitStringLength));\x0a\x20\x20\x20\x20\x20\x20\x20\x20int\x20pow2\x20=\x20bitStringLength\x20-\x201;\x0a\x20\x20\x20\x20\x20\x20\x20\x20for\x20(int\x20bitIndex\x20=\x20startIndex;\x20bitIndex\x20<\x20endBeforeIndex;\x20++bitIndex)\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20acc\x20+=\x20float(bits[bitIndex])\x20*\x20exp2(float(pow2--));\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20acc;\x0a\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20//\x20Parse\x20the\x20float\x20from\x20its\x2032\x20bits.\x0a\x20\x20\x20\x20\x20\x20float\x20decodeFloat_bitsToFloat(bool\x20bits[32])\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20signBit\x20=\x20float(bits[0])\x20*\x20-2.0\x20+\x201.0;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20exponent\x20=\x20getExponent(bits);\x0a\x20\x20\x20\x20\x20\x20\x20\x20bool\x20subnormal\x20=\x20abs(exponent\x20-\x200.0)\x20<\x200.01;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20mantissa\x20=\x20decodeFloat_getMantissa(bits,\x20subnormal);\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20exponentBias\x20=\x20127.0;\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20signBit\x20*\x20mantissa\x20*\x20exp2(exponent\x20-\x20exponentBias\x20-\x2023.0);\x0a\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20//\x20Decode\x20a\x2032-bit\x20float\x20from\x20the\x20RGBA\x20color\x20channels\x20of\x20a\x20texel.\x0a\x20\x20\x20\x20\x20\x20float\x20qe_decodeFloat(vec4\x20texelRGBA,\x20bool\x20littleEndian)\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20ivec4\x20rgbaBytes\x20=\x20decodeFloat_floatsToBytes(texelRGBA,\x20littleEndian);\x0a\x20\x20\x20\x20\x20\x20\x20\x20bool\x20bits[32];\x0a\x20\x20\x20\x20\x20\x20\x20\x20decodeFloat_bytesToBits(rgbaBytes,\x20bits);\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20decodeFloat_bitsToFloat(bits);\x0a\x20\x20\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20',
          function() {
              const cd = ik(0x615299)
                , cq = 57.29577951308232;
              ip[iy['qe_geoDistance']] = '\x0a\x20\x20\x20\x20float\x20qe_geoDistance(vec2\x20pt1,vec2\x20pt2){\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20' + ik(cd) + '*acos(cos(pt1.y)*cos(pt2.y)*cos(pt1.x-pt2.x)+sin(pt1.y)*sin(pt2.y));\x0a\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20',
              ip[iy['qe_geo2cartesian']] = '\x0a\x20\x20\x20\x20vec3\x20' + iy['qe_geo2cartesian'] + '(vec3\x20geo){\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20cosLat=cos(geo.y);\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20snX=cosLat*cos(geo.x);\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20snY=cosLat*sin(geo.x);\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20snZ=sin(geo.y);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20sn=normalize(vec3(snX,snY,snZ));\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20radiiSquared=vec3(40680631.59076899*1000000.,40680631.59076899*1000000.,40408299.98466144*1000000.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20sk=radiiSquared*sn;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20gamma=sqrt(dot(sn,sk));\x0a\x20\x20\x20\x20\x20\x20\x20\x20sk=sk/gamma;\x0a\x20\x20\x20\x20\x20\x20\x20\x20sn=sn*geo.z;\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20sk+sn;\x0a\x20\x20\x20\x20}\x0a',
              ip[iy['qe_deg2cartesian']] = '\x0a\x20\x20\x20\x20vec3\x20' + iy['qe_deg2cartesian'] + '(vec3\x20deg){\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20radGeo=radians(deg.xy);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20geo=vec3(radGeo.xy,deg.z);\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20' + iy['qe_geo2cartesian'] + '(geo);\x0a\x20\x20\x20\x20}\x0a',
              ip[iy['qe_deg2cartesianV2']] = '\x0a\x20\x20\x20\x20vec3\x20' + iy['qe_deg2cartesianV2'] + '(vec3\x20pos){\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20g\x20=\x20' + cd + '\x20+pos.z;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20e\x20=\x20radians(pos.y);\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20b\x20=radians(pos.x);\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20a\x20=\x20cos(e);\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20x\x20=\x20cos(b)*a*g;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20y\x20=\x20sin(b)*a*g;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20z\x20=\x20sin(e)*g;\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec3(x,y,z);\x0a\x20\x20\x20\x20}\x0a',
              ip[iy['qe_cartesian2deg']] = '\x0a\x20\x20\x20\x20vec3\x20' + iy['qe_cartesian2deg'] + '(vec3\x20pos,bool\x20global)\x0a\x20\x20\x20\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(global){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20z\x20=\x20length(pos);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20h\x20=\x20z\x20-\x20' + cd + ';\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20latRad\x20=\x20asin(pos.z/z);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20lat\x20=\x20latRad\x20*\x20' + cq + ';\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20lon\x20=\x200.;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(pos.y>0.){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20lon\x20=\x20acos(pos.x/(cos(latRad)*z))\x20*\x20' + cq + ';\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20lon\x20=\x20-acos(pos.x/(cos(latRad)*z))\x20*\x20' + cq + ';\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec3(lon,lat,h);\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20}else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20lon=degrees(pos.x/' + cd + ');\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20lat=degrees(3.141592653589793/2.-2.*atan(exp(-1.*pos.y/' + cd + ')));\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec3(lon,lat,pos.z);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20}\x0a';
          }(),
          function() {
              ip[iy['qe_getGridOneDimPos']] = '\x0a\x20\x20\x20\x20float\x20' + iy['qe_getGridOneDimPos'] + '(float\x20pos,vec4\x20attr){\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20(pos-attr.x)/(attr.y-attr.x+attr.z);\x0a\x20\x20\x20\x20}\x0a',
              ip[iy['qe_getLonLatTexPos']] = '\x0a\x20\x20\x20\x20vec2\x20' + iy['qe_getLonLatTexPos'] + '(vec2\x20pos,vec4\x20xAttr,vec4\x20yAttr){\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20xPos=' + iy['qe_getGridOneDimPos'] + '(pos.x,xAttr);\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20yPos=' + iy['qe_getGridOneDimPos'] + '(pos.y,yAttr);\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(xPos,yPos);\x0a\x20\x20\x20\x20}\x0a',
              ip[iy['qe_isUndef']] = '\x0a\x20\x20\x20\x20bool\x20' + iy['qe_isUndef'] + '(float\x20val,float\x20undef){\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(undef<=0.){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20val<=undef;\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20val>=undef;\x0a\x20\x20\x20\x20}\x0a';
              let cd = '\x0a\x20\x20\x20\x20#ifdef\x20IMAGE_SOURCE\x0a\x20\x20\x20\x20\x20\x20\x20\x20val=texture2D(grid,uv).r*baseScale;\x0a\x20\x20\x20\x20#elif\x20defined(IMAGE_SOURCE_FLOAT)\x0a\x20\x20\x20\x20\x20\x20\x20\x20val=' + iy['qe_decodeFloat'] + '(texture2D(grid,uv),true);\x0a\x20\x20\x20\x20#elif\x20defined(IMAGE_SOURCE_USHORT)\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20r_c=texture2D(grid,uv);\x0a\x20\x20\x20\x20\x20\x20\x20\x20val=r_c.r*255.*255.+r_c.g*255.;\x0a\x20\x20\x20\x20#else\x0a\x20\x20\x20\x20\x20\x20\x20\x20val=texture2D(grid,uv).w*baseScale;\x0a\x20\x20\x20\x20#endif\x0a\x20\x20\x20\x20';
              Kg['v']['useWebGL2'] && (cd = '\x0a\x20\x20\x20\x20if(baseScale!=1.){\x0a\x20\x20\x20\x20\x20\x20\x20\x20//uint8\x0a\x20\x20\x20\x20\x20\x20\x20\x20#ifdef\x20IMAGE_SOURCE\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val=texture(grid,uv).r*baseScale;\x0a\x20\x20\x20\x20\x20\x20\x20\x20#else\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val=texture(grid,uv).w*baseScale;\x0a\x20\x20\x20\x20\x20\x20\x20\x20#endif\x0a\x20\x20\x20\x20}else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20#ifdef\x20IMAGE_SOURCE_FLOAT\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val=' + iy['qe_decodeFloat'] + '(texture(grid,uv),true);\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20#elif\x20defined(IMAGE_SOURCE_USHORT)\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20r_c=texture(grid,uv);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val=r_c.r*255.*255.+r_c.g*255.;\x0a\x20\x20\x20\x20\x20\x20\x20\x20#else\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val=texture(grid,uv).r;\x0a\x20\x20\x20\x20\x20\x20\x20\x20#endif\x0a\x20\x20\x20\x20}\x0a\x20\x20\x20\x20');
              let cq = '\x0a\x20\x20\x20\x20#ifdef\x20IMAGE_SOURCE_H\x0a\x20\x20\x20\x20\x20\x20\x20\x20val=texture2D(grid,uv).r*baseScaleH;\x0a\x20\x20\x20\x20#elif\x20defined(IMAGE_SOURCE_FLOAT_H)\x0a\x20\x20\x20\x20\x20\x20\x20\x20val=' + iy['qe_decodeFloat'] + '(texture2D(grid,uv),true);\x0a\x20\x20\x20\x20#elif\x20defined(IMAGE_SOURCE_USHORT_H)\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20r_c=texture2D(grid,uv);\x0a\x20\x20\x20\x20\x20\x20\x20\x20val=r_c.r*255.*255.+r_c.g*255.;\x0a\x20\x20\x20\x20#else\x0a\x20\x20\x20\x20\x20\x20\x20\x20val=texture2D(grid,uv).w*baseScaleH;\x0a\x20\x20\x20\x20#endif\x0a\x20\x20\x20\x20';
              Kg['v']['useWebGL2'] && (cq = '\x0a\x20\x20\x20\x20if(baseScaleH!=1.){\x0a\x20\x20\x20\x20\x20\x20\x20\x20//uint8\x0a\x20\x20\x20\x20\x20\x20\x20\x20#ifdef\x20IMAGE_SOURCE_H\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val=texture(grid,uv).r*baseScaleH;\x0a\x20\x20\x20\x20\x20\x20\x20\x20#else\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val=texture(grid,uv).w*baseScaleH;\x0a\x20\x20\x20\x20\x20\x20\x20\x20#endif\x0a\x20\x20\x20\x20}else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20#ifdef\x20IMAGE_SOURCE_FLOAT_H\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val=' + iy['qe_decodeFloat'] + '(texture(grid,uv),true);\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20#elif\x20defined(IMAGE_SOURCE_USHORT_H)\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20r_c=texture(grid,uv);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val=r_c.r*255.*255.+r_c.g*255.;\x0a\x20\x20\x20\x20\x20\x20\x20\x20#else\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val=texture(grid,uv).r;\x0a\x20\x20\x20\x20\x20\x20\x20\x20#endif\x0a\x20\x20\x20\x20}\x0a\x20\x20\x20\x20');
              let cJ = '\x0a\x20\x20\x20\x20#ifdef\x20IMAGE_SOURCE\x0a\x20\x20\x20\x20\x20\x20\x20\x20val=texture2D(grid,p).r*baseScale;\x0a\x20\x20\x20\x20#elif\x20defined(IMAGE_SOURCE_FLOAT)\x0a\x20\x20\x20\x20\x20\x20\x20\x20val=' + iy['qe_decodeFloat'] + '(texture2D(grid,p),true);\x0a\x20\x20\x20\x20#elif\x20defined(IMAGE_SOURCE_USHORT)\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20r_c=texture2D(grid,p);\x0a\x20\x20\x20\x20\x20\x20\x20\x20val=r_c.r*255.*255.+r_c.g*255.;\x0a\x20\x20\x20\x20#else\x0a\x20\x20\x20\x20\x20\x20\x20\x20val=texture2D(grid,p).w*baseScale;\x0a\x20\x20\x20\x20#endif\x0a\x20\x20\x20\x20\x0a\x20\x20\x20\x20';
              Kg['v']['useWebGL2'] && (cJ = '\x0a\x20\x20\x20\x20if(baseScale!=1.){\x0a\x20\x20\x20\x20\x20\x20\x20\x20//uint8\x0a\x20\x20\x20\x20\x20\x20\x20\x20#ifdef\x20IMAGE_SOURCE\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val=texture(grid,p).r*baseScale;\x0a\x20\x20\x20\x20\x20\x20\x20\x20#else\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val=texture(grid,p).w*baseScale;\x0a\x20\x20\x20\x20\x20\x20\x20\x20#endif\x0a\x20\x20\x20\x20}else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20#ifdef\x20IMAGE_SOURCE_FLOAT\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val=' + iy['qe_decodeFloat'] + '(texture(grid,p),true);\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20#elif\x20defined(IMAGE_SOURCE_USHORT)\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20r_c=texture(grid,p);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val=r_c.r*255.*255.+r_c.g*255.;\x0a\x20\x20\x20\x20\x20\x20\x20\x20#else\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val=texture(grid,p).r;\x0a\x20\x20\x20\x20\x20\x20\x20\x20#endif\x0a\x20\x20\x20\x20}\x0a\x20\x20\x20\x20'),
              ip[iy['qe_readHeight2DRawVal']] = '\x0a\x20\x20\x20\x20float\x20' + iy['qe_readHeight2DRawVal'] + '(sampler2D\x20grid,vec2\x20uv,float\x20undefH){\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20val;\x0a\x20\x20\x20\x20\x20\x20\x20\x20' + cq + '\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(val,undefH)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20undefH;\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(dataAlgoH==2){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val\x20=\x20(val+dataOffsetH)*dataScaleH;\x0a\x20\x20\x20\x20\x20\x20\x20\x20}else{\x20//current\x200\x201\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val\x20=\x20val*dataScaleH+dataOffsetH;\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20val;\x0a\x20\x20\x20\x20}\x0a',
              ip[iy['qe_readHeightValByUV']] = '\x0a\x0avec2\x20' + iy['qe_readHeightValByUV'] + '(sampler2D\x20grid,vec2\x20uv,vec4\x20xAttr,vec4\x20yAttr,float\x20undefH,int\x20interpMethod){\x0a\x20\x20\x20\x20float\x20rawVal=\x20' + iy['qe_readHeight2DRawVal'] + '(grid,uv,undefH);\x0a\x20\x20\x20\x20if(interpMethod==0\x20||\x20' + iy['qe_isUndef'] + '(rawVal,undefH)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal);\x0a\x20\x20\x20\x20}\x0a\x20\x20\x20\x20vec2\x20dataSize=vec2(xAttr.w,yAttr.w);\x0a\x20\x20\x20\x20vec2\x20pos=uv*dataSize;\x0a\x20\x20\x20\x20vec2\x20prePos\x20=\x20floor(pos);\x20//i,j\x20p22\x0a\x20\x20\x20\x20vec2\x20nextPos\x20=\x20ceil(pos);\x20//i+1,j+1\x20p33\x0a\x20\x20\x20\x20vec2\x20preUv\x20=\x20prePos\x20/dataSize;\x0a\x20\x20\x20\x20vec2\x20nextUv\x20=\x20nextPos\x20/dataSize;\x0a\x20\x20\x20\x20//weight\x0a\x20\x20\x20\x20vec2\x20weight\x20=\x20fract(pos);\x0a\x20\x20\x20\x20vec2\x20lbUv\x20=\x20preUv;\x0a\x20\x20\x20\x20vec2\x20ltUv\x20=\x20vec2(preUv.x,nextUv.y);\x0a\x20\x20\x20\x20vec2\x20rbUv\x20=\x20vec2(nextUv.x,preUv.y);\x0a\x20\x20\x20\x20vec2\x20rtUv\x20=\x20nextUv;\x0a\x20\x20\x20\x20float\x20lbVal\x20=\x20' + iy['qe_readHeight2DRawVal'] + '(grid,lbUv,undefH);\x20//p(i,j)\x20p22\x0a\x20\x20\x20\x20float\x20ltVal\x20=\x20' + iy['qe_readHeight2DRawVal'] + '(grid,ltUv,undefH);\x20//p(i,j+1)\x20p23\x0a\x20\x20\x20\x20float\x20rbVal\x20=\x20' + iy['qe_readHeight2DRawVal'] + '(grid,rbUv,undefH);\x20//p(i+1,j)\x20p32\x0a\x20\x20\x20\x20float\x20rtVal\x20=\x20' + iy['qe_readHeight2DRawVal'] + '(grid,rtUv,undefH);\x20//p(i+1,j+1)\x20p33\x0a\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(lbVal,undefH)\x20||\x20' + iy['qe_isUndef'] + '(ltVal,undefH)\x20||\x20' + iy['qe_isUndef'] + '(rbVal,undefH)\x20||\x20' + iy['qe_isUndef'] + '(rtVal,undefH)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal);\x0a\x20\x20\x20\x20}\x0a\x20\x20\x20\x20float\x20upVal=\x20ltVal\x20*\x20(1.-weight.x)\x20+\x20rtVal\x20*\x20weight.x;\x0a\x20\x20\x20\x20float\x20downVal\x20=\x20lbVal\x20*\x20(1.-weight.x)\x20+\x20rbVal\x20*\x20weight.x;\x0a\x20\x20\x20\x20float\x20interpVal=\x20downVal\x20*\x20(1.-weight.y)\x20+\x20upVal\x20*\x20weight.y;\x0a\x20\x20\x20\x20return\x20vec2(rawVal,interpVal);\x0a}\x0a',
              ip[iy['qe_readGrid2DRawVal']] = '\x0a\x20\x20\x20\x20float\x20' + iy['qe_readGrid2DRawVal'] + '(sampler2D\x20grid,vec2\x20uv,float\x20undef){\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20val;\x0a\x20\x20\x20\x20\x20\x20\x20\x20' + cd + '\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(val,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20undef;\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(dataAlgo==2.0){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val\x20=\x20(val+dataOffset)*dataScale;\x0a\x20\x20\x20\x20\x20\x20\x20\x20}else{\x20//current\x200\x201\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val\x20=\x20val*dataScale+dataOffset;\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20val;\x0a\x20\x20\x20\x20}\x0a',
              ip[iy['qe_readGrid3DRawVal']] = '\x0a\x20\x20\x20\x20float\x20' + iy['qe_readGrid3DRawVal'] + '(highp\x20sampler3D\x20grid,vec3\x20p,float\x20undef){\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20val;\x0a\x20\x20\x20\x20\x20\x20\x20\x20' + cJ + '\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(val,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20undef;\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(dataAlgo==2.0){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val\x20=\x20(val+dataOffset)*dataScale;\x0a\x20\x20\x20\x20\x20\x20\x20\x20}else{\x20//current\x200\x201\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val\x20=\x20val*dataScale+dataOffset;\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20val;\x0a\x20\x20\x20\x20}\x0a',
              ip[iy['qe_interpGridValByUV']] = '\x0a\x20\x20\x20\x20vec2\x20' + iy['qe_interpGridValByUV'] + '(sampler2D\x20grid,vec2\x20uv,vec4\x20xAttr,vec4\x20yAttr,float\x20undef,int\x20interpMethod,sampler2D\x20nextGrid,float\x20percent){\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20val=' + iy['qe_readGridValByUV'] + '(grid,uv,xAttr,yAttr,undef,interpMethod);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20nextVal=' + iy['qe_readGridValByUV'] + '(nextGrid,uv,xAttr,yAttr,undef,interpMethod);\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(val.y,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(percent<=0.5){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20val;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20nextVal;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20return\x20val;\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(nextVal.y,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(percent>0.5){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20nextVal;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20val;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20return\x20val;\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20mix(val,nextVal,percent);\x0a\x20\x20\x20\x20}\x0a',
              ip[iy['qe_interpGridVal3DByUV']] = '\x0a\x20\x20\x20\x20vec2\x20' + iy['qe_interpGridVal3DByUV'] + '(highp\x20sampler3D\x20grid,vec3\x20p,vec4\x20xAttr,vec4\x20yAttr,vec3\x20zAttr,float\x20undef,int\x20interpMethod,highp\x20sampler3D\x20nextGrid,float\x20percent){\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20val=' + iy['qe_readGridVal3DByUV'] + '(grid,p,xAttr,yAttr,zAttr,undef,interpMethod);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20nextVal=' + iy['qe_readGridVal3DByUV'] + '(nextGrid,p,xAttr,yAttr,zAttr,undef,interpMethod);\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(val.y,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(percent<=0.5){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20val;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20nextVal;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(nextVal.y,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(percent>0.5){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20nextVal;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20val;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20mix(val,nextVal,percent);\x0a\x20\x20\x20\x20}\x0a',
              ip[iy['qe_readGridValByUV']] = '\x0a\x20\x20\x20\x20float\x20cardinalSpline(vec4\x20colVal,vec4\x20uvec){\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20dot(uvec,cardinalSplineMat*colVal);\x0a\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20vec2\x20' + iy['qe_readGridValByUV'] + '(sampler2D\x20grid,vec2\x20uv,vec4\x20xAttr,vec4\x20yAttr,float\x20undef,int\x20interpMethod){\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20rawVal=\x20' + iy['qe_readGrid2DRawVal'] + '(grid,uv,undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(interpMethod==0\x20||\x20' + iy['qe_isUndef'] + '(rawVal,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20dataSize=vec2(xAttr.w,yAttr.w);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20pos=uv*dataSize;\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20prePos\x20=\x20floor(pos);\x20//i,j\x20p22\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20nextPos\x20=\x20ceil(pos);\x20//i+1,j+1\x20p33\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20preUv\x20=\x20prePos\x20/dataSize;\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20nextUv\x20=\x20nextPos\x20/dataSize;\x0a\x20\x20\x20\x20\x20\x20\x20\x20//weight\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20weight\x20=\x20fract(pos);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20lbUv\x20=\x20preUv;\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20ltUv\x20=\x20vec2(preUv.x,nextUv.y);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20rbUv\x20=\x20vec2(nextUv.x,preUv.y);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20rtUv\x20=\x20nextUv;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20lbVal\x20=\x20' + iy['qe_readGrid2DRawVal'] + '(grid,lbUv,undef);\x20//p(i,j)\x20p22\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20ltVal\x20=\x20' + iy['qe_readGrid2DRawVal'] + '(grid,ltUv,undef);\x20//p(i,j+1)\x20p23\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20rbVal\x20=\x20' + iy['qe_readGrid2DRawVal'] + '(grid,rbUv,undef);\x20//p(i+1,j)\x20p32\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20rtVal\x20=\x20' + iy['qe_readGrid2DRawVal'] + '(grid,rtUv,undef);\x20//p(i+1,j+1)\x20p33\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(lbVal,undef)\x20||\x20' + iy['qe_isUndef'] + '(ltVal,undef)\x20||\x20' + iy['qe_isUndef'] + '(rbVal,undef)\x20||\x20' + iy['qe_isUndef'] + '(rtVal,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20upVal=\x20ltVal\x20*\x20(1.-weight.x)\x20+\x20rtVal\x20*\x20weight.x;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20downVal\x20=\x20lbVal\x20*\x20(1.-weight.x)\x20+\x20rbVal\x20*\x20weight.x;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20interpVal=\x20downVal\x20*\x20(1.-weight.y)\x20+\x20upVal\x20*\x20weight.y;\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(interpMethod==1){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal,interpVal);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20xWeight=vec4(weight.x*weight.x*weight.x,weight.x*weight.x,weight.x,1.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20yWeight=vec4(weight.y*weight.y*weight.y,weight.y*weight.y,weight.y,1.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20//use\x20Cardinal\x20spline\x0a\x20\x20\x20\x20\x20\x20\x20\x20//col1->p(i-1,j-1)\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20p11=prePos+vec2(-1.,-1.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20uv11=p11/dataSize;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20v11=' + iy['qe_readGrid2DRawVal'] + '(grid,uv11,undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(v11,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20//p(i-1,j)\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20p12=prePos+vec2(-1.,0.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20uv12=p12/dataSize;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20v12=' + iy['qe_readGrid2DRawVal'] + '(grid,uv12,undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(v12,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20//p(i-1,j+1)\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20p13=prePos+vec2(-1.,1.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20uv13=p13/dataSize;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20v13=' + iy['qe_readGrid2DRawVal'] + '(grid,uv13,undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(v13,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20//p(i-1,j+2)\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20p14=prePos+vec2(-1.,2.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20uv14=p14/dataSize;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20v14=' + iy['qe_readGrid2DRawVal'] + '(grid,uv14,undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(v14,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20col1Val=cardinalSpline(vec4(v11,v12,v13,v14),yWeight);\x0a\x20\x20\x20\x20\x20\x20\x20\x20//col2->p(i,j-1)\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20p21=prePos+vec2(0.,-1.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20uv21=p21/dataSize;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20v21=' + iy['qe_readGrid2DRawVal'] + '(grid,uv21,undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(v21,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20//p(i,j)\x20p22\x20exist\x0a\x20\x20\x20\x20\x20\x20\x20\x20//p(i,j+1)\x20p23\x20exist\x0a\x20\x20\x20\x20\x20\x20\x20\x20//p(i,j+2)\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20p24=prePos+vec2(0.,2.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20uv24=p24/dataSize;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20v24=' + iy['qe_readGrid2DRawVal'] + '(grid,uv24,undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(v24,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20col2Val=cardinalSpline(vec4(v21,lbVal,ltVal,v24),yWeight);\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20//col3->p(i+1,j-1)\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20p31=prePos+vec2(1.,-1.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20uv31=p31/dataSize;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20v31=' + iy['qe_readGrid2DRawVal'] + '(grid,uv31,undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(v31,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20//p(i+1,j)\x20p32\x20exist\x0a\x20\x20\x20\x20\x20\x20\x20\x20//p(i+1,j+1)\x20p33\x20exist\x0a\x20\x20\x20\x20\x20\x20\x20\x20//p(i+1,j+2)\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20p34=prePos+vec2(1.,2.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20uv34=p34/dataSize;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20v34=' + iy['qe_readGrid2DRawVal'] + '(grid,uv34,undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(v34,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20col3Val=cardinalSpline(vec4(v31,rbVal,rtVal,v34),yWeight);\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20//col4->p(i+2,j-1)\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20p41=prePos+vec2(2.,-1.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20uv41=p41/dataSize;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20v41=' + iy['qe_readGrid2DRawVal'] + '(grid,uv41,undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(v41,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20//p(i+2,j)\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20p42=prePos+vec2(2.,0.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20uv42=p42/dataSize;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20v42=' + iy['qe_readGrid2DRawVal'] + '(grid,uv42,undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(v42,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20//p(i+2,j+1)\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20p43=prePos+vec2(2.,1.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20uv43=p43/dataSize;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20v43=' + iy['qe_readGrid2DRawVal'] + '(grid,uv43,undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(v43,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20//p(i+2,j+2)\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20p44=prePos+vec2(2.,2.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20uv44=p44/dataSize;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20v44=' + iy['qe_readGrid2DRawVal'] + '(grid,uv44,undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(v44,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20col4Val=cardinalSpline(vec4(v41,v42,v43,v44),yWeight);\x0a\x20\x20\x20\x20\x20\x20\x20\x20//calc\x20row\x20val\x0a\x20\x20\x20\x20\x20\x20\x20\x20interpVal=cardinalSpline(vec4(col1Val,col2Val,col3Val,col4Val),xWeight);\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal,interpVal);\x0a\x20\x20\x20\x20}\x0a',
              ip[iy['qe_readGridVal3DByUV']] = '\x0a\x0a\x20\x20\x20\x20float\x20readPlaneGridVal(highp\x20sampler3D\x20grid,vec2\x20preUv,vec2\x20nextUv,float\x20z,vec2\x20weight,float\x20undef){\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20lbUv\x20=\x20vec3(preUv,z);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20ltUv\x20=\x20vec3(preUv.x,nextUv.y,z);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20rbUv\x20=\x20vec3(nextUv.x,preUv.y,z);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20rtUv\x20=\x20vec3(nextUv,z);\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20lbVal\x20=\x20' + iy['qe_readGrid3DRawVal'] + '(grid,lbUv,undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20ltVal\x20=\x20' + iy['qe_readGrid3DRawVal'] + '(grid,ltUv,undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20rbVal\x20=\x20' + iy['qe_readGrid3DRawVal'] + '(grid,rbUv,undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20rtVal\x20=\x20' + iy['qe_readGrid3DRawVal'] + '(grid,rtUv,undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(lbVal,undef)\x20||\x20' + iy['qe_isUndef'] + '(ltVal,undef)\x20||' + iy['qe_isUndef'] + '(rbVal,undef)\x20||' + iy['qe_isUndef'] + '(rtVal,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20undef;\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20upVal=\x20ltVal\x20*\x20(1.-weight.x)\x20+\x20rtVal\x20*\x20weight.x;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20downVal\x20=\x20lbVal\x20*\x20(1.-weight.x)\x20+\x20rbVal\x20*\x20weight.x;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20interpVal=\x20downVal\x20*\x20(1.-weight.y)\x20+\x20upVal\x20*\x20weight.y;\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20interpVal;\x0a\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20vec2\x20' + iy['qe_readGridVal3DByUV'] + '(highp\x20sampler3D\x20grid,vec3\x20uv,vec4\x20xAttr,vec4\x20yAttr,vec3\x20zAttr,float\x20undef,int\x20interpMethod){\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20rawVal=\x20' + iy['qe_readGrid3DRawVal'] + '(grid,uv,undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(interpMethod==0\x20||\x20' + iy['qe_isUndef'] + '(rawVal,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20dataSize=vec3(xAttr.w,yAttr.w,zAttr.z);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20pos=uv*dataSize;\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20prePos\x20=\x20floor(pos);\x20//i,j\x20p22\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20nextPos\x20=\x20ceil(pos);\x20//i+1,j+1\x20p33\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20preUv\x20=\x20prePos\x20/dataSize;\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20nextUv\x20=\x20nextPos\x20/dataSize;\x0a\x20\x20\x20\x20\x20\x20\x20\x20//weight\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20weight\x20=\x20fract(pos);\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20downVal=readPlaneGridVal(grid,preUv.xy,nextUv.xy,preUv.z,weight.xy,undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(downVal,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal,rawVal);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20upVal=readPlaneGridVal(grid,preUv.xy,nextUv.xy,nextUv.z,weight.xy,undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(upVal,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal,rawVal);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(rawVal,mix(downVal,upVal,weight.z));\x0a\x20\x20\x20\x20}\x0a',
              ip[iy['qe_getColor']] = '\x0a\x20\x20\x20\x20vec4\x20qe_getColor(float\x20val){\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(val,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec4(0.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20col;\x0a\x20\x20\x20\x20\x20\x20\x20\x20for(int\x20i=0;i<stepCount;i++){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20col=colors[i];\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(val<=steps[i]){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20break;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20col;\x0a\x20\x20\x20\x20}\x0a',
              ip[iy['qe_interpColor']] = '\x0a\x20\x20\x20\x20vec4\x20qe_interpColor(float\x20val){\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(val,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec4(0.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20weight=0.;\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20col;\x0a\x20\x20\x20\x20\x20\x20\x20\x20for(int\x20i=0;i<stepCount;i++){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20col=colors[i];\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(val<=steps[i]){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(i==0||(i==stepCount-1)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20break;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20weight=(val-steps[i-1])/(steps[i]-steps[i-1]);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20colorPre=colors[i-1];\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20colorCur=colors[i];\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20col\x20=\x20mix(colorPre,colorCur,weight);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20break;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20col;\x0a\x20\x20\x20\x20}\x0a',
              ip[iy['qe_getHeightByPreAndCurrent']] = '\x0a\x20\x20\x20\x20float\x20qe_getHeightByPreAndCurrent(vec2\x20uv,bool\x20useTexture,float\x20percent){\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20height=0.;\x0a\x20\x20\x20\x20\x20\x20\x20\x20//\x20if(useTexture){\x0a\x20\x20\x20\x20\x20\x20\x20\x20//\x20\x20\x20\x20\x20height=' + iy['qe_texture2DFloat'] + '(heightTexture,uv);\x0a\x20\x20\x20\x20\x20\x20\x20\x20//\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20height=height+mix(preHeight,currentHeight,percent);\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20height*zScale;\x0a\x20\x20\x20\x20}\x0a',
              ip[iy['qe_idx2LonLat']] = '\x0a\x20\x20\x20\x20vec2\x20qe_idx2LonLat(float\x20idx,vec4\x20xAttr,vec4\x20yAttr){\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20rowIdx=floor(idx/xAttr.w);\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20colIdx=mod(idx,xAttr.w);\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20lon=xAttr.x+colIdx*xAttr.z;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20lat=yAttr.x+rowIdx*yAttr.z;\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(lon,lat);\x0a\x20\x20\x20\x20}\x0a',
              ip[iy['qe_idx2LonLatTexPos']] = '\x0a\x20\x20\x20\x20vec2\x20qe_idx2LonLatTexPos(float\x20idx,float\x20xSize,float\x20ySize){\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20pos1d=idx\x20/\x20xSize;\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec2(\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20fract(pos1d),\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20floor(pos1d)/ySize\x0a\x20\x20\x20\x20\x20\x20\x20\x20);\x0a\x20\x20\x20\x20}\x0a',
              ip[iy['qe_maskout']] = '\x0a\x20\x20\x20\x20bool\x20qe_maskout(vec2\x20reso,sampler2D\x20maskTexture){\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20sUv=gl_FragCoord.xy/reso;\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20maskInfo=' + ic['textureFunc'] + '(maskTexture,vec2(sUv.x,sUv.y));\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(maskInfo.a<0.1){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20false;\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20true;\x0a\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20',
              ip[iy['qe_encodeFloat']] = '\x0a\x20\x20\x20\x20float\x20encodeFloat_shift_right\x20(float\x20v,\x20float\x20amt)\x20{\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20v\x20=\x20floor(v)\x20+\x200.5;\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20floor(v\x20/\x20exp2(amt));\x20\x0a\x20\x20\x20\x20}\x0a\x20\x20\x20\x20float\x20encodeFloat_shift_left\x20(float\x20v,\x20float\x20amt)\x20{\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20floor(v\x20*\x20exp2(amt)\x20+\x200.5);\x20\x0a\x20\x20\x20\x20}\x0a\x20\x20\x20\x20float\x20encodeFloat_mask_last\x20(float\x20v,\x20float\x20bits)\x20{\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20mod(v,\x20encodeFloat_shift_left(1.0,\x20bits));\x20\x0a\x20\x20\x20\x20}\x0a\x20\x20\x20\x20float\x20encodeFloat_extract_bits\x20(float\x20num,\x20float\x20from,\x20float\x20to)\x20{\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20from\x20=\x20floor(from\x20+\x200.5);\x20to\x20=\x20floor(to\x20+\x200.5);\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20encodeFloat_mask_last(encodeFloat_shift_right(num,\x20from),\x20to\x20-\x20from);\x20\x0a\x20\x20\x20\x20}\x0a\x20\x20\x20\x20vec4\x20qe_encodeFloat\x20(float\x20val)\x20{\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20if\x20(val\x20==\x200.0)\x20return\x20vec4(0,\x200,\x200,\x200);\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20sign\x20=\x20val\x20>\x200.0\x20?\x200.0\x20:\x201.0;\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20val\x20=\x20abs(val);\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20exponent\x20=\x20floor(log2(val));\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20biased_exponent\x20=\x20exponent\x20+\x20127.0;\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20fraction\x20=\x20((val\x20/\x20exp2(exponent))\x20-\x201.0)\x20*\x208388608.0;\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20t\x20=\x20biased_exponent\x20/\x202.0;\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20last_bit_of_biased_exponent\x20=\x20fract(t)\x20*\x202.0;\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20remaining_bits_of_biased_exponent\x20=\x20floor(t);\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20byte4\x20=\x20encodeFloat_extract_bits(fraction,\x200.0,\x208.0)\x20/\x20255.0;\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20byte3\x20=\x20encodeFloat_extract_bits(fraction,\x208.0,\x2016.0)\x20/\x20255.0;\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20byte2\x20=\x20(last_bit_of_biased_exponent\x20*\x20128.0\x20+\x20encodeFloat_extract_bits(fraction,\x2016.0,\x2023.0))\x20/\x20255.0;\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20byte1\x20=\x20(sign\x20*\x20128.0\x20+\x20remaining_bits_of_biased_exponent)\x20/\x20255.0;\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec4(byte4,\x20byte3,\x20byte2,\x20byte1);\x20\x0a\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x0a\x20\x20\x20\x20',
              ip[iy['qe_getColorByScale']] = '\x0a\x20\x20\x20\x20vec4\x20qe_getColorByScale(float\x20val){\x0a\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(val,undef)\x20||\x20val<csMin){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vec4(0.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20u=(val-csMin)/(csMax-csMin);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20uv=vec2(u,0.5);\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20' + ic['textureFunc'] + '(csTexture,uv);\x0a\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20';
          }(),
          iw = true);
      }
      var iu = n(0x1ca);
      class IDWScatterInterpolator {
          constructor() {
              this['interpUniforms'] = {};
          }
          ['init'](cd) {
              if (this['destroyShaders'](),
              this['options'] = (0x0,
              Kz['Ov'])({}, cd, IDWScatterInterpolator['DefaultOptions']),
              !this['gl']) {
                  const cC = document['createElement']('canvas');
                  this['gl'] = Kg['v']['useWebGL2'] ? cC['getContext']('webgl2') : cC['getContext']('webgl'),
                  function(cO) {
                      for (let cG = 0x0; cG < KG['length']; ++cG)
                          KO(cO, KG[cG]);
                  }(this['gl']);
              }
              this['gl']['canvas']['width'] = cd['gridOptions']['xSize'],
              this['gl']['canvas']['height'] = cd['gridOptions']['ySize'];
              const cq = ic['header'] + '\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20precision\x20highp\x20float;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20' + ic['attrIn'] + '\x20vec2\x20position;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20' + ic['attrIn'] + '\x20vec2\x20uv;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20' + ic['varOut'] + '\x20vec2\x20vUv;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20void\x20main(){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vUv=uv;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20gl_Position=vec4(position,0.,1.);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20'
                , cJ = ic['header'] + '\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20precision\x20highp\x20sampler2D;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20precision\x20highp\x20float;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20const\x20float\x20dataOffset=0.;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20const\x20float\x20dataScale=1.;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20const\x20int\x20maxCount=' + {} + ';\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20const\x20int\x20maxRadius=' + parseInt(this['options']['maxSearchGridSpan']) + ';\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20const\x20float\x20xi=' + ik(this['options']['gridOptions']['xDelta']) + ';\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//todo:xAttryAttr\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20const\x20vec4\x20xAttr=vec4(' + ik(this['options']['gridOptions']['xStart']) + ',' + ik(this['options']['gridOptions']['xEnd']) + ',' + ik(this['options']['gridOptions']['xDelta']) + ',' + ik(this['options']['gridOptions']['xSize']) + ');\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20const\x20vec4\x20yAttr=vec4(' + ik(this['options']['gridOptions']['yStart']) + ',' + ik(this['options']['gridOptions']['yEnd']) + ',' + ik(this['options']['gridOptions']['yDelta']) + ',' + ik(this['options']['gridOptions']['ySize']) + ');\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20const\x20float\x20uDelta=' + 0x1 / this['options']['gridOptions']['xSize'] + ';\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20const\x20float\x20vDelta=' + 0x1 / this['options']['gridOptions']['ySize'] + ';\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20const\x20mediump\x20int\x20dataAlgo=0;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20const\x20float\x20baseScale=1.;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20sampler2D\x20staTexture;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uniform\x20float\x20undef;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20' + ic['varIn'] + '\x20vec2\x20vUv;\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20' + ic['outColorDefine'] + '\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20$inject\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//todo:yy\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20idw(vec2\x20uv){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20wAll=0.;\x20//\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20vAll=0.;\x20//w\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20int\x20ptCount=0;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20dataSize=vec2(xAttr.w,yAttr.w);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20pos=floor(uv*dataSize);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20center=vec2(xAttr.x+\x20uv.x*xAttr.w,yAttr.x+uv.y*yAttr.w);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20for(int\x20i=0;i<maxRadius;i++){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20fi=float(i);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20lu=(pos.x-fi)/(dataSize.x);\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20float\x20lu=uv.x-fi*uDelta;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(lu<0.){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20continue;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20ru=(pos.x+fi)/(dataSize.x);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20float\x20ru=uv.x+fi*uDelta;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(ru>1.){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20continue;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20cLon=center.x+xAttr.z;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20for(int\x20j=0;j<maxRadius;j++){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20fj=float(j);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20upV=(pos.y-fj)/(dataSize.y);\x20\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20float\x20upV=uv.y-fj*vDelta;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(upV<0.){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20continue;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20downV=(pos.y+fj)/(dataSize.y);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20float\x20downV=uv.y+fj*vDelta;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(downV>1.){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20continue;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20cLat=center.y+yAttr.z;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20currentPos=vec2(cLon,cLat);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20h=' + iy['qe_geoDistance'] + '(center,currentPos);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20w=1./pow(h,' + ik(this['options']['p']) + ');\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//left\x20side,up\x20val\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20lUpVal=' + iy['qe_readGrid2DRawVal'] + '(staTexture,vec2(lu,upV),undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(!' + iy['qe_isUndef'] + '(lUpVal,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20wAll=wAll+w;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vAll=vAll+w*lUpVal;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20ptCount=ptCount+1;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20lDownVal=' + iy['qe_readGrid2DRawVal'] + '(staTexture,vec2(lu,downV),undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(!' + iy['qe_isUndef'] + '(lDownVal,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20wAll=wAll+w;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vAll=vAll+w*lDownVal;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20ptCount=ptCount+1;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20rUpVal=' + iy['qe_readGrid2DRawVal'] + '(staTexture,vec2(ru,upV),undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(!' + iy['qe_isUndef'] + '(rUpVal,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20wAll=wAll+w;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vAll=vAll+w*rUpVal;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20ptCount=ptCount+1;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20rDownVal=' + iy['qe_readGrid2DRawVal'] + '(staTexture,vec2(ru,downV),undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(!' + iy['qe_isUndef'] + '(rDownVal,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20wAll=wAll+w;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vAll=vAll+w*rDownVal;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20ptCount=ptCount+1;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20if(ptCount>=' + {} + '){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20\x20\x20\x20\x20return\x20vAll/wAll;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(ptCount==0){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20undef;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}else{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20vAll/wAll;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20void\x20main(){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20uv=vec2(vUv.x,1.-vUv.y);\x20//vec2(gl_FragCoord.xy);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20val=' + iy['qe_readGrid2DRawVal'] + '(staTexture,uv,undef);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//if\x20not\x20undef,use\x20exact\x20value\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if(' + iy['qe_isUndef'] + '(val,undef)){\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20val=idw(uv);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20color=' + iy['qe_encodeFloat'] + '(val);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20' + ic['outColorName'] + '=color;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20';
              return this['interpProgram'] = Kf(this['gl'], [cq, i5(cJ)]),
              this['interpBuffer'] = Ah(this['gl'], {
                  'position': {
                      'numComponents': 0x2,
                      'data': [-0x1, 0x1, -0x1, -0x1, 0x1, -0x1, -0x1, 0x1, 0x1, -0x1, 0x1, 0x1]
                  },
                  'uv': {
                      'numComponents': 0x2,
                      'data': [0x0, 0x0, 0x0, 0x1, 0x1, 0x1, 0x0, 0x0, 0x1, 0x1, 0x1, 0x0]
                  }
              }),
              this['interpFramebuffer'] = KJ(this['gl'], [{
                  'width': this['gl']['drawingBufferWidth'],
                  'height': this['gl']['drawingBufferHeight'],
                  'src': new Uint8Array(this['gl']['drawingBufferWidth'] * this['gl']['drawingBufferHeight'] * 0x4),
                  'format': this['gl']['RGBA'],
                  'type': this['gl']['UNSIGNED_BYTE'],
                  'wrap': this['gl']['CLAMP_TO_EDGE'],
                  'minMag': this['gl']['NEAREST']
              }]),
              this['gl']['bindFramebuffer'](this['gl']['FRAMEBUFFER'], null),
              this;
          }
          ['interpToProvider'](cd, cq, cJ) {
              const cC = this['interp'](cd, cq, cJ);
              return new iu['o']([[cC]],{
                  'gridOptions': this['options']['gridOptions']
              });
          }
          ['interp'](cd, cq, cJ) {
              (this['options']['p'] < 0x0 || this['options']['maxSearchGridSpan'] <= 0x0) && v0['kg']['error']('p0maxSearchGridSpan0'),
              v0['kg']['debug']('begin\x20interp');
              const cC = performance['now']();
              var cO, cG, cg;
              this['gl']['useProgram'](this['interpProgram']['program']),
              cO = this['gl'],
              cG = this['interpFramebuffer'],
              cg = cg || 0x8d40,
              cG ? (cO['bindFramebuffer'](cg, cG['framebuffer']),
              cO['viewport'](0x0, 0x0, cG['width'], cG['height'])) : (cO['bindFramebuffer'](cg, null),
              cO['viewport'](0x0, 0x0, cO['drawingBufferWidth'], cO['drawingBufferHeight'])),
              this['gl']['viewport'](0x0, 0x0, this['gl']['drawingBufferWidth'], this['gl']['drawingBufferHeight']),
              this['gl']['clear'](this['gl']['COLOR_BUFFER_BIT']),
              function(cz, cQ, cm) {
                  cm['vertexArrayObject'] ? cz['bindVertexArray'](cm['vertexArrayObject']) : (function(cL, cR) {
                      for (const H0 in cR) {
                          const H1 = cL[H0];
                          H1 && H1(cR[H0]);
                      }
                  }(cQ['attribSetters'] || cQ, cm['attribs']),
                  cm['indices'] && cz['bindBuffer'](0x8893, cm['indices']));
              }(this['gl'], this['interpProgram'], this['interpBuffer']),
              this['interpUniforms']['staTexture'] = this['createStaTexture'](cd, cq, cJ),
              this['interpUniforms']['undef'] = cq,
              KY(this['interpProgram'], this['interpUniforms']),
              function(cz, cQ, cm, cL, cR, H0) {
                  cm = undefined === cm ? 0x4 : cm;
                  const H1 = cQ['indices']
                    , H2 = cQ['elementType']
                    , H3 = undefined === cL ? cQ['numElements'] : cL;
                  cR = undefined === cR ? 0x0 : cR,
                  H2 || H1 ? undefined !== H0 ? cz['drawElementsInstanced'](cm, H3, undefined === H2 ? 0x1403 : cQ['elementType'], cR, H0) : cz['drawElements'](cm, H3, undefined === H2 ? 0x1403 : cQ['elementType'], cR) : undefined !== H0 ? cz['drawArraysInstanced'](cm, cR, H3, H0) : cz['drawArrays'](cm, cR, H3);
              }(this['gl'], this['interpBuffer']),
              this['gl']['finish']();
              const cN = performance['now']()
                , cP = new Uint8Array(this['options']['gridOptions']['xSize'] * this['options']['gridOptions']['ySize'] * 0x4);
              this['gl']['readPixels'](0x0, 0x0, this['options']['gridOptions']['xSize'], this['options']['gridOptions']['ySize'], this['gl']['RGBA'], this['gl']['UNSIGNED_BYTE'], cP);
              const cM = new KN['P'](KP['U']['Float32'],this['options']['gridOptions']['xSize'],this['options']['gridOptions']['ySize'],cP['buffer'],cq);
              return v0['kg']['debug']('read\x20pixels\x20costs\x20' + (performance['now']() - cN) + 'ms'),
              this['gl']['bindFramebuffer'](this['gl']['FRAMEBUFFER'], null),
              v0['kg']['debug']('interp\x20total\x20costs\x20' + (performance['now']() - cC) + 'ms'),
              cM;
          }
          ['getGLDataInfo'](cd) {
              const cq = cd['dataType'] !== KP['U']['UInt8'] && this['gl']instanceof WebGL2RenderingContext ? this['gl']['RED'] : this['gl']['ALPHA'];
              let cJ = cd['dataType'] === KP['U']['UInt8'] ? this['gl']['UNSIGNED_BYTE'] : this['gl']['FLOAT']
                , cC = cq
                , cO = cd['dataType'] === KP['U']['UInt8'] || cd['dataType'] === KP['U']['Float32'] ? cd['raw'] : new Float32Array(cd['raw']);
              return cq === this['gl']['RED'] && (cC = this['gl']['R32F']),
              {
                  'rawData': cO,
                  'dataType': cJ,
                  'innerFormat': cC,
                  'pixelFormat': cq
              };
          }
          ['getValReplaceFunc']() {
              return 'first' === this['options']['pointInSameGridStrategy'] ? (cd,cq)=>cd : 'last' === this['options']['pointInSameGridStrategy'] ? (cd,cq)=>cq : 'max' === this['options']['pointInSameGridStrategy'] ? (cd,cq)=>Math['max'](cd, cq) : 'min' === this['options']['pointInSameGridStrategy'] ? (cd,cq)=>Math['min'](cd, cq) : 'negMinPosMax' === this['options']['pointInSameGridStrategy'] ? (cd,cq)=>cd < 0x0 ? Math['min'](cd, cq) : Math['max'](cd, cq) : (cd,cq)=>(cd + cq) / 0x2;
          }
          ['createStaTexture'](cd, cq, cJ) {
              var cC;
              const cO = performance['now']()
                , cG = new Float32Array(this['options']['gridOptions']['xSize'] * this['options']['gridOptions']['ySize']);
              cG['fill'](cq);
              const cg = new KN['P'](KP['U']['Float32'],this['options']['gridOptions']['xSize'],this['options']['gridOptions']['ySize'],cG['buffer'],cq)
                , cN = cd['getFeatures']()['features']
                , cP = this['getValReplaceFunc']();
              for (const cQ of cN) {
                  const cm = cQ['geometry']['coordinates'];
                  if (!(0x0,
                  Kz['ri'])(cQ['properties'][cJ]))
                      continue;
                  const cL = (0x0,
                  Kz['tr'])(this['options']['gridOptions']['xStart'], this['options']['gridOptions']['xDelta'], cm[0x0]);
                  if (cL < 0x0 || cL >= this['options']['gridOptions']['xSize'])
                      continue;
                  const cR = (0x0,
                  Kz['tr'])(this['options']['gridOptions']['yStart'], this['options']['gridOptions']['yDelta'], cm[0x1]);
                  if (cR < 0x0 || cR >= this['options']['gridOptions']['ySize'])
                      continue;
                  let H0 = null !== (cC = parseFloat(cQ['properties'][cJ])) && undefined !== cC ? cC : cq;
                  const H1 = cg['getPos'](cR, cL)
                    , H2 = cg['read1D'](H1);
                  H0 == cq ? H0 = H2 : H2 != cq && (H0 = cP(H2, H0)),
                  cg['write2D'](cR, cL, H0);
              }
              const cM = this['getGLDataInfo'](cg)
                , cz = lY(this['gl'], {
                  'width': cg['xSize'],
                  'height': cg['ySize'],
                  'min': this['gl']['NEAREST'],
                  'mag': this['gl']['NEAREST'],
                  'format': cM['pixelFormat'],
                  'internalFormat': cM['innerFormat'],
                  'type': cM['dataType'],
                  'src': cM['rawData'],
                  'wrapS': this['gl']['CLAMP_TO_EDGE'],
                  'wrapT': this['gl']['CLAMP_TO_EDGE'],
                  'flipY': 0x0
              });
              return v0['kg']['debug']('create\x20' + cN['length'] + '\x20station\x20texutre\x20costs\x20' + (performance['now']() - cO) + 'ms'),
              cz;
          }
          ['deleteBufferInfo'](cd, cq) {
              if (cq) {
                  for (const cJ of Object['values'](cq['attribs']))
                      cd['deleteBuffer'](cJ['buffer']);
                  cq['indices'] && cd['deleteBuffer'](cq['indices']);
              }
          }
          ['deleteFrameBufferInfo'](cd, cq) {
              if (cq) {
                  cd['deleteFramebuffer'](cq['framebuffer']);
                  for (const cJ of cq['attachments'])
                      cJ instanceof WebGLRenderbuffer ? cd['deleteRenderbuffer'](cJ) : cd['deleteTexture'](cJ);
              }
          }
          ['destroyShaders']() {
              this['gl'] && (this['interpProgram'] && this['gl']['deleteProgram'](this['interpProgram']['program']),
              this['interpProgram'] = undefined,
              this['interpBuffer'] && this['deleteBufferInfo'](this['gl'], this['interpBuffer']),
              this['interpBuffer'] = undefined,
              this['interpFramebuffer'] && this['deleteFrameBufferInfo'](this['gl'], this['interpFramebuffer']),
              this['interpFramebuffer'] = undefined);
          }
          ['destroy']() {
              if (this['destroyShaders'](),
              !this['gl'])
                  return;
              const cd = this['gl']['getExtension']('WEBGL_lose_context');
              cd && cd['loseContext'](),
              this['gl'] = undefined;
          }
      }
      IDWScatterInterpolator['DefaultOptions'] = {
          'gridOptions': undefined,
          'p': 0x2,
          'maxSearchGridSpan': 0x5,
          'pointInSameGridStrategy': 'mean'
      };
      var iT = n(0x393);
      class iX extends iT['c'] {
          constructor(cd, cq, cJ='', cC=undefined) {
              super(),
              this['workerPath'] = cd,
              this['maxWorkerNumber'] = cq,
              this['name'] = cJ,
              this['workerOptions'] = cC,
              this['workersCount'] = 0x0,
              this['startTime'] = undefined,
              this['taskPosted'] = 0x0,
              this['taskProcessed'] = 0x0,
              this['maxWorkerNumber'] = this['maxWorkerNumber'] || 0x4,
              this['exeQueues'] = [],
              this['workers'] = [];
          }
          ['push'](cd) {
              this['exeQueues']['push'](cd),
              this['execNext']();
          }
          ['destroy']() {
              this['workers']['forEach'](cd=>cd['terminate']()),
              this['workers']['length'] = 0x0,
              this['workersCount'] = 0x0;
          }
          ['execNext']() {
              if (0x0 === this['exeQueues']['length'])
                  return void (this['taskPosted'] === this['taskProcessed'] && (v0['kg']['debug']('[' + this['name'] + ']\x20complete\x20' + this['taskPosted'] + '\x20task(s)\x20cost\x20' + (new Date()['getTime']() - this['startTime']['getTime']()) + 'ms'),
                  this['startTime'] = undefined,
                  this['taskPosted'] = 0x0,
                  this['taskProcessed'] = 0x0,
                  this['fire']('completed', {
                      'firer': this,
                      'msg': this
                  })));
              if (this['workersCount'] >= this['maxWorkerNumber'] && 0x0 === this['workers']['length'])
                  return;
              let cd;
              undefined === this['startTime'] && (this['startTime'] = new Date())
              // this['workers']['length'] > 0x0 ? cd = this['workers']['shift']() : (cd = new Worker(this['workerPath'],this['workerOptions']),

              if(this['workers']['length'] > 0x0){
                cd = this['workers']['shift']()
              }
              else{
                 cd = new Worker(this['workerPath'],this['workerOptions'])
                 this['workersCount']++
              }
              var cq = this['exeQueues']['shift']();
              cq['beforeExec'] && cq['beforeExec'](cq),
              cd['onerror'] = cq['onError'],
              cd['onmessage'] = cJ=>{
                  this['workers']['push'](cd),
                  this['taskProcessed']++,
                  cq['onCompleted'](cJ['data']),
                  this['execNext']();
              }
              ,
              cq['transffers'] && cq['transffers']['length'] > 0x0 ? cd['postMessage'](cq['data'], cq['transffers']) : cd['postMessage'](cq['data']),
              this['taskPosted']++;
          }
      }
      class iE extends iT['c'] {
          constructor(cd, cq) {
              super(),
              this['eventNames'] = {
                  'tChanged': 'tChanged',
                  'zChanged': 'zChanged',
                  'tzChanged': 'tzChanged',
                  'iTChanged': 'iTChanged',
                  'iZChanged': 'iZChanged',
                  'iTZChanged': 'iTZChanged',
                  'activeTZDataUpated': 'activeTZDataUpated'
              },
              this['meta'] = {},
              this['_currentTIdx'] = 0x0,
              this['_currentZIdx'] = 0x0,
              this['mc'] = [],
              this['options'] = (0x0,
              Kz['Ov'])(this['options'], cq, {
                  'maxTimeCount': 0x0
              }),
              this['mc'] = cd,
              this['meshOptions'] = {
                  'tCount': cd['length'],
                  'zValues': cd['length'] > 0x0 ? cd[0x0]['length'] : []
              },
              this['gridOptions'] = null == cq ? undefined : cq['gridOptions'];
          }
          ['allMeshes']() {
              return this['mc'];
          }
          ['addMeshTo'](cd, cq, cJ, cC, cO, cG) {
              cq = parseInt(cq),
              cJ = parseInt(cJ);
              const cg = this['getIntTIdx']()
                , cN = this['getIntZIdx']();
              return cG[cq] = cG[cq] || [],
              cG[cq][cJ] = cd,
              this['meshOptions']['tCount'] = cG['length'],
              (0x0,
              Kz['ri'])(cC) && this['meshOptions']['zValues'] && (this['meshOptions']['zValues'][cJ] = cC),
              cq === cg && cJ === cN ? this['fire'](this['eventNames']['activeTZDataUpated'], {
                  'firer': this,
                  'msg': this
              }) : cO && (this['lock'](),
              this['currentTIdx'] = cq,
              this['currentZIdx'] = cJ,
              this['unlock']()),
              this;
          }
          get['currentTIdx']() {
              return this['_currentTIdx'];
          }
          set['currentTIdx'](cd) {
              if (this['mc'] && cd >= this['mc']['length'])
                  return;
              if (cd === this['currentTIdx'])
                  return;
              const cq = this['getIntTIdx']();
              this['_currentTIdx'] = cd,
              cq !== this['getIntTIdx']() ? (this['fire'](this['eventNames']['iTChanged'], {
                  'firer': this,
                  'msg': this
              }),
              this['fire'](this['eventNames']['iTZChanged'], {
                  'firer': this,
                  'msg': this
              })) : (this['fire'](this['eventNames']['tChanged'], {
                  'firer': this,
                  'msg': this
              }),
              this['fire'](this['eventNames']['tzChanged'], {
                  'firer': this,
                  'msg': this
              }));
          }
          get['currentZIdx']() {
              return this['_currentZIdx'];
          }
          set['currentZIdx'](cd) {
              if (this['mc'] && cd >= this['mc'][this['getIntTIdx']()]['length'])
                  return;
              if (cd === this['currentZIdx'])
                  return;
              const cq = this['getIntZIdx']();
              this['_currentZIdx'] = cd,
              cq !== this['getIntZIdx']() ? (this['fire'](this['eventNames']['iZChanged'], {
                  'firer': this,
                  'msg': this
              }),
              this['fire'](this['eventNames']['iTZChanged'], {
                  'firer': this,
                  'msg': this
              })) : (this['fire'](this['eventNames']['zChanged'], {
                  'firer': this,
                  'msg': this
              }),
              this['fire'](this['eventNames']['tzChanged'], {
                  'firer': this,
                  'msg': this
              }));
          }
          ['getGrid'](cd, cq) {
              return undefined === cd && (cd = this['getIntTIdx']()),
              undefined === cq && (cq = this['getIntZIdx']()),
              this['mc'][cd][cq];
          }
          ['allGrids']() {
              return this['mc'];
          }
          ['updateMesh'](cd, cq, cJ, cC, cO) {
              return this['addMeshTo'](cd, cq, cJ, cC, cO, this['allMeshes']());
          }
          ['getIntTIdx']() {
              return parseInt(this['_currentTIdx']);
          }
          ['getIntZIdx']() {
              return parseInt(this['_currentZIdx']);
          }
          ['onTChanged'](cd) {
              return this['on'](this['eventNames']['tChanged'], cd),
              this;
          }
          ['onZChanged'](cd) {
              return this['on'](this['eventNames']['zChanged'], cd),
              this;
          }
          ['onTZChanged'](cd) {
              return this['on'](this['eventNames']['tzChanged'], cd),
              this;
          }
          ['onIntTChanged'](cd) {
              return this['on'](this['eventNames']['iTChanged'], cd),
              this;
          }
          ['onIntZChanged'](cd) {
              return this['on'](this['eventNames']['iZChanged'], cd),
              this;
          }
          ['onIntTZChanged'](cd) {
              return this['on'](this['eventNames']['iTZChanged'], cd),
              this;
          }
          ['offTChanged'](cd) {
              return this['off'](this['eventNames']['tChanged'], cd),
              this;
          }
          ['offZChanged'](cd) {
              return this['off'](this['eventNames']['zChanged'], cd),
              this;
          }
          ['offTZChanged'](cd) {
              return this['off'](this['eventNames']['tzChanged'], cd),
              this;
          }
          ['offIntTChanged'](cd) {
              return this['off'](this['eventNames']['iTChanged'], cd),
              this;
          }
          ['offIntZChanged'](cd) {
              return this['off'](this['eventNames']['iZChanged'], cd),
              this;
          }
          ['offIntTZChanged'](cd) {
              return this['off'](this['eventNames']['iTZChanged'], cd),
              this;
          }
          ['onActiveGridUpdated'](cd) {
              return this['on'](this['eventNames']['activeTZDataUpated'], cd),
              this;
          }
          ['offActiveGridUpdated'](cd) {
              return this['off'](this['eventNames']['activeTZDataUpated'], cd),
              this;
          }
      }
      var iW = function(cd, cq, cJ, cC) {
          return new (cJ || (cJ = Promise))(function(cO, cG) {
              function cg(cM) {
                  try {
                      cP(cC['next'](cM));
                  } catch (cz) {
                      cG(cz);
                  }
              }
              function cN(cM) {
                  try {
                      cP(cC['throw'](cM));
                  } catch (cz) {
                      cG(cz);
                  }
              }
              function cP(cM) {
                  var cz;
                  cM['done'] ? cO(cM['value']) : (cz = cM['value'],
                  cz instanceof cJ ? cz : new cJ(function(cQ) {
                      cQ(cz);
                  }
                  ))['then'](cg, cN);
              }
              cP((cC = cC['apply'](cd, cq || []))['next']());
          }
          );
      };
      const MCBDefaults = {
          'threadCount': 0x4
      };
      function ij(cd) {
          var cq, cJ, cC;
          return iW(this, undefined, undefined, function*() {
              const cO = cd['wasm'] ? Kg['v']['wasmPath'] + '/mcb.js' : Kg['v']['workerPath'] + '/mcb.worker.js'
                , cG = new iX(cO,null !== (cq = cd['threadCount']) && undefined !== cq ? cq : MCBDefaults['threadCount'],'mcb_' + (0x0,
              Kz['hQ'])(),{
                  'type': 'module'
              });
              if (!(null == cd ? undefined : cd['analysisValues']['length']))
                  return void v0['kg']['error']('');
              if (cd['dataSource']['gridOptions']['zValues']['length'] <= 0x1)
                  return void v0['kg']['error']('');
              const cg = cd['dataSource'];
              let cN, cP = cg['gridOptions'];
              const cM = cg['getGrid']()
                , cz = null !== (cJ = cM['dataScale']) && undefined !== cJ ? cJ : 0x1
                , cQ = null !== (cC = cM['dataOffset']) && undefined !== cC ? cC : 0x0
                , cm = cM['undef']
                , cL = cM['dataType'];
              if (cd['visibleExtent']) {
                  const H5 = Math['min'](cd['visibleExtent']['maxLon'], Math['max'](cP['xStart'], cP['xEnd']))
                    , H6 = Math['max'](cd['visibleExtent']['minLon'], Math['min'](cP['xStart'], cP['xEnd']))
                    , H7 = Math['min'](cd['visibleExtent']['maxLat'], Math['max'](cP['yStart'], cP['yEnd']))
                    , H8 = Math['max'](cd['visibleExtent']['minLat'], Math['min'](cP['yStart'], cP['yEnd']))
                    , H9 = cP['xDelta'] < 0x0 ? H5 : H6
                    , Hv = cP['yDelta'] < 0x0 ? H7 : H8
                    , HA = cP['xDelta'] < 0x0 ? H6 : H5
                    , Hk = cP['yDelta'] < 0x0 ? H8 : H7
                    , Hl = Math['floor']((HA - H9) / cP['xDelta']) + 0x1
                    , HK = Math['floor']((Hk - Hv) / cP['yDelta']) + 0x1
                    , Hb = HK * Hl
                    , Hc = cP['zValues']['length'] * Hb;
                  cN = new ArrayBuffer(Hc * cg['getGrid']()['raw']['BYTES_PER_ELEMENT']);
                  const HH = (0x0,
                  Kz['cM'])(cg['getGrid']()['dataType'], cN);
                  let Hx = (0x0,
                  Kz['tr'])(cP['xStart'], cP['xDelta'], H9)
                    , Hp = (0x0,
                  Kz['tr'])(cP['yStart'], cP['yDelta'], Hv)
                    , HF = 0x0;
                  const Hy = cg['allGrids']()[cg['getIntTIdx']()];
                  for (let Hw = 0x0; Hw < cP['zValues']['length']; Hw++) {
                      let Hh = Hy[Hw];
                      for (let Hu = Hp; Hu < HK + Hp; Hu++) {
                          let HY = Hu * cP['xSize'] + Hx
                            , HT = Hh['raw']['subarray'](HY, HY + Hl);
                          HH['set'](HT, HF * Hl),
                          HF++;
                      }
                  }
                  cP = {
                      'xStart': H9,
                      'xEnd': HA,
                      'yStart': Hv,
                      'yEnd': Hk,
                      'xSize': Hl,
                      'ySize': HK,
                      'tCount': 0x1,
                      'zValues': cP['zValues']
                  },
                  (0x0,
                  KM['T'])(cP);
              } else {
                  cN = new ArrayBuffer(cg['getGrid']()['raw']['byteLength'] * cg['gridOptions']['zValues']['length']);
                  const HX = (0x0,
                  Kz['cM'])(cg['getGrid']()['dataType'], cN);
                  let HE = 0x0;
                  cg['allGrids']()[cg['getIntTIdx']()]['forEach'](Hf=>{
                      HX['set'](Hf['raw'], HE),
                      HE += Hf['raw']['length'];
                  }
                  );
              }
              const cR = []
                , H0 = []
                , H1 = cd['analysisValues']['map'](Hf=>function(HW, HI, Hj, HD, HV, HZ, HB, HS, HU, Hd) {
                  return iW(this, undefined, undefined, function*() {
                      return new Promise((Hq,HJ)=>{
                          const HC = {
                              'data': {
                                  'raw': undefined,
                                  'dataType': HZ,
                                  'algo': HU,
                                  'gridOptions': Hj,
                                  'levels': Hj['zValues']['length'],
                                  'xSize': Hj['xSize'],
                                  'ySize': Hj['ySize'],
                                  'scale': null != HB ? HB : 0x1,
                                  'offset': null != HS ? HS : 0x0,
                                  'scaleFirst': 0x2 !== HU,
                                  'outerScale': 0x1,
                                  'outerOffset': 0x0,
                                  'hasOuter': false,
                                  'noShared': true,
                                  'undef': Hd,
                                  'undef_fill': 0x0,
                                  'anaValue': HW,
                                  'anaType': '>='
                              },
                              'beforeExec': ()=>{
                                  let HO;
                                  HO = 0x0 === HV['length'] ? HI['slice'](0x0) : HV['pop'](),
                                  HC['data']['raw'] = HO,
                                  HC['transffers'] = [HO];
                              }
                              ,
                              'onCompleted': HO=>{
                                  let HG = new Float32Array(HO['vertices']);
                                  HV['push'](HO['source']),
                                  Hq(new iE([[{
                                      'meshes': [{
                                          'vertices': HG,
                                          'properties': {
                                              'value': HW
                                          },
                                          'indices': HO['indices']
                                      }]
                                  }]],{
                                      'gridOptions': Hj
                                  }));
                              }
                          };
                          HD['push'](HC);
                      }
                      );
                  });
              }(Hf, cN, cP, cG, cR, cL, cz, cQ, cM['algo'], cm)['then'](HW=>{
                  if (cd['completeOne']) {
                      const HI = cd['layerCreator'](HW);
                      cd['completeOne'](HI, HW),
                      H0['push'](HI);
                  }
                  return HW;
              }
              ))
                , H2 = yield Promise['all'](H1)
                , H3 = {
                  'meshes': []
              };
              H2['forEach'](Hf=>{
                  Hf['allMeshes']()[0x0][0x0]['meshes']['forEach'](HW=>{
                      H3['meshes']['push'](HW);
                  }
                  );
              }
              );
              const H4 = new iE([[H3]],{
                  'gridOptions': cP
              });
              return cd['completeOne'] ? {
                  'dataSource': H4,
                  'layer': H0
              } : {
                  'dataSource': H4,
                  'layer': cd['layerCreator'](H4)
              };
          });
      }
      var CollisionDetectMode;
      !function(cd) {
          cd[cd['Hide_All_When_Any'] = 0x0] = 'Hide_All_When_Any',
          cd[cd['Hide_Only_Self'] = 0x1] = 'Hide_Only_Self';
      }(CollisionDetectMode || (CollisionDetectMode = {}));
      class iV {
          constructor(cd, cq, cJ, cC) {
              this['minX'] = cd,
              this['minY'] = cq,
              this['maxX'] = cJ,
              this['maxY'] = cC;
          }
          ['intersects'](cd) {
              const cq = cd['maxX'] >= this['minX'] && cd['minX'] <= this['maxX']
                , cJ = cd['maxY'] >= this['minY'] && cd['minY'] <= this['maxY'];
              return cq && cJ;
          }
      }
      class CollisonDetector {
          constructor(cd) {
              cd['width'] && cd['height'] || v0['kg']['error'](''),
              this['options'] = (0x0,
              Kz['Ov'])({}, cd, CollisonDetector['DefaultOptions']),
              this['collisionTree'] = new Quadtree({
                  'x': this['options']['x'],
                  'y': this['options']['y'],
                  'width': this['options']['width'],
                  'height': this['options']['height']
              },this['options']['maxNodeItems']),
              this['batchInsert'](this['options']['objs']);
          }
          ['_collisionDetectByFeature'](cd) {
              const cq = {};
              for (const cO of cd)
                  cO['feature']['id'] = cO['feature']['id'] || (0x0,
                  Kz['hQ'])(),
                  cq[cO['feature']['id']] ? cq[cO['feature']['id']]['push'](cO) : cq[cO['feature']['id']] = [cO];
              const cJ = [];
              for (const cG in cq) {
                  const cg = cq[cG];
                  if (!cg['some'](cN=>cN['hidden'])) {
                      cJ['push'](cG);
                      for (const cN of cg) {
                          const cP = this['collisionTree']['retrieve'](cN);
                          if (!cP || 0x0 === cP['length'])
                              continue;
                          let cM = cN['bounds'];
                          cM || (cM = cN['bounds'] = new iV(cN['x'],cN['y'],cN['x'] + cN['width'],cN['y'] + cN['height']));
                          let cz = 0x0;
                          cP['forEach'](cQ=>{
                              if (cQ['hidden'] || cQ === cN || cQ['feature'] === cN['feature'])
                                  return;
                              let cm = cQ['bounds'];
                              cm || (cm = cQ['bounds'] = new iV(cQ['x'],cQ['y'],cQ['x'] + cQ['width'],cQ['y'] + cQ['height'])),
                              cM['intersects'](cm) ? cQ['hidden'] = true : cz++;
                          }
                          );
                      }
                  }
              }
              const cC = [];
              for (const cQ of cJ)
                  for (const cm of cq[cQ])
                      cC['push'](cm);
              return cC;
          }
          ['insert'](cd) {
              this['collisionTree']['insert'](cd);
          }
          ['batchInsert'](cd) {
              cd && 0x0 !== cd['length'] && cd['forEach'](cq=>{
                  this['insert'](cq);
              }
              );
          }
          ['collisionDectect'](cd) {
              if (!cd || 0x0 === cd['length'])
                  return [];
              if (this['options']['collisonMode'] === CollisionDetectMode['Hide_All_When_Any'])
                  return this['_collisionDetectByFeature'](cd);
              let cq = [];
              for (const cJ of cd) {
                  if (cJ['hidden'])
                      continue;
                  cq['push'](cJ);
                  const cC = this['collisionTree']['retrieve'](cJ);
                  if (!cC || 0x0 === cC['length'])
                      continue;
                  let cO = cJ['bounds'];
                  cO || (cO = cJ['bounds'] = new iV(cJ['x'],cJ['y'],cJ['x'] + cJ['width'],cJ['y'] + cJ['height']));
                  let cG = 0x0;
                  cC['forEach'](cg=>{
                      if (cg['hidden'] || cg === cJ || cg['feature'] === cJ['feature'])
                          return;
                      let cN = cg['bounds'];
                      cN || (cN = cg['bounds'] = new iV(cg['x'],cg['y'],cg['x'] + cg['width'],cg['y'] + cg['height'])),
                      cO['intersects'](cN) ? cg['hidden'] = true : cG++;
                  }
                  );
              }
              return cq;
          }
          ['clear']() {
              this['collisionTree']['clear']();
          }
      }
      CollisonDetector['DefaultOptions'] = {
          'x': 0x0,
          'y': 0x0,
          'width': undefined,
          'height': undefined,
          'maxNodeItems': 0xa,
          'collisonMode': CollisionDetectMode['Hide_Only_Self']
      };
      var iB = n(0x19d)
        , iS = n(0x35a)
        , iU = n(0x219)
        , id = n(0x1de)
        , iq = n(0x133);
      class FeatureVolumeStyle extends iB['rJ'] {
          constructor(cd) {
              super(cd),
              (0x0,
              Kz['JY'])(cd['height']) || v0['kg']['error'](''),
              this['_update'](cd, true);
          }
          ['_update'](cd, cq) {
              cq ? (this['xDelta'] = (0x0,
              iB['JW'])((0x0,
              Kz['En'])(cd['xDelta'], FeatureVolumeStyle['DefaultOptions']['xDelta'])),
              this['yDelta'] = (0x0,
              iB['JW'])((0x0,
              Kz['En'])(cd['yDelta'], FeatureVolumeStyle['DefaultOptions']['yDelta'])),
              this['color'] = (0x0,
              iB['Jf'])((0x0,
              Kz['En'])(cd['color'], FeatureVolumeStyle['DefaultOptions']['color'])),
              this['visible'] = (0x0,
              iB['pd'])((0x0,
              Kz['En'])(cd['visible'], FeatureVolumeStyle['DefaultOptions']['visible']))) : (this['xDelta'] = (0x0,
              Kz['Rf'])(cd['xDelta'], this['xDelta'], iB['JW']),
              this['yDelta'] = (0x0,
              Kz['Rf'])(cd['yDelta'], this['yDelta'], iB['JW']),
              this['color'] = (0x0,
              Kz['Rf'])(cd['color'], this['color'], iB['Jf']),
              this['visible'] = (0x0,
              Kz['Rf'])(cd['visible'], this['visible'], iB['pd'])),
              this['height'] = (0x0,
              Kz['Rf'])(cd['height'], this['height'], iB['JW']);
          }
      }
      FeatureVolumeStyle['DefaultOptions'] = {
          'xDelta': 0.1,
          'yDelta': 0.1,
          'color': id['m']['aliceblue'],
          'visible': true,
          'height': undefined
      };
      class FeatureLabelStyle3D extends iB['PE'] {
          ['_update'](cd, cq) {
              super['_update'](cd, cq),
              cd['volume'] && (this['volume'] && !cq ? this['volume']['update'](cd['volume']) : this['volume'] = new FeatureVolumeStyle(cd['volume']));
          }
      }
      class iO extends iB['SC'] {
          constructor(cd) {
              super(cd);
          }
          ['updateLabels'](cd) {
              const cq = [];
              if (cd['label'] && cd['label']['length'] > 0x0) {
                  for (const cJ of cd['label'])
                      cq['push'](new FeatureLabelStyle3D(cJ));
              }
              this['label'] = cq;
          }
      }
      class PolylineStyle3D extends iB['Xx'] {
          constructor(cd) {
              super(cd);
          }
          ['_update'](cd, cq) {
              super['_update'](cd, cq),
              cq ? (this['simpleLine'] = (0x0,
              iB['pd'])((0x0,
              Kz['En'])(cd['simpleLine'], PolylineStyle3D['DefaultOptions']['simpleLine'])),
              this['glowPower'] = (0x0,
              iB['JW'])((0x0,
              Kz['En'])(cd['glowPower'], PolylineStyle3D['DefaultOptions']['glowPower'])),
              this['taperPower'] = (0x0,
              iB['JW'])((0x0,
              Kz['En'])(cd['taperPower'], PolylineStyle3D['DefaultOptions']['taperPower'])),
              this['strokeWidth'] = (0x0,
              iB['JW'])((0x0,
              Kz['En'])(cd['strokeWidth'], PolylineStyle3D['DefaultOptions']['strokeWidth']))) : (this['simpleLine'] = (0x0,
              Kz['Rf'])(cd['simpleLine'], this['simpleLine'], iB['pd']),
              this['glowPower'] = (0x0,
              Kz['Rf'])(cd['glowPower'], this['glowPower'], iB['JW']),
              this['taperPower'] = (0x0,
              Kz['Rf'])(cd['taperPower'], this['taperPower'], iB['JW']),
              this['strokeWidth'] = (0x0,
              Kz['Rf'])(cd['strokeWidth'], this['strokeWidth'], iB['JW'])),
              this['glowColor'] = (0x0,
              Kz['Rf'])(cd['glowColor'], this['glowColor'], iB['Jf']),
              this['dashColor'] = (0x0,
              Kz['Rf'])(cd['dashColor'], this['dashColor'], iB['Jf']),
              this['strokeColor'] = (0x0,
              Kz['Rf'])(cd['strokeColor'], this['strokeColor'], iB['Jf']);
          }
      }
      PolylineStyle3D['DefaultOptions'] = Object['assign'](Object['assign']({}, iB['Xx']['DefaultOptions']), {
          'simpleLine': false,
          'glowPower': 0.5,
          'taperPower': 0.5,
          'strokeWidth': 0x2
      });
      class ig extends iB['_7'] {
          constructor(cd) {
              super(cd);
          }
          ['_update'](cd, cq) {
              super['_update'](cd, cq),
              cq ? (this['closeTop'] = (0x0,
              iB['pd'])((0x0,
              Kz['En'])(cd['closeTop'], ig['DefaultOptions']['closeTop'])),
              this['closeBottom'] = (0x0,
              iB['pd'])((0x0,
              Kz['En'])(cd['closeBottom'], ig['DefaultOptions']['closeBottom']))) : (this['closeTop'] = (0x0,
              Kz['Rf'])(cd['closeTop'], this['closeTop'], iB['pd']),
              this['closeBottom'] = (0x0,
              Kz['Rf'])(cd['closeBottom'], this['closeBottom'], iB['pd'])),
              this['extrudeHeight'] = (0x0,
              Kz['Rf'])(cd['extrudeHeight'], this['extrudeHeight'], iB['JW']),
              this['strokeColor'] = (0x0,
              Kz['Rf'])(cd['strokeColor'], this['strokeColor'], iB['Jf']);
          }
          ['updateLineStyle'](cd) {
              this['lineStyle'] = cd['lineStyle'] && new PolylineStyle3D(cd['lineStyle']);
          }
          ['updateLabels'](cd) {
              const cq = [];
              if (cd['label'] && cd['label']['length'] > 0x0) {
                  for (const cJ of cd['label'])
                      cq['push'](new FeatureLabelStyle3D(cJ));
              }
              this['label'] = cq;
          }
      }
      ig['DefaultOptions'] = Object['assign'](Object['assign']({}, iB['_7']['DefaultOptions']), {
          'closeTop': true,
          'closeBottom': true
      });
      class FeatureStyle3D extends iB['sC'] {
          constructor(cd) {
              super(cd);
          }
          ['_update'](cd, cq) {
              cd && (cd['point'] && (this['point'] && !cq ? this['point']['update'](cd['point']) : this['point'] = new iO(cd['point'])),
              cd['polyline'] && (this['polyline'] && !cq ? this['polyline']['update'](cd['polyline']) : this['polyline'] = new PolylineStyle3D(cd['polyline'])),
              cd['polygon'] && (this['polygon'] && !cq ? this['polygon']['update'](cd['polygon']) : this['polygon'] = new ig(cd['polygon'])));
          }
      }
      class iP extends iq['Uw'] {
          constructor(cd) {
              super(cd),
              cd || v0['kg']['error']('PointImageStyle3D', true),
              this['_update'](cd, true);
          }
          ['_update'](cd, cq) {
              cq ? (this['textureDim'] = (0x0,
              iS['ce'])((0x0,
              Kz['En'])(cd['textureDim'], iP['DefaultOptions']['textureDim'])),
              this['size'] = (0x0,
              Kz['En'])(cd['size'], iP['DefaultOptions']['size']),
              this['scaleMax'] = (0x0,
              Kz['En'])(cd['scaleMax'], iP['DefaultOptions']['scaleMax'])) : (this['textureDim'] = (0x0,
              Kz['Rf'])(cd['textureDim'], this['textureDim'], iS['ce']),
              this['size'] = (0x0,
              Kz['Rf'])(cd['size'], this['size'], iS['ce'])),
              this['texture'] = (0x0,
              Kz['Rf'])(cd['texture'], this['texture'], iS['Rd']);
          }
          ['_createCacheId'](cd) {
              return '0';
          }
      }
      iP['DefaultOptions'] = {
          'textureDim': [0x1, 0x1],
          'texture': undefined,
          'size': 0x20,
          'scaleMax': 0x1
      };
      class CSStyle3D extends FeatureStyle3D {
          constructor(cd) {
              cd['analysisValues'] ? super(cd) : v0['kg']['error']('analysisValues', true);
          }
          ['_update'](cd, cq) {
              cq ? (this['analysisValues'] = (0x0,
              iB['M'])(cd['analysisValues']),
              this['withShaded'] = (0x0,
              Kz['En'])(cd['withShaded'], CSStyle3D['DefaultOptions']['withShaded'])) : (this['analysisValues'] = (0x0,
              Kz['Rf'])(cd['analysisValues'], this['analysisValues'], iB['M']),
              this['withShaded'] = (0x0,
              Kz['Rf'])(cd['withShaded'], this['withShaded'])),
              this['interpField'] = (0x0,
              Kz['Rf'])(cd['interpField'], this['interpField']),
              this['interpGridOptions'] = (0x0,
              Kz['Rf'])(cd['interpGridOptions'], this['interpGridOptions']),
              this['interpGridOptions'] && (0x0,
              KM['T'])(this['interpGridOptions']),
              this['undef'] = (0x0,
              Kz['Rf'])(cd['undef'], this['undef']),
              super['_update'](cd, cq);
          }
      }
      CSStyle3D['DefaultOptions'] = Object['assign'](Object['assign']({}, iB['sC']['DefaultOptions']), {
          'withShaded': true,
          'analysisValues': undefined
      });
      var iz = n(0x13c);
      class LayerCreator {
          constructor() {
              this['creators'] = {},
              this['providerCreators'] = {};
          }
          ['create'](cd) {
              const cq = new this['creators'][cd['type']](cd['options']);
              cq['setDrawOptions']((0x0,
              iq['it'])(cd['style']));
              const cJ = this['createProvider'](cd['data']);
              return cq['setDataSource'](cJ),
              cq['id'] = cd['name'] || (0x0,
              Kz['hQ'])(),
              cq;
          }
          ['createProvider'](cd) {
              if (!cd || !cd['source'] || !cd['type'])
                  return;
              let cq;
              if (cd['source2']) {
                  const cJ = cd
                    , cC = new (0x0,
                  this['providerCreators'][cJ['source']['type']])((0x0,
                  iq['it'])(cJ['source']['source']),cJ['source']['options'])
                    , cO = new (0x0,
                  this['providerCreators'][cJ['source2']['type']])((0x0,
                  iq['it'])(cJ['source2']['source']),cJ['source2']['options']);
                  cq = new (0x0,
                  this['providerCreators'][cJ['type']])(cC,cO,cJ['options']);
              } else {
                  const cG = (0x0,
                  iq['it'])(cd['source']);
                  cq = new (0x0,
                  this['providerCreators'][cd['type']])(cG,cd['options']);
              }
              return cq;
          }
          ['registerProviderCreator'](cd, cq) {
              (cq = cq || cd['qeName']) || v0['kg']['error'](''),
              this['providerCreators'][cq] = cd;
          }
          ['register'](cd, cq) {
              (cq = cq || cd['qeName']) || v0['kg']['error'](''),
              this['creators'][cq] = cd;
          }
      }
      function im(cd, cq, cJ) {
          const cC = cG=>{
              var cg;
              const cN = null !== (cg = cG['layerCreator']) && undefined !== cg ? cg : iL
                , cP = [];
              if (cG['layers'])
                  for (const cM of cG['layers']) {
                      const cz = cN['create'](cM);
                      cz && (cq(cz),
                      cP['push'](cz));
                  }
              cJ && cJ(cP);
          }
            , cO = cG=>{
              var cg;
              const cN = null !== (cg = cG['resourceService']) && undefined !== cg ? cg : iz['Zc'];
              cG['resources'] ? 'string' == typeof cG['resources'] || cG['resources']instanceof Request ? cN['loadResourceFromConfigPath'](cG['resources'])['then'](cP=>{
                  cC(cG);
              }
              )['catch'](v0['kg']['debug']) : cN['loadResourceFromConfig'](cG['resources'])['then'](cP=>{
                  cC(cG);
              }
              )['catch'](v0['kg']['debug']) : cC(cG);
          }
          ;
          'string' == typeof cd ? (0x0,
          Kz['xA'])(cd)['then'](cG=>{
              cO(cG);
          }
          )['catch'](v0['kg']['debug']) : cO(cd);
      }
      const iL = new LayerCreator();
      var iR = n(0x260)
        , b0 = n(0x313);
      class Array2DGridDataProvider extends Km['r'] {
          constructor(cd, cq) {
              super(cq),
              this['gridOptions'] = this['options']['gridOptions'],
              'function' == typeof cd && (cd = cd()),
              cd || v0['kg']['error']('');
              let cJ = 0x0;
              undefined === this['options']['dataScale'] && undefined === this['options']['dataOffset'] || (this['options']['dataScale'] = (0x0,
              Kz['En'])(this['options']['dataScale'], 0x1),
              this['options']['dataOffset'] = (0x0,
              Kz['En'])(this['options']['dataOffset'], 0x0),
              cJ = undefined === this['options']['scaleFirst'] || this['options']['scaleFirst'] ? 0x1 : 0x2);
              const cC = new KN['P'](KP['U']['Float32'],this['gridOptions']['xSize'],this['gridOptions']['ySize'],cd,this['options']['undef'],cJ,this['options']['dataScale'] || 0x1,this['options']['dataOffset'] || 0x0);
              this['grids'] = [[cC]];
          }
      }
      Array2DGridDataProvider['qeName'] = 'g_array2d',
      iL['registerProviderCreator'](Array2DGridDataProvider);
      class CimissGridDataProvider extends Array2DGridDataProvider {
          constructor(cd, cq) {
              'string' == typeof cd && (cd = JSON['parse'](cd)),
              super(cd['DS'], Object['assign']({
                  'gridOptions': {
                      'xStart': cd['startLon'],
                      'yStart': cd['startLat'],
                      'xDelta': cd['lonStep'],
                      'yDelta': cd['latStep'],
                      'xSize': cd['lonCount'],
                      'ySize': cd['latCount'],
                      'xEnd': cd['endLon'],
                      'yEnd': cd['endLat'],
                      'zValues': [0x0],
                      'tCount': 0x1
                  }
              }, cq || {}));
          }
      }
      CimissGridDataProvider['qeName'] = 'g_cimiss',
      iL['registerProviderCreator'](CimissGridDataProvider);
      class FeatureDataProviderBase extends iT['c'] {
          constructor() {
              super(...arguments),
              this['eventNames'] = {
                  'dataUpdated': 'dataUpdated'
              },
              this['meta'] = {};
          }
          ['updateFeatures'](cd) {
              this['_updateFeatures'](cd),
              this['fire'](this['eventNames']['dataUpdated'], {
                  'firer': this,
                  'msg': this
              });
          }
          ['onFeaturesUpdate'](cd) {
              return this['on'](this['eventNames']['dataUpdated'], cd),
              this;
          }
          ['offFeaturesUpdate'](cd) {
              return this['off'](this['eventNames']['dataUpdated'], cd),
              this;
          }
          ['getMaxMin'](cd, cq, cJ=true) {
              cq = null != cq ? cq : Kg['v']['defaultUndef'];
              const cC = this['getFeatures']()['features'];
              if (!(null == cC ? undefined : cC['length']))
                  return {
                      'min': undefined,
                      'max': undefined
                  };
              let cO = 0x1 / 0x0
                , cG = -0x1 / 0x0
                , cg = cN=>false;
              cJ && (cg = cq > 0x0 ? cN=>cN >= cq : cN=>cN <= cq);
              for (const cN of cC) {
                  const cP = cN['properties'][cd];
                  cg(cP) || (cP > cG && (cG = cP),
                  cP < cO && (cO = cP));
              }
              return {
                  'min': cO,
                  'max': cG
              };
          }
      }
      class b4 extends FeatureDataProviderBase {
          constructor(cd, cq) {
              super(),
              this['featuresMap'] = {},
              cd || v0['kg']['error'](''),
              this['options'] = (0x0,
              Kz['Ov'])(this['options'], cq, b4['DefaultOptions']),
              'function' == typeof cd && (cd = cd()),
              this['parseFeatures'](cd);
          }
          ['_updateFeatures'](cd) {
              this['features'] = undefined,
              this['featuresMap'] = {},
              this['parseFeatures'](cd);
          }
          ['parseFeatures'](cd) {
              let cq = new Array();
              const cJ = this['options']['prefix'] && this['options']['prefix']['length'] > 0x0 || this['options']['suffix'] && this['options']['suffix']['length'] > 0x0 ? (cC,cO,cG)=>{
                  cC[cO] = this['options']['prefix'] + cG + this['options']['suffix'];
              }
              : (cC,cO,cG)=>{
                  cC[cO] = cG;
              }
              ;
              for (let cC of cd) {
                  let cO, cG = cC[this['options']['idField']];
                  if (undefined === cG && (cG = (0x0,
                  Kz['hQ'])()),
                  undefined !== this['featuresMap'][cG])
                      cO = this['featuresMap'][cG];
                  else {
                      let cg;
                      if (cC[this['options']['latField']] && cC[this['options']['lonField']])
                          cg = {
                              'type': 'Point',
                              'coordinates': [parseFloat(cC[this['options']['lonField']]), parseFloat(cC[this['options']['latField']])]
                          };
                      else {
                          if (!this['options']['stationInfoMap'])
                              throw new Error('');
                          cg = {
                              'type': 'Point',
                              'coordinates': [this['options']['stationInfoMap'][cG][this['options']['lonField']], this['options']['stationInfoMap'][cG][this['options']['latField']]]
                          };
                      }
                      cO = {
                          'id': cG,
                          'type': 'Feature',
                          'geometry': cg,
                          'properties': {}
                      },
                      cq['push'](cO);
                  }
                  for (let cN in cC)
                      undefined !== cO['properties'][cN] && undefined !== this['options']['mergeFunc'] ? cO['properties'][cN] = this['options']['mergeFunc'](cN, cO['properties'][cN], cC[cN]) : cJ(cO['properties'], cN, cC[cN]);
                  this['featuresMap'][cG] = cO;
              }
              this['features'] = {
                  'type': 'FeatureCollection',
                  'features': cq
              };
          }
          ['getFeatures']() {
              return this['features'];
          }
          ['getFeature'](cd) {
              return this['featuresMap'][cd];
          }
      }
      b4['DefaultOptions'] = {
          'lonField': 'Lon',
          'latField': 'Lat',
          'idField': 'Station_Id_C'
      },
      b4['qeName'] = 'v_array',
      iL['registerProviderCreator'](b4);
      class CimissStationFeatureProvider extends b4 {
          constructor(cd, cq) {
              super(()=>('string' == typeof cd && (cd = JSON['parse'](cd)),
              cd['DS']), cq),
              this['headers'] = {};
              for (const cJ in cd)
                  'DS' !== cJ && (this['headers'][cJ] = cd[cJ]);
              this['meta'] = this['headers'];
          }
          ['_updateFeatures'](cd) {
              'string' == typeof cd && (cd = JSON['parse'](cd));
              for (const cq in cd)
                  'DS' !== cq && (this['headers'][cq] = cd[cq]);
              super['_updateFeatures'](cd['DS']);
          }
      }
      CimissStationFeatureProvider['qeName'] = 'v_cimiss',
      iL['registerProviderCreator'](CimissStationFeatureProvider);
      class QEGridDataProvider extends Km['r'] {
          constructor(cd, cq) {
              super(cq),
              this['load'](cd);
          }
          ['getDataType'](cd, cq) {
              switch (cd) {
              case 'Int8':
                  return cq ? KP['U']['UInt8'] : KP['U']['Int8'];
              case 'Int16':
                  return cq ? KP['U']['UInt16'] : KP['U']['Int16'];
              case 'Int32':
                  return cq ? KP['U']['UInt32'] : KP['U']['Int32'];
              case 'Int64':
                  return console['log']('Int64\x20currently\x20not\x20supported,use\x20Int32\x20instead!'),
                  cq ? KP['U']['UInt32'] : KP['U']['Int32'];
              case 'Float32':
                  return KP['U']['Float32'];
              case 'Float64':
                  return KP['U']['Float64'];
              default:
                  throw new Error('' + cd);
              }
          }
          ['load'](cd) {
              const cq = new BinaryReader(cd,true)
                , cJ = cq['readInt32']()
                , cC = String['fromCharCode']['apply'](null, new Uint8Array(cq['readBuffer'](cJ)));
              this['meta'] = JSON['parse'](cC),
              this['options']['meta'] && (this['meta'] = Object['assign'](Object['assign']({}, this['meta']), this['options']['meta'])),
              this['meta']['times'] = (0x0,
              Kz['En'])(this['meta']['times'], 0x1),
              (undefined === this['meta']['undef'] || isNaN(this['meta']['undef']) || null === this['meta']['undef']) && (v0['kg']['warn']('consts.defaultUndef=' + Kg['v']['defaultUndef'] + ''),
              this['meta']['undef'] = Kg['v']['defaultUndef']),
              this['grids'] = [],
              undefined !== this['meta']['algo'] && 0x1 === parseInt(this['meta']['algo']) ? this['loadByteGrid'](cq) : this['loadOriginalGrid'](cq),
              this['gridOptions'] = {
                  'xStart': this['meta']['xStart'],
                  'xSize': this['meta']['xSize'],
                  'xEnd': this['meta']['xEnd'],
                  'yStart': this['meta']['yStart'],
                  'ySize': this['meta']['ySize'],
                  'yEnd': this['meta']['yEnd'],
                  'zValues': this['meta']['levelList'],
                  'tCount': this['meta']['times']
              },
              (0x0,
              KM['T'])(this['gridOptions']);
          }
          ['loadOriginalGrid'](cd) {
              const cq = (cd['buffer']['byteLength'] - cd['offset']) / (this['meta']['times'] * this['meta']['levels']);
              let cJ = 0x0;
              (this['meta']['dataScale'] || this['meta']['dataOffset']) && (cJ = 0x1);
              for (let cC = 0x0; cC < this['meta']['times']; cC++) {
                  const cO = [];
                  for (let cG = 0x0; cG < this['meta']['levels']; cG++) {
                      const cg = cd['readBuffer'](cq)
                        , cN = new KN['P'](this['getDataType'](this['meta']['dataType'], this['meta']['unsigned']),this['meta']['xSize'],this['meta']['ySize'],cg,0x1 * this['meta']['undef'],cJ,this['meta']['dataScale'] || 0x1,this['meta']['dataOffset'] || 0x0);
                      cO['push'](cN);
                  }
                  this['grids']['push'](cO);
              }
          }
          ['loadByteGrid'](cd) {
              const cq = (cd['buffer']['byteLength'] - cd['offset']) / (this['meta']['times'] * this['meta']['levels'])
                , cJ = this['meta']['min'] || this['meta']['vmin']
                , cC = this['meta']['max'] || this['meta']['vmax'];
              for (let cO = 0x0; cO < this['meta']['times']; cO++) {
                  const cG = [];
                  for (let cg = 0x0; cg < this['meta']['levels']; cg++) {
                      const cN = cC[cg] - cJ[cg]
                        , cP = cd['readBuffer'](cq)
                        , cM = new KN['P'](this['getDataType'](this['meta']['dataType'], this['meta']['unsigned']),this['meta']['xSize'],this['meta']['ySize'],cP,0xff,0x1,cN / 0xfe,cJ[cg]);
                      cM['undef'] = 0xff,
                      cG['push'](cM);
                  }
                  this['grids']['push'](cG);
              }
          }
      }
      QEGridDataProvider['qeName'] = 'g_qe',
      iL['registerProviderCreator'](QEGridDataProvider);
      class GeoJSONFeatureProvider extends FeatureDataProviderBase {
          constructor(cd) {
              super(),
              this['featuresMap'] = {},
              cd || v0['kg']['warn'](''),
              this['_updateFeatures'](cd);
          }
          ['parseFeatures'](cd) {
              if (!cd)
                  return;
              let cq;
              switch (cd['type']) {
              case 'Point':
              case 'MultiPoint':
              case 'LineString':
              case 'MultiLineString':
              case 'Polygon':
              case 'MultiPolygon':
              case 'GeometryCollection':
                  return this['parseFeatures']({
                      'type': 'Feature',
                      'geometry': cd,
                      'properties': {}
                  });
              case 'Feature':
                  cq = {
                      'type': 'FeatureCollection',
                      'features': [cd]
                  };
                  break;
              case 'FeatureCollection':
                  cq = cd;
              }
              return cq;
          }
          ['_updateFeatures'](cd) {
              this['featuresMap'] = {},
              this['features'] = undefined,
              this['features'] = this['parseFeatures'](cd),
              this['features'] && this['features']['features'] && this['features']['features']['forEach'](cq=>{
                  cq['id'] || (cq['id'] = (0x0,
                  Kz['hQ'])()),
                  this['featuresMap'][cq['id']] = cq;
              }
              );
          }
          ['addFeature'](cd) {
              cd['id'] = cd['id'] || (0x0,
              Kz['hQ'])(),
              this['features']['features']['push'](cd),
              this['featuresMap'][cd['id']] = cd;
          }
          ['removeFeature'](cd) {
              const cq = this['getFeature'](cd);
              if (cq) {
                  const cJ = this['features']['features']['indexOf'](cq);
                  this['features']['features']['splice'](cJ, 0x1),
                  delete this['featuresMap'][cd];
              }
          }
          ['getFeatures']() {
              return this['features'];
          }
          ['getFeature'](cd) {
              if (this['features'])
                  return this['featuresMap'][cd];
          }
      }
      GeoJSONFeatureProvider['qeName'] = 'v_geojson',
      iL['registerProviderCreator'](GeoJSONFeatureProvider);
      class MemoryWindDataProvider extends Km['r'] {
          constructor(cd, cq, cJ) {
              var cC;
              super((0x0,
              Kz['Ov'])({}, cJ, MemoryWindDataProvider['DefaultOptions'])),
              this['gridOptions'] = (null == cd ? undefined : cd['gridOptions']) || cJ['gridOptions'],
              this['defaultGrid'] = null == cJ ? undefined : cJ['defaultGrid'],
              this['meta'] = Object['assign'](Object['assign'](Object['assign']({}, null !== (cC = this['meta']) && undefined !== cC ? cC : {}), (null == cd ? undefined : cd['meta']) || {}), (null == cq ? undefined : cq['meta']) || {}),
              this['options']['isUV'] ? (this['u'] = (null == cd ? undefined : cd['allGrids']()) || [],
              this['v'] = (null == cq ? undefined : cq['allGrids']()) || [],
              this['speed'] = [],
              this['dir'] = []) : (this['speed'] = (null == cd ? undefined : cd['allGrids']()) || [],
              this['dir'] = (null == cq ? undefined : cq['allGrids']()) || [],
              this['u'] = [],
              this['v'] = []),
              !this['options']['lazyCalc'] && cd && cq && (this['options']['isUV'] ? this['parseDataByUV']() : this['parseDataBySD']()),
              this['grids'] = this[this['options']['defaultGrid'] || 'speed'];
          }
          get['wProvider']() {
              return this['options']['wProvider'];
          }
          ['allU']() {
              var cd;
              return (null === (cd = this['u']) || undefined === cd ? undefined : cd['length']) || this['parseDataBySD'](),
              this['u'];
          }
          ['allV']() {
              var cd;
              return (null === (cd = this['v']) || undefined === cd ? undefined : cd['length']) || this['parseDataBySD'](),
              this['v'];
          }
          ['allW']() {
              var cd;
              return null === (cd = this['options']['wProvider']) || undefined === cd ? undefined : cd['allGrids']();
          }
          ['allS']() {
              var cd;
              return (null === (cd = this['speed']) || undefined === cd ? undefined : cd['length']) || this['parseDataByUV'](),
              this['speed'];
          }
          ['allD']() {
              var cd;
              return (null === (cd = this['dir']) || undefined === cd ? undefined : cd['length']) || this['parseDataByUV'](),
              this['dir'];
          }
          ['addUV'](cd, cq, cJ, cC, cO, cG) {
              if (this['lock'](),
              this['addGridTo'](cd, cJ, cC, cO, cG, this['u']),
              this['addGridTo'](cq, cJ, cC, cO, cG, this['v']),
              !this['options']['lazyCalc']) {
                  const cg = this['parseSingleGridByUV'](cd, cq, cd['xSize'] * cd['ySize']);
                  this['addGridTo'](cg[0x0], cJ, cC, cO, cG, this['speed']),
                  this['addGridTo'](cg[0x1], cJ, cC, cO, cG, this['dir']);
              }
              return this['unlock'](),
              this;
          }
          ['addSD'](cd, cq, cJ, cC, cO, cG) {
              if (!this['options']['lazyCalc']) {
                  const cg = this['parseSingleGridBySD'](cd, cq, cd['xSize'] * cd['ySize']);
                  this['addGridTo'](cg[0x0], cJ, cC, cO, cG, this['u']),
                  this['addGridTo'](cg[0x1], cJ, cC, cO, cG, this['v']);
              }
              this['lock'](),
              this['addGridTo'](cd, cJ, cC, cO, cG, this['speed']),
              this['addGridTo'](cq, cJ, cC, cO, cG, this['dir']),
              this['unlock']();
          }
          ['parseSingleGridByUV'](cd, cq, cJ) {
              const cC = new KN['P'](KP['U']['Float32'],this['gridOptions']['xSize'],this['gridOptions']['ySize'],undefined,cd['undef'])
                , cO = new KN['P'](KP['U']['Float32'],this['gridOptions']['xSize'],this['gridOptions']['ySize'],undefined,cd['undef']);
              for (let cG = 0x0; cG < cJ; cG++) {
                  const cg = cd['read1D'](cG);
                  if (cd['isUndef'](cg)) {
                      cC['write1D'](cG, cd['undef']),
                      cO['write1D'](cG, cd['undef']);
                      continue;
                  }
                  const cN = cq['read1D'](cG);
                  if (cq['isUndef'](cN)) {
                      cC['write1D'](cG, cd['undef']),
                      cO['write1D'](cG, cd['undef']);
                      continue;
                  }
                  const cP = (0x0,
                  Kz['C8'])([cd['read1D'](cG), cq['read1D'](cG)]);
                  cC['write1D'](cG, cP[0x0]),
                  cO['write1D'](cG, cP[0x1]);
              }
              return [cC, cO];
          }
          ['parseDataByUV']() {
              const cd = []
                , cq = []
                , cJ = this['gridOptions']['ySize'] * this['gridOptions']['xSize'];
              for (let cC = 0x0; cC < this['u']['length']; cC++) {
                  const cO = this['u'][cC]
                    , cG = this['v'][cC]
                    , cg = []
                    , cN = [];
                  for (let cP = 0x0; cP < cO['length']; cP++) {
                      const cM = cO[cP]
                        , cz = cG[cP]
                        , cQ = this['parseSingleGridByUV'](cM, cz, cJ);
                      cg['push'](cQ[0x0]),
                      cN['push'](cQ[0x1]);
                  }
                  cd['push'](cg),
                  cq['push'](cN);
              }
              this['speed'] = cd,
              this['dir'] = cq;
          }
          ['parseSingleGridBySD'](cd, cq, cJ) {
              const cC = new KN['P'](KP['U']['Float32'],this['gridOptions']['xSize'],this['gridOptions']['ySize'],undefined,cd['undef'])
                , cO = new KN['P'](KP['U']['Float32'],this['gridOptions']['xSize'],this['gridOptions']['ySize'],undefined,cd['undef']);
              for (let cG = 0x0; cG < cJ; cG++) {
                  const cg = cd['read1D'](cG);
                  if (cd['isUndef'](cg)) {
                      cC['write1D'](cG, cd['undef']),
                      cO['write1D'](cG, cd['undef']);
                      continue;
                  }
                  const cN = cq['read1D'](cG);
                  if (cq['isUndef'](cN)) {
                      cC['write1D'](cG, cd['undef']),
                      cO['write1D'](cG, cd['undef']);
                      continue;
                  }
                  const cP = (0x0,
                  Kz['Hn'])([cd['read1D'](cG), cq['read1D'](cG)]);
                  cC['write1D'](cG, cP[0x0]),
                  cO['write1D'](cG, cP[0x1]);
              }
              return [cC, cO];
          }
          ['parseDataBySD']() {
              const cd = []
                , cq = []
                , cJ = this['gridOptions']['ySize'] * this['gridOptions']['xSize'];
              for (let cC = 0x0; cC < this['speed']['length']; cC++) {
                  const cO = this['speed'][cC]
                    , cG = this['dir'][cC]
                    , cg = []
                    , cN = [];
                  for (let cP = 0x0; cP < cO['length']; cP++) {
                      const cM = cO[cP]
                        , cz = cG[cP]
                        , cQ = this['parseSingleGridBySD'](cM, cz, cJ);
                      cg['push'](cQ[0x0]),
                      cN['push'](cQ[0x1]);
                  }
                  cd['push'](cg),
                  cq['push'](cN);
              }
              this['u'] = cd,
              this['v'] = cq;
          }
          ['getDimLevel'](cd, cq) {
              return {
                  'dim': undefined === cd ? this['getIntTIdx']() : parseInt(cd),
                  'level': undefined === cq ? this['getIntZIdx']() : parseInt(cq)
              };
          }
          ['getUV'](cd, cq, cJ, cC) {
              var cO;
              (null === (cO = this['u']) || undefined === cO ? undefined : cO['length']) || this['parseDataBySD']();
              const cG = this['getDimLevel'](cJ, cC)
                , cg = this['u'][cG['dim']][cG['level']]
                , cN = this['v'][cG['dim']][cG['level']];
              let cP = this['speed'][0x0][0x0]['getPos'](cd, cq);
              return [cg['read1D'](cP), cN['read1D'](cP)];
          }
          ['getSD'](cd, cq, cJ, cC) {
              var cO;
              (null === (cO = this['speed']) || undefined === cO ? undefined : cO['length']) || this['parseDataByUV']();
              const cG = this['getDimLevel'](cJ, cC)
                , cg = this['speed'][cG['dim']][cG['level']]
                , cN = this['dir'][cG['dim']][cG['level']];
              let cP = this['speed'][0x0][0x0]['getPos'](cd, cq);
              return [cg['read1D'](cP), cN['read1D'](cP)];
          }
          ['getU'](cd, cq) {
              var cJ;
              (null === (cJ = this['u']) || undefined === cJ ? undefined : cJ['length']) || this['parseDataBySD']();
              const cC = this['getDimLevel'](cd, cq);
              return this['u'][cC['dim']][cC['level']];
          }
          ['getV'](cd, cq) {
              var cJ;
              (null === (cJ = this['v']) || undefined === cJ ? undefined : cJ['length']) || this['parseDataBySD']();
              const cC = this['getDimLevel'](cd, cq);
              return this['v'][cC['dim']][cC['level']];
          }
          ['getW'](cd, cq) {
              if (!this['options']['wProvider'])
                  throw new Error('');
              const cJ = this['getDimLevel'](cd, cq);
              return this['options']['wProvider']['getGrid'](cJ['dim'], cJ['level']);
          }
          ['getS'](cd, cq) {
              var cJ;
              (null === (cJ = this['speed']) || undefined === cJ ? undefined : cJ['length']) || this['parseDataByUV']();
              const cC = this['getDimLevel'](cd, cq);
              return this['speed'][cC['dim']][cC['level']];
          }
          ['getD'](cd, cq) {
              var cJ;
              (null === (cJ = this['dir']) || undefined === cJ ? undefined : cJ['length']) || this['parseDataByUV']();
              const cC = this['getDimLevel'](cd, cq);
              return this['dir'][cC['dim']][cC['level']];
          }
          ['getGrid'](cd, cq) {
              const cJ = this['getDimLevel'](cd, cq);
              return this['allGrids']()[cJ['dim']][cJ['level']];
          }
          ['allGrids']() {
              var cd, cq, cJ, cC, cO;
              if (!(null === (cd = this['grids']) || undefined === cd ? undefined : cd['length'])) {
                  let cG;
                  'dir' === this['options']['defaultGrid'] ? ((null === (cq = this['dir']) || undefined === cq ? undefined : cq['length']) || this['parseDataByUV'](),
                  cG = this['dir']) : 'speed' === this['options']['defaultGrid'] ? ((null === (cJ = this['speed']) || undefined === cJ ? undefined : cJ['length']) || this['parseDataByUV'](),
                  cG = this['speed']) : 'u' === this['options']['defaultGrid'] ? ((null === (cC = this['u']) || undefined === cC ? undefined : cC['length']) || this['parseDataBySD'](),
                  cG = this['u']) : ((null === (cO = this['v']) || undefined === cO ? undefined : cO['length']) || this['parseDataBySD'](),
                  cG = this['v']),
                  this['grids'] = cG;
              }
              return this['grids'];
          }
      }
      MemoryWindDataProvider['DefaultOptions'] = {
          'isUV': true,
          'lazyCalc': false,
          'meta': {},
          'defaultGrid': 'speed'
      },
      MemoryWindDataProvider['qeName'] = 'g_wind',
      iL['registerProviderCreator'](MemoryWindDataProvider);
      class MicapsDiamond4GridDataProvider extends Array2DGridDataProvider {
          constructor(cd, cq) {
              const cJ = (cd = cd['replaceAll']('\x0a', '\x20')['replaceAll']('\x0d', '\x20'))['split'](/\s+/);
              for (; 0x0 === cJ[0x0]['trim']()['length']; )
                  cJ['shift']();
              for (; 0x0 === cJ[cJ['length'] - 0x1]['trim']()['length']; )
                  cJ['pop']();
              const cC = {
                  'xStart': Number(cJ[0xb]),
                  'xEnd': Number(cJ[0xc]),
                  'yStart': Number(cJ[0xd]),
                  'yEnd': Number(cJ[0xe]),
                  'xDelta': Number(cJ[0x9]),
                  'yDelta': Number(cJ[0xa]),
                  'xSize': Number(cJ[0xf]),
                  'ySize': Number(cJ[0x10])
              }
                , cO = cJ['splice'](0x0, 0x16);
              super(cJ, Object['assign']({
                  'gridOptions': cC
              }, cq)),
              this['headers'] = cO,
              this['meta'] = this['headers'];
          }
      }

      class MicapsDiamond131GridDataProvider extends Km['r'] {
          constructor(cd, cq) {
              super((0x0,
              Kz['Ov'])({}, cq, MicapsDiamond131GridDataProvider['DefaultOptions'])),
              this['_decoder'] = new TextDecoder()

              this['_load'](cd);
          }
          ['_readString'](cd, cq) {
              return this['_decoder']['decode'](cd['readBuffer'](cq))['replace'](/\0/g, '')['trim']();
          }
          ['_load'](cd) {
              const cq = new BinaryReader(cd,true);
              this['meta'] = {},
              this['meta']['zoneName'] = this['_readString'](cq, 0xc),
              this['meta']['dataName'] = this['_readString'](cq, 0x26);
              let cJ = this['_readString'](cq, 0x8)['toLowerCase']()
                , cC = '1.5';
              'swan' !== cJ ? (cJ = 'old',
              cC = '1.0',
              cq['seek'](cq['offset'] - 0x8)) : cC = this['_readString'](cq, 0x8),
              this['meta']['version'] = cC,
              this['meta']['year'] = cq['readUint16'](),
              this['meta']['month'] = cq['readUint16'](),
              this['meta']['day'] = cq['readUint16'](),
              this['meta']['hour'] = cq['readUint16'](),
              this['meta']['minute'] = cq['readUint16'](),
              this['meta']['interval'] = cq['readUint16'](),
              this['meta']['xNumGrids'] = cq['readUint16'](),
              this['meta']['yNumGrids'] = cq['readUint16'](),
              this['meta']['zNumGrids'] = cq['readUint16'](),
              this['meta']['radarCount'] = cq['readInt32'](),
              this['meta']['startLon'] = Number(cq['readFloat32']()['toPrecision'](0x6)),
              this['meta']['startLat'] = Number(cq['readFloat32']()['toPrecision'](0x6)),
              this['meta']['centerLon'] = Number(cq['readFloat32']()['toPrecision'](0x6)),
              this['meta']['centerLat'] = Number(cq['readFloat32']()['toPrecision'](0x6)),
              this['meta']['xReso'] = Number(cq['readFloat32']()['toPrecision'](0x6)),
              this['meta']['yReso'] = Number(cq['readFloat32']()['toPrecision'](0x6));
              let cO = [];
              for (let cm = 0x0; cm < 0x28; cm++) {
                  const cL = cq['readFloat32']();
                  cL > 0x0 && cO['push'](cL);
              }
              0x0 === cO['length'] ? cO = [0x0] : this['options']['isZUnitKM'] && (cO = cO['map'](cR=>0x3e8 * cR));
              let cG = 0x0;
              'swan' === cJ && (cG = 0x2f0),
              cq['skip'](cG);
              const cg = this['meta']['xNumGrids'] * this['meta']['yNumGrids']
                , cN = cg * this['meta']['zNumGrids']
                , cP = cq['buffer']['byteLength'] - cN
                , cM = (cq['buffer']['byteLength'] - cP) / (cg * this['meta']['zNumGrids'])
                , cz = cg * cM;
              this['gridOptions'] = {
                  'xStart': this['meta']['startLon'],
                  'xSize': this['meta']['xNumGrids'],
                  'xDelta': this['meta']['xReso'],
                  'yStart': this['meta']['startLat'],
                  'ySize': this['meta']['yNumGrids'],
                  'yDelta': -this['meta']['yReso'],
                  'zValues': cO,
                  'tCount': 0x1
              },
              (0x0,
              KM['T'])(this['gridOptions']);
              const cQ = 0x1 === cM ? KP['U']['UInt8'] : KP['U']['Int16'];
              this['grids'] = [[]];
              for (let cR = 0x0; cR < cO['length']; cR++) {
                  const H0 = cq['readBuffer'](cz)
                  const  H1 = new KN['P'](cQ,this['gridOptions']['xSize'],this['gridOptions']['ySize'],H0,0x1 === cM ? 0xff : 0x270f,0x2,0x1 === cM ? 0.5 : 0x1,0x1 === cM ? -0x42 : 0x0);
                  this['grids'][0x0]['push'](H1);
              }
          }
          //mars3d  2024-12-29
          toJSON(){
            let gridData=[]
            for (let i = 0; i < this.grids[0].length; i++) {
              let grid = this.grids[0][i]
              gridData.push(Array.from(grid.raw))
            }
            return {
              grids:gridData,
              options:this.gridOptions
            }
          }
      }
      MicapsDiamond131GridDataProvider['DefaultOptions'] = {
          'isZUnitKM': true
      };
      function arrayToArrayBuffer(array) {
        const buffer = new ArrayBuffer(array.length);
        const view = new Uint8Array(buffer);
        for (let i = 0; i < array.length; i++) {
            view[i] = array[i];  // 
        }
        return buffer;
    }

     //mars3d  2024-12-29
      class JsonGridDataProvider extends Km['r'] {
        constructor(cd, cq) {
            super((0x0, Kz['Ov'])({}, cq, JsonGridDataProvider['DefaultOptions']))
            this._load(cd);
        }
        _load(data) {
         this.gridOptions=data.options

         let cM = 1
         this.grids = [[]];
         for (let i = 0x0; i < data.grids.length; i++) {
          let grid = arrayToArrayBuffer(data.grids[i])

          const  H1 = new KN['P'](
            cM,
            this.gridOptions.xSize,
            this.gridOptions.ySize,
            grid,
            0x1 === cM ? 0xff : 0x270f,
            0x2,
            0x1 === cM ? 0.5 : 0x1,0x1 === cM ? -0x42 : 0x0
          );
          this.grids[0].push(H1);
         }
        }
      }
      JsonGridDataProvider['DefaultOptions'] = {
        'isZUnitKM': true
      };


      class BinaryGridDataProvider extends Km['r'] {
          constructor(cd, cq) {
              super(cq),
              this['load'](cd);
          }
          ['load'](cd) {
              let cq = this['parseBinaryToGridDatas'](cd);
              this['gridOptions'] = this['getGridOptionsFromGridMetaInfo'](cq['metaInfo']),
              this['grids'] = cq['martixData'];
          }
          ['parseBinaryToGridDatas'](cd) {
              if (undefined === cd)
                  return;
              let cq = new Uint8Array(cd['slice'](0x0, 0xc))
                , cJ = String['fromCharCode']['apply'](null, cq)
                , cC = parseInt(String['fromCharCode']['apply'](null, new Uint8Array(cd['slice'](0xc, 0x14))))
                , cO = String['fromCharCode']['apply'](null, new Uint8Array(cd['slice'](0x14, cC)))['split'](',')
                , cG = {};
              for (let cQ of cO) {
                  let cm = cQ['split']('=');
                  cG[cm[0x0]] = cm[0x1];
              }
              let cg = {
                  'productId': cG['ProductId'],
                  'productTitle': cG['ProductTitle'],
                  'year': parseInt(cG['Year']),
                  'month': parseInt(cG['Month']),
                  'day': parseInt(cG['Day']),
                  'hour': parseInt(cG['Hour']),
                  'minute': parseInt(cG['Minute']),
                  'second': parseInt(cG['Second']),
                  'forecast': cG['Forecast'],
                  'width': parseInt(cG['Width']),
                  'height': parseInt(cG['Height']),
                  'dimension': parseInt(cG['Dimension']),
                  'levels': parseInt(cG['Levels']),
                  'left': parseFloat(cG['Left']),
                  'right': parseFloat(cG['Right']),
                  'top': parseFloat(cG['Top']),
                  'bottom': parseFloat(cG['Bottom']),
                  'resolutionX': parseFloat(cG['Resolution_x']),
                  'resolutionY': parseFloat(cG['Resolution_y']),
                  'resolutionCell': parseFloat(cG['ResolutionCell']),
                  'dataType': parseInt(cG['DataType']),
                  'levelValue': cG['LevelValue'] && cG['LevelValue']['split'](';'),
                  'levelUnit': cG['LevelUnit'],
                  'machine': cG['Machine'],
                  'storage': cG['Storage'],
                  'coordinateion': cG['Coordination'],
                  'palette': cG['Palette'],
                  'siteCode': cG['SiteCode'] && cG['SiteCode']['split'](';'),
                  'invalid': parseFloat(cG['Invalid']),
                  'offset': parseFloat(cG['Offset']),
                  'ratio': parseFloat(cG['Ratio'])
              };
              this['meta'] = cg;
              let cN = this['getDataSizeFromBinaryType'](cg['dataType'])
                , cP = cg['width'] * cg['height'] * cN
                , cM = cC
                , cz = [];
              for (let cL = 0x0; cL < cg['dimension']; cL++) {
                  cz[cL] = [];
                  for (let cR = 0x0; cR < cg['levels']; cR++) {
                      let H0 = cd['slice'](cM, cM + cP)
                        , H1 = new KN['P'](this['getDataTypeFromBinaryType'](cg['dataType']),cg['width'],cg['height'],H0,cg['invalid'],0x1,cg['ratio'],cg['offset']);
                      H1['undef'] = cg['invalid'],
                      cM += cP,
                      cz[cL][cR] = H1;
                  }
              }
              return {
                  'fileId': cJ,
                  'dataAddr': cC,
                  'metaInfo': cg,
                  'sourceMetaInfo': cG,
                  'martixData': cz
              };
          }
          ['getDataSizeFromBinaryType'](cd) {
              switch (cd) {
              case 0x0:
                  return console['warn']('charuint8'),
                  Uint8Array['BYTES_PER_ELEMENT'];
              case 0x3:
                  return Uint8Array['BYTES_PER_ELEMENT'];
              case 0x1:
                  return Int16Array['BYTES_PER_ELEMENT'];
              case 0x2:
                  return Int32Array['BYTES_PER_ELEMENT'];
              case 0x4:
                  return Uint16Array['BYTES_PER_ELEMENT'];
              case 0x5:
                  return Uint32Array['BYTES_PER_ELEMENT'];
              case 0x6:
                  return Float32Array['BYTES_PER_ELEMENT'];
              case 0x7:
                  return Float64Array['BYTES_PER_ELEMENT'];
              }
          }
          ['getDataTypeFromBinaryType'](cd) {
              switch (cd) {
              case 0x0:
                  return console['warn']('charuint8'),
                  KP['U']['UInt8'];
              case 0x3:
                  return KP['U']['UInt8'];
              case 0x1:
                  return KP['U']['Int16'];
              case 0x2:
                  return KP['U']['Int32'];
              case 0x4:
                  return KP['U']['UInt16'];
              case 0x5:
                  return KP['U']['UInt32'];
              case 0x6:
                  return KP['U']['Float32'];
              case 0x7:
                  return KP['U']['Float64'];
              }
          }
          ['getGridOptionsFromGridMetaInfo'](cd) {
              var cq;
              let cJ = [0x0];
              return cd['levelValue'] && (cJ = null === (cq = cd['levelValue']) || undefined === cq ? undefined : cq['map'](cC=>parseFloat(cC))),
              {
                  'xStart': cd['left'],
                  'xEnd': cd['right'],
                  'yStart': cd['top'],
                  'yEnd': cd['bottom'],
                  'xSize': cd['width'],
                  'ySize': cd['height'],
                  'xDelta': cd['left'] < cd['right'] ? Math['abs'](cd['resolutionX']) : -Math['abs'](cd['resolutionX']),
                  'yDelta': cd['bottom'] > cd['top'] ? Math['abs'](cd['resolutionY']) : -Math['abs'](cd['resolutionY']),
                  'tCount': this['grids']['length'],
                  'zValues': cJ
              };
          }
      }
      var DataAnimationType, bK = function(cd, cq, cJ, cC) {
          return new (cJ || (cJ = Promise))(function(cO, cG) {
              function cg(cM) {
                  try {
                      cP(cC['next'](cM));
                  } catch (cz) {
                      cG(cz);
                  }
              }
              function cN(cM) {
                  try {
                      cP(cC['throw'](cM));
                  } catch (cz) {
                      cG(cz);
                  }
              }
              function cP(cM) {
                  var cz;
                  cM['done'] ? cO(cM['value']) : (cz = cM['value'],
                  cz instanceof cJ ? cz : new cJ(function(cQ) {
                      cQ(cz);
                  }
                  ))['then'](cg, cN);
              }
              cP((cC = cC['apply'](cd, cq || []))['next']());
          }
          );
      };
      window['GeoTIFF'] || (v0['kg']['debug']('GeoTIFFGeoTIFF'),
      window['GeoTIFF'] = {});
      class bb extends Km['r'] {
          constructor(cd, cq) {
              super(cq),
              this['getDataType'] = cJ=>{
                  switch (cJ['constructor']['name']) {
                  case 'Int8Array':
                      return KP['U']['Int8'];
                  case 'Uint8Array':
                      return KP['U']['UInt8'];
                  case 'Int16Array':
                      return KP['U']['Int16'];
                  case 'Uint16Array':
                      return KP['U']['UInt16'];
                  case 'Int32Array':
                      return KP['U']['Int32'];
                  case 'Uint32Array':
                      return KP['U']['UInt32'];
                  case 'Float32Array':
                      return KP['U']['Float32'];
                  case 'Float64Array':
                      return KP['U']['Float64'];
                  default:
                      throw new Error('' + cJ['constructor']['name']);
                  }
              }
              ,
              this['load'] = (cJ,cC)=>{
                  var cO;
                  this['gridOptions'] = cC['gridOptions'],
                  (0x0,
                  KM['T'])(this['gridOptions']);
                  let cG = [];
                  const cg = this['getDataType'](cJ[0x0])
                    , cN = cC['undef'] ? cC['undef'] : Kg['v']['defaultUndef']
                    , cP = new KN['P'](cg,this['gridOptions']['xSize'],this['gridOptions']['ySize'],cJ[0x0],cN);
                  cP['useAccurateUndef'] = null !== (cO = cC['useAccurateUndef']) && undefined !== cO && cO,
                  cG['push'](cP),
                  this['grids']['push'](cG);
              }
              ,
              this['load'](cd, cq);
          }
          static['fromUrl'](cd, cq={}) {
              return bK(this, undefined, undefined, function*() {
                  const cJ = yield(0x0,
                  Kz['oT'])(cd);
                  return bb['fromBuffer'](cJ, cq);
              });
          }
      }
      bb['readTifBuffer'] = cd=>bK(undefined, undefined, undefined, function*() {
          const cq = yield window['GeoTIFF']['fromArrayBuffer'](cd)
            , cJ = yield cq['getImage']()
            , cC = cJ['getResolution']()
            , cO = cJ['getOrigin']()
            , cG = cJ['getWidth']()
            , cg = cJ['getHeight']();
          return {
              'options': {
                  'xStart': cO[0x0],
                  'yStart': cO[0x1],
                  'xDelta': cC[0x0],
                  'yDelta': cC[0x1],
                  'xSize': cG,
                  'ySize': cg
              },
              'data': yield cJ['readRasters']()
          };
      }),
      bb['fromBuffer'] = (cd,cq={})=>bK(undefined, undefined, undefined, function*() {
          return bb['readTifBuffer'](cd)['then'](cJ=>(cq['gridOptions'] = cq['gridOptions'] || cJ['options'],
          new bb(cJ['data'],cq)))['catch'](cJ=>{}
          );
      }),
      bb['qeName'] = 'g_tif';
      class MicapsDiamond14FeatureProvider extends FeatureDataProviderBase {
          constructor(cd, cq) {
              super(),
              this['featuresMap'] = {},
              this['_parseFeatures'](cd);
          }
          ['_updateFeature'](cd) {
              this['features']['features']['push'](cd),
              this['featuresMap'][cd['id']] = cd;
          }
          ['_parseClosedContours'](cd) {
              let cq = cd['indexOf']('CLOSED_CONTOURS:');
              if (cq < 0x0)
                  return;
              cq++;
              const cJ = parseInt(cd[cq++]);
              for (let cC = 0x0; cC < cJ; cC++) {
                  const cO = cd[cq++]
                    , cG = parseInt(cd[cq++]);
                  if (0x0 === cG)
                      continue;
                  const cg = [];
                  for (let cz = 0x0; cz < cG; cz++) {
                      const cQ = parseFloat(cd[cq++])
                        , cm = parseFloat(cd[cq++]);
                      cg['push']([cQ, cm]),
                      cq++;
                  }
                  const cN = cd[cq++]
                    , cP = {
                      'type': 'Feature',
                      'geometry': {
                          'type': 'Polygon',
                          'coordinates': [cg]
                      },
                      'properties': {
                          'value': cN,
                          'width': cO
                      },
                      'id': (0x0,
                      Kz['hQ'])()
                  };
                  this['_updateFeature'](cP);
                  const cM = parseInt(cd[cq++]);
                  if (cM > 0x0)
                      for (let cL = 0x0; cL < cM; cL++) {
                          const cR = parseFloat(cd[cq++])
                            , H0 = parseFloat(cd[cq++]);
                          cq++;
                          const H1 = {
                              'type': 'Feature',
                              'geometry': {
                                  'type': 'Point',
                                  'coordinates': [cR, H0]
                              },
                              'properties': {
                                  'value': cN
                              },
                              'id': (0x0,
                              Kz['hQ'])()
                          };
                          this['_updateFeature'](H1);
                      }
              }
          }
          ['_parseFeatures'](cd) {
              this['features'] = {
                  'type': 'FeatureCollection',
                  'features': []
              },
              this['featuresMap'] = {};
              const cq = (cd = cd['replaceAll']('\x0a', '\x20')['replaceAll']('\x0d', '\x20'))['split'](/\s+/);
              for (; 0x0 === cq[0x0]['trim']()['length']; )
                  cq['shift']();
              for (; 0x0 === cq[cq['length'] - 0x1]['trim']()['length']; )
                  cq['pop']();
              if (cq['length'] < 0x8 || 'diamond' !== cq[0x0] || '14' !== cq[0x1])
                  throw new Error('Micaps\x2014');
              this['meta']['title'] = cq[0x2],
              this['meta']['year'] = 0x2 === cq[0x3]['length'] ? parseInt(cq[0x3]) + 0x7d0 : parseInt(cq[0x3]),
              this['meta']['mon'] = parseInt(cq[0x4]),
              this['meta']['day'] = parseInt(cq[0x5]),
              this['meta']['hour'] = parseInt(cq[0x6]),
              this['meta']['time'] = new Date(this['meta']['year'],this['meta']['mon'] - 0x1,this['meta']['day'],this['meta']['hour']),
              this['meta']['period'] = parseInt(cq[0x7]),
              this['_parseClosedContours'](cq);
          }
          ['_updateFeatures'](cd) {
              this['_parseFeatures'](cd);
          }
          ['getFeatures']() {
              return this['features'];
          }
          ['getFeature'](cd) {
              return this['featuresMap'][cd];
          }
      }
      MicapsDiamond14FeatureProvider['qeName'] = 'v_diamond14';
      class bH extends FeatureDataProviderBase {
          constructor(cd) {
              super(),
              this['featuresMap'] = {},
              this['options'] = (0x0,
              Kz['Ov'])({}, cd, bH['DefaultOptions']),
              this['_generateFeatures']();
          }
          ['_generateFeatures']() {
              const cd = this['options'];
              cd['extent'] || v0['kg']['error']('', true);
              let cq = ()=>[(0x0,
              Kz['Zu'])(cd['extent']['minLon'], cd['extent']['maxLon']), (0x0,
              Kz['Zu'])(cd['extent']['minLat'], cd['extent']['maxLat'])];
              (0x0,
              Kz['ri'])(cd['extent']['minHeight']) && (0x0,
              Kz['ri'])(cd['extent']['maxHeight']) && (cq = ()=>[(0x0,
              Kz['Zu'])(cd['extent']['minLon'], cd['extent']['maxLon']), (0x0,
              Kz['Zu'])(cd['extent']['minLat'], cd['extent']['maxLat']), (0x0,
              Kz['Zu'])(cd['extent']['minHeight'], cd['extent']['maxHeight'])]),
              this['featuresMap'] = {},
              this['features'] = {
                  'type': 'FeatureCollection',
                  'features': []
              },
              cd['fields'] && cd['fields']['forEach'](cJ=>{
                  var cC, cO, cG;
                  cJ['randomMax'] = null !== (cC = cJ['randomMax']) && undefined !== cC ? cC : 0x64,
                  cJ['randomMin'] = null !== (cO = cJ['randomMin']) && undefined !== cO ? cO : 0x0,
                  cJ['valueMode'] = null !== (cG = cJ['valueMode']) && undefined !== cG ? cG : 'random';
              }
              );
              for (let cJ = 0x0; cJ < cd['count']; cJ++) {
                  const cC = cq()
                    , cO = {
                      'fid': 'qe_' + cJ
                  };
                  if (cd['fields']) {
                      for (let cg = 0x0; cg < cd['fields']['length']; cg++)
                          this['_updateField'](cJ, cd['fields'][cg], cO);
                  }
                  const cG = {
                      'type': 'Feature',
                      'geometry': {
                          'type': 'Point',
                          'coordinates': cC
                      },
                      'properties': cO
                  };
                  this['featuresMap'][cO['fid']] = cG,
                  this['features']['features']['push'](cG);
              }
          }
          ['_updateField'](cd, cq, cJ) {
              var cC;
              let cO;
              if ('list' === cq['valueMode']) {
                  (null === (cC = cq['valueList']) || undefined === cC ? undefined : cC['length']) || v0['kg']['error']('listvalueList', true);
                  const cG = parseInt(Math['random']() * cq['valueList']['length']);
                  cO = cq['valueList'][cG];
              } else
                  cO = (0x0,
                  Kz['Zu'])(cq['randomMin'], cq['randomMax']);
              cq['postProcessor'] && (cO = cq['postProcessor'](cO, cd)),
              cJ[cq['name']] = cO;
          }
          ['_updateFeatures'](cd) {
              this['options'] = (0x0,
              Kz['Ov'])({}, cd, bH['DefaultOptions']),
              this['_generateFeatures']();
          }
          ['getFeatures']() {
              return this['features'];
          }
          ['getFeature'](cd) {
              return this['featuresMap'][cd];
          }
      }
      bH['DefaultOptions'] = {
          'count': 0x3e8,
          'extent': undefined
      };
      class MicapsDiamond2WindGridProvider extends MemoryWindDataProvider {
          constructor(cd, cq) {
              if (!(null == cq ? undefined : cq['gridOptions']))
                  throw new Error('provider');
              (0x0,
              KM['T'])(cq['gridOptions']);
              const {s: cJ, d: cC} = MicapsDiamond2WindGridProvider['_getSDProvider'](cd, cq['gridOptions']);
              super(cJ, cC, Object['assign']({
                  'isUV': false
              }, cq));
          }
          static['_getSDProvider'](cd, cq) {
              const cJ = cd['replaceAll']('\x0a', '\x20')['replaceAll']('\x0d', '\x20')['split'](/\s+/);
              for (; 0x0 === cJ[0x0]['trim']()['length']; )
                  cJ['shift']();
              for (; 0x0 === cJ[cJ['length'] - 0x1]['trim']()['length']; )
                  cJ['pop']();
              const cC = cJ['splice'](0x0, 0x9)
                , cO = new KN['P'](KP['U']['Float32'],cq['xSize'],cq['ySize'],undefined,0x270f)
                , cG = new KN['P'](KP['U']['Float32'],cq['xSize'],cq['ySize'],undefined,0x270f)
                , cg = Number(cC[cC['length'] - 0x1]);
              for (let cN = 0x0; cN < cg; cN++)
                  cO['write1D'](cN, Number(cJ[0xa * cN + 0x9])),
                  cG['write1D'](cN, Number(cJ[0xa * cN + 0x8]));
              return {
                  's': new iu['o']([[cO]],{
                      'gridOptions': cq
                  }),
                  'd': new iu['o']([[cG]],{
                      'gridOptions': cq
                  })
              };
          }
      }
      !function(cd) {
          cd[cd['Time'] = 0x0] = 'Time',
          cd[cd['Level'] = 0x1] = 'Level';
      }(DataAnimationType || (DataAnimationType = {}));
      class DataAnimationService extends iT['c'] {
          constructor(cd, cq) {
              super(),
              this['paused'] = 0x0,
              undefined === cq['all'] && v0['kg']['error'](''),
              this['dataSources'] = cd instanceof Array ? cd : [cd],
              this['options'] = (0x0,
              Kz['Ov'])({}, cq, DataAnimationService['DefaultOptions']),
              !this['options']['layer'] || this['options']['layer']instanceof Array || (this['options']['layer'] = [this['options']['layer']]),
              this['setAnimationFunc']();
          }
          ['setAnimationFunc']() {
              this['options']['useTimer'] ? (this['startFunc'] = setInterval['bind'](window),
              this['stopFunc'] = clearInterval['bind'](window)) : (this['startFunc'] = requestAnimationFrame['bind'](window),
              this['stopFunc'] = cancelAnimationFrame['bind'](window));
          }
          ['setInterval'](cd) {
              this['options']['useTimer'] ? this['animationId'] ? v0['kg']['warn']('') : this['options']['timerInterval'] = cd : v0['kg']['warn']('');
          }
          ['setLoop'](cd) {
              this['options']['loop'] = cd;
          }
          ['setDelta'](cd) {
              this['options']['delta'] = cd;
          }
          ['start']() {
              var cd;
              if (this['animationId'])
                  return void v0['kg']['warn']('');
              let cq = this['options']['all'] - this['options']['delta'];
              const cJ = Math['min'](Math['max'](null !== (cd = this['options']['fromIdx']) && undefined !== cd ? cd : 0x0, 0x0), this['options']['all'] - 0x2);
              (0x0,
              Kz['ri'])(this['options']['toIdx']) && (this['options']['toIdx'] <= cJ && v0['kg']['error']('toIdx<=fromIdx'),
              cq = Math['max'](Math['min'](this['options']['toIdx'] + 0x1, this['options']['all']), 0x2) - this['options']['delta']);
              const cC = this['options']['type'] === DataAnimationType['Level'] ? 'currentZIdx' : 'currentTIdx'
                , cO = ()=>{
                  if (!(this['paused'] > 0x0)) {
                      if (this['dataSources'][0x0][cC] < cJ && this['dataSources']['forEach'](cG=>cG[cC] = cJ),
                      this['dataSources'][0x0][cC] >= cq) {
                          if (this['options']['loop'])
                              return this['dataSources']['forEach'](cG=>{
                                  cG[cC] = cJ;
                              }
                              ),
                              this['options']['layer'] && this['options']['layer']['forEach'](cG=>cG['clearPreDataSource'] && cG['clearPreDataSource']()),
                              this['options']['clearPreSource'] && this['options']['clearPreSource'](),
                              void this['fire'](DataAnimationService['EventTypes']['backUpdate'], {
                                  'firer': this,
                                  'msg': 0x0
                              });
                          this['stop']();
                      }
                      this['dataSources']['forEach'](cG=>{
                          cG[cC] += this['options']['delta'];
                      }
                      ),
                      this['fire'](DataAnimationService['EventTypes']['idxUpdate'], {
                          'firer': this,
                          'msg': this['dataSources'][0x0][cC]
                      });
                  }
              }
              ;
              if (this['options']['useTimer'])
                  this['animationId'] = this['startFunc'](cO, this['options']['timerInterval']);
              else {
                  let cG = performance['now']();
                  const cg = ()=>{
                      if (!this['animationId'])
                          return;
                      const cN = performance['now']();
                      cN - cG >= this['options']['timerInterval'] && (cO(),
                      cG = cN),
                      this['animationId'] = this['startFunc'](cg);
                  }
                  ;
                  this['animationId'] = this['startFunc'](cg);
              }
              return this;
          }
          ['pause']() {
              return this['paused']++,
              this;
          }
          ['resume']() {
              return this['paused']--,
              this['paused'] < 0x0 && (this['paused'] = 0x0),
              this;
          }
          ['stop']() {
              return this['animationId'] ? (this['stopFunc'](this['animationId']),
              this['animationId'] = undefined,
              this['paused'] = 0x0,
              this['fire'](DataAnimationService['EventTypes']['stopped'], {
                  'firer': this,
                  'msg': this
              }),
              this) : this;
          }
      }
      DataAnimationService['DefaultOptions'] = {
          'timerInterval': 0x1e,
          'loop': true,
          'autoStart': false,
          'useTimer': true,
          'all': undefined,
          'type': DataAnimationType['Time'],
          'layer': undefined,
          'delta': 0.05
      },
      DataAnimationService['EventTypes'] = {
          'idxUpdate': 'update:idx',
          'backUpdate': 'update:back',
          'stopped': 'stopped'
      };
      var bF = n(0x4b);
      function by(cd, cq, cJ) {
          if (null !== cd)
              for (var cC, cO, cG, cg, cN, cP, cM, cz, cQ = 0x0, cm = 0x0, cL = cd['type'], cR = 'FeatureCollection' === cL, H0 = 'Feature' === cL, H1 = cR ? cd['features']['length'] : 0x1, H2 = 0x0; H2 < H1; H2++) {
                  cN = (cz = !!(cM = cR ? cd['features'][H2]['geometry'] : H0 ? cd['geometry'] : cd) && 'GeometryCollection' === cM['type']) ? cM['geometries']['length'] : 0x1;
                  for (var H3 = 0x0; H3 < cN; H3++) {
                      var H4 = 0x0
                        , H5 = 0x0;
                      if (null !== (cg = cz ? cM['geometries'][H3] : cM)) {
                          cP = cg['coordinates'];
                          var H6 = cg['type'];
                          switch (cQ = !cJ || 'Polygon' !== H6 && 'MultiPolygon' !== H6 ? 0x0 : 0x1,
                          H6) {
                          case null:
                              break;
                          case 'Point':
                              if (false === cq(cP, cm, H2, H4, H5))
                                  return false;
                              cm++,
                              H4++;
                              break;
                          case 'LineString':
                          case 'MultiPoint':
                              for (cC = 0x0; cC < cP['length']; cC++) {
                                  if (false === cq(cP[cC], cm, H2, H4, H5))
                                      return false;
                                  cm++,
                                  'MultiPoint' === H6 && H4++;
                              }
                              'LineString' === H6 && H4++;
                              break;
                          case 'Polygon':
                          case 'MultiLineString':
                              for (cC = 0x0; cC < cP['length']; cC++) {
                                  for (cO = 0x0; cO < cP[cC]['length'] - cQ; cO++) {
                                      if (false === cq(cP[cC][cO], cm, H2, H4, H5))
                                          return false;
                                      cm++;
                                  }
                                  'MultiLineString' === H6 && H4++,
                                  'Polygon' === H6 && H5++;
                              }
                              'Polygon' === H6 && H4++;
                              break;
                          case 'MultiPolygon':
                              for (cC = 0x0; cC < cP['length']; cC++) {
                                  for (H5 = 0x0,
                                  cO = 0x0; cO < cP[cC]['length']; cO++) {
                                      for (cG = 0x0; cG < cP[cC][cO]['length'] - cQ; cG++) {
                                          if (false === cq(cP[cC][cO][cG], cm, H2, H4, H5))
                                              return false;
                                          cm++;
                                      }
                                      H5++;
                                  }
                                  H4++;
                              }
                              break;
                          case 'GeometryCollection':
                              for (cC = 0x0; cC < cg['geometries']['length']; cC++)
                                  if (false === by(cg['geometries'][cC], cq, cJ))
                                      return false;
                              break;
                          default:
                              throw new Error('Unknown\x20Geometry\x20Type');
                          }
                      }
                  }
              }
      }
      function bw(cd, cq) {
          !function(cJ, cC) {
              var cO, cG, cg, cN, cP, cM, cz, cQ, cm, cL, cR = 0x0, H0 = 'FeatureCollection' === cJ['type'], H1 = 'Feature' === cJ['type'], H2 = H0 ? cJ['features']['length'] : 0x1;
              for (cO = 0x0; cO < H2; cO++) {
                  for (cM = H0 ? cJ['features'][cO]['geometry'] : H1 ? cJ['geometry'] : cJ,
                  cQ = H0 ? cJ['features'][cO]['properties'] : H1 ? cJ['properties'] : {},
                  cm = H0 ? cJ['features'][cO]['bbox'] : H1 ? cJ['bbox'] : undefined,
                  cL = H0 ? cJ['features'][cO]['id'] : H1 ? cJ['id'] : undefined,
                  cP = (cz = !!cM && 'GeometryCollection' === cM['type']) ? cM['geometries']['length'] : 0x1,
                  cg = 0x0; cg < cP; cg++)
                      if (null !== (cN = cz ? cM['geometries'][cg] : cM))
                          switch (cN['type']) {
                          case 'Point':
                          case 'LineString':
                          case 'MultiPoint':
                          case 'Polygon':
                          case 'MultiLineString':
                          case 'MultiPolygon':
                              if (false === cC(cN, cR, cQ, cm, cL))
                                  return false;
                              break;
                          case 'GeometryCollection':
                              for (cG = 0x0; cG < cN['geometries']['length']; cG++)
                                  if (false === cC(cN['geometries'][cG], cR, cQ, cm, cL))
                                      return false;
                              break;
                          default:
                              throw new Error('Unknown\x20Geometry\x20Type');
                          }
                      else {
                          if (false === cC(null, cR, cQ, cm, cL))
                              return false;
                      }
                  cR++;
              }
          }(cd, function(cJ, cC, cO, cG, cg) {
              var cN, cP = null === cJ ? null : cJ['type'];
              switch (cP) {
              case null:
              case 'Point':
              case 'LineString':
              case 'Polygon':
                  return false !== cq((0x0,
                  bF['zL'])(cJ, cO, {
                      'bbox': cG,
                      'id': cg
                  }), cC, 0x0) && undefined;
              }
              switch (cP) {
              case 'MultiPoint':
                  cN = 'Point';
                  break;
              case 'MultiLineString':
                  cN = 'LineString';
                  break;
              case 'MultiPolygon':
                  cN = 'Polygon';
              }
              for (var cM = 0x0; cM < cJ['coordinates']['length']; cM++) {
                  var cz = {
                      'type': cN,
                      'coordinates': cJ['coordinates'][cM]
                  };
                  if (false === cq((0x0,
                  bF['zL'])(cz, cO), cC, cM))
                      return false;
              }
          });
      }
      function bh(cd, cq, cJ) {
          var cC = cJ
            , cO = false;
          return function(cG, cg) {
              bw(cG, function(cN, cP, cM) {
                  var cz = 0x0;
                  if (cN['geometry']) {
                      var cQ = cN['geometry']['type'];
                      if ('Point' !== cQ && 'MultiPoint' !== cQ) {
                          var cm, cL = 0x0, cR = 0x0, H0 = 0x0;
                          return false !== by(cN, function(H1, H2, H3, H4, H5) {
                              if (undefined === cm || cP > cL || H4 > cR || H5 > H0)
                                  return cm = H1,
                                  cL = cP,
                                  cR = H4,
                                  H0 = H5,
                                  void (cz = 0x0);
                              var H6 = (0x0,
                              bF['Tu'])([cm, H1], cN['properties']);
                              if (false === cg(H6, cP, cM, H5, cz))
                                  return false;
                              cz++,
                              cm = H1;
                          }) && undefined;
                      }
                  }
              });
          }(cd, function(cG, cg, cN, cP, cM) {
              cC = false === cO && undefined === cJ ? cG : cq(cC, cG, cg, cN, cP, cM),
              cO = true;
          }),
          cC;
      }
      class bu {
          static['createGridXY_Delt'](cd, cq, cJ, cC, cO, cG) {
              let cg, cN, cP;
              cN = (cJ - cd) / cO + 0x1,
              cP = (cC - cq) / cG + 0x1;
              let cM = []
                , cz = [];
              for (cg = 0x0; cg < cN; cg++)
                  cM[cg] = cd + cg * cO;
              for (cg = 0x0; cg < cP; cg++)
                  cz[cg] = cq + cg * cG;
              let cQ = [];
              return cQ['push'](cM),
              cQ['push'](cz),
              cQ;
          }
          static['createGridXY_Num'](cd, cq, cJ, cC, cO, cG) {
              let cg, cN, cP, cM = cO['length'], cz = cG['length'];
              for (cN = (cJ - cd) / cM,
              cP = (cC - cq) / cz,
              cg = 0x0; cg < cM; cg++)
                  cO[cg] = cd + cg * cN;
              for (cg = 0x0; cg < cz; cg++)
                  cG[cg] = cq + cg * cP;
          }
          static['interpolation_IDW_Neighbor'](cd, cq, cJ, cC) {
              let cO, cG, cg;
              cG = cq['length'],
              cO = cJ['length'],
              cg = cd['length'];
              let cN, cP, cM, cz, cQ, cm, cL, cR, H0, H1, H2 = [];
              H1 = cC;
              let H3 = [];
              for (H3[0x0] = [],
              H3[0x1] = [],
              cN = 0x0; cN < cO; cN++)
                  for (H2[cN] = [],
                  cP = 0x0; cP < cG; cP++) {
                      for (H2[cN][cP] = -0x3e7,
                      cL = 0x0,
                      cR = 0x0,
                      cM = 0x0; cM < H1; cM++) {
                          if (cq[cP] == cd[cM][0x0] && cJ[cN] == cd[cM][0x1]) {
                              H2[cN][cP] = cd[cM][0x2];
                              break;
                          }
                          cm = 0x1 / (Math['pow'](cq[cP] - cd[cM][0x0], 0x2) + Math['pow'](cJ[cN] - cd[cM][0x1], 0x2)),
                          H3[0x0][cM] = cm,
                          H3[0x1][cM] = cM;
                      }
                      if (-0x3e7 == H2[cN][cP]) {
                          for (cM = H1; cM < cg; cM++) {
                              if (Math['pow'](cq[cP] - cd[cM][0x0], 0x2) + Math['pow'](cJ[cN] - cd[cM][0x1], 0x2) == 0x0) {
                                  H2[cN][cP] = cd[cM][0x2];
                                  break;
                              }
                              for (cm = 0x1 / (Math['pow'](cq[cP] - cd[cM][0x0], 0x2) + Math['pow'](cJ[cN] - cd[cM][0x1], 0x2)),
                              H0 = parseFloat(H3[0x0][0x0]),
                              cQ = 0x0,
                              cz = 0x1; cz < H1; cz++)
                                  parseFloat(H3[0x0][cz]) < H0 && (H0 = parseFloat(H3[0x0][cz]),
                                  cQ = cz);
                              cm > H0 && (H3[0x0][cQ] = cm,
                              H3[0x1][cQ] = cM);
                          }
                          if (-0x3e7 == H2[cN][cP]) {
                              for (cM = 0x0; cM < H1; cM++)
                                  cL += parseFloat(H3[0x0][cM]) * cd[parseInt(H3[0x1][cM])][0x2],
                                  cR += parseFloat(H3[0x0][cM]);
                              H2[cN][cP] = cL / cR;
                          }
                      }
                  }
              for (cN = 0x1; cN < cO - 0x1; cN++)
                  for (cP = 0x1; cP < cG - 0x1; cP++)
                      H2[cN][cP] = H2[cN][cP] + 0.125 * (H2[cN + 0x1][cP] + H2[cN - 0x1][cP] + H2[cN][cP + 0x1] + H2[cN][cP - 0x1] - 0x4 * H2[cN][cP]);
              return H2;
          }
          static['interpolation_IDW_Neighbor_Undef'](cd, cq, cJ, cC, cO) {
              let cG, cg, cN;
              cg = cq['length'],
              cG = cJ['length'],
              cN = cd['length'];
              let cP, cM, cz, cQ, cm, cL, cR, H0, H1, H2, H3 = [];
              H2 = cC;
              let H4, H5 = [], H6 = [];
              for (H6[0x0] = [],
              H6[0x1] = [],
              cP = 0x0; cP < cG; cP++)
                  for (H3[cP] = [],
                  cM = 0x0; cM < cg; cM++) {
                      for (H3[cP][cM] = cO,
                      cR = 0x0,
                      H0 = 0x0,
                      H4 = 0x0,
                      cz = 0x0; cz < cN; cz++)
                          if (cd[cz][0x2] != cO) {
                              if (cq[cM] == cd[cz][0x0] && cJ[cP] == cd[cz][0x1]) {
                                  H3[cP][cM] = cd[cz][0x2];
                                  break;
                              }
                              cL = 0x1 / (Math['pow'](cq[cM] - cd[cz][0x0], 0x2) + Math['pow'](cJ[cP] - cd[cz][0x1], 0x2)),
                              H5[cz] = cL,
                              H4 < H2 && (H6[0x0][H4] = cL,
                              H6[0x1][H4] = cz),
                              H4 += 0x1;
                          } else
                              H5[cz] = -0x1;
                      if (H3[cP][cM] == cO) {
                          for (cz = 0x0; cz < cN; cz++)
                              if (cL = H5[cz],
                              -0x1 != cL) {
                                  for (H1 = H6[0x0][0x0],
                                  cm = 0x0,
                                  cQ = 0x1; cQ < H2; cQ++)
                                      H6[0x0][cQ] < H1 && (H1 = H6[0x0][cQ],
                                      cm = cQ);
                                  cL > H1 && (H6[0x0][cm] = cL,
                                  H6[0x1][cm] = cz);
                              }
                          for (cz = 0x0; cz < H2; cz++)
                              cR += H6[0x0][cz] * cd[H6[0x1][cz]][0x2],
                              H0 += H6[0x0][cz];
                          H3[cP][cM] = cR / H0;
                      }
                  }
              for (cP = 0x1; cP < cG - 0x1; cP++)
                  for (cM = 0x1; cM < cg - 0x1; cM++)
                      H3[cP][cM] = H3[cP][cM] + 0.125 * (H3[cP + 0x1][cM] + H3[cP - 0x1][cM] + H3[cP][cM + 0x1] + H3[cP][cM - 0x1] - 0x4 * H3[cP][cM]);
              return H3;
          }
          static['interpolation_IDW_Radius'](cd, cq, cJ, cC, cO, cG) {
              let cg, cN, cP;
              cN = cq['length'],
              cg = cJ['length'],
              cP = cd['length'];
              let cM, cz, cQ, cm, cL, cR, H0, H1, H2 = [];
              for (cM = 0x0; cM < cg; cM++)
                  for (H2[cM] = [],
                  cz = 0x0; cz < cN; cz++) {
                      for (H2[cM][cz] = cG,
                      H1 = false,
                      cR = 0x0,
                      H0 = 0x0,
                      cm = 0x0,
                      cQ = 0x0; cQ < cP; cQ++)
                          if (cd[cQ][0x2] != cG && !(cd[cQ][0x0] < cq[cz] - cO || cd[cQ][0x0] > cq[cz] + cO || cd[cQ][0x1] < cJ[cM] - cO || cd[cQ][0x1] > cJ[cM] + cO)) {
                              if (cq[cz] == cd[cQ][0x0] && cJ[cM] == cd[cQ][0x1]) {
                                  H2[cM][cz] = cd[cQ][0x2],
                                  H1 = true;
                                  break;
                              }
                              Math['sqrt'](Math['pow'](cq[cz] - cd[cQ][0x0], 0x2) + Math['pow'](cJ[cM] - cd[cQ][0x1], 0x2)) <= cO && (cL = 0x1 / (Math['pow'](cq[cz] - cd[cQ][0x0], 0x2) + Math['pow'](cJ[cM] - cd[cQ][0x1], 0x2)),
                              H0 += cL,
                              cR += cd[cQ][0x2] * cL,
                              cm += 0x1);
                          }
                      H1 || cm >= cC && (H2[cM][cz] = cR / H0);
                  }
              for (cM = 0x1; cM < cg - 0x1; cM++)
                  for (cz = 0x1; cz < cN - 0x2; cz++)
                      H2[cM][cz] != cG && H2[cM + 0x1][cz] != cG && H2[cM - 0x1][cz] != cG && H2[cM][cz + 0x1] != cG && H2[cM][cz - 0x1] != cG && (H2[cM][cz] = H2[cM][cz] + 0.125 * (H2[cM + 0x1][cz] + H2[cM - 0x1][cz] + H2[cM][cz + 0x1] + H2[cM][cz - 0x1] - 0x4 * H2[cM][cz]));
              return H2;
          }
          static['interpolation_Grid'](cd, cq, cJ, cC, cO, cG) {
              let cg = 0x2 * cq['length'] - 0x1
                , cN = 0x2 * cJ['length'] - 0x1;
              cO = [],
              cG = [];
              let cP, cM, cz, cQ, cm, cL, cR, H0 = [];
              for (cP = 0x0; cP < cg; cP++)
                  cO[cP] = cP % 0x2 == 0x0 ? cq[cP / 0x2] : (cq[(cP - 0x1) / 0x2] + cq[(cP - 0x1) / 0x2 + 0x1]) / 0x2;
              for (cP = 0x0; cP < cN; cP++)
                  for (cG[cP] = cP % 0x2 == 0x0 ? cJ[cP / 0x2] : (cJ[(cP - 0x1) / 0x2] + cJ[(cP - 0x1) / 0x2 + 0x1]) / 0x2,
                  cM = 0x0; cM < cg; cM++)
                      if (H0[cM] = [],
                      cP % 0x2 == 0x0 && cM % 0x2 == 0x0)
                          H0[cP][cM] = cd[cP / 0x2][cM / 0x2];
                      else {
                          if (cP % 0x2 == 0x0 && cM % 0x2 != 0x0)
                              cz = cd[cP / 0x2][(cM - 0x1) / 0x2],
                              cQ = cd[cP / 0x2][(cM - 0x1) / 0x2 + 0x1],
                              cR = [],
                              cz != cC && cR['push'](cz),
                              cQ != cC && cR['push'](cQ),
                              0x0 === cR['length'] ? H0[cP][cM] = cC : 0x1 == cR['length'] ? H0[cP][cM] = cR[0x0] : H0[cP][cM] = (cz + cQ) / 0x2;
                          else {
                              if (cP % 0x2 != 0x0 && cM % 0x2 == 0x0)
                                  cz = cd[(cP - 0x1) / 0x2][cM / 0x2],
                                  cQ = cd[(cP - 0x1) / 0x2 + 0x1][cM / 0x2],
                                  cR = [],
                                  cz != cC && cR['push'](cz),
                                  cQ != cC && cR['push'](cQ),
                                  0x0 === cR['length'] ? H0[cP][cM] = cC : 0x1 == cR['length'] ? H0[cP][cM] = cR[0x0] : H0[cP][cM] = (cz + cQ) / 0x2;
                              else {
                                  if (cz = cd[(cP - 0x1) / 0x2][(cM - 0x1) / 0x2],
                                  cQ = cd[(cP - 0x1) / 0x2][(cM - 0x1) / 0x2 + 0x1],
                                  cm = cd[(cP - 0x1) / 0x2 + 0x1][(cM - 0x1) / 0x2 + 0x1],
                                  cL = cd[(cP - 0x1) / 0x2 + 0x1][(cM - 0x1) / 0x2],
                                  cR = [],
                                  cz != cC && cR['push'](cz),
                                  cQ != cC && cR['push'](cQ),
                                  cm != cC && cR['push'](cm),
                                  cL != cC && cR['push'](cL),
                                  cR['length'])
                                      H0[cP][cM] = cC;
                                  else {
                                      if (0x1 == cR['length'])
                                          H0[cP][cM] = cR[0x0];
                                      else {
                                          let H1 = 0x0;
                                          for (let H2 of cR)
                                              H1 += H2;
                                          H0[cP][cM] = H1 / cR['length'];
                                      }
                                  }
                              }
                          }
                      }
              return H0;
          }
          static['cressman'](cd, cq, cJ, cC) {
              let cO = [];
              return cO['push'](0xa),
              cO['push'](0x7),
              cO['push'](0x4),
              cO['push'](0x2),
              cO['push'](0x1),
              bu['cressman_rad'](cd, cq, cJ, cC, cO);
          }
          static['cressman_rad'](cd, cq, cJ, cC, cO) {
              let cG, cg, cN, cP, cM = cq['length'], cz = cJ['length'], cQ = cd['length'], cm = [], cL = cO['length'], cR = cq[0x0], H0 = cq[cq['length'] - 0x1], H1 = cJ[0x0], H2 = cJ[cJ['length'] - 0x1], H3 = cq[0x1] - cq[0x0], H4 = cJ[0x1] - cJ[0x0], H5 = 0x0, H6 = 0x0, H7 = 0x0, H8 = [];
              for (cG = 0x0; cG < cQ; cG++)
                  H8[cG] = [],
                  cN = cd[cG][0x0],
                  cP = cd[cG][0x1],
                  H8[cG][0x0] = Math['floor']((cN - cR) / H3),
                  H8[cG][0x1] = Math['floor']((cP - H1) / H4),
                  H8[cG][0x2] = cd[cG][0x2],
                  H8[cG][0x2] != cC && (H6 += H8[cG][0x2],
                  H7 += 0x1);
              H6 /= H7;
              let H9, Hv = [], HA = [];
              for (cG = 0x0; cG < cz; cG++)
                  for (Hv[cG] = [],
                  HA[cG] = [],
                  cg = 0x0; cg < cM; cg++)
                      Hv[cG][cg] = -0x363466684d81160000,
                      HA[cG][cg] = 0x363466684d81160000;
              for (H9 = cO['length'] > 0x0 ? cO[0x0] : 0x4,
              cG = 0x0; cG < cz; cG++)
                  for (cP = cG,
                  H1 = cP - H9,
                  H2 = cP + H9,
                  cm[cG] = [],
                  cg = 0x0; cg < cM; cg++) {
                      cN = cg,
                      cR = cN - H9,
                      H0 = cN + H9,
                      H7 = 0x0,
                      H5 = 0x0;
                      for (let Hk = 0x0; Hk < cQ; Hk++) {
                          let Hl = H8[Hk][0x2]
                            , HK = H8[Hk][0x0]
                            , Hb = H8[Hk][0x1];
                          HK < 0x0 || HK >= cM - 0x1 || Hb < 0x0 || Hb >= cz - 0x1 || Hl == cC || HK < cR || HK > H0 || Hb < H1 || Hb > H2 || Math['sqrt'](Math['pow'](HK - cN, 0x2) + Math['pow'](Hb - cP, 0x2)) > H9 || (H5 += Hl,
                          H7 += 0x1,
                          Hv[cG][cg] < Hl && (Hv[cG][cg] = Hl),
                          HA[cG][cg] > Hl && (HA[cG][cg] = Hl));
                      }
                      cm[cG][cg] = 0x0 == H7 ? cC : H5 / H7;
                  }
              for (let Hc = 0x0; Hc < cL; Hc++)
                  for (H9 = cO[Hc],
                  cG = 0x0; cG < cz; cG++)
                      for (cP = cG,
                      H1 = cP - H9,
                      H2 = cP + H9,
                      cg = 0x0; cg < cM; cg++) {
                          if (cm[cG][cg] == cC)
                              continue;
                          cN = cg,
                          cR = cN - H9,
                          H0 = cN + H9,
                          H5 = 0x0;
                          let HH = 0x0;
                          for (let Hx = 0x0; Hx < cQ; Hx++) {
                              let Hp = H8[Hx][0x2]
                                , HF = H8[Hx][0x0]
                                , Hy = H8[Hx][0x1];
                              if (HF < 0x0 || HF >= cM - 0x1 || Hy < 0x0 || Hy >= cz - 0x1)
                                  continue;
                              if (Hp == cC || HF < cR || HF > H0 || Hy < H1 || Hy > H2)
                                  continue;
                              let Hw = Math['sqrt'](Math['pow'](HF - cN, 0x2) + Math['pow'](Hy - cP, 0x2));
                              if (Hw > H9)
                                  continue;
                              let Hh, Hu = Hy, HY = HF, HT = Hu + 0x1, HX = HY + 0x1, HE = cm[Hu][HY], Hf = cm[Hu][HX], HW = cm[HT][HY], HI = cm[HT][HX], Hj = [];
                              if (HE != cC && Hj['push'](HE),
                              Hf != cC && Hj['push'](Hf),
                              HW != cC && Hj['push'](HW),
                              HI != cC && Hj['push'](HI),
                              0x0 === Hj['length'])
                                  continue;
                              if (0x1 == Hj['length'])
                                  Hh = Hj[0x0];
                              else {
                                  if (Hj['length'] <= 0x3) {
                                      let HV = 0x0;
                                      for (let HZ of Hj)
                                          HV += HZ;
                                      Hh = HV / Hj['length'];
                                  } else {
                                      let HB = HE + (HW - HE) * (Hy - Hu);
                                      Hh = HB + (Hf + (HI - Hf) * (Hy - Hu) - HB) * (HF - HY);
                                  }
                              }
                              let HD = (H9 * H9 - Hw * Hw) / (H9 * H9 + Hw * Hw);
                              H5 += (Hp - Hh) * HD,
                              HH += HD;
                          }
                          if (HH < 0.000001)
                              cm[cG][cg] = cC;
                          else {
                              let HS = cm[cG][cg] + H5 / HH;
                              cm[cG][cg] = Math['max'](HA[cG][cg], Math['min'](Hv[cG][cg], HS));
                          }
                      }
              return cm;
          }
          static['assignPointToGrid'](cd, cq, cJ, cC) {
              let cO, cG, cg;
              cG = cq['length'],
              cO = cJ['length'],
              cg = cd['length'];
              let cN = []
                , cP = cq[0x1] - cq[0x0]
                , cM = cJ[0x1] - cJ[0x0]
                , cz = [];
              for (let cQ = 0x0; cQ < cO; cQ++) {
                  cz[cQ] = [],
                  cN[cQ] = [];
                  for (let cm = 0x0; cm < cG; cm++)
                      cz[cQ][cm] = 0x0,
                      cN[cQ][cm] = 0x0;
              }
              for (let cL = 0x0; cL < cg; cL++) {
                  if (bu['doubleEquals'](cd[cL][0x2], cC))
                      continue;
                  let cR = cd[cL][0x0]
                    , H0 = cd[cL][0x1];
                  if (cR < cq[0x0] || cR > cq[cG - 0x1])
                      continue;
                  if (H0 < cJ[0x0] || H0 > cJ[cO - 0x1])
                      continue;
                  let H1 = ((cR - cq[0x0]) / cP)['toFixed'](0x0)
                    , H2 = ((H0 - cJ[0x0]) / cM)['toFixed'](0x0);
                  cz[H2][H1] += 0x1,
                  cN[H2][H1] += cd[cL][0x2];
              }
              for (let H3 = 0x0; H3 < cO; H3++)
                  for (let H4 = 0x0; H4 < cG; H4++)
                      0x0 == cz[H3][H4] ? cN[H3][H4] = cC : cN[H3][H4] = cN[H3][H4] / cz[H3][H4];
              return cN;
          }
          static['doubleEquals'](cd, cq) {
              return Math['abs'](cd / cq - 0x1) < 1e-11;
          }
      }
      class bY {
          constructor() {
              this['LineList'] = [];
          }
          ['getLineNum']() {
              return this['LineList']['length'];
          }
      }
      class bT {
          constructor(cd, cq, cJ, cC) {
              this['xMin'] = cd,
              this['xMax'] = cq,
              this['yMin'] = cJ,
              this['yMax'] = cC;
          }
          ['Include'](cd) {
              return this['xMin'] <= cd['xMin'] && this['xMax'] >= cd['xMax'] && this['yMin'] <= cd['yMin'] && this['yMax'] >= cd['yMax'];
          }
      }
      class bX {
          constructor() {
              this['extent'] = new bT(),
              this['pointList'] = [],
              this['ijPointList'] = [];
          }
      }
      class bE {
          constructor(cd, cq) {
              this['X'] = cd || 0x0,
              this['Y'] = cq || 0x0;
          }
          ['clone']() {
              return new bE(this['X'],this['Y']);
          }
      }
      class bf {
          constructor() {
              this['Point'] = new bE();
          }
          ['clone']() {
              let cd = new bf();
              return cd['Id'] = this['Id'],
              cd['BorderIdx'] = this['BorderIdx'],
              cd['BInnerIdx'] = this['BInnerIdx'],
              cd['Point'] = this['Point'],
              cd['Value'] = this['Value'],
              cd;
          }
      }
      class bW {
          constructor() {
              this['sPoint'] = new bE(),
              this['Point'] = new bE();
          }
      }
      class bI {
      }
      class bj {
      }
      class bD {
          constructor(cd, cq) {
              this['X'] = cd,
              this['Y'] = cq;
          }
      }
      class bV {
          constructor() {
              this['PointList'] = [];
          }
      }
      class bZ {
          constructor() {
              this['IsInnerBorder'] = false,
              this['Extent'] = new bT(),
              this['OutLine'] = new bV(),
              this['HoleLines'] = [];
          }
          ['Clone']() {
              let cd = new bZ();
              cd['IsBorder'] = this['IsBorder'],
              cd['LowValue'] = this['LowValue'],
              cd['HighValue'] = this['HighValue'],
              cd['IsClockWise'] = this['IsClockWise'],
              cd['StartPointIdx'] = this['StartPointIdx'],
              cd['IsHighCenter'] = this['IsHighCenter'],
              cd['Extent'] = this['Extent'],
              cd['Area'] = this['Area'],
              cd['OutLine'] = this['OutLine'];
              for (let cq of this['HoleLines'])
                  cd['HoleLines']['push'](cq);
              return cd['HoleIndex'] = this['HoleIndex'],
              cd;
          }
          ['HasHoles']() {
              return this['HoleLines']['length'] > 0x0;
          }
          ['AddHole'](cd) {
              if (cd instanceof bZ)
                  this['HoleLines']['push'](cd['OutLine']);
              else {
                  let cq = cd;
                  bB['isClockwise'](cq) && (cq = cq['reverse']());
                  let cJ = new bV();
                  cJ['PointList'] = cq,
                  this['HoleLines']['push'](cJ);
              }
          }
      }
      class bB {
          static['tracingContourLines'](cd, cq, cJ, cC, cO, cG, cg, cN) {
              return bB['createContourLines_UndefData'](cd, cq, cJ, cC, cO, cN, cG, cg);
          }
          static['tracingBorders'](cd, cq, cJ, cC, cO) {
              let cG, cg, cN, cP, cM, cz, cQ, cm, cL, cR, H0, H1, H2, H3 = [];
              for (cG = cd['length'],
              cg = cd[0x0]['length'],
              cN = 0x0; cN < cG; cN++)
                  for (cC[cN] = [],
                  cP = 0x0; cP < cg; cP++)
                      bB['doubleEquals'](cd[cN][cP], cO) ? cC[cN][cP] = 0x0 : cC[cN][cP] = 0x1;
              for (cN = 0x1; cN < cG - 0x1; cN++)
                  for (cP = 0x1; cP < cg - 0x1; cP++)
                      0x1 === cC[cN][cP] && (cM = cC[cN][cP - 0x1],
                      cz = cC[cN][cP + 0x1],
                      cQ = cC[cN - 0x1][cP],
                      cm = cC[cN + 0x1][cP],
                      cL = cC[cN - 0x1][cP - 0x1],
                      cR = cC[cN - 0x1][cP + 0x1],
                      H0 = cC[cN + 0x1][cP - 0x1],
                      H1 = cC[cN + 0x1][cP + 0x1],
                      cM > 0x0 && cz > 0x0 && cQ > 0x0 && cm > 0x0 && cL > 0x0 && cR > 0x0 && H0 > 0x0 && H1 > 0x0 && (cC[cN][cP] = 0x2),
                      cM + cz + cQ + cm + cL + cR + H0 + H1 <= 0x2 && (cC[cN][cP] = 0x0));
              for (; ; ) {
                  for (H2 = false,
                  cN = 0x1; cN < cG - 0x1; cN++)
                      for (cP = 0x1; cP < cg - 0x1; cP++)
                          0x1 === cC[cN][cP] && (cM = cC[cN][cP - 0x1],
                          cz = cC[cN][cP + 0x1],
                          cQ = cC[cN - 0x1][cP],
                          cm = cC[cN + 0x1][cP],
                          cL = cC[cN - 0x1][cP - 0x1],
                          cR = cC[cN - 0x1][cP + 0x1],
                          H0 = cC[cN + 0x1][cP - 0x1],
                          H1 = cC[cN + 0x1][cP + 0x1],
                          (0x0 === cM && 0x0 === cz || 0x0 === cQ && 0x0 === cm) && (cC[cN][cP] = 0x0,
                          H2 = true),
                          (0x0 === H0 && 0x0 === cz && 0x0 === cQ || 0x0 === H1 && 0x0 === cM && 0x0 === cQ || 0x0 === cL && 0x0 === cz && 0x0 === cm || 0x0 === cR && 0x0 === cM && 0x0 === cm) && (cC[cN][cP] = 0x0,
                          H2 = true));
                  if (!H2)
                      break;
              }
              for (cP = 0x0; cP < cg; cP++)
                  0x1 === cC[0x0][cP] && (0x0 === cC[0x1][cP] ? cC[0x0][cP] = 0x0 : 0x0 === cP ? 0x0 === cC[0x0][cP + 0x1] && (cC[0x0][cP] = 0x0) : cP === cg - 0x1 ? 0x0 === cC[0x0][cg - 0x2] && (cC[0x0][cP] = 0x0) : 0x0 === cC[0x0][cP - 0x1] && 0x0 === cC[0x0][cP + 0x1] && (cC[0x0][cP] = 0x0)),
                  0x1 === cC[cG - 0x1][cP] && (0x0 === cC[cG - 0x2][cP] ? cC[cG - 0x1][cP] = 0x0 : 0x0 === cP ? 0x0 === cC[cG - 0x1][cP + 0x1] && (cC[cG - 0x1][cP] = 0x0) : cP === cg - 0x1 ? 0x0 === cC[cG - 0x1][cg - 0x2] && (cC[cG - 0x1][cP] = 0x0) : 0x0 === cC[cG - 0x1][cP - 0x1] && 0x0 === cC[cG - 0x1][cP + 0x1] && (cC[cG - 0x1][cP] = 0x0));
              for (cN = 0x0; cN < cG; cN++)
                  0x1 === cC[cN][0x0] && (0x0 === cC[cN][0x1] ? cC[cN][0x0] = 0x0 : 0x0 === cN ? 0x0 === cC[cN + 0x1][0x0] && (cC[cN][0x0] = 0x0) : cN === cG - 0x1 ? 0x0 === cC[cG - 0x2][0x0] && (cC[cN][0x0] = 0x0) : 0x0 === cC[cN - 0x1][0x0] && 0x0 === cC[cN + 0x1][0x0] && (cC[cN][0x0] = 0x0)),
                  0x1 === cC[cN][cg - 0x1] && (0x0 === cC[cN][cg - 0x2] ? cC[cN][cg - 0x1] = 0x0 : 0x0 === cN ? 0x0 === cC[cN + 0x1][cg - 0x1] && (cC[cN][cg - 0x1] = 0x0) : cN === cG - 0x1 ? 0x0 === cC[cG - 0x2][cg - 0x1] && (cC[cN][cg - 0x1] = 0x0) : 0x0 === cC[cN - 0x1][cg - 0x1] && 0x0 === cC[cN + 0x1][cg - 0x1] && (cC[cN][cg - 0x1] = 0x0));
              let H4 = [];
              for (cN = 0x0; cN < cG + 0x2; cN++)
                  for (H4[cN] = [],
                  cP = 0x0; cP < cg + 0x2; cP++)
                      H4[cN][cP] = 0x0 === cN || cN === cG + 0x1 || 0x0 === cP || cP === cg + 0x1 ? 0x0 : cC[cN - 0x1][cP - 0x1];
              let H5, H6, H7, H8, H9, Hv = [];
              for (cN = 0x0; cN < cG + 0x2; cN++)
                  for (Hv[cN] = [],
                  cP = 0x0; cP < cg + 0x2; cP++)
                      0x1 === H4[cN][cP] ? (cM = H4[cN][cP - 0x1],
                      cz = H4[cN][cP + 0x1],
                      cQ = H4[cN - 0x1][cP],
                      cm = H4[cN + 0x1][cP],
                      cL = H4[cN - 0x1][cP - 0x1],
                      cR = H4[cN - 0x1][cP + 0x1],
                      H0 = H4[cN + 0x1][cP - 0x1],
                      H1 = H4[cN + 0x1][cP + 0x1],
                      Hv[cN][cP] = 0x1 === cM && 0x1 === cz && 0x1 === cQ && 0x1 === cm && (0x0 === cL && 0x0 === H1 || 0x0 === cR && 0x0 === H0) ? 0x2 : 0x1) : Hv[cN][cP] = 0x0;
              let HA, Hk, Hl, HK, Hb, Hc, HH = 0x0, Hx = 0x0;
              for (cN = 0x1; cN < cG + 0x1; cN++)
                  for (cP = 0x1; cP < cg + 0x1; cP++)
                      if (0x1 === H4[cN][cP]) {
                          for (H8 = [],
                          H9 = [],
                          H5 = new bE(),
                          H5['X'] = cq[cP - 0x1],
                          H5['Y'] = cJ[cN - 0x1],
                          H6 = new bI(),
                          H6['I'] = cN - 0x1,
                          H6['J'] = cP - 0x1,
                          H8['push'](H5),
                          H9['push'](H6),
                          HA = cN,
                          Hk = cP,
                          Hb = cN,
                          Hc = cP,
                          Hl = Hb,
                          HK = -0x1; ; ) {
                              let Hu = [];
                              if (Hu[0x0] = HH,
                              Hu[0x1] = Hx,
                              !bB['traceBorder'](H4, Hl, Hb, HK, Hc, Hu))
                                  break;
                              if (HH = Hu[0x0],
                              Hx = Hu[0x1],
                              Hl = Hb,
                              HK = Hc,
                              Hb = HH,
                              Hc = Hx,
                              Hv[HH][Hx] = Hv[HH][Hx] - 0x1,
                              0x0 === Hv[HH][Hx] && (H4[HH][Hx] = 0x3),
                              H5 = new bE(),
                              H5['X'] = cq[Hx - 0x1],
                              H5['Y'] = cJ[HH - 0x1],
                              H6 = new bI(),
                              H6['I'] = HH - 0x1,
                              H6['J'] = Hx - 0x1,
                              H8['push'](H5),
                              H9['push'](H6),
                              HH === HA && Hx === Hk)
                                  break;
                          }
                          Hv[cN][cP] = Hv[cN][cP] - 0x1,
                          0x0 === Hv[cN][cP] && (H4[cN][cP] = 0x3),
                          H8['length'] > 0x1 && (H7 = new bX(),
                          H7['area'] = bB['getExtentAndArea'](H8, H7['extent']),
                          H7['isOutLine'] = true,
                          H7['isClockwise'] = true,
                          H7['pointList'] = H8,
                          H7['ijPointList'] = H9,
                          H3['push'](H7));
                      }
              let Hp, HF, Hy, Hw, Hh = [];
              for (cN = 0x1; cN < H3['length']; cN++)
                  for (HF = H3[cN],
                  cP = 0x0; cP < cN; cP++)
                      if (Hy = H3[cN],
                      HF['area'] > Hy['area']) {
                          H3['splice'](cN, 0x1),
                          H3['splice'](cP, 0x0, HF);
                          break;
                      }
              if (0x1 === H3['length'])
                  HF = H3[0x0],
                  bB['isClockwise'](HF['pointList']) || (HF['pointList'] = HF['pointList']['reverse'](),
                  HF['ijPointList']['reverse']()),
                  HF['isClockwise'] = true,
                  Hw = [],
                  Hw['push'](HF),
                  Hp = new bY(),
                  Hp['LineList'] = Hw,
                  Hh['push'](Hp);
              else
                  for (cN = 0x0; cN < H3['length'] && cN !== H3['length']; cN++) {
                      for (HF = H3[cN],
                      bB['isClockwise'](HF['pointList']) || (HF['pointList']['reverse'](),
                      HF['ijPointList']['reverse']()),
                      HF['isClockwise'] = true,
                      Hw = [],
                      Hw['push'](HF),
                      cP = cN + 0x1; cP < H3['length'] && cP !== H3['length']; cP++)
                          Hy = H3[cN],
                          Hy['extent']['xMin'] > HF['extent']['xMin'] && Hy['extent']['xMax'] < HF['extent']['xMax'] && Hy['extent']['yMin'] > HF['extent']['yMin'] && Hy['extent']['yMax'] < HF['extent']['yMax'] && (H5 = Hy['pointList'][0x0],
                          bB['pointInPolygonByPList'](HF['pointList'], H5) && (Hy['isOutLine'] = false,
                          bB['isClockwise'](Hy['pointList']) && (Hy['pointList']['reverse'](),
                          Hy['ijPointList']['reverse']()),
                          Hy['isClockwise'] = false,
                          Hw['push'](Hy),
                          H3['splice'](cP, 0x1),
                          cP -= 0x1));
                      Hp = new bY(),
                      Hp['LineList'] = Hw,
                      Hh['push'](Hp);
                  }
              return Hh;
          }
          static['createContourLines_UndefData'](cd, cq, cJ, cC, cO, cG, cg, cN) {
              let cP, cM, cz, cQ, cm, cL, cR = [];
              for (cM = cd['length'],
              cz = cd[0x0]['length'],
              cL = 0.00001 * cO[0x0],
              0x0 === cL && (cL = 0.00001),
              cQ = 0x0; cQ < cM; cQ++)
                  for (cm = 0x0; cm < cz; cm++)
                      bB['doubleEquals'](cd[cQ][cm], cg) || (cd[cQ][cm] = cd[cQ][cm] + cL);
              let H0, H1, H2, H3, H4, H5, H6, H7, H8 = [], H9 = [];
              for (H8[0x0] = [],
              H8[0x1] = [],
              H9[0x0] = [],
              H9[0x1] = [],
              cQ = 0x0; cQ < cM; cQ++)
                  for (H8[0x0][cQ] = [],
                  H8[0x1][cQ] = [],
                  H9[0x0][cQ] = [],
                  H9[0x1][cQ] = [],
                  cm = 0x0; cm < cz; cm++)
                      cm < cz - 0x1 && (H8[0x0][cQ][cm] = -0x1,
                      H8[0x1][cQ][cm] = -0x1),
                      cQ < cM - 0x1 && (H9[0x0][cQ][cm] = -0x1,
                      H9[0x1][cQ][cm] = -0x1);
              for (cQ = 0x0; cQ < cN['length']; cQ++)
                  for (H0 = cN[cQ],
                  cm = 0x0; cm < H0['getLineNum'](); cm++)
                      for (H1 = H0['LineList'][cm],
                      H2 = H1['ijPointList'],
                      H3 = 0x0; H3 < H2['length'] - 0x1; H3++)
                          H6 = H2[H3],
                          H7 = H2[H3 + 0x1],
                          H6['I'] === H7['I'] ? (H4 = H6['I'],
                          H5 = Math['min'](H6['J'], H7['J']),
                          H8[0x0][H4][H5] = cQ,
                          H7['J'] > H6['J'] ? H8[0x1][H4][H5] = 0x1 : H8[0x1][H4][H5] = 0x0) : (H5 = H6['J'],
                          H4 = Math['min'](H6['I'], H7['I']),
                          H9[0x0][H4][H5] = cQ,
                          H7['I'] > H6['I'] ? H9[0x1][H4][H5] = 0x0 : H9[0x1][H4][H5] = 0x1);
              let Hv, HA, Hk, Hl, HK = [], Hb = [];
              for (HA = 0x0; HA < cC; HA++) {
                  for (Hv = cO[HA],
                  cQ = 0x0; cQ < cM; cQ++)
                      for (HK[cQ] = [],
                      Hb[cQ] = [],
                      cm = 0x0; cm < cz; cm++)
                          cm < cz - 0x1 && (0x0 !== cG[cQ][cm] && 0x0 !== cG[cQ][cm + 0x1] && (cd[cQ][cm] - Hv) * (cd[cQ][cm + 0x1] - Hv) < 0x0 ? HK[cQ][cm] = (Hv - cd[cQ][cm]) / (cd[cQ][cm + 0x1] - cd[cQ][cm]) : HK[cQ][cm] = -0x2),
                          cQ < cM - 0x1 && (0x0 !== cG[cQ][cm] && 0x0 !== cG[cQ + 0x1][cm] && (cd[cQ][cm] - Hv) * (cd[cQ + 0x1][cm] - Hv) < 0x0 ? Hb[cQ][cm] = (Hv - cd[cQ][cm]) / (cd[cQ + 0x1][cm] - cd[cQ][cm]) : Hb[cQ][cm] = -0x2);
                  cP = bB['isoline_UndefData'](cd, cq, cJ, Hv, HK, Hb, H8, H9, cR['length']);
                  for (let Hc of cP)
                      cR['push'](Hc);
              }
              for (cQ = 0x0; cQ < cN['length']; cQ++)
                  for (H0 = cN[cQ],
                  H1 = H0['LineList'][0x0],
                  cm = 0x0; cm < cR['length']; cm++)
                      Hk = cR[cm],
                      'Close' === Hk['Type'] && (Hl = Hk['PointList'][0x0],
                      bB['pointInPolygonByPList'](H1['pointList'], Hl) && (Hk['BorderIdx'] = cQ)),
                      cR['splice'](cm, 0x1),
                      cR['splice'](cm, 0x0, Hk);
              return cR;
          }
          static['createContourLines'](cd, cq, cJ, cC, cO, cG, cg) {
              let cN, cP, cM, cz, cQ, cm, cL, cR, H0, H1 = [];
              cm = cd['length'],
              cL = cd[0x0]['length'];
              let H2, H3, H4, H5 = [], H6 = [];
              for (H2 = 0.00001 * cO[0x0],
              0x0 === H2 && (H2 = 0.00001),
              cR = 0x0; cR < cm; cR++)
                  for (H0 = 0x0; H0 < cL; H0++)
                      cd[cR][H0] = cd[cR][H0] + H2;
              for (H4 = 0x0; H4 < cC; H4++) {
                  for (H3 = cO[H4],
                  cR = 0x0; cR < cm; cR++)
                      for (H0 = 0x0; H0 < cL; H0++)
                          H0 < cL - 0x1 && ((cd[cR][H0] - H3) * (cd[cR][H0 + 0x1] - H3) < 0x0 ? H5[cR][H0] = (H3 - cd[cR][H0]) / (cd[cR][H0 + 0x1] - cd[cR][H0]) : H5[cR][H0] = -0x2),
                          cR < cm - 0x1 && ((cd[cR][H0] - H3) * (cd[cR + 0x1][H0] - H3) < 0x0 ? H6[cR][H0] = (H3 - cd[cR][H0]) / (cd[cR + 0x1][H0] - cd[cR][H0]) : H6[cR][H0] = -0x2);
                  cN = bB['isoline_Bottom'](cd, cq, cJ, H3, cG, cg, H5, H6),
                  cP = bB['isoline_Left'](cd, cq, cJ, H3, cG, cg, H5, H6),
                  cM = bB['isoline_Top'](cd, cq, cJ, H3, cG, cg, H5, H6),
                  cz = bB['isoline_Right'](cd, cq, cJ, H3, cG, cg, H5, H6),
                  cQ = bB['isoline_Close'](cd, cq, cJ, H3, cG, cg, H5, H6),
                  bB['addAll'](cN, H1),
                  bB['addAll'](cP, H1),
                  bB['addAll'](cM, H1),
                  bB['addAll'](cz, H1),
                  bB['addAll'](cQ, H1);
              }
              return H1;
          }
          static['addAll'](cd, cq) {
              cq || console['log']('');
              for (let cJ of cd)
                  cq['push'](cJ);
          }
          static['cutContourWithPolygon'](cd, cq) {
              let cJ, cC, cO, cG, cg, cN, cP, cM, cz, cQ, cm, cL, cR, H0, H1, H2 = [], H3 = new bV(), H4 = new bW();
              for (bB['_endPointList'] = [],
              bB['isClockwise'](cq) || cq['reverse'](),
              cJ = 0x0; cJ < cd['length']; cJ++) {
                  cG = cd[cJ],
                  cN = cG['Value'],
                  cP = cG['Type'],
                  cg = [],
                  bB['addAll'](cG['PointList'], cg),
                  cM = false;
                  let H5 = [];
                  if ('Close' === cP && bB['pointInPolygonByPList'](cq, cg[0x0])) {
                      let H6 = true
                        , H7 = 0x0;
                      for (cC = 0x0; cC < cg['length']; cC++)
                          if (!bB['pointInPolygonByPList'](cq, cg[cC])) {
                              H7 = cC,
                              H6 = false;
                              break;
                          }
                      if (!H6) {
                          let H8 = [];
                          for (cC = H7; cC < cg['length']; cC++)
                              H8['push'](cg[0x0]);
                          for (cC = 0x1; cC < H7; cC++)
                              H8['push'](cg[0x0]);
                          H8['push'](H8[0x0]),
                          cg = H8;
                      }
                  }
                  for (cm = new bE(),
                  cC = 0x0; cC < cg['length']; cC++) {
                      if (cL = cg[cC],
                      bB['pointInPolygonByPList'](cq, cL)) {
                          if (!cM && cC > 0x0) {
                              for (H0 = new bj(),
                              H0['P1'] = cm,
                              H0['P2'] = cL,
                              cz = cq[cq['length'] - 0x1],
                              cR = new bE(),
                              cO = 0x0; cO < cq['length']; cO++) {
                                  if (cQ = cq[cO],
                                  H1 = new bj(),
                                  H1['P1'] = cz,
                                  H1['P2'] = cQ,
                                  bB['isLineSegmentCross'](H0, H1)) {
                                      cR = bB['getCrossPointD'](H0, H1),
                                      H4['sPoint'] = cz,
                                      H4['Point'] = cR,
                                      H4['Index'] = H2['length'],
                                      bB['_endPointList']['push'](H4);
                                      break;
                                  }
                                  cz = cQ;
                              }
                              H5['push'](cR),
                              cP = 'Border';
                          }
                          H5['push'](cg[cC]),
                          cM = true;
                      } else {
                          if (cM) {
                              for (H0 = new bj(),
                              H0['P1'] = cm,
                              H0['P2'] = cL,
                              cz = cq[cq['length'] - 0x1],
                              cR = new bE(),
                              cO = 0x0; cO < cq['length']; cO++) {
                                  if (cQ = cq[cO],
                                  H1 = new bj(),
                                  H1['P1'] = cz,
                                  H1['P2'] = cQ,
                                  bB['isLineSegmentCross'](H0, H1)) {
                                      cR = bB['getCrossPointD'](H0, H1),
                                      H4['sPoint'] = cz,
                                      H4['Point'] = cR,
                                      H4['Index'] = H2['length'],
                                      bB['_endPointList']['push'](H4);
                                      break;
                                  }
                                  cz = cQ;
                              }
                              H5['push'](cR),
                              H3['Value'] = cN,
                              H3['Type'] = cP,
                              H3['PointList'] = H5,
                              H2['push'](H3),
                              cM = false,
                              H5 = [],
                              cP = 'Border';
                          }
                      }
                      cm = cL;
                  }
                  cM && H5['length'] > 0x1 && (H3['Value'] = cN,
                  H3['Type'] = cP,
                  H3['PointList'] = H5,
                  H2['push'](H3));
              }
              return H2;
          }
          static['cutContourLines'](cd, cq) {
              let cJ, cC, cO, cG, cg, cN, cP, cM, cz, cQ, cm, cL, cR, H0, H1, H2, H3 = cq['LineList'][0x0]['pointList'], H4 = [], H5 = new bW();
              for (bB['_endPointList'] = [],
              bB['isClockwise'](H3) || H3['reverse'](),
              cJ = 0x0; cJ < cd['length']; cJ++) {
                  cG = cd[cJ],
                  cP = cG['Value'],
                  cM = cG['Type'],
                  cN = [],
                  bB['addAll'](cG['PointList'], cN),
                  cz = false;
                  let H6 = [];
                  if ('Close' === cM && bB['pointInPolygonByPList'](H3, cN[0x0])) {
                      let H7 = true
                        , H8 = 0x0;
                      for (cC = 0x0; cC < cN['length']; cC++)
                          if (!bB['pointInPolygonByPList'](H3, cN[cC])) {
                              H8 = cC,
                              H7 = false;
                              break;
                          }
                      if (!H7) {
                          let H9 = [];
                          for (cC = H8; cC < cN['length']; cC++)
                              H9['push'](cN[cC]);
                          for (cC = 0x1; cC < H8; cC++)
                              H9['push'](cN[cC]);
                          H9['push'](H9[0x0]),
                          cN = H9;
                      }
                  }
                  for (cL = new bE(),
                  cC = 0x0; cC < cN['length']; cC++) {
                      if (cR = cN[cC],
                      bB['pointInPolygonByPList'](H3, cR)) {
                          if (!cz && cC > 0x0) {
                              for (H1 = new bj(),
                              H1['P1'] = cL,
                              H1['P2'] = cR,
                              cQ = H3[H3['length'] - 0x1],
                              H0 = new bE(),
                              cO = 0x0; cO < H3['length']; cO++) {
                                  if (cm = H3[cO],
                                  H2 = new bj(),
                                  H2['P1'] = cQ,
                                  H2['P2'] = cm,
                                  bB['isLineSegmentCross'](H1, H2)) {
                                      H0 = bB['getCrossPointD'](H1, H2),
                                      H5['sPoint'] = cQ,
                                      H5['Point'] = H0,
                                      H5['Index'] = H4['length'],
                                      bB['_endPointList']['push'](H5);
                                      break;
                                  }
                                  cQ = cm;
                              }
                              H6['push'](H0),
                              cM = 'Border';
                          }
                          H6['push'](cN[cC]),
                          cz = true;
                      } else {
                          if (cz) {
                              for (H1 = new bj(),
                              H1['P1'] = cL,
                              H1['P2'] = cR,
                              cQ = H3[H3['length'] - 0x1],
                              H0 = new bE(),
                              cO = 0x0; cO < H3['length']; cO++) {
                                  if (cm = H3[cO],
                                  H2 = new bj(),
                                  H2['P1'] = cQ,
                                  H2['P2'] = cm,
                                  bB['isLineSegmentCross'](H1, H2)) {
                                      H0 = bB['getCrossPointD'](H1, H2),
                                      H5['sPoint'] = cQ,
                                      H5['Point'] = H0,
                                      H5['Index'] = H4['length'],
                                      bB['_endPointList']['push'](H5);
                                      break;
                                  }
                                  cQ = cm;
                              }
                              H6['push'](H0),
                              cg = new bV(),
                              cg['Value'] = cP,
                              cg['Type'] = cM,
                              cg['PointList'] = H6,
                              H4['push'](cg),
                              cz = false,
                              H6 = [],
                              cM = 'Border';
                          }
                      }
                      cL = cR;
                  }
                  cz && H6['length'] > 0x1 && (cg = new bV(),
                  cg['Value'] = cP,
                  cg['Type'] = cM,
                  cg['PointList'] = H6,
                  H4['push'](cg));
              }
              return H4;
          }
          static['smoothLines'](cd) {
              let cq, cJ, cC, cO = [];
              for (cq = 0x0; cq < cd['length']; cq++)
                  if (cJ = cd[cq],
                  cC = [],
                  bB['addAll'](cJ['PointList'], cC),
                  !(cC['length'] <= 0x1)) {
                      if (0x2 === cC['length']) {
                          let cG = new bE()
                            , cg = cC[0x0]
                            , cN = cC[0x1];
                          cG['X'] = (cN['X'] - cg['X']) / 0x4 + cg['X'],
                          cG['Y'] = (cN['Y'] - cg['Y']) / 0x4 + cg['Y'],
                          cC['splice'](0x1, 0x0, cG),
                          cG = new bE(),
                          cG['X'] = (cN['X'] - cg['X']) / 0x4 * 0x3 + cg['X'],
                          cG['Y'] = (cN['Y'] - cg['Y']) / 0x4 * 0x3 + cg['Y'],
                          cC['splice'](0x2, 0x0, cG);
                      }
                      if (0x3 === cC['length']) {
                          let cP = new bE()
                            , cM = cC[0x0]
                            , cz = cC[0x1];
                          cP['X'] = (cz['X'] - cM['X']) / 0x2 + cM['X'],
                          cP['Y'] = (cz['Y'] - cM['Y']) / 0x2 + cM['Y'],
                          cC['splice'](0x1, 0x0, cP);
                      }
                      cC = bB['BSplineScanning'](cC, cC['length']),
                      cJ['PointList'] = cC,
                      cO['push'](cJ);
                  }
              return cO;
          }
          static['smoothPoints'](cd) {
              return bB['BSplineScanning'](cd, cd['length']);
          }
          static['tracingPolygons'](cd, cq, cJ, cC) {
              let cO, cG, cg, cN, cP, cM, cz, cQ, cm, cL, cR, H0, H1 = [], H2 = [], H3 = [], H4 = [], H5 = [], H6 = 0x0;
              for (cz = 0x0; cz < cJ['length']; cz++) {
                  if (H5 = [],
                  H3 = [],
                  H4 = [],
                  H1 = [],
                  cg = cJ[cz],
                  cN = cg['LineList'][0x0],
                  cG = cN['pointList'],
                  bB['isClockwise'](cG) || cG['reverse'](),
                  0x1 === cg['getLineNum']()) {
                      for (cQ = 0x0; cQ < cG['length']; cQ++)
                          cP = cG[cQ],
                          cM = new bf(),
                          cM['Id'] = -0x1,
                          cM['Point'] = cP,
                          cM['Value'] = cd[cN['ijPointList'][cQ]['I']][cN['ijPointList'][cQ]['J']],
                          H5['push'](cM);
                      for (cQ = 0x0; cQ < cq['length']; cQ++)
                          cm = cq[cQ],
                          cm['BorderIdx'] === cz && (H4['push'](cm),
                          'Border' === cm['Type'] && (cP = cm['PointList'][0x0],
                          cM = new bf(),
                          cM['Id'] = H4['length'] - 0x1,
                          cM['Point'] = cP,
                          cM['Value'] = cm['Value'],
                          H3['push'](cM),
                          cP = cm['PointList'][cm['PointList']['length'] - 0x1],
                          cM = new bf(),
                          cM['Id'] = H4['length'] - 0x1,
                          cM['Point'] = cP,
                          cM['Value'] = cm['Value'],
                          H3['push'](cM)));
                      if (0x0 === H4['length']) {
                          if (cR = cN['ijPointList'][0x0],
                          cL = new bZ(),
                          cd[cR['I']][cR['J']] < cC[0x0])
                              H6 = cC[0x0],
                              cL['IsHighCenter'] = false;
                          else {
                              for (cQ = cC['length'] - 0x1; cQ >= 0x0; cQ--)
                                  if (cd[cR['I']][cR['J']] > cC[cQ]) {
                                      H6 = cC[cQ];
                                      break;
                                  }
                              cL['IsHighCenter'] = true;
                          }
                          cG['length'] > 0x0 && (cL['IsBorder'] = true,
                          cL['HighValue'] = H6,
                          cL['LowValue'] = H6,
                          cL['Extent'] = new bT(),
                          cL['Area'] = bB['getExtentAndArea'](cG, cL['Extent']),
                          cL['StartPointIdx'] = 0x0,
                          cL['IsClockWise'] = true,
                          cL['OutLine']['Type'] = 'Border',
                          cL['OutLine']['Value'] = H6,
                          cL['OutLine']['BorderIdx'] = cz,
                          cL['OutLine']['PointList'] = cG,
                          cL['HoleLines'] = [],
                          H1['push'](cL));
                      } else
                          cO = H3['length'] > 0x0 ? bB['insertPoint2Border'](H3, H5) : H5,
                          H1 = bB['tracingPolygons_Line_Border'](H4, cO);
                      H1 = bB['addPolygonHoles'](H1);
                  } else {
                      for (cN = cg['LineList'][0x0],
                      cQ = 0x0; cQ < cq['length']; cQ++)
                          cm = cq[cQ],
                          cm['BorderIdx'] === cz && (H4['push'](cm),
                          'Border' === cm['Type'] && (cP = cm['PointList'][0x0],
                          cM = new bf(),
                          cM['Id'] = H4['length'] - 0x1,
                          cM['Point'] = cP,
                          cM['Value'] = cm['Value'],
                          H3['push'](cM),
                          cP = cm['PointList'][cm['PointList']['length'] - 0x1],
                          cM = new bf(),
                          cM['Id'] = H4['length'] - 0x1,
                          cM['Point'] = cP,
                          cM['Value'] = cm['Value'],
                          H3['push'](cM)));
                      if (0x0 === H4['length']) {
                          if (cR = cN['ijPointList'][0x0],
                          cL = new bZ(),
                          cd[cR['I']][cR['J']] < cC[0x0])
                              H6 = cC[0x0],
                              cL['IsHighCenter'] = false;
                          else {
                              for (cQ = cC['length'] - 0x1; cQ >= 0x0; cQ--)
                                  if (cd[cR['I']][cR['J']] > cC[cQ]) {
                                      H6 = cC[cQ];
                                      break;
                                  }
                              cL['IsHighCenter'] = true;
                          }
                          cG['length'] > 0x0 && (cL['IsBorder'] = true,
                          cL['HighValue'] = H6,
                          cL['LowValue'] = H6,
                          cL['Area'] = bB['getExtentAndArea'](cG, cL['Extent']),
                          cL['StartPointIdx'] = 0x0,
                          cL['IsClockWise'] = true,
                          cL['OutLine']['Type'] = 'Border',
                          cL['OutLine']['Value'] = H6,
                          cL['OutLine']['BorderIdx'] = cz,
                          cL['OutLine']['PointList'] = cG,
                          cL['HoleLines'] = [],
                          H1['push'](cL));
                      } else {
                          H0 = [],
                          H0['length'] = cg['getLineNum'](),
                          cO = bB['insertPoint2Border_Ring'](cd, H3, cg, H0),
                          H1 = bB['tracingPolygons_Ring'](H4, cO, cg, cC, H0);
                          let H8 = [];
                          for (; H1['length'] > 0x0; ) {
                              let H9 = false;
                              for (cQ = 0x0; cQ < H8['length']; cQ++)
                                  if (H1[0x0]['Area'] > H8[cQ]['Area']) {
                                      H8['push'](H1[0x0]),
                                      H9 = true;
                                      break;
                                  }
                              H9 || H8['push'](H1[0x0]),
                              H1['splice'](0x0, 0x1);
                          }
                          H1 = H8;
                      }
                      let H7 = [];
                      for (cQ = 0x0; cQ < cg['getLineNum'](); cQ++)
                          H7['push'](cg['LineList'][cQ]['pointList']);
                      H7['length'] > 0x0 && bB['addHoles_Ring'](H1, H7),
                      H1 = bB['addPolygonHoles_Ring'](H1);
                  }
                  bB['addAll'](H1, H2);
              }
              for (let Hv of H2)
                  bB['isClockwise'](Hv['OutLine']['PointList']) || Hv['OutLine']['PointList']['reverse']();
              return H2;
          }
          static['createContourPolygons'](cd, cq, cJ) {
              let cC, cO;
              return cO = bB['insertPoint2RectangleBorder'](cd, cq),
              cC = bB['tracingPolygons_Extent'](cd, cO, cq, cJ),
              cC;
          }
          static['createCutContourPolygons'](cd, cq, cJ, cC) {
              let cO, cG, cg, cN, cP, cM = [];
              for (bB['isClockwise'](cq) || cq['reverse'](),
              cP = 0x0; cP < cq['length']; cP++)
                  cg = cq[cP],
                  cN = new bf(),
                  cN['Id'] = -0x1,
                  cN['Point'] = cg,
                  cM['push'](cN);
              return cG = bB['insertEndPoint2Border'](bB['_endPointList'], cM),
              cO = bB['tracingPolygons_Extent'](cd, cG, cJ, cC),
              cO;
          }
          static['createBorderContourPolygons'](cd, cq, cJ, cC, cO) {
              let cG, cg, cN, cP, cM, cz, cQ, cm, cL, cR, H0, H1 = [], H2 = [], H3 = [], H4 = [], H5 = [], H6 = [], H7 = 0x0;
              for (cz = 0x0; cz < cJ['length']; cz++) {
                  if (H6 = [],
                  H3 = [],
                  H5 = [],
                  H1 = [],
                  cg = cJ[cz],
                  0x1 === cg['getLineNum']()) {
                      for (cN = cg['LineList'][0x0],
                      H4 = cN['pointList'],
                      bB['isClockwise'](H4) || H4['reverse'](),
                      cQ = 0x0; cQ < H4['length']; cQ++)
                          cP = H4[cQ],
                          cM = new bf(),
                          cM['Id'] = -0x1,
                          cM['Point'] = cP,
                          cM['Value'] = cd[cN['ijPointList'][cQ]['I']][cN['ijPointList'][cQ]['J']],
                          H6['push'](cM);
                      for (cQ = 0x0; cQ < cq['length']; cQ++)
                          cm = cq[cQ],
                          cm['BorderIdx'] === cz && (H5['push'](cm),
                          'Border' === cm['Type'] && (cP = cm['PointList'][0x0],
                          cM = new bf(),
                          cM['Id'] = H5['length'] - 0x1,
                          cM['Point'] = cP,
                          cM['Value'] = cm['Value'],
                          H3['push'](cM),
                          cP = cm['PointList'][cm['PointList']['length'] - 0x1],
                          cM = new bf(),
                          cM['Id'] = H5['length'] - 0x1,
                          cM['Point'] = cP,
                          cM['Value'] = cm['Value'],
                          H3['push'](cM)));
                      if (0x0 === H5['length']) {
                          if (cR = cN['ijPointList'][0x0],
                          cL = new bZ(),
                          cd[cR['I']][cR['J']] < cO[0x0])
                              H7 = cO[0x0],
                              cL['IsHighCenter'] = false;
                          else {
                              for (cQ = cO['length'] - 0x1; cQ >= 0x0; cQ--)
                                  if (cd[cR['I']][cR['J']] > cO[cQ]) {
                                      H7 = cO[cQ];
                                      break;
                                  }
                              cL['IsHighCenter'] = true;
                          }
                          H4['length'] > 0x0 && (cL['HighValue'] = H7,
                          cL['LowValue'] = H7,
                          cL['Extent'] = new bT(),
                          cL['Area'] = bB['getExtentAndArea'](H4, cL['Extent']),
                          cL['StartPointIdx'] = 0x0,
                          cL['IsClockWise'] = true,
                          cL['OutLine']['Type'] = 'Border',
                          cL['OutLine']['Value'] = H7,
                          cL['OutLine']['BorderIdx'] = cz,
                          cL['OutLine']['PointList'] = H4,
                          H1['push'](cL));
                      } else
                          cG = bB['insertPoint2Border'](H3, H6),
                          H1 = bB['tracingPolygons_Line_Border'](H5, cG);
                  } else {
                      for (cN = cg['LineList'][0x0],
                      cQ = 0x0; cQ < cq['length']; cQ++)
                          cm = cq[cQ],
                          cm['BorderIdx'] === cz && (H5['push'](cm),
                          'Border' === cm['Type'] && (cP = cm['PointList'][0x0],
                          cM = new bf(),
                          cM['Id'] = H5['length'] - 0x1,
                          cM['Point'] = cP,
                          cM['Value'] = cm['Value'],
                          H3['push'](cM),
                          cP = cm['PointList'][cm['PointList']['length'] - 0x1],
                          cM = new bf(),
                          cM['Id'] = H5['length'] - 0x1,
                          cM['Point'] = cP,
                          cM['Value'] = cm['Value'],
                          H3['push'](cM)));
                      if (0x0 === H5['length']) {
                          if (cL = new bZ(),
                          cR = cN['ijPointList'][0x0],
                          cd[cR['I']][cR['J']] < cO[0x0])
                              H7 = cO[0x0],
                              cL['IsHighCenter'] = false;
                          else {
                              for (cQ = cO['length'] - 0x1; cQ >= 0x0; cQ--)
                                  if (cd[cR['I']][cR['J']] > cO[cQ]) {
                                      H7 = cO[cQ];
                                      break;
                                  }
                              cL['IsHighCenter'] = true;
                          }
                          H4['length'] > 0x0 && (cL['HighValue'] = H7,
                          cL['LowValue'] = H7,
                          cL['Area'] = bB['getExtentAndArea'](H4, cL['Extent']),
                          cL['StartPointIdx'] = 0x0,
                          cL['IsClockWise'] = true,
                          cL['OutLine']['Type'] = 'Border',
                          cL['OutLine']['Value'] = H7,
                          cL['OutLine']['BorderIdx'] = cz,
                          cL['OutLine']['PointList'] = H4,
                          H1['push'](cL));
                      } else
                          H0 = [],
                          cG = bB['insertPoint2Border_Ring'](cd, H3, cg, H0),
                          H1 = bB['tracingPolygons_Ring'](H5, cG, cg, cO, H0);
                  }
                  bB['addAll'](H1, H2);
              }
              return H2;
          }
          static['pointInPolygonByPList'](cd, cq) {
              let cJ, cC, cO, cG, cg, cN, cP, cM, cz, cQ = false, cm = cd['length'];
              if (cm < 0x3)
                  return false;
              for (cO = cd[cm - 0x1]['X'],
              cG = cd[cm - 0x1]['Y'],
              cz = 0x0; cz < cm; cz++)
                  cJ = cd[cz]['X'],
                  cC = cd[cz]['Y'],
                  cJ > cO ? (cg = cO,
                  cP = cJ,
                  cN = cG,
                  cM = cC) : (cg = cJ,
                  cP = cO,
                  cN = cC,
                  cM = cG),
                  cJ < cq['X'] == cq['X'] <= cO && (cq['Y'] - cN) * (cP - cg) < (cM - cN) * (cq['X'] - cg) && (cQ = !cQ),
                  cO = cJ,
                  cG = cC;
              return cQ;
          }
          static['pointInPolygon'](cd, cq) {
              if (cd['HasHoles']()) {
                  let cJ = bB['pointInPolygonByPList'](cd['OutLine']['PointList'], cq);
                  if (cJ) {
                      for (let cC of cd['HoleLines'])
                          if (bB['pointInPolygonByPList'](cC['PointList'], cq)) {
                              cJ = false;
                              break;
                          }
                  }
                  return cJ;
              }
              return bB['pointInPolygonByPList'](cd['OutLine']['PointList'], cq);
          }
          static['clipPolylines'](cd, cq) {
              let cJ = [];
              for (let cC of cd)
                  bB['addAll'](bB['cutPolyline'](cC, cq), cJ);
              return cJ;
          }
          static['clipPolygons'](cd, cq) {
              let cJ = [];
              for (let cG = 0x0; cG < cd['length']; cG++) {
                  let cg = cd[cG];
                  cg['HasHoles']() ? bB['addAll'](bB['cutPolygon_Hole'](cg, cq), cJ) : bB['addAll'](bB['cutPolygon'](cg, cq), cJ);
              }
              let cC, cO = [];
              for (let cN = 0x0; cN < cJ['length']; cN++) {
                  let cP = cJ[cN];
                  cC = false;
                  for (let cM = 0x0; cM < cO['length']; cM++)
                      if (cP['Area'] > cO[cM]['Area']) {
                          cO['splice'](cM, 0x0, cP),
                          cC = true;
                          break;
                      }
                  cC || cO['push'](cP);
              }
              return cO;
          }
          static['traceBorder'](cd, cq, cJ, cC, cO, cG) {
              let cg, cN, cP, cM, cz = true;
              return cq < cJ ? 0x1 === cd[cJ][cO - 0x1] && 0x1 === cd[cJ][cO + 0x1] ? (cg = cd[cJ - 0x1][cO - 0x1],
              cN = cd[cJ + 0x1][cO],
              cP = cd[cJ + 0x1][cO - 0x1],
              0x0 !== cg && 0x0 === cN || 0x0 === cg && 0x0 !== cN && 0x0 !== cP ? (cG[0x0] = cJ,
              cG[0x1] = cO - 0x1) : (cG[0x0] = cJ,
              cG[0x1] = cO + 0x1)) : 0x1 === cd[cJ][cO - 0x1] && 0x1 === cd[cJ + 0x1][cO] ? (cg = cd[cJ + 0x1][cO - 0x1],
              cN = cd[cJ + 0x1][cO + 0x1],
              cP = cd[cJ][cO - 0x1],
              cM = cd[cJ][cO + 0x1],
              0x0 === cg || 0x0 === cN || 0x0 === cP || 0x0 === cM ? 0x0 === cg && 0x0 === cM || 0x0 === cN && 0x0 === cP ? (cG[0x0] = cJ,
              cG[0x1] = cO - 0x1) : (cG[0x0] = cJ + 0x1,
              cG[0x1] = cO) : (cG[0x0] = cJ,
              cG[0x1] = cO - 0x1)) : 0x1 === cd[cJ][cO + 0x1] && 0x1 === cd[cJ + 0x1][cO] ? (cg = cd[cJ + 0x1][cO - 0x1],
              cN = cd[cJ + 0x1][cO + 0x1],
              cP = cd[cJ][cO - 0x1],
              cM = cd[cJ][cO + 0x1],
              0x0 === cg || 0x0 === cN || 0x0 === cP || 0x0 === cM ? 0x0 === cg && 0x0 === cM || 0x0 === cN && 0x0 === cP ? (cG[0x0] = cJ,
              cG[0x1] = cO + 0x1) : (cG[0x0] = cJ + 0x1,
              cG[0x1] = cO) : (cG[0x0] = cJ,
              cG[0x1] = cO + 0x1)) : 0x1 === cd[cJ][cO - 0x1] ? (cG[0x0] = cJ,
              cG[0x1] = cO - 0x1) : 0x1 === cd[cJ][cO + 0x1] ? (cG[0x0] = cJ,
              cG[0x1] = cO + 0x1) : 0x1 === cd[cJ + 0x1][cO] ? (cG[0x0] = cJ + 0x1,
              cG[0x1] = cO) : cz = false : cC < cO ? 0x1 === cd[cJ + 0x1][cO] && 0x1 === cd[cJ - 0x1][cO] ? (cg = cd[cJ + 0x1][cO - 0x1],
              cN = cd[cJ][cO + 0x1],
              cP = cd[cJ + 0x1][cO + 0x1],
              0x0 !== cg && 0x0 === cN || 0x0 === cg && 0x0 !== cN && 0x0 !== cP ? (cG[0x0] = cJ + 0x1,
              cG[0x1] = cO) : (cG[0x0] = cJ - 0x1,
              cG[0x1] = cO)) : 0x1 === cd[cJ + 0x1][cO] && 0x1 === cd[cJ][cO + 0x1] ? (cP = cd[cJ - 0x1][cO],
              cM = cd[cJ + 0x1][cO],
              cg = cd[cJ - 0x1][cO + 0x1],
              cN = cd[cJ + 0x1][cO + 0x1],
              0x0 === cg || 0x0 === cN || 0x0 === cP || 0x0 === cM ? 0x0 === cg && 0x0 === cM || 0x0 === cN && 0x0 === cP ? (cG[0x0] = cJ + 0x1,
              cG[0x1] = cO) : (cG[0x0] = cJ,
              cG[0x1] = cO + 0x1) : (cG[0x0] = cJ + 0x1,
              cG[0x1] = cO)) : 0x1 === cd[cJ - 0x1][cO] && 0x1 === cd[cJ][cO + 0x1] ? (cP = cd[cJ - 0x1][cO],
              cM = cd[cJ + 0x1][cO],
              cg = cd[cJ - 0x1][cO + 0x1],
              cN = cd[cJ + 0x1][cO + 0x1],
              0x0 === cg || 0x0 === cN || 0x0 === cP || 0x0 === cM ? 0x0 === cg && 0x0 === cM || 0x0 === cN && 0x0 === cP ? (cG[0x0] = cJ - 0x1,
              cG[0x1] = cO) : (cG[0x0] = cJ,
              cG[0x1] = cO + 0x1) : (cG[0x0] = cJ - 0x1,
              cG[0x1] = cO)) : 0x1 === cd[cJ + 0x1][cO] ? (cG[0x0] = cJ + 0x1,
              cG[0x1] = cO) : 0x1 === cd[cJ - 0x1][cO] ? (cG[0x0] = cJ - 0x1,
              cG[0x1] = cO) : 0x1 === cd[cJ][cO + 0x1] ? (cG[0x0] = cJ,
              cG[0x1] = cO + 0x1) : cz = false : cq > cJ ? 0x1 === cd[cJ][cO - 0x1] && 0x1 === cd[cJ][cO + 0x1] ? (cg = cd[cJ + 0x1][cO - 0x1],
              cN = cd[cJ - 0x1][cO],
              cP = cd[cJ - 0x1][cO + 0x1],
              0x0 !== cg && 0x0 === cN || 0x0 === cg && 0x0 !== cN && 0x0 !== cP ? (cG[0x0] = cJ,
              cG[0x1] = cO - 0x1) : (cG[0x0] = cJ,
              cG[0x1] = cO + 0x1)) : 0x1 === cd[cJ][cO - 0x1] && 0x1 === cd[cJ - 0x1][cO] ? (cg = cd[cJ - 0x1][cO - 0x1],
              cN = cd[cJ - 0x1][cO + 0x1],
              cP = cd[cJ][cO - 0x1],
              cM = cd[cJ][cO + 0x1],
              0x0 === cg || 0x0 === cN || 0x0 === cP || 0x0 === cM ? 0x0 === cg && 0x0 === cM || 0x0 === cN && 0x0 === cP ? (cG[0x0] = cJ,
              cG[0x1] = cO - 0x1) : (cG[0x0] = cJ - 0x1,
              cG[0x1] = cO) : (cG[0x0] = cJ,
              cG[0x1] = cO - 0x1)) : 0x1 === cd[cJ][cO + 0x1] && 0x1 === cd[cJ - 0x1][cO] ? (cg = cd[cJ - 0x1][cO - 0x1],
              cN = cd[cJ - 0x1][cO + 0x1],
              cP = cd[cJ][cO - 0x1],
              cM = cd[cJ][cO + 0x1],
              0x0 === cg || 0x0 === cN || 0x0 === cP || 0x0 === cM ? 0x0 === cg && 0x0 === cM || 0x0 === cN && 0x0 === cP ? (cG[0x0] = cJ,
              cG[0x1] = cO + 0x1) : (cG[0x0] = cJ - 0x1,
              cG[0x1] = cO) : (cG[0x0] = cJ,
              cG[0x1] = cO + 0x1)) : 0x1 === cd[cJ][cO - 0x1] ? (cG[0x0] = cJ,
              cG[0x1] = cO - 0x1) : 0x1 === cd[cJ][cO + 0x1] ? (cG[0x0] = cJ,
              cG[0x1] = cO + 0x1) : 0x1 === cd[cJ - 0x1][cO] ? (cG[0x0] = cJ - 0x1,
              cG[0x1] = cO) : cz = false : cC > cO && (0x1 === cd[cJ + 0x1][cO] && 0x1 === cd[cJ - 0x1][cO] ? (cg = cd[cJ + 0x1][cO + 0x1],
              cN = cd[cJ][cO - 0x1],
              cP = cd[cJ - 0x1][cO - 0x1],
              0x0 !== cg && 0x0 === cN || 0x0 === cg && 0x0 !== cN && 0x0 !== cP ? (cG[0x0] = cJ + 0x1,
              cG[0x1] = cO) : (cG[0x0] = cJ - 0x1,
              cG[0x1] = cO)) : 0x1 === cd[cJ + 0x1][cO] && 0x1 === cd[cJ][cO - 0x1] ? (cP = cd[cJ - 0x1][cO],
              cM = cd[cJ + 0x1][cO],
              cg = cd[cJ - 0x1][cO - 0x1],
              cN = cd[cJ + 0x1][cO - 0x1],
              0x0 === cg || 0x0 === cN || 0x0 === cP || 0x0 === cM ? 0x0 === cg && 0x0 === cM || 0x0 === cN && 0x0 === cP ? (cG[0x0] = cJ + 0x1,
              cG[0x1] = cO) : (cG[0x0] = cJ,
              cG[0x1] = cO - 0x1) : (cG[0x0] = cJ + 0x1,
              cG[0x1] = cO)) : 0x1 === cd[cJ - 0x1][cO] && 0x1 === cd[cJ][cO - 0x1] ? (cP = cd[cJ - 0x1][cO],
              cM = cd[cJ + 0x1][cO],
              cg = cd[cJ - 0x1][cO - 0x1],
              cN = cd[cJ + 0x1][cO - 0x1],
              0x0 === cg || 0x0 === cN || 0x0 === cP || 0x0 === cM ? 0x0 === cg && 0x0 === cM || 0x0 === cN && 0x0 === cP ? (cG[0x0] = cJ - 0x1,
              cG[0x1] = cO) : (cG[0x0] = cJ,
              cG[0x1] = cO - 0x1) : (cG[0x0] = cJ - 0x1,
              cG[0x1] = cO)) : 0x1 === cd[cJ + 0x1][cO] ? (cG[0x0] = cJ + 0x1,
              cG[0x1] = cO) : 0x1 === cd[cJ - 0x1][cO] ? (cG[0x0] = cJ - 0x1,
              cG[0x1] = cO) : 0x1 === cd[cJ][cO - 0x1] ? (cG[0x0] = cJ,
              cG[0x1] = cO - 0x1) : cz = false),
              cz;
          }
          static['traceIsoline_UndefData'](cd, cq, cJ, cC, cO, cG, cg, cN, cP, cM, cz, cQ) {
              let cm = true
                , cL = 0x0
                , cR = 0x0
                , H0 = 0x0
                , H1 = 0x0
                , H2 = true;
              return cd < cq ? -0x2 !== cJ[cq][cG] && -0x2 !== cJ[cq][cG + 0x1] ? cJ[cq][cG] < cJ[cq][cG + 0x1] ? (cL = cg[cG],
              cR = cN[cq] + cJ[cq][cG] * (cN[cq + 0x1] - cN[cq]),
              H0 = cq,
              H1 = cG,
              cJ[H0][H1] = -0x2,
              H2 = false) : (cL = cg[cG + 0x1],
              cR = cN[cq] + cJ[cq][cG + 0x1] * (cN[cq + 0x1] - cN[cq]),
              H0 = cq,
              H1 = cG + 0x1,
              cJ[H0][H1] = -0x2,
              H2 = false) : -0x2 !== cJ[cq][cG] && -0x2 === cJ[cq][cG + 0x1] ? (cL = cg[cG],
              cR = cN[cq] + cJ[cq][cG] * (cN[cq + 0x1] - cN[cq]),
              H0 = cq,
              H1 = cG,
              cJ[H0][H1] = -0x2,
              H2 = false) : -0x2 === cJ[cq][cG] && -0x2 !== cJ[cq][cG + 0x1] ? (cL = cg[cG + 0x1],
              cR = cN[cq] + cJ[cq][cG + 0x1] * (cN[cq + 0x1] - cN[cq]),
              H0 = cq,
              H1 = cG + 0x1,
              cJ[H0][H1] = -0x2,
              H2 = false) : -0x2 !== cC[cq + 0x1][cG] ? (cL = cg[cG] + cC[cq + 0x1][cG] * (cg[cG + 0x1] - cg[cG]),
              cR = cN[cq + 0x1],
              H0 = cq + 0x1,
              H1 = cG,
              cC[H0][H1] = -0x2,
              H2 = true) : cm = false : cO < cG ? -0x2 !== cC[cq][cG] && -0x2 !== cC[cq + 0x1][cG] ? cC[cq][cG] < cC[cq + 0x1][cG] ? (cL = cg[cG] + cC[cq][cG] * (cg[cG + 0x1] - cg[cG]),
              cR = cN[cq],
              H0 = cq,
              H1 = cG,
              cC[H0][H1] = -0x2,
              H2 = true) : (cL = cg[cG] + cC[cq + 0x1][cG] * (cg[cG + 0x1] - cg[cG]),
              cR = cN[cq + 0x1],
              H0 = cq + 0x1,
              H1 = cG,
              cC[H0][H1] = -0x2,
              H2 = true) : -0x2 !== cC[cq][cG] && -0x2 === cC[cq + 0x1][cG] ? (cL = cg[cG] + cC[cq][cG] * (cg[cG + 0x1] - cg[cG]),
              cR = cN[cq],
              H0 = cq,
              H1 = cG,
              cC[H0][H1] = -0x2,
              H2 = true) : -0x2 === cC[cq][cG] && -0x2 !== cC[cq + 0x1][cG] ? (cL = cg[cG] + cC[cq + 0x1][cG] * (cg[cG + 0x1] - cg[cG]),
              cR = cN[cq + 0x1],
              H0 = cq + 0x1,
              H1 = cG,
              cC[H0][H1] = -0x2,
              H2 = true) : -0x2 !== cJ[cq][cG + 0x1] ? (cL = cg[cG + 0x1],
              cR = cN[cq] + cJ[cq][cG + 0x1] * (cN[cq + 0x1] - cN[cq]),
              H0 = cq,
              H1 = cG + 0x1,
              cJ[H0][H1] = -0x2,
              H2 = false) : cm = false : cg[cG] < cP ? -0x2 !== cJ[cq - 0x1][cG] && -0x2 !== cJ[cq - 0x1][cG + 0x1] ? cJ[cq - 0x1][cG] > cJ[cq - 0x1][cG + 0x1] ? (cL = cg[cG],
              cR = cN[cq - 0x1] + cJ[cq - 0x1][cG] * (cN[cq] - cN[cq - 0x1]),
              H0 = cq - 0x1,
              H1 = cG,
              cJ[H0][H1] = -0x2,
              H2 = false) : (cL = cg[cG + 0x1],
              cR = cN[cq - 0x1] + cJ[cq - 0x1][cG + 0x1] * (cN[cq] - cN[cq - 0x1]),
              H0 = cq - 0x1,
              H1 = cG + 0x1,
              cJ[H0][H1] = -0x2,
              H2 = false) : -0x2 !== cJ[cq - 0x1][cG] && -0x2 === cJ[cq - 0x1][cG + 0x1] ? (cL = cg[cG],
              cR = cN[cq - 0x1] + cJ[cq - 0x1][cG] * (cN[cq] - cN[cq - 0x1]),
              H0 = cq - 0x1,
              H1 = cG,
              cJ[H0][H1] = -0x2,
              H2 = false) : -0x2 === cJ[cq - 0x1][cG] && -0x2 !== cJ[cq - 0x1][cG + 0x1] ? (cL = cg[cG + 0x1],
              cR = cN[cq - 0x1] + cJ[cq - 0x1][cG + 0x1] * (cN[cq] - cN[cq - 0x1]),
              H0 = cq - 0x1,
              H1 = cG + 0x1,
              cJ[H0][H1] = -0x2,
              H2 = false) : -0x2 !== cC[cq - 0x1][cG] ? (cL = cg[cG] + cC[cq - 0x1][cG] * (cg[cG + 0x1] - cg[cG]),
              cR = cN[cq - 0x1],
              H0 = cq - 0x1,
              H1 = cG,
              cC[H0][H1] = -0x2,
              H2 = true) : cm = false : -0x2 !== cC[cq + 0x1][cG - 0x1] && -0x2 !== cC[cq][cG - 0x1] ? cC[cq + 0x1][cG - 0x1] > cC[cq][cG - 0x1] ? (cL = cg[cG - 0x1] + cC[cq + 0x1][cG - 0x1] * (cg[cG] - cg[cG - 0x1]),
              cR = cN[cq + 0x1],
              H0 = cq + 0x1,
              H1 = cG - 0x1,
              cC[H0][H1] = -0x2,
              H2 = true) : (cL = cg[cG - 0x1] + cC[cq][cG - 0x1] * (cg[cG] - cg[cG - 0x1]),
              cR = cN[cq],
              H0 = cq,
              H1 = cG - 0x1,
              cC[H0][H1] = -0x2,
              H2 = true) : -0x2 !== cC[cq + 0x1][cG - 0x1] && -0x2 === cC[cq][cG - 0x1] ? (cL = cg[cG - 0x1] + cC[cq + 0x1][cG - 0x1] * (cg[cG] - cg[cG - 0x1]),
              cR = cN[cq + 0x1],
              H0 = cq + 0x1,
              H1 = cG - 0x1,
              cC[H0][H1] = -0x2,
              H2 = true) : -0x2 === cC[cq + 0x1][cG - 0x1] && -0x2 !== cC[cq][cG - 0x1] ? (cL = cg[cG - 0x1] + cC[cq][cG - 0x1] * (cg[cG] - cg[cG - 0x1]),
              cR = cN[cq],
              H0 = cq,
              H1 = cG - 0x1,
              cC[H0][H1] = -0x2,
              H2 = true) : -0x2 !== cJ[cq][cG - 0x1] ? (cL = cg[cG - 0x1],
              cR = cN[cq] + cJ[cq][cG - 0x1] * (cN[cq + 0x1] - cN[cq]),
              H0 = cq,
              H1 = cG - 0x1,
              cJ[H0][H1] = -0x2,
              H2 = false) : cm = false,
              cM[0x0] = H0,
              cM[0x1] = H1,
              cz[0x0] = cL,
              cz[0x1] = cR,
              cQ[0x0] = H2,
              cm;
          }
          static['isoline_UndefData'](cd, cq, cJ, cC, cO, cG, cg, cN, cP) {
              let cM, cz, cQ, cm, cL = [];
              cM = cd['length'],
              cz = cd[0x0]['length'];
              let cR, H0, H1, H2, H3, H4, H5, H6, H7, H8, H9, Hv = 0x0, HA = 0x0, Hk = 0x0, Hl = 0x0, HK = true, Hb = new bW();
              for (cQ = 0x0; cQ < cM; cQ++)
                  for (cm = 0x0; cm < cz; cm++) {
                      if (cm < cz - 0x1 && cg[0x0][cQ][cm] > -0x1 && -0x2 !== cO[cQ][cm]) {
                          for (H9 = [],
                          H0 = cQ,
                          H2 = cm,
                          H3 = cq[H2] + cO[H0][H2] * (cq[H2 + 0x1] - cq[H2]),
                          H4 = cJ[H0],
                          0x0 === cg[0x1][cQ][cm] ? (cR = -0x1,
                          Hb['sPoint']['X'] = cq[cm + 0x1],
                          Hb['sPoint']['Y'] = cJ[cQ]) : (cR = H0,
                          Hb['sPoint']['X'] = cq[cm],
                          Hb['sPoint']['Y'] = cJ[cQ]),
                          H1 = H2,
                          H7 = new bE(),
                          H7['X'] = H3,
                          H7['Y'] = H4,
                          H9['push'](H7),
                          Hb['Index'] = cP + cL['length'],
                          Hb['Point'] = H7,
                          Hb['BorderIdx'] = cg[0x0][cQ][cm],
                          bB['_endPointList']['push'](Hb),
                          H8 = new bV(),
                          H8['Type'] = 'Border',
                          H8['BorderIdx'] = cg[0x0][cQ][cm]; ; ) {
                              let Hc = [Hv, HA]
                                , HH = [Hk, Hl]
                                , Hx = [HK];
                              if (!bB['traceIsoline_UndefData'](cR, H0, cG, cO, H1, H2, cq, cJ, H3, Hc, HH, Hx)) {
                                  H8['Type'] = 'Error';
                                  break;
                              }
                              if (Hv = Hc[0x0],
                              HA = Hc[0x1],
                              Hk = HH[0x0],
                              Hl = HH[0x1],
                              HK = Hx[0x0],
                              H7 = new bE(),
                              H7['X'] = Hk,
                              H7['Y'] = Hl,
                              H9['push'](H7),
                              HK) {
                                  if (cg[0x0][Hv][HA] > -0x1) {
                                      0x0 === cg[0x1][Hv][HA] ? (Hb['sPoint']['X'] = cq[HA + 0x1],
                                      Hb['sPoint']['Y'] = cJ[Hv]) : (Hb['sPoint']['X'] = cq[HA],
                                      Hb['sPoint']['Y'] = cJ[Hv]);
                                      break;
                                  }
                              } else {
                                  if (cN[0x0][Hv][HA] > -0x1) {
                                      0x0 === cN[0x1][Hv][HA] ? (Hb['sPoint']['X'] = cq[HA],
                                      Hb['sPoint']['Y'] = cJ[Hv]) : (Hb['sPoint']['X'] = cq[HA],
                                      Hb['sPoint']['Y'] = cJ[Hv + 0x1]);
                                      break;
                                  }
                              }
                              H3 = Hk,
                              cR = H0,
                              H1 = H2,
                              H0 = Hv,
                              H2 = HA;
                          }
                          cO[cQ][cm] = -0x2,
                          H9['length'] > 0x1 && 'Error' !== H8['Type'] ? (Hb['Point'] = H7,
                          bB['_endPointList']['push'](Hb),
                          H8['Value'] = cC,
                          H8['PointList'] = H9,
                          cL['push'](H8)) : bB['_endPointList']['pop']();
                      }
                      if (cQ < cM - 0x1 && cN[0x0][cQ][cm] > -0x1 && -0x2 !== cG[cQ][cm]) {
                          for (H9 = [],
                          H0 = cQ,
                          H2 = cm,
                          H3 = cq[H2],
                          H4 = cJ[H0] + cG[H0][H2] * (cJ[H0 + 0x1] - cJ[H0]),
                          cR = H0,
                          0x0 === cN[0x1][cQ][cm] ? (H1 = -0x1,
                          Hb['sPoint']['X'] = cq[cm],
                          Hb['sPoint']['Y'] = cJ[cQ]) : (H1 = H2,
                          Hb['sPoint']['X'] = cq[cm],
                          Hb['sPoint']['Y'] = cJ[cQ + 0x1]),
                          H7 = new bE(),
                          H7['X'] = H3,
                          H7['Y'] = H4,
                          H9['push'](H7),
                          Hb['Index'] = cP + cL['length'],
                          Hb['Point'] = H7,
                          Hb['BorderIdx'] = cN[0x0][cQ][cm],
                          bB['_endPointList']['push'](Hb),
                          H8 = new bV(),
                          H8['Type'] = 'Border',
                          H8['BorderIdx'] = cN[0x0][cQ][cm]; ; ) {
                              let Hp = [Hv, HA]
                                , HF = [Hk, Hl]
                                , Hy = [HK];
                              if (!bB['traceIsoline_UndefData'](cR, H0, cG, cO, H1, H2, cq, cJ, H3, Hp, HF, Hy)) {
                                  H8['Type'] = 'Error';
                                  break;
                              }
                              if (Hv = Hp[0x0],
                              HA = Hp[0x1],
                              Hk = HF[0x0],
                              Hl = HF[0x1],
                              HK = Hy[0x0],
                              H7 = new bE(),
                              H7['X'] = Hk,
                              H7['Y'] = Hl,
                              H9['push'](H7),
                              HK) {
                                  if (cg[0x0][Hv][HA] > -0x1) {
                                      0x0 === cg[0x1][Hv][HA] ? (Hb['sPoint']['X'] = cq[HA + 0x1],
                                      Hb['sPoint']['Y'] = cJ[Hv]) : (Hb['sPoint']['X'] = cq[HA],
                                      Hb['sPoint']['Y'] = cJ[Hv]);
                                      break;
                                  }
                              } else {
                                  if (cN[0x0][Hv][HA] > -0x1) {
                                      0x0 === cN[0x1][Hv][HA] ? (Hb['sPoint']['X'] = cq[HA],
                                      Hb['sPoint']['Y'] = cJ[Hv]) : (Hb['sPoint']['X'] = cq[HA],
                                      Hb['sPoint']['Y'] = cJ[Hv + 0x1]);
                                      break;
                                  }
                              }
                              H3 = Hk,
                              cR = H0,
                              H1 = H2,
                              H0 = Hv,
                              H2 = HA;
                          }
                          cG[cQ][cm] = -0x2,
                          H9['length'] > 0x1 && 'Error' !== H8['Type'] ? (Hb['Point'] = H7,
                          bB['_endPointList']['push'](Hb),
                          H8['Value'] = cC,
                          H8['PointList'] = H9,
                          cL['push'](H8)) : bB['_endPointList']['pop']();
                      }
                  }
              for (cm = 0x0; cm < cz - 0x1; cm++)
                  -0x2 !== cO[0x0][cm] && (cO[0x0][cm] = -0x2),
                  -0x2 !== cO[cM - 0x1][cm] && (cO[cM - 0x1][cm] = -0x2);
              for (cQ = 0x0; cQ < cM - 0x1; cQ++)
                  -0x2 !== cG[cQ][0x0] && (cG[cQ][0x0] = -0x2),
                  -0x2 !== cG[cQ][cz - 0x1] && (cG[cQ][cz - 0x1] = -0x2);
              for (cQ = 0x1; cQ < cM - 0x2; cQ++)
                  for (cm = 0x1; cm < cz - 0x1; cm++)
                      if (-0x2 !== cG[cQ][cm]) {
                          let Hw = [];
                          for (H0 = cQ,
                          H2 = cm,
                          H3 = cq[H2],
                          H4 = cJ[cQ] + cG[cQ][H2] * (cJ[cQ + 0x1] - cJ[cQ]),
                          H1 = -0x1,
                          cR = H0,
                          H5 = H3,
                          H6 = H4,
                          H7 = new bE(),
                          H7['X'] = H3,
                          H7['Y'] = H4,
                          Hw['push'](H7),
                          H8 = new bV(),
                          H8['Type'] = 'Close'; ; ) {
                              let Hh = []
                                , Hu = []
                                , HY = [];
                              if (!bB['traceIsoline_UndefData'](cR, H0, cG, cO, H1, H2, cq, cJ, H3, Hh, Hu, HY)) {
                                  H8['Type'] = 'Error';
                                  break;
                              }
                              if (Hv = Hh[0x0],
                              HA = Hh[0x1],
                              Hk = Hu[0x0],
                              Hl = Hu[0x1],
                              H7 = new bE(),
                              H7['X'] = Hk,
                              H7['Y'] = Hl,
                              Hw['push'](H7),
                              Math['abs'](Hl - H6) < 0.000001 && Math['abs'](Hk - H5) < 0.000001)
                                  break;
                              H3 = Hk,
                              cR = H0,
                              H1 = H2,
                              H0 = Hv,
                              H2 = HA;
                          }
                          cG[cQ][cm] = -0x2,
                          Hw['length'] > 0x1 && 'Error' !== H8['Type'] && (H8['Value'] = cC,
                          H8['PointList'] = Hw,
                          cL['push'](H8));
                      }
              for (cQ = 0x1; cQ < cM - 0x1; cQ++)
                  for (cm = 0x1; cm < cz - 0x2; cm++)
                      if (-0x2 !== cO[cQ][cm]) {
                          let HT = [];
                          for (H0 = cQ,
                          H2 = cm,
                          H3 = cq[H2] + cO[cQ][cm] * (cq[H2 + 0x1] - cq[H2]),
                          H4 = cJ[cQ],
                          H1 = H2,
                          cR = -0x1,
                          H5 = H3,
                          H6 = H4,
                          H7 = new bE(),
                          H7['X'] = H3,
                          H7['Y'] = H4,
                          HT['push'](H7),
                          H8 = new bV(),
                          H8['Type'] = 'Close'; ; ) {
                              let HX = []
                                , HE = []
                                , Hf = [];
                              if (!bB['traceIsoline_UndefData'](cR, H0, cG, cO, H1, H2, cq, cJ, H3, HX, HE, Hf)) {
                                  H8['Type'] = 'Error';
                                  break;
                              }
                              if (Hv = HX[0x0],
                              HA = HX[0x1],
                              Hk = HE[0x0],
                              Hl = HE[0x1],
                              H7 = new bE(),
                              H7['X'] = Hk,
                              H7['Y'] = Hl,
                              HT['push'](H7),
                              Math['abs'](Hl - H6) < 0.000001 && Math['abs'](Hk - H5) < 0.000001)
                                  break;
                              H3 = Hk,
                              cR = H0,
                              H1 = H2,
                              H0 = Hv,
                              H2 = HA;
                          }
                          cO[cQ][cm] = -0x2,
                          HT['length'] > 0x1 && 'Error' !== H8['Type'] && (H8['Value'] = cC,
                          H8['PointList'] = HT,
                          cL['push'](H8));
                      }
              return cL;
          }
          static['traceIsoline'](cd, cq, cJ, cC, cO, cG, cg, cN, cP, cM, cz) {
              let cQ, cm, cL, cR;
              return cd < cq ? -0x2 !== cJ[cq][cG] && -0x2 !== cJ[cq][cG + 0x1] ? cJ[cq][cG] < cJ[cq][cG + 0x1] ? (cL = cg[cG],
              cR = cN[cq] + cJ[cq][cG] * cM,
              cQ = cq,
              cm = cG,
              cJ[cQ][cm] = -0x2) : (cL = cg[cG + 0x1],
              cR = cN[cq] + cJ[cq][cG + 0x1] * cM,
              cQ = cq,
              cm = cG + 0x1,
              cJ[cQ][cm] = -0x2) : -0x2 !== cJ[cq][cG] && -0x2 === cJ[cq][cG + 0x1] ? (cL = cg[cG],
              cR = cN[cq] + cJ[cq][cG] * cM,
              cQ = cq,
              cm = cG,
              cJ[cQ][cm] = -0x2) : -0x2 === cJ[cq][cG] && -0x2 !== cJ[cq][cG + 0x1] ? (cL = cg[cG + 0x1],
              cR = cN[cq] + cJ[cq][cG + 0x1] * cM,
              cQ = cq,
              cm = cG + 0x1,
              cJ[cQ][cm] = -0x2) : (cL = cg[cG] + cC[cq + 0x1][cG] * cP,
              cR = cN[cq + 0x1],
              cQ = cq + 0x1,
              cm = cG,
              cC[cQ][cm] = -0x2) : cO < cG ? -0x2 !== cC[cq][cG] && -0x2 !== cC[cq + 0x1][cG] ? cC[cq][cG] < cC[cq + 0x1][cG] ? (cL = cg[cG] + cC[cq][cG] * cP,
              cR = cN[cq],
              cQ = cq,
              cm = cG,
              cC[cQ][cm] = -0x2) : (cL = cg[cG] + cC[cq + 0x1][cG] * cP,
              cR = cN[cq + 0x1],
              cQ = cq + 0x1,
              cm = cG,
              cC[cQ][cm] = -0x2) : -0x2 !== cC[cq][cG] && -0x2 === cC[cq + 0x1][cG] ? (cL = cg[cG] + cC[cq][cG] * cP,
              cR = cN[cq],
              cQ = cq,
              cm = cG,
              cC[cQ][cm] = -0x2) : -0x2 === cC[cq][cG] && -0x2 !== cC[cq + 0x1][cG] ? (cL = cg[cG] + cC[cq + 0x1][cG] * cP,
              cR = cN[cq + 0x1],
              cQ = cq + 0x1,
              cm = cG,
              cC[cQ][cm] = -0x2) : (cL = cg[cG + 0x1],
              cR = cN[cq] + cJ[cq][cG + 0x1] * cM,
              cQ = cq,
              cm = cG + 0x1,
              cJ[cQ][cm] = -0x2) : cg[cG] < cz ? -0x2 !== cJ[cq - 0x1][cG] && -0x2 !== cJ[cq - 0x1][cG + 0x1] ? cJ[cq - 0x1][cG] > cJ[cq - 0x1][cG + 0x1] ? (cL = cg[cG],
              cR = cN[cq - 0x1] + cJ[cq - 0x1][cG] * cM,
              cQ = cq - 0x1,
              cm = cG,
              cJ[cQ][cm] = -0x2) : (cL = cg[cG + 0x1],
              cR = cN[cq - 0x1] + cJ[cq - 0x1][cG + 0x1] * cM,
              cQ = cq - 0x1,
              cm = cG + 0x1,
              cJ[cQ][cm] = -0x2) : -0x2 !== cJ[cq - 0x1][cG] && -0x2 === cJ[cq - 0x1][cG + 0x1] ? (cL = cg[cG],
              cR = cN[cq - 0x1] + cJ[cq - 0x1][cG] * cM,
              cQ = cq - 0x1,
              cm = cG,
              cJ[cQ][cm] = -0x2) : -0x2 === cJ[cq - 0x1][cG] && -0x2 !== cJ[cq - 0x1][cG + 0x1] ? (cL = cg[cG + 0x1],
              cR = cN[cq - 0x1] + cJ[cq - 0x1][cG + 0x1] * cM,
              cQ = cq - 0x1,
              cm = cG + 0x1,
              cJ[cQ][cm] = -0x2) : (cL = cg[cG] + cC[cq - 0x1][cG] * cP,
              cR = cN[cq - 0x1],
              cQ = cq - 0x1,
              cm = cG,
              cC[cQ][cm] = -0x2) : -0x2 !== cC[cq + 0x1][cG - 0x1] && -0x2 !== cC[cq][cG - 0x1] ? cC[cq + 0x1][cG - 0x1] > cC[cq][cG - 0x1] ? (cL = cg[cG - 0x1] + cC[cq + 0x1][cG - 0x1] * cP,
              cR = cN[cq + 0x1],
              cQ = cq + 0x1,
              cm = cG - 0x1,
              cC[cQ][cm] = -0x2) : (cL = cg[cG - 0x1] + cC[cq][cG - 0x1] * cP,
              cR = cN[cq],
              cQ = cq,
              cm = cG - 0x1,
              cC[cQ][cm] = -0x2) : -0x2 !== cC[cq + 0x1][cG - 0x1] && -0x2 === cC[cq][cG - 0x1] ? (cL = cg[cG - 0x1] + cC[cq + 0x1][cG - 0x1] * cP,
              cR = cN[cq + 0x1],
              cQ = cq + 0x1,
              cm = cG - 0x1,
              cC[cQ][cm] = -0x2) : -0x2 === cC[cq + 0x1][cG - 0x1] && -0x2 !== cC[cq][cG - 0x1] ? (cL = cg[cG - 0x1] + cC[cq][cG - 0x1] * cP,
              cR = cN[cq],
              cQ = cq,
              cm = cG - 0x1,
              cC[cQ][cm] = -0x2) : (cL = cg[cG - 0x1],
              cR = cN[cq] + cJ[cq][cG - 0x1] * cM,
              cQ = cq,
              cm = cG - 0x1,
              cJ[cQ][cm] = -0x2),
              [cQ, cm, cL, cR];
          }
          static['isoline_Bottom'](cd, cq, cJ, cC, cO, cG, cg, cN) {
              let cP, cM, cz, cQ = [];
              cP = cd['length'],
              cM = cd[0x0]['length'];
              let cm, cL, cR, H0, H1, H2, H3, H4, H5, H6, H7 = 0x0, H8 = new bE(), H9 = new bV();
              for (cz = 0x0; cz < cM - 0x1; cz++)
                  if (-0x2 !== cg[0x0][cz]) {
                      let Hv = [];
                      for (cL = 0x0,
                      cR = cz,
                      H2 = cq[cz] + cg[0x0][cz] * cO,
                      H3 = cJ[0x0],
                      cm = -0x1,
                      H8['X'] = H2,
                      H8['Y'] = H3,
                      Hv['push'](H8); H6 = bB['traceIsoline'](cm, cL, cN, cg, H7, cR, cq, cJ, cO, cG, H2),
                      H0 = parseInt(H6[0x0]),
                      H1 = parseInt(H6[0x1]),
                      H4 = parseFloat(H6[0x2]['toString']()),
                      H5 = parseFloat(H6[0x3]['toString']()),
                      H8['X'] = H4,
                      H8['Y'] = H5,
                      Hv['push'](H8),
                      H0 !== cP - 0x1 && H1 !== cM - 0x1 && H5 !== cJ[0x0] && H4 !== cq[0x0]; )
                          H2 = H4,
                          cm = cL,
                          H7 = cR,
                          cL = H0,
                          cR = H1;
                      cg[0x0][cz] = -0x2,
                      Hv['length'] > 0x4 && (H9['Value'] = cC,
                      H9['Type'] = 'Bottom',
                      H9['PointList'] = [],
                      bB['addAll'](Hv, H9['PointList']),
                      cQ['push'](H9));
                  }
              return cQ;
          }
          static['isoline_Left'](cd, cq, cJ, cC, cO, cG, cg, cN) {
              let cP, cM, cz, cQ, cm, cL, cR, H0, H1, H2, H3, H4, H5, H6, H7 = [];
              cP = cd['length'],
              cM = cd[0x0]['length'];
              let H8 = new bE()
                , H9 = new bV();
              for (cz = 0x0; cz < cP - 0x1; cz++)
                  if (-0x2 !== cN[cz][0x0]) {
                      let Hv = [];
                      for (cm = cz,
                      cR = 0x0,
                      H2 = cq[0x0],
                      H3 = cJ[cz] + cN[cz][0x0] * cG,
                      cL = -0x1,
                      cQ = cm,
                      H8['X'] = H2,
                      H8['Y'] = H3,
                      Hv['push'](H8); H6 = bB['traceIsoline'](cQ, cm, cN, cg, cL, cR, cq, cJ, cO, cG, H2),
                      H0 = parseInt(H6[0x0]),
                      H1 = parseInt(H6[0x1]),
                      H4 = parseFloat(H6[0x2]),
                      H5 = parseFloat(H6[0x3]),
                      H8['X'] = H4,
                      H8['Y'] = H5,
                      Hv['push'](H8),
                      H0 !== cP - 0x1 && H1 !== cM - 0x1 && H5 !== cJ[0x0] && H4 !== cq[0x0]; )
                          H2 = H4,
                          cQ = cm,
                          cL = cR,
                          cm = H0,
                          cR = H1;
                      Hv['length'] > 0x4 && (H9['Value'] = cC,
                      H9['Type'] = 'Left',
                      H9['PointList'] = [],
                      bB['addAll'](Hv, H9['PointList']),
                      H7['push'](H9));
                  }
              return H7;
          }
          static['isoline_Top'](cd, cq, cJ, cC, cO, cG, cg, cN) {
              let cP, cM, cz, cQ, cm, cL, cR, H0, H1, H2, H3, H4, H5, H6, H7 = [];
              cP = cd['length'],
              cM = cd[0x0]['length'];
              let H8 = new bE()
                , H9 = new bV();
              for (cz = 0x0; cz < cM - 0x1; cz++)
                  if (-0x2 !== cg[cP - 0x1][cz]) {
                      let Hv = [];
                      for (cm = cP - 0x1,
                      cR = cz,
                      H2 = cq[cz] + cg[cm][cz] * cO,
                      H3 = cJ[cm],
                      cQ = cm,
                      cL = cR,
                      H8['X'] = H2,
                      H8['Y'] = H3,
                      Hv['push'](H8); H6 = bB['traceIsoline'](cQ, cm, cN, cg, cL, cR, cq, cJ, cO, cG, H2),
                      H0 = parseInt(H6[0x0]),
                      H1 = parseInt(H6[0x1]),
                      H4 = parseFloat(H6[0x2]),
                      H5 = parseFloat(H6[0x3]),
                      H8['X'] = H4,
                      H8['Y'] = H5,
                      Hv['push'](H8),
                      H0 !== cP - 0x1 && H1 !== cM - 0x1 && H5 !== cJ[0x0] && H4 !== cq[0x0]; )
                          H2 = H4,
                          cQ = cm,
                          cL = cR,
                          cm = H0,
                          cR = H1;
                      cg[cP - 0x1][cz] = -0x2,
                      Hv['length'] > 0x4 && (H9['Value'] = cC,
                      H9['Type'] = 'Top',
                      H9['PointList'] = [],
                      bB['addAll'](Hv, H9['PointList']),
                      H7['push'](H9));
                  }
              return H7;
          }
          static['isoline_Right'](cd, cq, cJ, cC, cO, cG, cg, cN) {
              let cP, cM, cz, cQ, cm, cL, cR, H0, H1, H2, H3, H4, H5, H6, H7 = [];
              cP = cd['length'],
              cM = cd[0x0]['length'];
              let H8 = new bE()
                , H9 = new bV();
              for (cz = 0x0; cz < cP - 0x1; cz++)
                  if (-0x2 !== cN[cz][cM - 0x1]) {
                      let Hv = [];
                      for (cm = cz,
                      cR = cM - 0x1,
                      H2 = cq[cR],
                      H3 = cJ[cz] + cN[cz][cR] * cG,
                      cL = cR,
                      cQ = cm,
                      H8['X'] = H2,
                      H8['Y'] = H3,
                      Hv['push'](H8); H6 = bB['traceIsoline'](cQ, cm, cN, cg, cL, cR, cq, cJ, cO, cG, H2),
                      H0 = parseInt(H6[0x0]),
                      H1 = parseInt(H6[0x1]),
                      H4 = parseFloat(H6[0x2]),
                      H5 = parseFloat(H6[0x3]),
                      H8['X'] = H4,
                      H8['Y'] = H5,
                      Hv['push'](H8),
                      H0 !== cP - 0x1 && H1 !== cM - 0x1 && H5 !== cJ[0x0] && H4 !== cq[0x0]; )
                          H2 = H4,
                          cQ = cm,
                          cL = cR,
                          cm = H0,
                          cR = H1;
                      Hv['length'] > 0x4 && (H9['Value'] = cC,
                      H9['Type'] = 'Right',
                      H9['PointList'] = [],
                      bB['addAll'](Hv, H9['PointList']),
                      H7['push'](H9));
                  }
              return H7;
          }
          static['isoline_Close'](cd, cq, cJ, cC, cO, cG, cg, cN) {
              let cP, cM, cz, cQ, cm, cL, cR, H0, H1, H2, H3, H4, H5, H6, H7, H8, H9, Hv = [];
              cP = cd['length'],
              cM = cd[0x0]['length'];
              let HA = new bE()
                , Hk = new bV();
              for (cz = 0x1; cz < cP - 0x2; cz++)
                  for (cQ = 0x1; cQ < cM - 0x1; cQ++)
                      if (-0x2 !== cN[cz][cQ]) {
                          let Hl = [];
                          for (cL = cz,
                          H0 = cQ,
                          H3 = cq[H0],
                          H4 = cJ[cz] + cN[cz][H0] * cG,
                          cR = 0x0,
                          cm = cL,
                          H7 = H3,
                          H8 = H4,
                          HA['X'] = H3,
                          HA['Y'] = H4,
                          Hl['push'](HA); H9 = bB['traceIsoline'](cm, cL, cN, cg, cR, H0, cq, cJ, cO, cG, H3),
                          H1 = parseInt(H9[0x0]),
                          H2 = parseInt(H9[0x1]),
                          H5 = parseFloat(H9[0x2]),
                          H6 = parseFloat(H9[0x3]),
                          !(0x0 === H1 && 0x0 === H2 || (HA['X'] = H5,
                          HA['Y'] = H6,
                          Hl['push'](HA),
                          Math['abs'](H6 - H8) < 0.000001 && Math['abs'](H5 - H7) < 0.000001) || (H3 = H5,
                          cm = cL,
                          cR = H0,
                          cL = H1,
                          H0 = H2,
                          cL === cP - 0x1 || H0 === cM - 0x1)); )
                              ;
                          cN[cz][cQ] = -0x2,
                          Hl['length'] > 0x4 && (Hk['Value'] = cC,
                          Hk['Type'] = 'Close',
                          Hk['PointList'] = [],
                          bB['addAll'](Hl, Hk['PointList']),
                          Hv['push'](Hk));
                      }
              for (cz = 0x1; cz < cP - 0x1; cz++)
                  for (cQ = 0x1; cQ < cM - 0x2; cQ++)
                      if (-0x2 !== cg[cz][cQ]) {
                          let HK = [];
                          for (cL = cz,
                          H0 = cQ,
                          H3 = cq[H0] + cg[cz][cQ] * cO,
                          H4 = cJ[cz],
                          cR = H0,
                          cm = 0x0,
                          H7 = H3,
                          H8 = H4,
                          HA['X'] = H3,
                          HA['Y'] = H4,
                          HK['push'](HA); H9 = bB['traceIsoline'](cm, cL, cN, cg, cR, H0, cq, cJ, cO, cG, H3),
                          H1 = parseInt(H9[0x0]),
                          H2 = parseInt(H9[0x1]),
                          H5 = parseFloat(H9[0x2]),
                          H6 = parseFloat(H9[0x3]),
                          HA['X'] = H5,
                          HA['Y'] = H6,
                          HK['push'](HA),
                          !(Math['abs'](H6 - H8) < 0.000001 && Math['abs'](H5 - H7) < 0.000001 || (H3 = H5,
                          cm = cL,
                          cR = H0,
                          cL = H1,
                          H0 = H2,
                          cL === cP - 0x1 || H0 === cM - 0x1)); )
                              ;
                          cg[cz][cQ] = -0x2,
                          HK['length'] > 0x4 && (Hk['Value'] = cC,
                          Hk['Type'] = 'Close',
                          Hk['PointList'] = [],
                          bB['addAll'](HK, Hk['PointList']),
                          Hv['push'](Hk));
                      }
              return Hv;
          }
          static['tracingPolygons_Extent'](cd, cq, cJ, cC) {
              if (0x0 === cd['length'])
                  return [];
              let cO, cG, cg, cN, cP, cM, cz, cQ = [], cm = [];
              bB['addAll'](cd, cm);
              let cL, cR, H0, H1, H2 = [], H3 = [];
              for (H3['length'] = cq['length'] - 0x1,
              cP = 0x0; cP < H3['length']; cP++)
                  H3[cP] = 0x0;
              let H4 = 0x0
                , H5 = 0x0
                , H6 = [];
              for (H0 = cq['length'] - 0x1,
              cP = 0x0; cP < H0; cP++)
                  if (-0x1 !== cq[cP]['Id']) {
                      if (cR = cP,
                      cz = [],
                      H6['push'](cq[cP]),
                      H3[cR] < 0x2)
                          for (cz['push'](cq[cR]['Point']),
                          cR += 0x1,
                          cR === H0 && (cR = 0x0),
                          H1 = 0x0; ; ) {
                              if (cL = cq[cR],
                              -0x1 === cL['Id']) {
                                  if (0x1 === H3[cR])
                                      break;
                                  cz['push'](cL['Point']),
                                  H3[cR] += 0x1;
                              } else {
                                  if (0x2 === H3[cR])
                                      break;
                                  for (H3[cR] += 0x1,
                                  cO = cm[cL['Id']],
                                  0x0 === H1 ? (H4 = cO['Value'],
                                  H5 = cO['Value'],
                                  H1 += 0x1) : H4 === H5 && (cO['Value'] > H4 ? H5 = cO['Value'] : cO['Value'] < H4 && (H4 = cO['Value']),
                                  H1 += 0x1),
                                  H2 = [],
                                  bB['addAll'](cO['PointList'], H2),
                                  cG = H2[0x0],
                                  cL['Point']['X'] === cG['X'] && cL['Point']['Y'] === cG['Y'] || H2['reverse'](),
                                  bB['addAll'](H2, cz),
                                  cM = 0x0; cM < cq['length'] - 0x1; cM++)
                                      if (cM !== cR && cq[cM]['Id'] === cL['Id']) {
                                          cR = cM,
                                          H3[cR] += 0x1;
                                          break;
                                      }
                              }
                              if (cR === cP) {
                                  cz['length'] > 0x0 && (cg = new bZ(),
                                  cg['LowValue'] = H4,
                                  cg['HighValue'] = H5,
                                  cN = new bT(),
                                  cg['Area'] = bB['getExtentAndArea'](cz, cN),
                                  cg['IsClockWise'] = true,
                                  cg['StartPointIdx'] = H6['length'] - 0x1,
                                  cg['Extent'] = cN,
                                  cg['OutLine']['PointList'] = cz,
                                  cg['OutLine']['Value'] = H4,
                                  cg['IsHighCenter'] = true,
                                  cg['OutLine']['Type'] = 'Border',
                                  cQ['push'](cg));
                                  break;
                              }
                              cR += 0x1,
                              cR === H0 && (cR = 0x0);
                          }
                      if (cR = cP,
                      H3[cR] < 0x2)
                          for (cz = [],
                          cz['push'](cq[cR]['Point']),
                          cR += -0x1,
                          -0x1 === cR && (cR = H0 - 0x1),
                          H1 = 0x0; ; ) {
                              if (cL = cq[cR],
                              -0x1 === cL['Id']) {
                                  if (0x1 === H3[cR])
                                      break;
                                  cz['push'](cL['Point']),
                                  H3[cR] += 0x1;
                              } else {
                                  if (0x2 === H3[cR])
                                      break;
                                  for (H3[cR] += 0x1,
                                  cO = cm[cL['Id']],
                                  0x0 === H1 ? (H4 = cO['Value'],
                                  H5 = cO['Value'],
                                  H1 += 0x1) : H4 === H5 && (cO['Value'] > H4 ? H5 = cO['Value'] : cO['Value'] < H4 && (H4 = cO['Value']),
                                  H1 += 0x1),
                                  H2 = [],
                                  bB['addAll'](cO['PointList'], H2),
                                  cG = H2[0x0],
                                  cL['Point']['X'] === cG['X'] && cL['Point']['Y'] === cG['Y'] || H2['reverse'](),
                                  bB['addAll'](H2, cz),
                                  cM = 0x0; cM < cq['length'] - 0x1; cM++)
                                      if (cM !== cR && cq[cM]['Id'] === cL['Id']) {
                                          cR = cM,
                                          H3[cR] += 0x1;
                                          break;
                                      }
                              }
                              if (cR === cP) {
                                  cz['length'] > 0x0 && (cg = new bZ(),
                                  cg['LowValue'] = H4,
                                  cg['HighValue'] = H5,
                                  cN = new bT(),
                                  cg['Area'] = bB['getExtentAndArea'](cz, cN),
                                  cg['IsClockWise'] = false,
                                  cg['StartPointIdx'] = H6['length'] - 0x1,
                                  cg['Extent'] = cN,
                                  cg['OutLine']['PointList'] = cz,
                                  cg['OutLine']['Value'] = H4,
                                  cg['IsHighCenter'] = true,
                                  cg['OutLine']['Type'] = 'Border',
                                  cQ['push'](cg));
                                  break;
                              }
                              cR += -0x1,
                              -0x1 === cR && (cR = H0 - 0x1);
                          }
                  }
              let H7, H8, H9, Hv, HA = [];
              for (cP = 0x0; cP < cm['length']; cP++)
                  if (cO = cm[cP],
                  'Close' === cO['Type'] && cO['PointList']['length'] > 0x0) {
                      for (cg = new bZ(),
                      cg['LowValue'] = cO['Value'],
                      cg['HighValue'] = cO['Value'],
                      cN = new bT(),
                      cg['Area'] = bB['getExtentAndArea'](cO['PointList'], cN),
                      cg['IsClockWise'] = bB['isClockwise'](cO['PointList']),
                      cg['Extent'] = cN,
                      cg['OutLine'] = cO,
                      cg['IsHighCenter'] = true,
                      H7 = false,
                      cM = 0x0; cM < HA['length']; cM++)
                          if (cg['Area'] > HA[cM]['Area']) {
                              HA['splice'](cM, 0x0, cg),
                              H7 = true;
                              break;
                          }
                      H7 || HA['push'](cg);
                  }
              if (cQ['length'] > 0x0) {
                  let Hk, Hl, HK = false;
                  if (cg = cQ[0x0],
                  cg['LowValue'] === cg['HighValue'])
                      for (Hk = cg['StartPointIdx']; ; ) {
                          if (cg['IsClockWise'] ? (Hk -= 0x1,
                          -0x1 === Hk && (Hk = H6['length'] - 0x1)) : (Hk += 0x1,
                          Hk === H6['length'] && (Hk = 0x0)),
                          cL = H6[Hk],
                          cO = cm[cL['Id']],
                          cO['Value'] !== cg['LowValue']) {
                              HK = false;
                              break;
                          }
                          if (Hk === cg['StartPointIdx']) {
                              HK = true;
                              break;
                          }
                      }
                  if (HK) {
                      if (HA['length'] > 0x0) {
                          for (H8 = HA[0x0]['Extent'],
                          cP = 0x0; cP < cQ['length']; cP++)
                              cg = cQ[cP],
                              H9 = cg['Extent'],
                              H8['xMin'] > H9['xMin'] && H8['yMin'] > H9['yMin'] && H8['xMax'] < H9['xMax'] && H8['yMax'] < H9['yMax'] ? cg['IsHighCenter'] = false : cg['IsHighCenter'] = true;
                      } else {
                          let Hb = true;
                          for (cP = 0x0; cP < cQ['length']; cP++)
                              cg = cQ[cP],
                              Hb = !Hb,
                              cg['IsHighCenter'] = Hb;
                      }
                  } else {
                      for (cP = 0x0; cP < cQ['length']; cP++)
                          if (cg = cQ[cP],
                          cg['LowValue'] === cg['HighValue'])
                              for (Hl = false,
                              Hk = cg['StartPointIdx']; ; ) {
                                  if (cg['IsClockWise'] ? (Hk -= 0x1,
                                  -0x1 === Hk && (Hk = H6['length'] - 0x1)) : (Hk += 0x1,
                                  Hk === H6['length'] && (Hk = 0x0)),
                                  cL = H6[Hk],
                                  cO = cm[cL['Id']],
                                  cO['Value'] !== cg['LowValue']) {
                                      Hl ? cO['Value'] < cg['LowValue'] && (cg['IsHighCenter'] = false) : cO['Value'] > cg['LowValue'] && (cg['IsHighCenter'] = false);
                                      break;
                                  }
                                  if (Hk === cg['StartPointIdx'])
                                      break;
                                  Hl = !Hl;
                              }
                  }
              } else {
                  let Hc = cm[0x0]['Value']
                    , HH = cm[0x0]['Value'];
                  for (let Hx of cm)
                      Hx['Value'] > Hc && (Hc = Hx['Value']),
                      Hx['Value'] < HH && (HH = Hx['Value']);
                  cg = new bZ(),
                  cO = new bV(),
                  cO['Type'] = 'Border',
                  cO['Value'] = cC[0x0],
                  cg['IsHighCenter'] = false,
                  HA['length'] > 0x0 && HA[0x0]['LowValue'] === Hc && (cO['Value'] = cC[cC['length'] - 0x1],
                  cg['IsHighCenter'] = true),
                  H2 = [],
                  cG = new bE(),
                  cG['X'] = cJ['xMin'],
                  cG['Y'] = cJ['yMin'],
                  H2['push'](cG),
                  cG = new bE(),
                  cG['X'] = cJ['xMin'],
                  cG['Y'] = cJ['yMax'],
                  H2['push'](cG),
                  cG = new bE(),
                  cG['X'] = cJ['xMax'],
                  cG['Y'] = cJ['yMax'],
                  H2['push'](cG),
                  cG = new bE(),
                  cG['X'] = cJ['xMax'],
                  cG['Y'] = cJ['yMin'],
                  H2['push'](cG),
                  H2['push'](H2[0x0]),
                  cO['PointList'] = [],
                  bB['addAll'](H2, cO['PointList']),
                  cO['PointList']['length'] > 0x0 && (cg['LowValue'] = cO['Value'],
                  cg['HighValue'] = cO['Value'],
                  cN = new bT(),
                  cg['Area'] = bB['getExtentAndArea'](cO['PointList'], cN),
                  cg['IsClockWise'] = bB['isClockwise'](cO['PointList']),
                  cg['Extent'] = cN,
                  cg['OutLine'] = cO,
                  cQ['push'](cg));
              }
              for (bB['addAll'](HA, cQ),
              cP = cQ['length'] - 0x1; cP >= 0x0; cP--)
                  if (cg = cQ[cP],
                  'Close' === cg['OutLine']['Type']) {
                      for (H8 = cg['Extent'],
                      H4 = cg['LowValue'],
                      cG = cg['OutLine']['PointList'][0x0],
                      cM = cP - 0x1; cM >= 0x0; cM--)
                          if (Hv = cQ[cM],
                          H9 = Hv['Extent'],
                          H5 = Hv['LowValue'],
                          H2 = [],
                          bB['addAll'](Hv['OutLine']['PointList'], H2),
                          bB['pointInPolygonByPList'](H2, cG) && H8['xMin'] > H9['xMin'] && H8['yMin'] > H9['yMin'] && H8['xMax'] < H9['xMax'] && H8['yMax'] < H9['yMax']) {
                              (H4 < H5 || H4 === H5 && Hv['IsHighCenter']) && (cg['IsHighCenter'] = false);
                              break;
                          }
                  }
              return cQ;
          }
          static['tracingPolygons_Line_Border'](cd, cq) {
              if (0x0 === cd['length'])
                  return [];
              let cJ, cC, cO, cG, cg, cN, cP, cM, cz, cQ = [], cm = [];
              bB['addAll'](cd, cm);
              let cL, cR, H0, H1, H2 = [];
              for (H2['length'] = cq['length'] - 0x1,
              cg = 0x0; cg < H2['length']; cg++)
                  H2[cg] = 0x0;
              let H3 = 0x0
                , H4 = 0x0
                , H5 = 0x0
                , H6 = [];
              for (cR = cq['length'] - 0x1,
              cg = 0x0; cg < cR; cg++)
                  if (-0x1 !== cq[cg]['Id']) {
                      if (cL = cg,
                      cP = [],
                      H6['push'](cq[cg]),
                      H2[cL] < 0x2)
                          for (cP['push'](cq[cL]['Point']),
                          cL += 0x1,
                          cL === cR && (cL = 0x0),
                          H0 = 0x0,
                          H1 = 0x0; ; ) {
                              if (cz = cq[cL],
                              -0x1 === cz['Id']) {
                                  if (0x1 === H2[cL])
                                      break;
                                  H5 = cz['Value'],
                                  H1 += 0x1,
                                  cP['push'](cz['Point']),
                                  H2[cL] += 0x1;
                              } else {
                                  if (0x2 === H2[cL])
                                      break;
                                  for (H2[cL] += 0x1,
                                  cJ = cm[cz['Id']],
                                  0x0 === H0 ? (H3 = cJ['Value'],
                                  H4 = cJ['Value'],
                                  H0 += 0x1) : (cJ['Value'] > H3 ? H4 = cJ['Value'] : cJ['Value'] < H3 && (H3 = cJ['Value']),
                                  H0 += 0x1),
                                  cM = [],
                                  bB['addAll'](cJ['PointList'], cM),
                                  cC = cM[0x0],
                                  cz['Point']['X'] === cC['X'] && cz['Point']['Y'] === cC['Y'] || cM['reverse'](),
                                  bB['addAll'](cM, cP),
                                  cN = 0x0; cN < cq['length'] - 0x1; cN++)
                                      if (cN !== cL && cq[cN]['Id'] === cz['Id']) {
                                          cL = cN,
                                          H2[cL] += 0x1;
                                          break;
                                      }
                              }
                              if (cL === cg) {
                                  cP['length'] > 0x0 && (cO = new bZ(),
                                  cO['IsBorder'] = true,
                                  cO['LowValue'] = H3,
                                  cO['HighValue'] = H4,
                                  cG = new bT(),
                                  cO['Area'] = bB['getExtentAndArea'](cP, cG),
                                  cO['IsClockWise'] = true,
                                  cO['StartPointIdx'] = H6['length'] - 0x1,
                                  cO['Extent'] = cG,
                                  cO['OutLine']['PointList'] = cP,
                                  cO['OutLine']['Value'] = H3,
                                  cO['IsHighCenter'] = true,
                                  cO['HoleLines'] = [],
                                  H1 > 0x0 && H5 < H3 && (cO['IsHighCenter'] = false,
                                  cO['HighValue'] = H3),
                                  cO['OutLine']['Type'] = 'Border',
                                  cQ['push'](cO));
                                  break;
                              }
                              cL += 0x1,
                              cL === cR && (cL = 0x0);
                          }
                      if (cL = cg,
                      H2[cL] < 0x2)
                          for (cP = [],
                          cP['push'](cq[cL]['Point']),
                          cL += -0x1,
                          -0x1 === cL && (cL = cR - 0x1),
                          H0 = 0x0,
                          H1 = 0x0; ; ) {
                              if (cz = cq[cL],
                              -0x1 === cz['Id']) {
                                  if (0x1 === H2[cL])
                                      break;
                                  H5 = cz['Value'],
                                  H1 += 0x1,
                                  cP['push'](cz['Point']),
                                  H2[cL] += 0x1;
                              } else {
                                  if (0x2 === H2[cL])
                                      break;
                                  for (H2[cL] += 0x1,
                                  cJ = cm[cz['Id']],
                                  0x0 === H0 ? (H3 = cJ['Value'],
                                  H4 = cJ['Value'],
                                  H0 += 0x1) : (cJ['Value'] > H3 ? H4 = cJ['Value'] : cJ['Value'] < H3 && (H3 = cJ['Value']),
                                  H0 += 0x1),
                                  cM = [],
                                  bB['addAll'](cJ['PointList'], cM),
                                  cC = cM[0x0],
                                  cz['Point']['X'] === cC['X'] && cz['Point']['Y'] === cC['Y'] || cM['reverse'](),
                                  bB['addAll'](cM, cP),
                                  cN = 0x0; cN < cq['length'] - 0x1; cN++)
                                      if (cN !== cL && cq[cN]['Id'] === cz['Id']) {
                                          cL = cN,
                                          H2[cL] += 0x1;
                                          break;
                                      }
                              }
                              if (cL === cg) {
                                  cP['length'] > 0x0 && (cO = new bZ(),
                                  cO['IsBorder'] = true,
                                  cO['LowValue'] = H3,
                                  cO['HighValue'] = H4,
                                  cG = new bT(),
                                  cO['Area'] = bB['getExtentAndArea'](cP, cG),
                                  cO['IsClockWise'] = false,
                                  cO['StartPointIdx'] = H6['length'] - 0x1,
                                  cO['Extent'] = cG,
                                  cO['OutLine']['PointList'] = cP,
                                  cO['OutLine']['Value'] = H3,
                                  cO['IsHighCenter'] = true,
                                  cO['HoleLines'] = [],
                                  H1 > 0x0 && H5 < H3 && (cO['IsHighCenter'] = false,
                                  cO['HighValue'] = H3),
                                  cO['OutLine']['Type'] = 'Border',
                                  cQ['push'](cO));
                                  break;
                              }
                              cL += -0x1,
                              -0x1 === cL && (cL = cR - 0x1);
                          }
                  }
              let H7, H8 = [];
              for (cg = 0x0; cg < cm['length']; cg++)
                  if (cJ = cm[cg],
                  'Close' === cJ['Type'] && cJ['PointList']['length'] > 0x0) {
                      for (cO = new bZ(),
                      cO['IsBorder'] = false,
                      cO['LowValue'] = cJ['Value'],
                      cO['HighValue'] = cJ['Value'],
                      cG = new bT(),
                      cO['Area'] = bB['getExtentAndArea'](cJ['PointList'], cG),
                      cO['IsClockWise'] = bB['isClockwise'](cJ['PointList']),
                      cO['Extent'] = cG,
                      cO['OutLine'] = cJ,
                      cO['IsHighCenter'] = true,
                      cO['HoleLines'] = [],
                      H7 = false,
                      cN = 0x0; cN < H8['length']; cN++)
                          if (cO['Area'] > H8[cN]['Area']) {
                              H8['splice'](cN, 0x0, cO),
                              H7 = true;
                              break;
                          }
                      H7 || H8['push'](cO);
                  }
              return cQ = bB['judgePolygonHighCenter'](cQ, H8, cm, cq),
              cQ;
          }
          static['tracingClipPolygons'](cd, cq, cJ) {
              if (0x0 === cq['length'])
                  return [];
              let cC, cO, cG, cg, cN, cP, cM, cz = [], cQ = [];
              bB['addAll'](cq, cQ);
              let cm, cL, cR, H0 = [], H1 = [];
              for (H1['length'] = cJ['length'] - 0x1,
              cN = 0x0; cN < H1['length']; cN++)
                  H1[cN] = 0x0;
              let H2, H3, H4 = [];
              for (cR = cJ['length'] - 0x1,
              cN = 0x0; cN < cR; cN++)
                  if (-0x1 !== cJ[cN]['Id']) {
                      if (cL = cN,
                      H4['push'](cJ[cN]),
                      H3 = cJ[cL]['Point'],
                      H1[cL] < 0x1) {
                          if (cM = [],
                          cM['push'](cJ[cL]['Point']),
                          cL += 0x1,
                          cL === cR && (cL = 0x0),
                          H2 = cJ[cL]['Point']['clone'](),
                          -0x1 === cJ[cL]['Id']) {
                              let H5 = cL + 0xa;
                              for (let H6 = 0x1; H6 <= 0xa; H6++)
                                  if (cJ[cL + H6]['Id'] > -0x1) {
                                      H5 = cL + H6 - 0x1;
                                      break;
                                  }
                              H2 = cJ[H5]['Point']['clone']();
                          } else
                              H2['X'] = (H2['X'] + H3['X']) / 0x2,
                              H2['Y'] = (H2['Y'] + H3['Y']) / 0x2;
                          if (bB['pointInPolygon'](cd, H2))
                              for (; ; ) {
                                  if (cm = cJ[cL],
                                  -0x1 === cm['Id']) {
                                      if (0x1 === H1[cL])
                                          break;
                                      cM['push'](cm['Point']),
                                      H1[cL] += 0x1;
                                  } else {
                                      if (0x1 === H1[cL])
                                          break;
                                      for (H1[cL] += 0x1,
                                      cC = cQ[cm['Id']],
                                      H0 = [],
                                      bB['addAll'](cC['PointList'], H0),
                                      cO = H0[0x0],
                                      bB['doubleEquals'](cm['Point']['X'], cO['X']) && bB['doubleEquals'](cm['Point']['Y'], cO['Y']) || H0['reverse'](),
                                      bB['addAll'](H0, cM),
                                      cP = 0x0; cP < cJ['length'] - 0x1; cP++)
                                          if (cP !== cL && cJ[cP]['Id'] === cm['Id']) {
                                              cL = cP,
                                              H1[cL] += 0x1;
                                              break;
                                          }
                                  }
                                  if (cL === cN) {
                                      cM['length'] > 0x0 && (cG = new bZ(),
                                      cG['IsBorder'] = true,
                                      cG['LowValue'] = cd['LowValue'],
                                      cG['HighValue'] = cd['HighValue'],
                                      cg = new bT(),
                                      cG['Area'] = bB['getExtentAndArea'](cM, cg),
                                      cG['IsClockWise'] = true,
                                      cG['StartPointIdx'] = H4['length'] - 0x1,
                                      cG['Extent'] = cg,
                                      cG['OutLine']['PointList'] = cM,
                                      cG['OutLine']['Value'] = cd['LowValue'],
                                      cG['IsHighCenter'] = cd['IsHighCenter'],
                                      cG['OutLine']['Type'] = 'Border',
                                      cG['HoleLines'] = [],
                                      cz['push'](cG));
                                      break;
                                  }
                                  cL += 0x1,
                                  cL === cR && (cL = 0x0);
                              }
                      }
                      if (cL = cN,
                      H1[cL] < 0x1) {
                          if (cM = [],
                          cM['push'](cJ[cL]['Point']),
                          cL += -0x1,
                          -0x1 === cL && (cL = cR - 0x1),
                          H2 = cJ[cL]['Point']['clone'](),
                          -0x1 === cJ[cL]['Id']) {
                              let H7 = cL + 0xa;
                              for (let H8 = 0x1; H8 <= 0xa; H8++)
                                  if (cJ[cL + H8]['Id'] > -0x1) {
                                      H7 = cL + H8 - 0x1;
                                      break;
                                  }
                              H2 = cJ[H7]['Point']['clone']();
                          } else
                              H2['X'] = (H2['X'] + H3['X']) / 0x2,
                              H2['Y'] = (H2['Y'] + H3['Y']) / 0x2;
                          if (bB['pointInPolygon'](cd, H2))
                              for (; ; ) {
                                  if (cm = cJ[cL],
                                  -0x1 === cm['Id']) {
                                      if (0x1 === H1[cL])
                                          break;
                                      cM['push'](cm['Point']),
                                      H1[cL] += 0x1;
                                  } else {
                                      if (0x1 === H1[cL])
                                          break;
                                      for (H1[cL] += 0x1,
                                      cC = cQ[cm['Id']],
                                      H0 = [],
                                      bB['addAll'](cC['PointList'], H0),
                                      cO = H0[0x0],
                                      bB['doubleEquals'](cm['Point']['X'], cO['X']) && bB['doubleEquals'](cm['Point']['Y'], cO['Y']) || H0['reverse'](),
                                      bB['addAll'](H0, cM),
                                      cP = 0x0; cP < cJ['length'] - 0x1; cP++)
                                          if (cP !== cL && cJ[cP]['Id'] === cm['Id']) {
                                              cL = cP,
                                              H1[cL] += 0x1;
                                              break;
                                          }
                                  }
                                  if (cL === cN) {
                                      cM['length'] > 0x0 && (cG = new bZ(),
                                      cG['IsBorder'] = true,
                                      cG['LowValue'] = cd['LowValue'],
                                      cG['HighValue'] = cd['HighValue'],
                                      cg = new bT(),
                                      cG['Area'] = bB['getExtentAndArea'](cM, cg),
                                      cG['IsClockWise'] = false,
                                      cG['StartPointIdx'] = H4['length'] - 0x1,
                                      cG['Extent'] = cg,
                                      cG['OutLine']['PointList'] = cM,
                                      cG['OutLine']['Value'] = cd['LowValue'],
                                      cG['IsHighCenter'] = cd['IsHighCenter'],
                                      cG['OutLine']['Type'] = 'Border',
                                      cG['HoleLines'] = [],
                                      cz['push'](cG));
                                      break;
                                  }
                                  cL += -0x1,
                                  -0x1 === cL && (cL = cR - 0x1);
                              }
                      }
                  }
              return cz;
          }
          static['judgePolygonHighCenter'](cd, cq, cJ, cC) {
              let cO, cG, cg, cN, cP, cM, cz, cQ, cm, cL = [];
              if (0x0 === cd['length']) {
                  let H1 = cJ[0x0]['Value']
                    , H2 = cJ[0x0]['Value'];
                  for (let H3 of cJ)
                      H3['Value'] > H1 && (H1 = H3['Value']),
                      H3['Value'] < H2 && (H2 = H3['Value']);
                  cg = new bZ(),
                  cM = cC[0x0]['Value'],
                  cM < H2 ? (H1 = H2,
                  H2 = cM,
                  cg['IsHighCenter'] = true) : cM > H1 && (H2 = H1,
                  H1 = cM,
                  cg['IsHighCenter'] = false),
                  cN = new bV(),
                  cN['Type'] = 'Border',
                  cN['Value'] = cM,
                  cL = [];
                  for (let H4 of cC)
                      cL['push'](H4['Point']);
                  cN['PointList'] = [],
                  bB['addAll'](cL, cN['PointList']),
                  cN['PointList']['length'] > 0x0 && (cg['IsBorder'] = true,
                  cg['LowValue'] = H2,
                  cg['HighValue'] = H1,
                  cP = new bT(),
                  cg['Area'] = bB['getExtentAndArea'](cN['PointList'], cP),
                  cg['IsClockWise'] = bB['isClockwise'](cN['PointList']),
                  cg['Extent'] = cP,
                  cg['OutLine'] = cN,
                  cg['HoleLines'] = [],
                  cd['push'](cg));
              }
              bB['addAll'](cq, cd);
              let cR, H0 = cd['length'];
              for (cO = 0x1; cO < H0; cO++)
                  if (cg = cd[cO],
                  'Close' === cg['OutLine']['Type']) {
                      for (cQ = cg['Extent'],
                      cz = cg['OutLine']['PointList'][0x0],
                      cG = cO - 0x1; cG >= 0x0; cG--)
                          if (cR = cd[cG],
                          cm = cR['Extent'],
                          cL = [],
                          bB['addAll'](cR['OutLine']['PointList'], cL),
                          bB['pointInPolygonByPList'](cL, cz) && cQ['xMin'] > cm['xMin'] && cQ['yMin'] > cm['yMin'] && cQ['xMax'] < cm['xMax'] && cQ['yMax'] < cm['yMax']) {
                              cR['IsHighCenter'] ? cg['IsHighCenter'] = cg['HighValue'] !== cR['LowValue'] : cg['IsHighCenter'] = cg['LowValue'] === cR['HighValue'];
                              break;
                          }
                  }
              return cd;
          }
          static['judgePolygonHighCenter_old'](cd, cq, cJ, cC) {
              let cO, cG, cg, cN, cP, cM, cz, cQ, cm, cL, cR = [];
              if (0x0 === cd['length']) {
                  let H2 = cJ[0x0]['Value']
                    , H3 = cJ[0x0]['Value'];
                  for (let H4 of cJ)
                      H4['Value'] > H2 && (H2 = H4['Value']),
                      H4['Value'] < H3 && (H3 = H4['Value']);
                  cg = new bZ(),
                  cN = new bV(),
                  cN['Type'] = 'Border',
                  cN['Value'] = H3,
                  cg['IsHighCenter'] = false,
                  cq['length'] > 0x0 && cC[0x0]['Value'] >= cq[0x0]['LowValue'] && (cN['Value'] = H2,
                  cg['IsHighCenter'] = true),
                  cR = [];
                  for (let H5 of cC)
                      cR['push'](H5['Point']);
                  cN['PointList'] = [],
                  bB['addAll'](cR, cN['PointList']),
                  cN['PointList']['length'] > 0x0 && (cg['IsBorder'] = true,
                  cg['LowValue'] = cN['Value'],
                  cg['HighValue'] = cN['Value'],
                  cP = new bT(),
                  cg['Area'] = bB['getExtentAndArea'](cN['PointList'], cP),
                  cg['IsClockWise'] = bB['isClockwise'](cN['PointList']),
                  cg['Extent'] = cP,
                  cg['OutLine'] = cN,
                  cg['HoleLines'] = [],
                  cd['push'](cg));
              }
              bB['addAll'](cq, cd);
              let H0, H1 = cd['length'];
              for (cO = 0x1; cO < H1; cO++)
                  if (cg = cd[cO],
                  'Close' === cg['OutLine']['Type']) {
                      for (cm = cg['Extent'],
                      cM = cg['LowValue'],
                      cQ = cg['OutLine']['PointList'][0x0],
                      cG = cO - 0x1; cG >= 0x0; cG--)
                          if (H0 = cd[cG],
                          cL = H0['Extent'],
                          cz = H0['LowValue'],
                          cR = [],
                          bB['addAll'](H0['OutLine']['PointList'], cR),
                          bB['pointInPolygonByPList'](cR, cQ) && cm['xMin'] > cL['xMin'] && cm['yMin'] > cL['yMin'] && cm['xMax'] < cL['xMax'] && cm['yMax'] < cL['yMax']) {
                              (cM < cz || cM === cz && H0['IsHighCenter']) && (cg['IsHighCenter'] = false);
                              break;
                          }
                  }
              return cd;
          }
          static['tracingPolygons_Ring'](cd, cq, cJ, cC, cO) {
              let cG, cg, cN, cP, cM, cz, cQ, cm, cL, cR, H0, H1 = [];
              cG = [],
              bB['addAll'](cd, cG);
              let H2, H3, H4, H5 = [];
              for (H5['length'] = cq['length'] - 0x1,
              cz = 0x0; cz < H5['length']; cz++)
                  H5[cz] = 0x0;
              let H6, H7, H8, H9 = 0x0, Hv = 0x0, HA = 0x0, Hk = [];
              for (H3 = cq['length'],
              cz = 0x0; cz < H3; cz++) {
                  if (-0x1 === cq[cz]['Id'])
                      continue;
                  H2 = cz,
                  Hk['push'](cq[cz]);
                  let Hx = false;
                  if (H5[H2] < 0x2) {
                      cR = cq[H2],
                      H8 = cR['BInnerIdx'],
                      cm = [];
                      let Hp = [];
                      for (cm['push'](cR['Point']),
                      Hp['push'](H2),
                      H6 = cR['BorderIdx'],
                      H7 = H6,
                      H2 += 0x1,
                      H8 += 0x1,
                      H8 === cO[H6] - 0x1 && (H2 -= cO[H6] - 0x1),
                      H4 = 0x0; ; ) {
                          if (cR = cq[H2],
                          -0x1 === cR['Id']) {
                              if (0x1 === H5[H2])
                                  break;
                              HA = cR['Value'],
                              cm['push'](cR['Point']),
                              H5[H2] += 0x1,
                              Hp['push'](H2);
                          } else {
                              if (0x2 === H5[H2])
                                  break;
                              for (H5[H2] += 0x1,
                              Hp['push'](H2),
                              cg = cG[cR['Id']],
                              0x0 === H4 ? (H9 = cg['Value'],
                              Hv = cg['Value'],
                              H4 += 0x1) : H9 === Hv && (cg['Value'] > H9 ? Hv = cg['Value'] : cg['Value'] < H9 && (H9 = cg['Value']),
                              H4 += 0x1),
                              cL = [],
                              bB['addAll'](cg['PointList'], cL),
                              cN = cL[0x0],
                              cR['Point']['X'] === cN['X'] && cR['Point']['Y'] === cN['Y'] || cL['reverse'](),
                              bB['addAll'](cL, cm),
                              cQ = 0x0; cQ < cq['length']; cQ++)
                                  if (cQ !== H2 && (H0 = cq[cQ],
                                  H0['Id'] === cR['Id'])) {
                                      H2 = cQ,
                                      H8 = H0['BInnerIdx'],
                                      H5[H2] += 0x1,
                                      Hp['push'](H2),
                                      H7 = H0['BorderIdx'],
                                      cR['BorderIdx'] > 0x0 && cR['BorderIdx'] === H0['BorderIdx'] && (Hx = true);
                                      break;
                                  }
                          }
                          if (H2 === cz) {
                              if (cm['length'] > 0x0) {
                                  if (Hx) {
                                      let HF = false
                                        , Hy = 0x0;
                                      for (let HY = 0x0; HY < cR['BorderIdx']; HY++)
                                          Hy += cO[HY];
                                      let Hw = Hy
                                        , Hh = Hy + cO[cR['BorderIdx']]
                                        , Hu = Hw;
                                      for (let HT = Hw; HT < Hh; HT++)
                                          if (Hp['indexOf'](HT) < 0x0) {
                                              Hu = HT;
                                              break;
                                          }
                                      if (bB['pointInPolygonByPList'](cm, cq[Hu]['Point']) && (HF = true),
                                      HF)
                                          break;
                                  }
                                  cP = new bZ(),
                                  cP['IsBorder'] = true,
                                  cP['IsInnerBorder'] = Hx,
                                  cP['LowValue'] = H9,
                                  cP['HighValue'] = Hv,
                                  cM = new bT(),
                                  cP['Area'] = bB['getExtentAndArea'](cm, cM),
                                  cP['IsClockWise'] = true,
                                  cP['StartPointIdx'] = Hk['length'] - 0x1,
                                  cP['Extent'] = cM,
                                  cP['OutLine']['PointList'] = cm,
                                  cP['OutLine']['Value'] = H9,
                                  cP['IsHighCenter'] = true,
                                  H9 === Hv && HA < H9 && (cP['IsHighCenter'] = false),
                                  cP['OutLine']['Type'] = 'Border',
                                  cP['HoleLines'] = [],
                                  H1['push'](cP);
                              }
                              break;
                          }
                          H2 += 0x1,
                          H8 += 0x1,
                          H6 !== H7 && (H6 = H7),
                          H8 === cO[H6] - 0x1 && (H2 -= cO[H6] - 0x1,
                          H8 = 0x0);
                      }
                  }
                  if (Hx = false,
                  H2 = cz,
                  H5[H2] < 0x2) {
                      cm = [];
                      let HX = [];
                      for (cR = cq[H2],
                      H8 = cR['BInnerIdx'],
                      cm['push'](cR['Point']),
                      HX['push'](H2),
                      H6 = cR['BorderIdx'],
                      H7 = H6,
                      H2 += -0x1,
                      H8 += -0x1,
                      -0x1 === H8 && (H2 += cO[H6] - 0x1),
                      H4 = 0x0; ; ) {
                          if (cR = cq[H2],
                          -0x1 === cR['Id']) {
                              if (0x1 === H5[H2])
                                  break;
                              HA = cR['Value'],
                              cm['push'](cR['Point']),
                              HX['push'](H2),
                              H5[H2] += 0x1;
                          } else {
                              if (0x2 === H5[H2])
                                  break;
                              for (H5[H2] += 0x1,
                              HX['push'](H2),
                              cg = cG[cR['Id']],
                              0x0 === H4 ? (H9 = cg['Value'],
                              Hv = cg['Value'],
                              H4 += 0x1) : H9 === Hv && (cg['Value'] > H9 ? Hv = cg['Value'] : cg['Value'] < H9 && (H9 = cg['Value']),
                              H4 += 0x1),
                              cL = [],
                              bB['addAll'](cg['PointList'], cL),
                              cN = cL[0x0],
                              cR['Point']['X'] === cN['X'] && cR['Point']['Y'] === cN['Y'] || cL['reverse'](),
                              bB['addAll'](cL, cm),
                              cQ = 0x0; cQ < cq['length']; cQ++)
                                  if (cQ !== H2 && (H0 = cq[cQ],
                                  H0['Id'] === cR['Id'])) {
                                      H2 = cQ,
                                      H8 = H0['BInnerIdx'],
                                      H5[H2] += 0x1,
                                      HX['push'](H2),
                                      H7 = H0['BorderIdx'],
                                      cR['BorderIdx'] > 0x0 && cR['BorderIdx'] === H0['BorderIdx'] && (Hx = true);
                                      break;
                                  }
                          }
                          if (H2 === cz) {
                              if (cm['length'] > 0x0) {
                                  if (Hx) {
                                      let HE = false
                                        , Hf = 0x0;
                                      for (let HD = 0x0; HD < cR['BorderIdx']; HD++)
                                          Hf += cO[HD];
                                      let HW = Hf
                                        , HI = Hf + cO[cR['BorderIdx']]
                                        , Hj = HW;
                                      for (let HV = HW; HV < HI; HV++)
                                          if (HX['indexOf'](HV) < 0x0) {
                                              Hj = HV;
                                              break;
                                          }
                                      if (bB['pointInPolygonByPList'](cm, cq[Hj]['Point']) && (HE = true),
                                      HE)
                                          break;
                                  }
                                  cP = new bZ(),
                                  cP['IsBorder'] = true,
                                  cP['IsInnerBorder'] = Hx,
                                  cP['LowValue'] = H9,
                                  cP['HighValue'] = Hv,
                                  cM = new bT(),
                                  cP['Area'] = bB['getExtentAndArea'](cm, cM),
                                  cP['IsClockWise'] = false,
                                  cP['StartPointIdx'] = Hk['length'] - 0x1,
                                  cP['Extent'] = cM,
                                  cP['OutLine']['PointList'] = cm,
                                  cP['OutLine']['Value'] = H9,
                                  cP['IsHighCenter'] = true,
                                  H9 === Hv && HA < H9 && (cP['IsHighCenter'] = false),
                                  cP['OutLine']['Type'] = 'Border',
                                  cP['HoleLines'] = [],
                                  H1['push'](cP);
                              }
                              break;
                          }
                          H2 += -0x1,
                          H8 += -0x1,
                          H6 !== H7 && (H6 = H7),
                          -0x1 === H8 && (H2 += cO[H6],
                          H8 = cO[H6] - 0x1);
                      }
                  }
              }
              let Hl, HK, Hb, Hc, HH = [];
              for (cz = 0x0; cz < cG['length']; cz++)
                  if (cg = cG[cz],
                  'Close' === cg['Type']) {
                      for (cP = new bZ(),
                      cP['IsBorder'] = false,
                      cP['LowValue'] = cg['Value'],
                      cP['HighValue'] = cg['Value'],
                      cM = new bT(),
                      cP['Area'] = bB['getExtentAndArea'](cg['PointList'], cM),
                      cP['IsClockWise'] = bB['isClockwise'](cg['PointList']),
                      cP['Extent'] = cM,
                      cP['OutLine'] = cg,
                      cP['IsHighCenter'] = true,
                      cP['HoleLines'] = [],
                      Hl = false,
                      cQ = 0x0; cQ < HH['length']; cQ++)
                          if (cP['Area'] > HH[cQ]['Area']) {
                              HH['splice'](cQ, 0x0, cP),
                              Hl = true;
                              break;
                          }
                      Hl || HH['push'](cP);
                  }
              for (0x0 === H1['length'] && (cg = new bV(),
              cg['Type'] = 'Border',
              cg['Value'] = cC[0x0],
              cg['PointList'] = [],
              bB['addAll'](cJ['LineList'][0x0]['pointList'], cg['PointList']),
              cg['PointList']['length'] > 0x0 && (cP = new bZ(),
              cP['LowValue'] = cg['Value'],
              cP['HighValue'] = cg['Value'],
              cM = new bT(),
              cP['Area'] = bB['getExtentAndArea'](cg['PointList'], cM),
              cP['IsClockWise'] = bB['isClockwise'](cg['PointList']),
              cP['Extent'] = cM,
              cP['OutLine'] = cg,
              cP['IsHighCenter'] = false,
              H1['push'](cP))),
              bB['addAll'](HH, H1),
              cz = H1['length'] - 0x1; cz >= 0x0; cz += -0x1)
                  if (cP = H1[cz],
                  'Close' === cP['OutLine']['Type']) {
                      for (HK = cP['Extent'],
                      H9 = cP['LowValue'],
                      cN = cP['OutLine']['PointList'][0x0],
                      cQ = cz - 0x1; cQ >= 0x0; cQ += -0x1)
                          if (Hc = H1[cQ],
                          Hb = Hc['Extent'],
                          Hv = Hc['LowValue'],
                          cL = [],
                          bB['addAll'](Hc['OutLine']['PointList'], cL),
                          bB['pointInPolygonByPList'](cL, cN) && HK['xMin'] > Hb['xMin'] && HK['yMin'] > Hb['yMin'] && HK['xMax'] < Hb['xMax'] && HK['yMax'] < Hb['yMax']) {
                              (H9 < Hv || H9 === Hv && Hc['IsHighCenter']) && (cP['IsHighCenter'] = false);
                              break;
                          }
                  }
              return H1;
          }
          static['addPolygonHoles'](cd) {
              let cq, cJ, cC = [];
              for (cq = 0x0; cq < cd['length']; cq++) {
                  let cO = cd[cq];
                  cO['IsBorder'] || (cO['HoleIndex'] = 0x1,
                  cC['push'](cO));
              }
              if (0x0 === cC['length'])
                  return cd;
              {
                  let cG = [];
                  for (cq = 0x1; cq < cC['length']; cq++) {
                      let cN = cC[cq];
                      for (cJ = cq - 0x1; cJ >= 0x0; cJ--) {
                          let cP = cC[cJ];
                          if (cP['Extent']['Include'](cN['Extent']) && bB['pointInPolygonByPList'](cP['OutLine']['PointList'], cN['OutLine']['PointList'][0x0])) {
                              cN['HoleIndex'] = cP['HoleIndex'] + 0x1,
                              cP['AddHole'](cN);
                              break;
                          }
                      }
                  }
                  let cg = [];
                  for (cq = 0x0; cq < cC['length']; cq++)
                      0x1 === cC[cq]['HoleIndex'] && cg['push'](cC[cq]);
                  for (cq = 0x0; cq < cd['length']; cq++) {
                      let cM = cd[cq];
                      if (true === cM['IsBorder']) {
                          for (cJ = 0x0; cJ < cg['length']; cJ++) {
                              let cz = cg[cJ];
                              cM['Extent']['Include'](cz['Extent']) && bB['pointInPolygonByPList'](cM['OutLine']['PointList'], cz['OutLine']['PointList'][0x0]) && cM['AddHole'](cz);
                          }
                          cG['push'](cM);
                      }
                  }
                  return bB['addAll'](cC, cG),
                  cG;
              }
          }
          static['addPolygonHoles_Ring'](cd) {
              let cq, cJ, cC = [];
              for (cq = 0x0; cq < cd['length']; cq++) {
                  let cO = cd[cq];
                  cO['IsBorder'] && !cO['IsInnerBorder'] || (cO['HoleIndex'] = 0x1,
                  cC['push'](cO));
              }
              if (0x0 === cC['length'])
                  return cd;
              {
                  let cG = [];
                  for (cq = 0x1; cq < cC['length']; cq++) {
                      let cN = cC[cq];
                      for (cJ = cq - 0x1; cJ >= 0x0; cJ--) {
                          let cP = cC[cJ];
                          if (cP['Extent']['Include'](cN['Extent']) && bB['pointInPolygonByPList'](cP['OutLine']['PointList'], cN['OutLine']['PointList'][0x0])) {
                              cN['HoleIndex'] = cP['HoleIndex'] + 0x1,
                              cP['AddHole'](cN);
                              break;
                          }
                      }
                  }
                  let cg = [];
                  for (cq = 0x0; cq < cC['length']; cq++)
                      0x1 === cC[cq]['HoleIndex'] && cg['push'](cC[cq]);
                  for (cq = 0x0; cq < cd['length']; cq++) {
                      let cM = cd[cq];
                      if (cM['IsBorder'] && !cM['IsInnerBorder']) {
                          for (cJ = 0x0; cJ < cg['length']; cJ++) {
                              let cz = cg[cJ];
                              cM['Extent']['Include'](cz['Extent']) && bB['pointInPolygonByPList'](cM['OutLine']['PointList'], cz['OutLine']['PointList'][0x0]) && cM['AddHole'](cz);
                          }
                          cG['push'](cM);
                      }
                  }
                  return bB['addAll'](cC, cG),
                  cG;
              }
          }
          static['addHoles_Ring'](cd, cq) {
              let cJ, cC;
              for (cJ = 0x0; cJ < cq['length']; cJ++) {
                  let cO = cq[cJ]
                    , cG = bB['getExtent'](cO);
                  for (cC = cd['length'] - 0x1; cC >= 0x0; cC--) {
                      let cg = cd[cC];
                      if (cg['Extent']['Include'](cG)) {
                          let cN = true;
                          for (let cP of cO)
                              if (!bB['pointInPolygonByPList'](cg['OutLine']['PointList'], cP)) {
                                  cN = false;
                                  break;
                              }
                          if (cN) {
                              cg['AddHole'](cO);
                              break;
                          }
                      }
                  }
              }
          }
          static['cutPolyline'](cd, cq) {
              let cJ, cC, cO = [], cG = cd['PointList'], cg = bB['getExtent'](cG), cN = bB['getExtent'](cq);
              if (!bB['isExtentCross'](cg, cN))
                  return cO;
              if (bB['isClockwise'](cq) || cq['reverse'](),
              bB['pointInPolygonByPList'](cq, cG[0x0])) {
                  let H3 = true
                    , H4 = 0x0;
                  for (cJ = 0x0; cJ < cG['length']; cJ++)
                      if (!bB['pointInPolygonByPList'](cq, cG[cJ])) {
                          H4 = cJ,
                          H3 = false;
                          break;
                      }
                  if (H3)
                      return cO['push'](cd),
                      cO;
                  if ('Close' === cd['Type']) {
                      let H5 = [];
                      for (cJ = H4; cJ < cG['length']; cJ++)
                          H5['push'](cG[cJ]);
                      for (cJ = 0x1; cJ < H4; cJ++)
                          H5['push'](cG[cJ]);
                      H5['push'](H5[0x0]),
                      cG = [],
                      bB['addAll'](H5, cG);
                  } else
                      cG['reverse']();
              }
              let cP, cM, cz, cQ, cm, cL, cR, H0, H1 = bB['pointInPolygonByPList'](cq, cG[0x0]), H2 = [];
              for (cz = cG[0x0],
              cJ = 0x1; cJ < cG['length']; cJ++) {
                  if (cQ = cG[cJ],
                  bB['pointInPolygonByPList'](cq, cQ)) {
                      if (!H1) {
                          for (cm = new bE(),
                          cL = new bj(),
                          cL['P1'] = cz,
                          cL['P2'] = cQ,
                          cP = cq[cq['length'] - 0x1],
                          cC = 0x0; cC < cq['length']; cC++) {
                              if (cM = cq[cC],
                              cR = new bj(),
                              cR['P1'] = cP,
                              cR['P2'] = cM,
                              bB['isLineSegmentCross'](cL, cR)) {
                                  cm = bB['getCrossPointD'](cL, cR);
                                  break;
                              }
                              cP = cM;
                          }
                          H2['push'](cm);
                      }
                      H2['push'](cG[cJ]),
                      H1 = true;
                  } else {
                      if (H1) {
                          for (cm = new bE(),
                          cL = new bj(),
                          cL['P1'] = cz,
                          cL['P2'] = cQ,
                          cP = cq[cq['length'] - 0x1],
                          cC = 0x0; cC < cq['length']; cC++) {
                              if (cM = cq[cC],
                              cR = new bj(),
                              cR['P1'] = cP,
                              cR['P2'] = cM,
                              bB['isLineSegmentCross'](cL, cR)) {
                                  cm = bB['getCrossPointD'](cL, cR);
                                  break;
                              }
                              cP = cM;
                          }
                          H2['push'](cm),
                          H0 = new bV(),
                          H0['Value'] = cd['Value'],
                          H0['Type'] = cd['Type'],
                          H0['PointList'] = H2,
                          cO['push'](H0),
                          H1 = false,
                          H2 = [];
                      }
                  }
                  cz = cQ;
              }
              return H1 && H2['length'] > 0x1 && (H0 = new bV(),
              H0['Value'] = cd['Value'],
              H0['Type'] = cd['Type'],
              H0['PointList'] = H2,
              cO['push'](H0)),
              cO;
          }
          static['cutPolygon_Hole'](cd, cq) {
              let cJ, cC, cO = [], cG = [], cg = cd['OutLine']['PointList'], cN = bB['getExtent'](cg), cP = bB['getExtent'](cq);
              if (!bB['isExtentCross'](cN, cP))
                  return cO;
              bB['isClockwise'](cq) || cq['reverse']();
              let cM = [];
              if (bB['pointInPolygonByPList'](cq, cg[0x0])) {
                  let cL = true
                    , cR = 0x0;
                  for (cJ = 0x0; cJ < cg['length']; cJ++)
                      if (!bB['pointInPolygonByPList'](cq, cg[cJ])) {
                          cR = cJ,
                          cL = false;
                          break;
                      }
                  if (cL)
                      return cO['push'](cd),
                      cO;
                  {
                      let H0 = [];
                      for (cJ = cR; cJ < cg['length']; cJ++)
                          H0['push'](cg[cJ]);
                      for (cJ = 0x1; cJ < cR; cJ++)
                          H0['push'](cg[cJ]);
                      H0['push'](H0[0x0]),
                      cM['push'](H0);
                  }
              } else
                  cM['push'](cg);
              let cz = [];
              for (let H1 = 0x0; H1 < cd['HoleLines']['length']; H1++) {
                  let H2 = cd['HoleLines'][H1]['PointList'];
                  if (cN = bB['getExtent'](H2),
                  bB['isExtentCross'](cN, cP)) {
                      if (bB['pointInPolygonByPList'](cq, H2[0x0])) {
                          let H3 = true
                            , H4 = 0x0;
                          for (cJ = 0x0; cJ < H2['length']; cJ++)
                              if (!bB['pointInPolygonByPList'](cq, H2[cJ])) {
                                  H4 = cJ,
                                  H3 = false;
                                  break;
                              }
                          if (H3)
                              cz['push'](H2);
                          else {
                              let H5 = [];
                              for (cJ = H4; cJ < H2['length']; cJ++)
                                  H5['push'](H2[cJ]);
                              for (cJ = 0x1; cJ < H4; cJ++)
                                  H5['push'](H2[cJ]);
                              H5['push'](H5[0x0]),
                              cM['push'](H5);
                          }
                      } else
                          cM['push'](H2);
                  }
              }
              let cQ = []
                , cm = new bf();
              for (let H6 of cq)
                  cm = new bf(),
                  cm['Point'] = H6,
                  cm['Id'] = -0x1,
                  cQ['push'](cm);
              for (let H7 = 0x0; H7 < cM['length']; H7++) {
                  cg = cM[H7];
                  let H8, H9, Hv, HA, Hk, Hl, HK, Hb, Hc = false, HH = [];
                  Hv = cg[0x0];
                  let Hx = -0x1
                    , Hp = -0x1
                    , HF = true
                    , Hy = 0x0;
                  for (cJ = 0x1; cJ < cg['length']; cJ++) {
                      if (HA = cg[cJ],
                      bB['pointInPolygonByPList'](cq, HA)) {
                          if (!Hc) {
                              for (Hl = new bj(),
                              Hl['P1'] = Hv,
                              Hl['P2'] = HA,
                              H8 = cQ[cQ['length'] - 0x1]['Point'],
                              Hk = new bE(),
                              cC = 0x0; cC < cQ['length']; cC++) {
                                  if (H9 = cQ[cC]['Point'],
                                  HK = new bj(),
                                  HK['P1'] = H8,
                                  HK['P2'] = H9,
                                  bB['isLineSegmentCross'](Hl, HK)) {
                                      Hk = bB['getCrossPointD'](Hl, HK),
                                      cm = new bf(),
                                      cm['Id'] = cG['length'],
                                      cm['Point'] = Hk,
                                      cQ['splice'](cC, 0x0, cm),
                                      Hx = cC;
                                      break;
                                  }
                                  H8 = H9;
                              }
                              HH['push'](Hk);
                          }
                          HH['push'](cg[cJ]),
                          Hc = true;
                      } else {
                          if (Hc) {
                              for (Hl = new bj(),
                              Hl['P1'] = Hv,
                              Hl['P2'] = HA,
                              H8 = cQ[cQ['length'] - 0x1]['Point'],
                              Hk = new bE(),
                              cC = 0x0; cC < cQ['length']; cC++) {
                                  if (H9 = cQ[cC]['Point'],
                                  HK = new bj(),
                                  HK['P1'] = H8,
                                  HK['P2'] = H9,
                                  bB['isLineSegmentCross'](Hl, HK)) {
                                      HF || (Hx - Hp >= 0x1 && Hx - Hp <= 0xa ? bB['twoPointsInside'](Hy, Hp, Hx, cC) || (cQ['splice'](Hx, 0x1),
                                      cQ['splice'](Hp, 0x0, cm)) : Hx - Hp <= -0x1 && Hx - Hp >= -0xa ? bB['twoPointsInside'](Hy, Hp, Hx, cC) || (cQ['splice'](Hx, 0x1),
                                      cQ['splice'](Hp + 0x1, 0x0, cm)) : Hx === Hp && (bB['twoPointsInside'](Hy, Hp, Hx, cC) || (cQ['splice'](Hx, 0x1),
                                      cQ['splice'](Hx + 0x1, 0x0, cm)))),
                                      Hk = bB['getCrossPointD'](Hl, HK),
                                      cm = new bf(),
                                      cm['Id'] = cG['length'],
                                      cm['Point'] = Hk,
                                      cQ['splice'](cC, 0x0, cm),
                                      Hp = cC,
                                      Hy = Hx,
                                      HF = false;
                                      break;
                                  }
                                  H8 = H9;
                              }
                              HH['push'](Hk),
                              Hb = new bV(),
                              Hb['Value'] = cd['OutLine']['Value'],
                              Hb['Type'] = cd['OutLine']['Type'],
                              Hb['PointList'] = HH,
                              cG['push'](Hb),
                              Hc = false,
                              HH = [];
                          }
                      }
                      Hv = HA;
                  }
              }
              if (cG['length'] > 0x0)
                  cO = bB['tracingClipPolygons'](cd, cG, cQ);
              else {
                  if (bB['pointInPolygonByPList'](cg, cq[0x0])) {
                      let Hw = new bT()
                        , Hh = new bZ();
                      Hh['IsBorder'] = true,
                      Hh['LowValue'] = cd['LowValue'],
                      Hh['HighValue'] = cd['HighValue'],
                      Hh['Area'] = bB['getExtentAndArea'](cq, Hw),
                      Hh['IsClockWise'] = true,
                      Hh['Extent'] = Hw,
                      Hh['OutLine']['PointList'] = cq,
                      Hh['OutLine']['Value'] = cd['LowValue'],
                      Hh['IsHighCenter'] = cd['IsHighCenter'],
                      Hh['OutLine']['Type'] = 'Border',
                      Hh['HoleLines'] = [],
                      cO['push'](Hh);
                  }
              }
              return cz['length'] > 0x0 && bB['addHoles_Ring'](cO, cz),
              cO;
          }
          static['cutPolygon'](cd, cq) {
              let cJ, cC, cO = [], cG = [], cg = cd['OutLine']['PointList'], cN = bB['getExtent'](cg), cP = bB['getExtent'](cq);
              if (!bB['isExtentCross'](cN, cP))
                  return cO;
              if (bB['isClockwise'](cq) || cq['reverse'](),
              bB['pointInPolygonByPList'](cq, cg[0x0])) {
                  let Hv = true
                    , HA = 0x0;
                  for (cJ = 0x0; cJ < cg['length']; cJ++)
                      if (!bB['pointInPolygonByPList'](cq, cg[cJ])) {
                          HA = cJ,
                          Hv = false;
                          break;
                      }
                  if (Hv)
                      return cO['push'](cd),
                      cO;
                  {
                      let Hk = [];
                      for (cJ = HA; cJ < cg['length']; cJ++)
                          Hk['push'](cg[cJ]);
                      for (cJ = 0x1; cJ < HA; cJ++)
                          Hk['push'](cg[cJ]);
                      Hk['push'](Hk[0x0]),
                      cg = [],
                      bB['addAll'](Hk, cg);
                  }
              }
              let cM = []
                , cz = new bf();
              for (let Hl of cq)
                  cz = new bf(),
                  cz['Point'] = Hl,
                  cz['Id'] = -0x1,
                  cM['push'](cz);
              let cQ, cm, cL, cR, H0, H1, H2, H3, H4 = false, H5 = [];
              cL = cg[0x0];
              let H6 = -0x1
                , H7 = -0x1
                , H8 = 0x0
                , H9 = true;
              for (cJ = 0x1; cJ < cg['length']; cJ++) {
                  if (cR = cg[cJ],
                  bB['pointInPolygonByPList'](cq, cR)) {
                      if (!H4) {
                          for (H1 = new bj(),
                          H1['P1'] = cL,
                          H1['P2'] = cR,
                          cQ = cM[cM['length'] - 0x1]['Point'],
                          H0 = new bE(),
                          cC = 0x0; cC < cM['length']; cC++) {
                              if (cm = cM[cC]['Point'],
                              H2 = new bj(),
                              H2['P1'] = cQ,
                              H2['P2'] = cm,
                              bB['isLineSegmentCross'](H1, H2)) {
                                  H0 = bB['getCrossPointD'](H1, H2),
                                  cz = new bf(),
                                  cz['Id'] = cG['length'],
                                  cz['Point'] = H0,
                                  cM['splice'](cC, 0x0, cz),
                                  H6 = cC;
                                  break;
                              }
                              cQ = cm;
                          }
                          H5['push'](H0);
                      }
                      H5['push'](cg[cJ]),
                      H4 = true;
                  } else {
                      if (H4) {
                          for (H1 = new bj(),
                          H1['P1'] = cL,
                          H1['P2'] = cR,
                          cQ = cM[cM['length'] - 0x1]['Point'],
                          H0 = new bE(),
                          cC = 0x0; cC < cM['length']; cC++) {
                              if (cm = cM[cC]['Point'],
                              H2 = new bj(),
                              H2['P1'] = cQ,
                              H2['P2'] = cm,
                              bB['isLineSegmentCross'](H1, H2)) {
                                  H9 || (H6 - H7 >= 0x1 && H6 - H7 <= 0xa ? bB['twoPointsInside'](H8, H7, H6, cC) || (cM['splice'](H6, 0x1),
                                  cM['splice'](H7, 0x0, cz)) : H6 - H7 <= -0x1 && H6 - H7 >= -0xa ? bB['twoPointsInside'](H8, H7, H6, cC) || (cM['splice'](H6, 0x1),
                                  cM['splice'](H7 + 0x1, 0x0, cz)) : H6 === H7 && (bB['twoPointsInside'](H8, H7, H6, cC) || (cM['splice'](H6, 0x1),
                                  cM['splice'](H6 + 0x1, 0x0, cz)))),
                                  H0 = bB['getCrossPointD'](H1, H2),
                                  cz = new bf(),
                                  cz['Id'] = cG['length'],
                                  cz['Point'] = H0,
                                  cM['splice'](cC, 0x0, cz),
                                  H7 = cC,
                                  H8 = H6,
                                  H9 = false;
                                  break;
                              }
                              cQ = cm;
                          }
                          H5['push'](H0),
                          H3 = new bV(),
                          H3['Value'] = cd['OutLine']['Value'],
                          H3['Type'] = cd['OutLine']['Type'],
                          H3['PointList'] = H5,
                          cG['push'](H3),
                          H4 = false,
                          H5 = [];
                      }
                  }
                  cL = cR;
              }
              if (cG['length'] > 0x0)
                  cO = bB['tracingClipPolygons'](cd, cG, cM);
              else {
                  if (bB['pointInPolygonByPList'](cg, cq[0x0])) {
                      let HK = new bT()
                        , Hb = new bZ();
                      Hb['IsBorder'] = true,
                      Hb['LowValue'] = cd['LowValue'],
                      Hb['HighValue'] = cd['HighValue'],
                      Hb['Area'] = bB['getExtentAndArea'](cq, HK),
                      Hb['IsClockWise'] = true,
                      Hb['Extent'] = HK,
                      Hb['OutLine']['PointList'] = cq,
                      Hb['OutLine']['Value'] = cd['LowValue'],
                      Hb['IsHighCenter'] = cd['IsHighCenter'],
                      Hb['OutLine']['Type'] = 'Border',
                      Hb['HoleLines'] = [],
                      cO['push'](Hb);
                  }
              }
              return cO;
          }
          static['twoPointsInside'](cd, cq, cJ, cC) {
              if (cq < cd && (cd += 0x1),
              cJ < cd && (cd += 0x1),
              cJ < cq && (cq += 0x1),
              cq < cd) {
                  let cO = cd;
                  cd = cq,
                  cq = cO;
              }
              return cJ > cd && cJ <= cq ? cC > cd && cC <= cq : !(cC > cd && cC <= cq);
          }
          static['BSplineScanning'](cd, cq) {
              let cJ, cC, cO, cG, cg, cN = [];
              if (cq < 0x4)
                  return null;
              let cP = false;
              cg = cd[0x0];
              let cM = cd[cq - 0x1];
              for (cg['X'] === cM['X'] && cg['Y'] === cM['Y'] && (cd['splice'](0x0, 0x1),
              cd['push'](cd[0x0]),
              cd['push'](cd[0x1]),
              cd['push'](cd[0x2]),
              cd['push'](cd[0x3]),
              cd['push'](cd[0x4]),
              cd['push'](cd[0x5]),
              cd['push'](cd[0x6]),
              cP = true),
              cq = cd['length'],
              cC = 0x0; cC < cq - 0x3; cC++)
                  for (cJ = 0x0; cJ <= 0x1; cJ += 0.05) {
                      let cz = bB['BSpline'](cd, cJ, cC);
                      cO = cz[0x0],
                      cG = cz[0x1],
                      cP ? cC > 0x3 && (cg = new bE(),
                      cg['X'] = cO,
                      cg['Y'] = cG,
                      cN['push'](cg)) : (cg = new bE(),
                      cg['X'] = cO,
                      cg['Y'] = cG,
                      cN['push'](cg));
                  }
              return cP ? cN['push'](cN[0x0]) : (cN['splice'](0x0, 0x0, cd[0x0]),
              cN['push'](cd[cd['length'] - 0x1])),
              cN;
          }
          static['BSpline'](cd, cq, cJ) {
              let cC, cO = [];
              bB['fb'](cq, cO);
              let cG, cg = 0x0, cN = 0x0;
              for (cC = 0x0; cC < 0x4; cC++)
                  cG = cd[cJ + cC],
                  cg += cO[cC] * cG['X'],
                  cN += cO[cC] * cG['Y'];
              let cP = [];
              return cP[0x0] = cg,
              cP[0x1] = cN,
              cP;
          }
          static['f0'](cd) {
              return 0x1 / 0x6 * (0x1 - cd) * (0x1 - cd) * (0x1 - cd);
          }
          static['f1'](cd) {
              return 0x1 / 0x6 * (0x3 * cd * cd * cd - 0x6 * cd * cd + 0x4);
          }
          static['f2'](cd) {
              return 0x1 / 0x6 * (-0x3 * cd * cd * cd + 0x3 * cd * cd + 0x3 * cd + 0x1);
          }
          static['f3'](cd) {
              return 0x1 / 0x6 * cd * cd * cd;
          }
          static['fb'](cd, cq) {
              cq[0x0] = bB['f0'](cd),
              cq[0x1] = bB['f1'](cd),
              cq[0x2] = bB['f2'](cd),
              cq[0x3] = bB['f3'](cd);
          }
          static['tracingStreamline'](cd, cq, cJ, cC, cO, cG) {
              let cg = []
                , cN = cd[0x1]['length']
                , cP = cd['length']
                , cM = []
                , cz = []
                , cQ = cJ[0x1] - cJ[0x0]
                , cm = cC[0x1] - cC[0x0];
              0x0 === cG && (cG = 0x1);
              let cL, cR, H0 = cQ / Math['pow'](cG, 0x2), H1 = 1.5 * H0;
              for (cL = 0x0; cL < cP; cL++)
                  for (cM[cL] = [],
                  cz[cL] = [],
                  cR = 0x0; cR < cN; cR++)
                      if (Math['abs'](cd[cL][cR] / cO - 0x1) < 0.01)
                          cM[cL][cR] = 0.1,
                          cz[cL][cR] = 0.1;
                      else {
                          let H7 = Math['sqrt'](cd[cL][cR] * cd[cL][cR] + cq[cL][cR] * cq[cL][cR]);
                          0x0 === H7 && (H7 = 0x1),
                          cM[cL][cR] = cd[cL][cR] / H7 * cQ / cG,
                          cz[cL][cR] = cq[cL][cR] / H7 * cm / cG;
                      }
              let H2, H3, H4 = [], H5 = [];
              for (cL = 0x0; cL < cP - 0x1; cL++)
                  for (H4[cL] = [],
                  H5[cL] = [],
                  cR = 0x0; cR < cN - 0x1; cR++)
                      H5[cL][cR] = cL % 0x2 == 0x0 && cR % 0x2 == 0x0 ? 0x0 : 0x1,
                      H4[cL][cR] = [];
              let H6 = 0x0;
              for (cL = 0x0; cL < cP - 0x1; cL++)
                  for (cR = 0x0; cR < cN - 0x1; cR++)
                      if (0x0 === H5[cL][cR]) {
                          let H8, H9, Hv, HA = [], Hk = new bE(), Hl = new bV();
                          Hk['X'] = cJ[cR] + cQ / 0x2,
                          Hk['Y'] = cC[cL] + cm / 0x2,
                          HA['push'](Hk['clone']()),
                          H3 = new bf(),
                          H3['Point'] = Hk['clone'](),
                          H3['Id'] = H6,
                          H4[cL][cR]['push'](H3),
                          H5[cL][cR] = 0x1,
                          H8 = cL,
                          H9 = cR;
                          let HK = 0x1f4;
                          for (Hv = 0x0; Hv < HK; ) {
                              let Hb = [];
                              Hb[0x0] = H8,
                              Hb[0x1] = H9;
                              let Hc = bB['tracingStreamlinePoint'](Hk, cM, cz, cJ, cC, Hb, true);
                              if (H8 = Hb[0x0],
                              H9 = Hb[0x1],
                              !Hc)
                                  break;
                              if (Math['abs'](cd[H8][H9] / cO - 0x1) < 0.01 || Math['abs'](cd[H8][H9 + 0x1] / cO - 0x1) < 0.01 || Math['abs'](cd[H8 + 0x1][H9] / cO - 0x1) < 0.01 || Math['abs'](cd[H8 + 0x1][H9 + 0x1] / cO - 0x1) < 0.01)
                                  break;
                              {
                                  let HH = false;
                                  for (let Hx of H4[H8][H9])
                                      if (Math['sqrt']((Hk['X'] - Hx['Point']['X']) * (Hk['X'] - Hx['Point']['X']) + (Hk['Y'] - Hx['Point']['Y']) * (Hk['Y'] - Hx['Point']['Y'])) < H0) {
                                          HH = true;
                                          break;
                                      }
                                  if (!HH && H4[H8][H9]['length'] > 0x1) {
                                      let Hp = H4[H8][H9][0x0]
                                        , HF = H4[H8][H9][0x1];
                                      H6 === Hp['Id'] && H6 === HF['Id'] || (H2 = bB['distance_point2line'](Hp['Point'], HF['Point'], Hk),
                                      H2 < H1 && (HH = true));
                                  }
                                  if (HH)
                                      break;
                                  HA['push'](Hk['clone']()),
                                  H3 = new bf(),
                                  H3['Point'] = Hk['clone'](),
                                  H3['Id'] = H6,
                                  H4[H8][H9]['push'](H3),
                                  H5[H8][H9] = 0x1;
                              }
                              Hv += 0x1;
                          }
                          for (Hk['X'] = cJ[cR] + cQ / 0x2,
                          Hk['Y'] = cC[cL] + cm / 0x2,
                          H8 = cL,
                          H9 = cR,
                          Hv = 0x0; Hv < HK; ) {
                              let Hy = [];
                              Hy[0x0] = H8,
                              Hy[0x1] = H9;
                              let Hw = bB['tracingStreamlinePoint'](Hk, cM, cz, cJ, cC, Hy, false);
                              if (H8 = Hy[0x0],
                              H9 = Hy[0x1],
                              !Hw)
                                  break;
                              if (Math['abs'](cd[H8][H9] / cO - 0x1) < 0.01 || Math['abs'](cd[H8][H9 + 0x1] / cO - 0x1) < 0.01 || Math['abs'](cd[H8 + 0x1][H9] / cO - 0x1) < 0.01 || Math['abs'](cd[H8 + 0x1][H9 + 0x1] / cO - 0x1) < 0.01)
                                  break;
                              {
                                  let Hh = false;
                                  for (let Hu of H4[H8][H9])
                                      if (Math['sqrt']((Hk['X'] - Hu['Point']['X']) * (Hk['X'] - Hu['Point']['X']) + (Hk['Y'] - Hu['Point']['Y']) * (Hk['Y'] - Hu['Point']['Y'])) < H0) {
                                          Hh = true;
                                          break;
                                      }
                                  if (!Hh && H4[H8][H9]['length'] > 0x1) {
                                      let HY = H4[H8][H9][0x0]
                                        , HT = H4[H8][H9][0x1];
                                      H6 === HY['Id'] && H6 === HT['Id'] || (H2 = bB['distance_point2line'](HY['Point'], HT['Point'], Hk),
                                      H2 < H1 && (Hh = true));
                                  }
                                  if (Hh)
                                      break;
                                  HA['splice'](0x0, 0x0, Hk['clone']()),
                                  H3 = new bf(),
                                  H3['Point'] = Hk['clone'](),
                                  H3['Id'] = H6,
                                  H4[H8][H9]['push'](H3),
                                  H5[H8][H9] = 0x1;
                              }
                              Hv += 0x1;
                          }
                          HA['length'] > 0x1 && (Hl['PointList'] = HA,
                          cg['push'](Hl),
                          H6 += 0x1);
                      }
              return cg;
          }
          static['tracingStreamlinePoint'](cd, cq, cJ, cC, cO, cG, cg) {
              let cN, cP, cM, cz, cQ, cm, cL, cR, H0 = cC['length'], H1 = cO['length'], H2 = cC[0x1] - cC[0x0], H3 = cO[0x1] - cO[0x0], H4 = cG[0x0], H5 = cG[0x1];
              if (cN = cq[H4][H5],
              cP = cq[H4][H5 + 0x1],
              cM = cq[H4 + 0x1][H5],
              cz = cq[H4 + 0x1][H5 + 0x1],
              cQ = cN + (cM - cN) * ((cd['Y'] - cO[H4]) / H3),
              cm = cP + (cz - cP) * ((cd['Y'] - cO[H4]) / H3),
              cL = cQ + (cm - cQ) * ((cd['X'] - cC[H5]) / H2),
              cN = cJ[H4][H5],
              cP = cJ[H4][H5 + 0x1],
              cM = cJ[H4 + 0x1][H5],
              cz = cJ[H4 + 0x1][H5 + 0x1],
              cQ = cN + (cM - cN) * ((cd['Y'] - cO[H4]) / H3),
              cm = cP + (cz - cP) * ((cd['Y'] - cO[H4]) / H3),
              cR = cQ + (cm - cQ) * ((cd['X'] - cC[H5]) / H2),
              cg ? (cd['X'] += cL,
              cd['Y'] += cR) : (cd['X'] -= cL,
              cd['Y'] -= cR),
              !(cd['X'] >= cC[H5] && cd['X'] <= cC[H5 + 0x1] && cd['Y'] >= cO[H4] && cd['Y'] <= cO[H4 + 0x1])) {
                  if (cd['X'] < cC[0x0] || cd['X'] > cC[cC['length'] - 0x1] || cd['Y'] < cO[0x0] || cd['Y'] > cO[cO['length'] - 0x1])
                      return false;
                  for (let H6 = H4 - 0x2; H6 < H4 + 0x3; H6++)
                      if (H6 >= 0x0 && H6 < H1 && cd['Y'] >= cO[H6] && cd['Y'] <= cO[H6 + 0x1]) {
                          H4 = H6;
                          for (let H7 = H5 - 0x2; H7 < H5 + 0x3; H7++)
                              if (H7 >= 0x0 && H7 < H0 && cd['X'] >= cC[H7] && cd['X'] <= cC[H7 + 0x1]) {
                                  H5 = H7;
                                  break;
                              }
                          break;
                      }
              }
              return cG[0x0] = H4,
              cG[0x1] = H5,
              true;
          }
          static['distance_point2line'](cd, cq, cJ) {
              let cC = (cq['Y'] - cd['Y']) / (cq['X'] - cd['X'])
                , cO = (cC * cC * cd['X'] + cC * (cJ['Y'] - cd['Y']) + cJ['X']) / (cC * cC + 0x1)
                , cG = cC * (cO - cd['X']) + cd['Y'];
              return Math['sqrt']((cJ['Y'] - cG) * (cJ['Y'] - cG) + (cJ['X'] - cO) * (cJ['X'] - cO));
          }
          static['getExtent'](cd) {
              let cq, cJ, cC, cO, cG, cg = cd[0x0];
              for (cq = cg['X'],
              cC = cg['X'],
              cJ = cg['Y'],
              cO = cg['Y'],
              cG = 0x1; cG < cd['length']; cG++)
                  cg = cd[cG],
                  cg['X'] < cq && (cq = cg['X']),
                  cg['X'] > cC && (cC = cg['X']),
                  cg['Y'] < cJ && (cJ = cg['Y']),
                  cg['Y'] > cO && (cO = cg['Y']);
              let cN = new bT();
              return cN['xMin'] = cq,
              cN['yMin'] = cJ,
              cN['xMax'] = cC,
              cN['yMax'] = cO,
              cN;
          }
          static['getExtentAndArea'](cd, cq) {
              let cJ, cC, cO, cG, cg, cN, cP = cd[0x0];
              for (cC = cP['X'],
              cG = cP['X'],
              cO = cP['Y'],
              cg = cP['Y'],
              cN = 0x1; cN < cd['length']; cN++)
                  cP = cd[cN],
                  cP['X'] < cC && (cC = cP['X']),
                  cP['X'] > cG && (cG = cP['X']),
                  cP['Y'] < cO && (cO = cP['Y']),
                  cP['Y'] > cg && (cg = cP['Y']);
              return cq['xMin'] = cC,
              cq['yMin'] = cO,
              cq['xMax'] = cG,
              cq['yMax'] = cg,
              cJ = (cG - cC) * (cg - cO),
              cJ;
          }
          static['isClockwise'](cd) {
              let cq, cJ, cC, cO, cG, cg, cN, cP, cM = 0x0, cz = 0x0;
              for (cq = 0x0; cq < cd['length'] - 0x1; cq++)
                  cJ = cd[cq],
                  0x0 === cq ? (cM = cJ['Y'],
                  cz = 0x0) : cM < cJ['Y'] && (cM = cJ['Y'],
                  cz = cq);
              return cg = cz - 0x1,
              cN = cz,
              cP = cz + 0x1,
              0x0 === cz && (cg = cd['length'] - 0x2),
              cC = cd[cg],
              cO = cd[cN],
              cG = cd[cP],
              (cG['X'] - cC['X']) * (cO['Y'] - cC['Y']) - (cO['X'] - cC['X']) * (cG['Y'] - cC['Y']) > 0x0;
          }
          static['isLineSegmentCross'](cd, cq) {
              let cJ = new bT()
                , cC = new bT()
                , cO = []
                , cG = [];
              return cO['push'](cd['P1']),
              cO['push'](cd['P2']),
              cG['push'](cq['P1']),
              cG['push'](cq['P2']),
              bB['getExtentAndArea'](cO, cJ),
              bB['getExtentAndArea'](cG, cC),
              !!bB['isExtentCross'](cJ, cC) && !(((cq['P1']['X'] - cd['P1']['X']) * (cd['P2']['Y'] - cd['P1']['Y']) - (cd['P2']['X'] - cd['P1']['X']) * (cq['P1']['Y'] - cd['P1']['Y'])) * ((cq['P2']['X'] - cd['P1']['X']) * (cd['P2']['Y'] - cd['P1']['Y']) - (cd['P2']['X'] - cd['P1']['X']) * (cq['P2']['Y'] - cd['P1']['Y'])) > 0x0);
          }
          static['isExtentCross'](cd, cq) {
              return !(cd['xMin'] > cq['xMax'] || cd['xMax'] < cq['xMin'] || cd['yMin'] > cq['yMax'] || cd['yMax'] < cq['yMin']);
          }
          static['getCrossPointF'](cd, cq, cJ, cC) {
              let cO, cG, cg, cN, cP, cM, cz = new bD(0x0,0x0), cQ = (cJ['X'] - cd['X']) * (cq['Y'] - cd['Y']) - (cq['X'] - cd['X']) * (cJ['Y'] - cd['Y']), cm = (cC['X'] - cd['X']) * (cq['Y'] - cd['Y']) - (cq['X'] - cd['X']) * (cC['Y'] - cd['Y']);
              return 0x0 === cQ ? cz = cJ : 0x0 === cm ? cz = cC : (cO = cd,
              cG = cq,
              cg = cJ,
              cN = cC,
              cP = (cN['X'] - cg['X']) * (cO['Y'] - cG['Y']) - (cG['X'] - cO['X']) * (cg['Y'] - cN['Y']),
              cM = (cO['Y'] - cg['Y']) * (cG['X'] - cO['X']) * (cN['X'] - cg['X']) + cg['X'] * (cN['Y'] - cg['Y']) * (cG['X'] - cO['X']) - cO['X'] * (cG['Y'] - cO['Y']) * (cN['X'] - cg['X']),
              cz['X'] = cM / cP,
              cP = (cO['X'] - cG['X']) * (cN['Y'] - cg['Y']) - (cG['Y'] - cO['Y']) * (cg['X'] - cN['X']),
              cM = cG['Y'] * (cO['X'] - cG['X']) * (cN['Y'] - cg['Y']) + (cN['X'] - cG['X']) * (cN['Y'] - cg['Y']) * (cO['Y'] - cG['Y']) - cN['Y'] * (cg['X'] - cN['X']) * (cG['Y'] - cO['Y']),
              cz['Y'] = cM / cP),
              cz;
          }
          static['getCrossPointD'](cd, cq) {
              let cJ, cC, cO, cG, cg, cN, cP = new bE(), cM = (cq['P1']['X'] - cd['P1']['X']) * (cd['P2']['Y'] - cd['P1']['Y']) - (cd['P2']['X'] - cd['P1']['X']) * (cq['P1']['Y'] - cd['P1']['Y']), cz = (cq['P2']['X'] - cd['P1']['X']) * (cd['P2']['Y'] - cd['P1']['Y']) - (cd['P2']['X'] - cd['P1']['X']) * (cq['P2']['Y'] - cd['P1']['Y']);
              return 0x0 === cM ? cP = cq['P1'] : 0x0 === cz ? cP = cq['P2'] : (cJ = cd['P1'],
              cC = cd['P2'],
              cO = cq['P1'],
              cG = cq['P2'],
              cg = (cG['X'] - cO['X']) * (cJ['Y'] - cC['Y']) - (cC['X'] - cJ['X']) * (cO['Y'] - cG['Y']),
              cN = (cJ['Y'] - cO['Y']) * (cC['X'] - cJ['X']) * (cG['X'] - cO['X']) + cO['X'] * (cG['Y'] - cO['Y']) * (cC['X'] - cJ['X']) - cJ['X'] * (cC['Y'] - cJ['Y']) * (cG['X'] - cO['X']),
              cP['X'] = cN / cg,
              cg = (cJ['X'] - cC['X']) * (cG['Y'] - cO['Y']) - (cC['Y'] - cJ['Y']) * (cO['X'] - cG['X']),
              cN = cC['Y'] * (cJ['X'] - cC['X']) * (cG['Y'] - cO['Y']) + (cG['X'] - cC['X']) * (cG['Y'] - cO['Y']) * (cJ['Y'] - cC['Y']) - cG['Y'] * (cO['X'] - cG['X']) * (cC['Y'] - cJ['Y']),
              cP['Y'] = cN / cg),
              cP;
          }
          static['insertPoint2Border'](cd, cq) {
              let cJ, cC, cO, cG, cg, cN, cP, cM = [];
              for (bB['addAll'](cq, cM),
              cO = 0x0; cO < cd['length']; cO++)
                  for (cC = cd[cO],
                  cP = cC['Point'],
                  cJ = cM[0x0],
                  cg = cJ['Point'],
                  cG = 0x1; cG < cM['length']; cG++) {
                      if (cJ = cM[cG],
                      cN = cJ['Point'],
                      (cP['X'] - cg['X']) * (cP['X'] - cN['X']) <= 0x0 && (cP['Y'] - cg['Y']) * (cP['Y'] - cN['Y']) <= 0x0 && (cP['X'] - cg['X']) * (cN['Y'] - cg['Y']) - (cN['X'] - cg['X']) * (cP['Y'] - cg['Y']) == 0x0) {
                          cM['splice'](cG, 0x0, cC);
                          break;
                      }
                      cg = cN;
                  }
              return cM;
          }
          static['insertPoint2RectangleBorder'](cd, cq) {
              let cJ, cC, cO, cG, cg, cN, cP, cM, cz, cQ = [], cm = [], cL = [], cR = [], H0 = [];
              for (cg = 0x0; cg < cd['length']; cg++)
                  if (cO = cd[cg],
                  'Close' !== cO['Type']) {
                      for (cM = [],
                      bB['addAll'](cO['PointList'], cM),
                      cC = new bf(),
                      cC['Id'] = cg,
                      cP = 0x0; cP <= 0x1; cP++)
                          if (cG = 0x0 === cP ? cM[0x0] : cM[cM['length'] - 0x1],
                          cC['Point'] = cG,
                          cz = false,
                          cG['X'] === cq['xMin']) {
                              for (cN = 0x0; cN < cQ['length']; cN++)
                                  if (cJ = cQ[cN],
                                  cG['Y'] < cJ['Point']['Y']) {
                                      cQ['splice'](cN, 0x0, cC),
                                      cz = true;
                                      break;
                                  }
                              cz || cQ['push'](cC);
                          } else {
                              if (cG['X'] === cq['xMax']) {
                                  for (cN = 0x0; cN < cL['length']; cN++)
                                      if (cJ = cL[cN],
                                      cG['Y'] > cJ['Point']['Y']) {
                                          cL['splice'](cN, 0x0, cC),
                                          cz = true;
                                          break;
                                      }
                                  cz || cL['push'](cC);
                              } else {
                                  if (cG['Y'] === cq['yMin']) {
                                      for (cN = 0x0; cN < cR['length']; cN++)
                                          if (cJ = cR[cN],
                                          cG['X'] > cJ['Point']['X']) {
                                              cR['splice'](cN, 0x0, cC),
                                              cz = true;
                                              break;
                                          }
                                      cz || cR['push'](cC);
                                  } else {
                                      if (cG['Y'] === cq['yMax']) {
                                          for (cN = 0x0; cN < cm['length']; cN++)
                                              if (cJ = cm[cN],
                                              cG['X'] < cJ['Point']['X']) {
                                                  cm['splice'](cN, 0x0, cC),
                                                  cz = true;
                                                  break;
                                              }
                                          cz || cm['push'](cC);
                                      }
                                  }
                              }
                          }
                  }
              return cC = new bf(),
              cC['Id'] = -0x1,
              cG = new bE(),
              cG['X'] = cq['xMin'],
              cG['Y'] = cq['yMin'],
              cC['Point'] = cG,
              H0['push'](cC),
              bB['addAll'](cQ, H0),
              cC = new bf(),
              cC['Id'] = -0x1,
              cG = new bE(),
              cG['X'] = cq['xMin'],
              cG['Y'] = cq['yMax'],
              cC['Point'] = cG,
              H0['push'](cC),
              bB['addAll'](cm, H0),
              cC = new bf(),
              cC['Id'] = -0x1,
              cG = new bE(),
              cG['X'] = cq['xMax'],
              cG['Y'] = cq['yMax'],
              cC['Point'] = cG,
              H0['push'](cC),
              bB['addAll'](cL, H0),
              cC = new bf(),
              cC['Id'] = -0x1,
              cG = new bE(),
              cG['X'] = cq['xMax'],
              cG['Y'] = cq['yMin'],
              cC['Point'] = cG,
              H0['push'](cC),
              bB['addAll'](cR, H0),
              H0['push'](H0[0x0]),
              H0;
          }
          static['insertEndPoint2Border'](cd, cq) {
              let cJ, cC, cO, cG, cg, cN, cP, cM, cz, cQ, cm, cL = [], cR = [], H0 = [];
              for (cM = [],
              bB['addAll'](cd, cM),
              cJ = cq[0x0],
              cN = cJ['Point'],
              H0['push'](cJ),
              cO = 0x1; cO < cq['length']; cO++) {
                  for (cJ = cq[cO],
                  cP = cJ['Point'],
                  cL = [],
                  cG = 0x0; cG < cM['length'] && cG !== cM['length']; cG++)
                      cz = cM[cG],
                      Math['abs'](cz['sPoint']['X'] - cN['X']) < 0.000001 && Math['abs'](cz['sPoint']['Y'] - cN['Y']) < 0.000001 && (cL['push'](cz),
                      cM['splice'](cG, 0x1),
                      cG -= 0x1);
                  if (cL['length'] > 0x0) {
                      if (cR = [],
                      cL['length'] > 0x1) {
                          for (cG = 0x0; cG < cL['length']; cG++)
                              if (cz = cL[cG],
                              cQ = Math['pow'](cz['Point']['X'] - cN['X'], 0x2) + Math['pow'](cz['Point']['Y'] - cN['Y'], 0x2),
                              0x0 === cG)
                                  cR['push']([cQ, cG]);
                              else {
                                  for (cm = false,
                                  cg = 0x0; cg < cR['length']; cg++)
                                      if (cQ < parseFloat(cR[cg][0x0])) {
                                          cR['splice'](cg, 0x0, [cQ, cG]),
                                          cm = true;
                                          break;
                                      }
                                  cm || cR['push']([cQ, cG]);
                              }
                          for (cG = 0x0; cG < cR['length']; cG++)
                              cz = cL[parseInt(cR[cG][0x1])],
                              cC = new bf(),
                              cC['Id'] = cz['Index'],
                              cC['Point'] = cz['Point'],
                              H0['push'](cC);
                      } else
                          cz = cL[0x0],
                          cC = new bf(),
                          cC['Id'] = cz['Index'],
                          cC['Point'] = cz['Point'],
                          H0['push'](cC);
                  }
                  H0['push'](cJ),
                  cN = cP;
              }
              return H0;
          }
          static['insertPoint2Border_Ring'](cd, cq, cJ, cC) {
              let cO, cG, cg, cN, cP, cM, cz, cQ, cm, cL = [], cR = [], H0 = [];
              for (cP = 0x0; cP < cJ['getLineNum'](); cP++) {
                  for (cm = cJ['LineList'][cP],
                  cR = [],
                  cg = 0x0; cg < cm['pointList']['length']; cg++)
                      cO = new bf(),
                      cO['Id'] = -0x1,
                      cO['BorderIdx'] = cP,
                      cO['Point'] = cm['pointList'][cg],
                      cO['Value'] = cd[cm['ijPointList'][cg]['I']][cm['ijPointList'][cg]['J']],
                      cR['push'](cO);
                  for (cg = 0x0; cg < cq['length']; cg++)
                      for (cG = cq[cg]['clone'](),
                      cG['BorderIdx'] = cP,
                      cQ = cG['Point'],
                      cM = cR[0x0]['Point']['clone'](),
                      cN = 0x1; cN < cR['length']; cN++) {
                          if (cz = cR[cN]['Point']['clone'](),
                          (cQ['X'] - cM['X']) * (cQ['X'] - cz['X']) <= 0x0 && (cQ['Y'] - cM['Y']) * (cQ['Y'] - cz['Y']) <= 0x0 && (cQ['X'] - cM['X']) * (cz['Y'] - cM['Y']) - (cz['X'] - cM['X']) * (cQ['Y'] - cM['Y']) == 0x0) {
                              cR['splice'](cN, 0x0, cG);
                              break;
                          }
                          cM = cz;
                      }
                  for (H0 = [],
                  cg = 0x0; cg < cR['length']; cg++)
                      cG = cR[cg],
                      cG['BInnerIdx'] = cg,
                      H0['push'](cG);
                  cC[cP] = H0['length'],
                  bB['addAll'](H0, cL);
              }
              return cL;
          }
          static['doubleEquals'](cd, cq) {
              let cJ = Math['abs'](0.00001 * cd);
              return Math['abs'](cd - cq) <= cJ;
          }
      }
      bB['_endPointList'] = [];
      var bS = function(cd, cq, cJ, cC) {
          return new (cJ || (cJ = Promise))(function(cO, cG) {
              function cg(cM) {
                  try {
                      cP(cC['next'](cM));
                  } catch (cz) {
                      cG(cz);
                  }
              }
              function cN(cM) {
                  try {
                      cP(cC['throw'](cM));
                  } catch (cz) {
                      cG(cz);
                  }
              }
              function cP(cM) {
                  var cz;
                  cM['done'] ? cO(cM['value']) : (cz = cM['value'],
                  cz instanceof cJ ? cz : new cJ(function(cQ) {
                      cQ(cz);
                  }
                  ))['then'](cg, cN);
              }
              cP((cC = cC['apply'](cd, cq || []))['next']());
          }
          );
      };
      let bU, bd = null, bq = 0x0;
      function bJ(cd, cq) {
          const cJ = cq(0x8 * cd['length']);
          return (null !== bd && bd['buffer'] === bU['memory']['buffer'] || (bd = new Float64Array(bU['memory']['buffer'])),
          bd)['set'](cd, cJ / 0x8),
          bq = cd['length'],
          cJ;
      }
      let bC = null;
      function bO() {
          return null !== bC && bC['buffer'] === bU['memory']['buffer'] || (bC = new Int32Array(bU['memory']['buffer'])),
          bC;
      }
      const bG = new TextDecoder('utf-8',{
          'ignoreBOM': true,
          'fatal': true
      });
      bG['decode']();
      let bg = null;
      function bN(cd, cq) {
          return bG['decode']((null !== bg && bg['buffer'] === bU['memory']['buffer'] || (bg = new Uint8Array(bU['memory']['buffer'])),
          bg)['subarray'](cd, cd + cq));
      }
      let bP = null;
      function bM() {
          return null !== bP && bP['buffer'] === bU['memory']['buffer'] || (bP = new Float32Array(bU['memory']['buffer'])),
          bP;
      }
      function bz(cd, cq) {
          const cJ = cq(0x4 * cd['length']);
          return bM()['set'](cd, cJ / 0x4),
          bq = cd['length'],
          cJ;
      }
      function bQ(cd) {
          return bS(this, undefined, undefined, function*() {
              if (bU)
                  return v0['kg']['debug']('wasm\x20contour\x20already\x20intialized'),
                  bU;
              ('string' == typeof (cd = null != cd ? cd : Kg['v']['wasmPath'] + '/qe_lib_bg.wasm') || 'function' == typeof Request && cd instanceof Request || 'function' == typeof URL && cd instanceof URL) && (cd = yield fetch(cd)['catch'](cC=>{
                  v0['kg']['error']('load\x20contour\x20wasm\x20failed\x20from\x20' + cd);
              }
              ));
              const {instance: cq, module: cJ} = yield function(cC, cO) {
                  return bS(this, undefined, undefined, function*() {
                      if (v0['kg']['debug']('load\x20wasm'),
                      'function' == typeof Response && cC instanceof Response) {
                          const cG = yield cC['arrayBuffer']();
                          return yield WebAssembly['instantiate'](cG, cO);
                      }
                      {
                          const cg = yield WebAssembly['instantiate'](cC, cO);
                          return cg instanceof WebAssembly['Instance'] ? {
                              'instance': cg,
                              'module': cC
                          } : cg;
                      }
                  });
              }(cd, {});
              return bU = cq['exports'],
              bQ['__wbindgen_wasm_module'] = cJ,
              bU;
          });
      }
      var bm = function(cd, cq, cJ, cC) {
          return new (cJ || (cJ = Promise))(function(cO, cG) {
              function cg(cM) {
                  try {
                      cP(cC['next'](cM));
                  } catch (cz) {
                      cG(cz);
                  }
              }
              function cN(cM) {
                  try {
                      cP(cC['throw'](cM));
                  } catch (cz) {
                      cG(cz);
                  }
              }
              function cP(cM) {
                  var cz;
                  cM['done'] ? cO(cM['value']) : (cz = cM['value'],
                  cz instanceof cJ ? cz : new cJ(function(cQ) {
                      cQ(cz);
                  }
                  ))['then'](cg, cN);
              }
              cP((cC = cC['apply'](cd, cq || []))['next']());
          }
          );
      };
      class bL {
          static['createDefaultColorStops'](cd, cq, cJ) {
              const cC = JSON['parse'](JSON['stringify'](bL['DefaultColorStopOptions']));
              cC['fieldName'] = (0x0,
              Kz['En'])(cq, cC['fieldName']);
              const cO = cd['length'] + 0x1
                , cG = cC['stops']['length'];
              if (cO <= cG) {
                  for (let cR = 0x0; cR <= cd['length']; cR++)
                      cC['stops'][cR]['value'] = cd[cR];
                  return cC['stops']['length'] > cd['length'] + 0x1 && (cC['stops'][cd['length'] + 0x1]['value'] = (0x0,
                  Kz['En'])(cJ, Kg['v']['defaultUndef'])),
                  cC['stops']['splice'](cO),
                  cC;
              }
              const cg = cG - 0x1
                , cN = cO - cG
                , cP = parseInt(cN / cg)
                , cM = cN - cP * (cg - 0x1)
                , cz = {
                  'stops': [],
                  'fieldName': cC['fieldName']
              };
              let cQ = 0x0;
              const cm = (H0,H1,H2,H3)=>{
                  const H4 = (H3 + 0x1) / (H2 + 0x1) * 0x64;
                  return H0['mix'](H1, H4);
              }
              ;
              let cL = null;
              for (let H0 = 0x0; H0 < cg; H0++) {
                  cL = cL || new id['t'](cC['stops'][H0]['stop']),
                  cz['stops']['push']({
                      'value': cd[cQ++],
                      'stop': cL
                  });
                  const H1 = H0 === cC['stops']['length'] - 0x2 ? cP : cM
                    , H2 = new id['t'](cC['stops'][H0 + 0x1]['stop']);
                  for (let H3 = 0x0; H3 < H1; H3++)
                      cz['stops']['push']({
                          'value': cd[cQ++],
                          'stop': cm(cL, H2, H1, H3)
                      });
                  cL = H2;
              }
              return cz['stops']['push']({
                  'value': (0x0,
                  Kz['En'])(cJ, Kg['v']['defaultUndef']),
                  'stop': 'rgba(0,0,0,0)'
              }),
              cz;
          }
          constructor(cd) {
              this['options'] = {},
              (0x0,
              Kz['Ov'])(this['options'], cd);
          }
          ['getFeatureOfPoints'](cd, cq, cJ, cC, cO) {
              cq = cq || 'value';
              const cG = [];
              for (let cM of cJ['PointList'])
                  cG['push']([cM['X'], cM['Y']]);
              let cg, cN = cJ['Value'];
              if ('LineString' === cd)
                  cg = {
                      'type': 'LineString',
                      'coordinates': cG
                  };
              else {
                  if (cg = {
                      'type': 'Polygon',
                      'coordinates': [cG]
                  },
                  cO && cC) {
                      if (cO['IsHighCenter']) {
                          const cz = cC['indexOf'](cO['LowValue']);
                          cN = cz >= 0x0 && cz < cC['length'] - 0x1 ? cC[cz + 0x1] : cO['HighValue'];
                      } else
                          cN = cO['LowValue'];
                      if (cO['HasHoles']())
                          for (let cQ = 0x0; cQ < cO['HoleLines']['length']; cQ++) {
                              const cm = cO['HoleLines'][cQ]
                                , cL = [];
                              for (let cR of cm['PointList'])
                                  cL['push']([cR['X'], cR['Y']]);
                              cg['coordinates']['push'](cL);
                          }
                  }
              }
              let cP = {
                  'id': cJ['BorderIdx']
              };
              return cP[cq] = cN,
              {
                  'type': 'Feature',
                  'geometry': cg,
                  'properties': cP
              };
          }
          ['traceShaded'](cd, cq, cJ, cC, cO) {
              let cG = bB['tracingPolygons'](cJ, cd['contourlines'], cd['borders'], cq);
              for (let cg of cG) {
                  let cN = cg['OutLine']
                    , cP = this['getFeatureOfPoints']('Polygon', cO, cN, cq, cg);
                  cC['push'](cP);
              }
              return {
                  'type': 'FeatureCollection',
                  'features': cC
              };
          }
          ['traceShadedWithContourResult'](cd) {
              const cq = this['traceShaded'](cd['contourInfo'], cd['analysisValues'], cd['dataSource']['getGrid']()['getYxArr'](), [], cd['valueFieldName'])
                , cJ = new GeoJSONFeatureProvider(cq);
              let cC = cd['drawOptions'];
              return cC || (cC = {
                  'polygon': {
                      'color': bL['createDefaultColorStops'](cd['analysisValues'], cd['valueFieldName'])
                  }
              }),
              this['options']['layerCreator'] && this['options']['layerCreator'](cd['layerOptions'], cJ, cC);
          }
          ['tracingContourShaded'](cd) {
              if (!cd || !cd['dataSource'])
                  return;
              const cq = cd['dataSource']['getGrid']();
              let cJ = (0x0,
              Kz['En'])(cd['undef'], cq['undef']);
              undefined === cJ && (v0['kg']['warn']('' + Kg['v']['defaultUndef']),
              cJ = Kg['v']['defaultUndef']),
              (0x0,
              KM['T'])(cd['dataSource']['gridOptions']);
              const cC = bu['createGridXY_Delt'](cd['dataSource']['gridOptions']['xStart'], cd['dataSource']['gridOptions']['yStart'], cd['dataSource']['gridOptions']['xEnd'], cd['dataSource']['gridOptions']['yEnd'], cd['dataSource']['gridOptions']['xDelta'], cd['dataSource']['gridOptions']['yDelta'])
                , cO = cq['getYxArr']()
                , cG = []
                , cg = bB['tracingBorders'](cO, cC[0x0], cC[0x1], cG, cJ);
              let cN = bB['tracingContourLines'](cO, cC[0x0], cC[0x1], cd['analysisValues']['length'], cd['analysisValues'], cJ, cg, cG);
              cN = bB['smoothLines'](cN);
              let cP = [];
              for (let cR of cN) {
                  let H0 = this['getFeatureOfPoints']('LineString', cd['valueFieldName'], cR);
                  cP['push'](H0);
              }
              const cM = {
                  'type': 'FeatureCollection',
                  'features': cP
              };
              let cz = cd['drawOptions'];
              cz ? ('string' == typeof cz && (cz = iz['Zc']['getResource'](cz),
              cz || v0['kg']['error']('' + cz + '')),
              cz['polyline'] = (0x0,
              Kz['En'])(cz['polyline'], JSON['parse'](JSON['stringify'](bL['DefaultContourShadedStyle']['polyline']))),
              cz['polygon'] = (0x0,
              Kz['En'])(cz['polygon'], {
                  'color': bL['createDefaultColorStops'](cd['analysisValues'], cd['valueFieldName'])
              })) : cz = {
                  'polyline': Object['assign']({}, JSON['parse'](JSON['stringify'](bL['DefaultContourShadedStyle']['polyline']))),
                  'polygon': {
                      'color': bL['createDefaultColorStops'](cd['analysisValues'], cd['valueFieldName'])
                  }
              };
              const cQ = {
                  'contourlines': cN,
                  'borders': cg,
                  'layer': undefined,
                  'dataSource': undefined,
                  'drawOptions': cz
              };
              cd['withShaded'] && this['traceShaded'](cQ, cd['analysisValues'], cO, cP, cd['valueFieldName']);
              const cm = new GeoJSONFeatureProvider(cM);
              cQ['dataSource'] = cm;
              const cL = this['options']['layerCreator'] && this['options']['layerCreator'](cd['layerOptions'], cm, cz);
              return cQ['layer'] = cL,
              cd['reserveTracingInfo'] ? cQ : {
                  'layer': cL
              };
          }
          ['tracingContourShadedWASM'](cd) {
              var cq, cJ, cC, cO;
              return bm(this, undefined, undefined, function*() {
                  if (!cd || !cd['dataSource'])
                      return;
                  const cG = cd['dataSource']
                    , cg = cG['gridOptions'];
                  yield bQ();
                  const cN = JSON['parse'](cd['withShaded'] ? function(cm, cL, cR, H0, H1, H2, H3, H4, H5) {
                      try {
                          const H8 = bU['__wbindgen_add_to_stack_pointer'](-0x10)
                            , H9 = bJ(cm, bU['__wbindgen_malloc'])
                            , Hv = bq
                            , HA = bJ(cL, bU['__wbindgen_malloc'])
                            , Hk = bq;
                          bU['make_contours_lonlat'](H8, H9, Hv, HA, Hk, cR, H0, H1, H2, H3, H4, H5);
                          var H6 = bO()[H8 / 0x4 + 0x0]
                            , H7 = bO()[H8 / 0x4 + 0x1];
                          return bN(H6, H7);
                      } finally {
                          bU['__wbindgen_add_to_stack_pointer'](0x10),
                          bU['__wbindgen_free'](H6, H7);
                      }
                  }(cG['getGrid']()['toNumberArr'](), cd['analysisValues'], cG['getGrid']()['xSize'], cG['getGrid']()['ySize'], cg['xStart'], cg['xDelta'], cg['yStart'], cg['yDelta'], null !== (cJ = null !== (cq = cd['undef']) && undefined !== cq ? cq : cG['getGrid']()['undef']) && undefined !== cJ ? cJ : Kg['v']['defaultUndef']) : function(cm, cL, cR, H0, H1, H2, H3, H4, H5) {
                      try {
                          const H8 = bU['__wbindgen_add_to_stack_pointer'](-0x10)
                            , H9 = bJ(cm, bU['__wbindgen_malloc'])
                            , Hv = bq
                            , HA = bJ(cL, bU['__wbindgen_malloc'])
                            , Hk = bq;
                          bU['make_contour_rings_lonlat'](H8, H9, Hv, HA, Hk, cR, H0, H1, H2, H3, H4, H5);
                          var H6 = bO()[H8 / 0x4 + 0x0]
                            , H7 = bO()[H8 / 0x4 + 0x1];
                          return bN(H6, H7);
                      } finally {
                          bU['__wbindgen_add_to_stack_pointer'](0x10),
                          bU['__wbindgen_free'](H6, H7);
                      }
                  }(cG['getGrid']()['toNumberArr'](), cd['analysisValues'], cG['getGrid']()['xSize'], cG['getGrid']()['ySize'], cg['xStart'], cg['xDelta'], cg['yStart'], cg['yDelta'], null !== (cO = null !== (cC = cd['undef']) && undefined !== cC ? cC : cG['getGrid']()['undef']) && undefined !== cO ? cO : Kg['v']['defaultUndef']))
                    , cP = new GeoJSONFeatureProvider(cN);
                  let cM = cd['drawOptions'];
                  cM ? 'string' == typeof cM && (cM = iz['Zc']['getResource'](cM),
                  cM || v0['kg']['error']('' + cM + '')) : cM = {
                      'polyline': Object['assign']({}, JSON['parse'](JSON['stringify'](bL['DefaultContourShadedStyle']['polyline']))),
                      'polygon': {
                          'color': bL['createDefaultColorStops'](cd['analysisValues'], cd['valueFieldName'])
                      }
                  };
                  const cz = this['options']['layerCreator'] && this['options']['layerCreator'](cd['layerOptions'], cP, cM)
                    , cQ = {
                      'contourlines': cN,
                      'layer': cz,
                      'dataSource': cP,
                      'drawOptions': cM
                  };
                  return cd['reserveTracingInfo'] ? cQ : {
                      'layer': cz
                  };
              });
          }
          static['interpToGridWASM'](cd, cq, cJ, cC) {
              return bm(this, undefined, undefined, function*() {
                  const cO = performance['now']();
                  cC = (0x0,
                  Kz['En'])(cC, Kg['v']['defaultUndef']);
                  const cG = cq['getFeatures']();
                  if (!cG || 0x0 === cG['features']['length'])
                      return;
                  const cg = [];
                  if (bw(cG, (cQ,cm)=>{
                      if ('Point' !== cQ['geometry']['type'])
                          return;
                      let cL = parseFloat(cQ['properties'][cJ]);
                      if ('number' != typeof cL || isNaN(cL) || cL > 0x15f90)
                          return;
                      let cR = cQ['geometry'];
                      cg['push'](parseFloat(cR['coordinates'][0x0]), parseFloat(cR['coordinates'][0x1]), cL);
                  }
                  ),
                  (0x0,
                  KM['T'])(cd),
                  (cg['length'] > 0xf ? 0x5 : cg['length'] / 0x3 - 0x1) <= 0x0)
                      return void v0['kg']['error']('');
                  let cN = new Float32Array(cd['xSize'] * cd['ySize']);
                  cN['fill'](cC);
                  const cP = new Float32Array(cd['xSize']);
                  cP['forEach']((cQ,cm)=>{
                      cP[cm] = cd['xStart'] + cd['xDelta'] * cm;
                  }
                  );
                  const cM = new Float32Array(cd['ySize']);
                  cM['forEach']((cQ,cm)=>{
                      cM[cm] = cd['yStart'] + cd['yDelta'] * cm;
                  }
                  ),
                  cN = function(cQ, cm, cL, cR) {
                      try {
                          const H5 = bU['__wbindgen_add_to_stack_pointer'](-0x10)
                            , H6 = bz(cQ, bU['__wbindgen_malloc'])
                            , H7 = bq
                            , H8 = bz(cm, bU['__wbindgen_malloc'])
                            , H9 = bq
                            , Hv = bz(cL, bU['__wbindgen_malloc'])
                            , HA = bq;
                          bU['interp_idw'](H5, H6, H7, H8, H9, Hv, HA, cR);
                          var H0 = bO()[H5 / 0x4 + 0x0]
                            , H1 = bO()[H5 / 0x4 + 0x1]
                            , H2 = (H3 = H0,
                          H4 = H1,
                          bM()['subarray'](H3 / 0x4, H3 / 0x4 + H4))['slice']();
                          return bU['__wbindgen_free'](H0, 0x4 * H1),
                          H2;
                      } finally {
                          bU['__wbindgen_add_to_stack_pointer'](0x10);
                      }
                      var H3, H4;
                  }(new Float32Array(cg), cP, cM, 0x4);
                  const cz = new KN['P'](KP['U']['Float32'],cd['xSize'],cd['ySize'],cN['buffer'],cC);
                  return v0['kg']['debug']('interp\x20costs\x20' + (performance['now']() - cO) + 'ms'),
                  new iu['o']([[cz]],{
                      'gridOptions': cd
                  });
              });
          }
          static['interpToGridProvider'](cd, cq, cJ, cC) {
              const cO = performance['now']();
              (0x0,
              KM['T'])(cd);
              const cG = new Float32Array(cd['xSize']);
              cG['forEach']((cL,cR)=>{
                  cG[cR] = cd['xStart'] + cd['xDelta'] * cR;
              }
              );
              const cg = new Float32Array(cd['ySize']);
              cg['forEach']((cL,cR)=>{
                  cg[cR] = cd['yStart'] + cd['yDelta'] * cR;
              }
              );
              let cN = new Float32Array(cd['xSize'] * cd['ySize']);
              cN['fill'](cC);
              const cP = cq['getFeatures']();
              if (!cP || 0x0 === cP['features']['length'])
                  return;
              const cM = [];
              bw(cP, (cL,cR)=>{
                  if ('Point' !== cL['geometry']['type'])
                      return;
                  let H0 = parseFloat(cL['properties'][cJ]);
                  if ('number' != typeof H0 || isNaN(H0) || H0 > 0x15f90)
                      return;
                  let H1 = cL['geometry'];
                  cM['push'](parseFloat(H1['coordinates'][0x0]), parseFloat(H1['coordinates'][0x1]), H0);
              }
              );
              const cz = cM['length'] > 0xf ? 0x5 : cM['length'] / 0x3 - 0x1;
              if (cz <= 0x0)
                  return void v0['kg']['error']('');
              const cQ = cM['length'] / 0x3;
              for (let cL = 0x0; cL < cd['ySize']; cL++) {
                  const cR = cL * cd['xSize'];
                  for (let H0 = 0x0; H0 < cd['xSize']; H0++) {
                      const H1 = cR + H0
                        , H2 = cG[H0]
                        , H3 = cg[cL]
                        , H4 = [new Float32Array(cz), new Float32Array(cz)];
                      for (let H7 = 0x0; H7 < cQ; H7++) {
                          let H8 = 0x3 * H7
                            , H9 = cM[H8]
                            , Hv = cM[H8 + 0x1]
                            , HA = cM[H8 + 0x2];
                          if (H2 == H9 && H3 == Hv) {
                              cN[H1] = HA;
                              break;
                          }
                          {
                              let Hk = H2 - H9
                                , Hl = H3 - Hv
                                , HK = 0x1 / (Hk * Hk + Hl * Hl);
                              for (let Hb = 0x0; Hb < cz; Hb++)
                                  if (H4[0x0][Hb] < HK) {
                                      H4[0x0][Hb] = HK,
                                      H4[0x1][Hb] = HA;
                                      break;
                                  }
                          }
                      }
                      let H5 = 0x0
                        , H6 = 0x0;
                      for (let Hc = 0x0; Hc < cz; Hc++)
                          H5 += H4[0x0][Hc] * H4[0x1][Hc],
                          H6 += H4[0x0][Hc];
                      cN[H1] = H5 / H6;
                  }
              }
              for (let HH = 0x1; HH < cd['ySize'] - 0x1; HH++) {
                  let Hx = HH * cd['xSize']
                    , Hp = Hx + cd['xSize']
                    , HF = Hx - cd['xSize'];
                  for (let Hy = 0x1; Hy < cd['xSize'] - 0x1; Hy++) {
                      let Hw = Hx + Hy
                        , Hh = Hp + Hy
                        , Hu = HF + Hy
                        , HY = Hw + 0x1
                        , HT = Hw - 0x1;
                      cN[Hw] = cN[Hw] + 0.125 * (cN[Hh] + cN[Hu] + cN[HY] + cN[HT] - 0x4 * cN[Hw]);
                  }
              }
              const cm = new KN['P'](KP['U']['Float32'],cd['xSize'],cd['ySize'],cN['buffer'],cC);
              return v0['kg']['debug']('interp\x20costs\x20' + (performance['now']() - cO) + 'ms'),
              new iu['o']([[cm]],{
                  'gridOptions': cd
              });
          }
          static['interpToGrid'](cd, cq, cJ, cC) {
              const cO = performance['now']()
                , cG = cq['getFeatures']();
              if (!cG || 0x0 === cG['features']['length'])
                  return;
              const cg = [];
              let cN = 0x0;
              bw(cG, (cR,H0)=>{
                  if ('Point' !== cR['geometry']['type'])
                      return;
                  let H1 = parseFloat(cR['properties'][cJ]);
                  if ('number' != typeof H1 || isNaN(H1) || H1 > 0x15f90)
                      return;
                  let H2 = cR['geometry'];
                  cg[cN] = [],
                  cg[cN][0x0] = parseFloat(H2['coordinates'][0x0]),
                  cg[cN][0x1] = parseFloat(H2['coordinates'][0x1]),
                  cg[cN][0x2] = H1,
                  cN++;
              }
              ),
              (cd['xDelta'] < 0x0 || cd['yDelta'] < 0x0) && v0['kg']['error']('x\x20y'),
              (0x0,
              KM['T'])(cd);
              let cP = [];
              cP['length'] = cd['xSize'];
              let cM = [];
              cM['length'] = cd['ySize'],
              bu['createGridXY_Num'](cd['xStart'], cd['yStart'], cd['xEnd'], cd['yEnd'], cP, cM);
              const cz = cg['length'] > 0x5 ? 0x5 : cg['length'] - 0x1;
              if (cz <= 0x0)
                  return void v0['kg']['warn']('5');
              const cQ = bu['interpolation_IDW_Neighbor_Undef'](cg, cP, cM, cz, (0x0,
              Kz['En'])(cC, Kg['v']['defaultUndef']))
                , cm = new KN['P'](KP['U']['Float32'],cd['xSize'],cd['ySize'],undefined,(0x0,
              Kz['En'])(cC, Kg['v']['defaultUndef']));
              cm['update'](cQ);
              const cL = new iu['o']([[cm]],{
                  'gridOptions': cd
              });
              return v0['kg']['debug']('interp\x20costs\x20' + (performance['now']() - cO) + 'ms'),
              cL;
          }
          ['tracingContourShadedFromPoints'](cd) {
              const cq = bL['interpToGridProvider'](cd['gridOpts'], cd['points'], cd['fieldName'], cd['undef']);
              return this['tracingContourShaded']({
                  'dataSource': cq,
                  'withShaded': cd['withShaded'],
                  'drawOptions': cd['drawOptions'],
                  'valueFieldName': (0x0,
                  Kz['En'])(cd['valueFieldName'], cd['fieldName']),
                  'analysisValues': cd['analysisValues'],
                  'layerOptions': cd['layerOptions'],
                  'reserveTracingInfo': cd['reserveTracingInfo']
              });
          }
          ['tracingContourShadedFromPointsWASM'](cd) {
              return bm(this, undefined, undefined, function*() {
                  const cq = bL['interpToGridProvider'](cd['gridOpts'], cd['points'], cd['fieldName'], cd['undef']);
                  return this['tracingContourShadedWASM']({
                      'dataSource': cq,
                      'withShaded': cd['withShaded'],
                      'drawOptions': cd['drawOptions'],
                      'analysisValues': cd['analysisValues'],
                      'layerOptions': cd['layerOptions'],
                      'reserveTracingInfo': cd['reserveTracingInfo']
                  });
              });
          }
          ['tracingStreamLinesAsync'](cd, cq) {
              var cJ, cC, cO;
              return bm(this, undefined, undefined, function*() {
                  const cG = cd['dataSource']['getU']()
                    , cg = cd['dataSource']['getV']()
                    , cN = cd['dataSource']['wProvider'] && cd['dataSource']['wProvider']['getGrid']();
                  (null === (cJ = cd['dataSource']['gridOptions']['zValues']) || undefined === cJ ? undefined : cJ['length']) || (cd['dataSource']['gridOptions']['zValues'] = [0x0]);
                  let cP = (0x0,
                  Kz['En'])(cd['undef'], cG['undef']);
                  undefined === cP && (v0['kg']['warn']('' + Kg['v']['defaultUndef']),
                  cP = Kg['v']['defaultUndef']);
                  const cM = null !== (cC = cd['threadCount']) && undefined !== cC ? cC : 0x1;
                  cd['needVolume'] && cd['point2D'] && (v0['kg']['debug'](''),
                  cd['point2D'] = false);
                  const cz = cd['needVolume'] ? new iX(Kg['v']['workerPath'] + '/sl.volume.js',cM,'streamline',{
                      'type': 'classic'
                  }) : new iX(Kg['v']['workerPath'] + '/sl.js',cM,'streamline',{
                      'type': 'classic'
                  })
                    , cQ = []
                    , cm = []
                    , cL = []
                    , cR = (H5,H6)=>{
                      if (!H5)
                          return;
                      let H7;
                      return H7 = 0x0 === H6['length'] ? H5['slice'](0x0) : H6['pop'](),
                      H7;
                  }
                    , H0 = (null === (cO = cd['dataSource']['gridOptions']['zValues']) || undefined === cO ? undefined : cO['length']) || 0x1;
                  let H1, H2, H3, H4 = false;
                  if (0x1 === H0)
                      H1 = cG['raw']['buffer'],
                      H2 = cg['raw']['buffer'],
                      H3 = undefined;
                  else {
                      if (cd['zIdx'] >= 0x0)
                          H1 = cd['dataSource']['getU'](undefined, cd['zIdx'])['raw']['buffer'],
                          H2 = cd['dataSource']['getV'](undefined, cd['zIdx'])['raw']['buffer'],
                          H3 = undefined;
                      else {
                          const H5 = (0x0,
                          Kz['cM'])(cG['dataType'], new ArrayBuffer(cG['raw']['byteLength'] * H0))
                            , H6 = (0x0,
                          Kz['cM'])(cg['dataType'], new ArrayBuffer(cg['raw']['byteLength'] * H0))
                            , H7 = cd['dataSource']['wProvider'] && (0x0,
                          Kz['cM'])(cd['dataSource']['getW']()['dataType'], new ArrayBuffer(cd['dataSource']['getW']()['raw']['byteLength'] * H0));
                          let H8 = 0x0;
                          for (let H9 = 0x0; H9 < H0; H9++)
                              H5['set'](cd['dataSource']['getU'](undefined, H9)['raw'], H8),
                              H6['set'](cd['dataSource']['getV'](undefined, H9)['raw'], H8),
                              null == H7 || H7['set'](cd['dataSource']['getW'](undefined, H9)['raw'], H8),
                              H8 += cG['raw']['length'];
                          H1 = H5['buffer'],
                          H2 = H6['buffer'],
                          H3 = null == H7 ? undefined : H7['buffer'],
                          H4 = true;
                      }
                  }
                  return new Promise((Hv,HA)=>{
                      var Hk, Hl;
                      let HK = 0x0
                        , Hb = 0x0;
                      const Hc = {
                          'type': 'FeatureCollection',
                          'features': []
                      }
                        , HH = []
                        , Hx = null !== (Hk = cd['lineCount']) && undefined !== Hk ? Hk : 0x3e8
                        , Hp = Math['max'](parseInt(Hx / cM) + 0x1, cM);
                      let HF = Hx
                        , Hy = 0x0;
                      const Hw = Object['assign']({}, cd['dataSource']['gridOptions']);
                      let Hh;
                      H4 || (cd['zIdx'] > 0x0 && (0x0,
                      Kz['ri'])(Hw['zValues'][cd['zIdx']]) ? Hw['zValues'] = [Hw['zValues'][cd['zIdx']]] : Hw['zValues'] = [0x0]),
                      Hh = cd['seedGenerator'] ? cd['seedGenerator'] : cd['zIdx'] < 0x0 ? ()=>(0x0,
                      Kz['r_'])(cd['dataSource']['gridOptions']) : ()=>[...(0x0,
                      Kz['r_'])(cd['dataSource']['gridOptions'], false), cd['dataSource']['gridOptions']['zValues'][cd['zIdx']]];
                      const Hu = cd['volumeOptions'] || {}
                        , HY = {
                          'vertices': [],
                          'indices': [],
                          'st': [],
                          'normals': []
                      }
                        , HT = (HE,Hf)=>{
                          if (0x1 === HE)
                              return new Uint8Array(Hf);
                          if (0x2 === HE)
                              return new Uint16Array(Hf);
                          if (0x4 === HE)
                              return new Uint32Array(Hf);
                          throw new Error('' + HE);
                      }
                        , HX = HE=>{
                          if (0x1 === HY['vertices']['length']) {
                              HE['vertices'] = new Float32Array(HY['vertices'][0x0]);
                              const HC = HY['indices'][0x0]['len'];
                              return HE['indices'] = HT(HC, HY['indices'][0x0]['data']),
                              HE['normals'] = new Float32Array(HY['normals'][0x0]),
                              void (HE['st'] = new Float32Array(HY['st'][0x0]));
                          }
                          let Hf = 0x0
                            , HW = 0x0
                            , HI = 0x0
                            , Hj = 0x0;
                          for (let HO = 0x0; HO < HY['indices']['length']; HO++)
                              Hf += HY['vertices'][HO]['byteLength'] / 0x4,
                              HW += HY['indices'][HO]['data']['byteLength'] / HY['indices'][HO]['len'],
                              HI += HY['normals'][HO]['byteLength'] / 0x4,
                              Hj += HY['st'][HO]['byteLength'] / 0x4;
                          const HD = new Float32Array(Hf)
                            , HV = new Float32Array(HI)
                            , HZ = new Float32Array(Hj);
                          let HB = 0x0
                            , HS = 0x0
                            , HU = 0x0;
                          for (let HG = 0x0; HG < HY['indices']['length']; HG++) {
                              const Hg = new Float32Array(HY['vertices'][HG]);
                              HD['set'](Hg, HB),
                              HB += Hg['length'];
                              const HN = new Float32Array(HY['normals'][HG]);
                              HV['set'](HN, HS),
                              HS += HN['length'];
                              const HP = new Float32Array(HY['st'][HG]);
                              HZ['set'](HP, HU),
                              HU += HP['length'];
                          }
                          const Hd = Hf / 0x3 > 0xffff ? new Uint32Array(HW) : new Uint16Array(HW);
                          let Hq = 0x0
                            , HJ = 0x0;
                          for (let HM = 0x0; HM < HY['indices']['length']; HM++) {
                              const Hz = HY['vertices'][HM]['byteLength'] / 0xc
                                , HQ = HT(HY['indices'][HM]['len'], HY['indices'][HM]['data']);
                              Hq > 0x0 ? HQ['forEach'](Hm=>{
                                  Hd[HJ++] = Hm + Hq;
                              }
                              ) : (Hd['set'](HQ),
                              HJ = HQ['length']),
                              Hq += Hz;
                          }
                          HE['vertices'] = HD,
                          HE['indices'] = Hd,
                          HE['normals'] = HV,
                          HE['st'] = HZ;
                      }
                      ;
                      for (; !(HF <= 0x0); ) {
                          let HE = Hp;
                          HF < Hp && (HE = HF);
                          const Hf = [];
                          for (let HI = 0x0; HI < HE; HI++) {
                              const Hj = Hh(Hy);
                              Hj && (Hf['push'](...Hj),
                              Hy++);
                          }
                          const HW = {
                              'data': Object['assign']({
                                  'gridOptions': Hw,
                                  'u': cG['raw']['buffer'],
                                  'v': cg['raw']['buffer'],
                                  'scale': cG['dataScale'],
                                  'offset': cG['dataOffset'],
                                  'dataType': cG['dataType'],
                                  'algo': cG['algo'],
                                  'wScale': null == cN ? undefined : cN['dataScale'],
                                  'wOffset': null == cN ? undefined : cN['dataOffset'],
                                  'wAlgo': null == cN ? undefined : cN['algo'],
                                  'wUndef': null == cN ? undefined : cN['undef'],
                                  'undef': cP,
                                  'step': cd['step'],
                                  'backward': cd['backward'],
                                  'seeds': Hf,
                                  'hReso': cd['hReso'],
                                  'vReso': cd['vReso'],
                                  'allLoop': cd['allLoop'],
                                  'stayLoop': cd['stayLoop'],
                                  'lineMinCount': cd['lineMinCount'],
                                  'wDataType': cd['dataSource']['wProvider'] && (null === (Hl = cd['dataSource']['wProvider']['getGrid']()) || undefined === Hl ? undefined : Hl['dataType']),
                                  'zScale': cd['zScale'],
                                  'disableDensityControl': cd['disableDensityControl'],
                                  'point2D': cd['point2D']
                              }, Hu),
                              'beforeExec': ()=>{
                                  HW['data']['u'] = cR(H1, cQ),
                                  HW['data']['v'] = cR(H2, cm),
                                  HW['transffers'] = [HW['data']['u'], HW['data']['v']],
                                  H3 && (HW['data']['w'] = cR(H3, cL),
                                  HW['transffers']['push'](HW['data']['w']));
                              }
                              ,
                              'onCompleted': HD=>{
                                  var HV, HZ;
                                  const HB = {
                                      'type': 'FeatureCollection',
                                      'features': []
                                  };
                                  if ((null === (HV = HD['streamlines']) || undefined === HV ? undefined : HV['length']) && HD['streamlines']['forEach'](HS=>{
                                      const HU = {
                                          'type': 'Feature',
                                          'geometry': {
                                              'type': 'LineString',
                                              'coordinates': HS
                                          },
                                          'properties': {}
                                      };
                                      HB['features']['push'](HU),
                                      Hc['features']['push'](HU),
                                      HH['push'](HS);
                                  }
                                  ),
                                  cq && cq({
                                      'streamlines': HD['streamlines'],
                                      'allFC': Hc,
                                      'fc': HB
                                  }),
                                  cQ['push'](HD['u']),
                                  cm['push'](HD['v']),
                                  HD['w'] && cL['push'](HD['w']),
                                  cd['needVolume'] && (null === (HZ = HD['streamlines']) || undefined === HZ ? undefined : HZ['length']) && (HY['indices']['push']({
                                      'len': HD['indiceByteLen'],
                                      'data': HD['indices']
                                  }),
                                  HY['normals']['push'](HD['normals']),
                                  HY['st']['push'](HD['st']),
                                  HY['vertices']['push'](HD['vertices'])),
                                  Hb++,
                                  Hb === HK) {
                                      const HS = {
                                          'provider': new GeoJSONFeatureProvider(Hc),
                                          'streamlines': HH
                                      };
                                      cd['needVolume'] && HX(HS),
                                      Hv(HS),
                                      cz['destroy']();
                                  }
                              }
                          };
                          cz['push'](HW),
                          HK++,
                          HF -= Hp;
                      }
                  }
                  );
              });
          }
      }
      bL['DefaultContourShadedStyle'] = {
          'polyline': {
              'color': 'rgba(255,255,255,0.5)',
              'label': [{
                  'text': {
                      'data': '$value',
                      'backColor': '#edf2ba',
                      'backPadding': [0x8, 0x2],
                      'backRoundRect': true,
                      'backRoundRadius': 0x8,
                      'backHeight': 0xc,
                      'color': 'black',
                      'font': '12px\x20Arial',
                      'backShadowColor': 'gray',
                      'backShadowOffset': [0x2, 0x2]
                  }
              }]
          },
          'polygon': {}
      },
      bL['DefaultColorStopOptions'] = {
          'stops': [{
              'value': -0x64,
              'stop': 'rgba(0,0,255,0.8)'
          }, {
              'value': 0x0,
              'stop': 'rgba(255,255,255,0.8)'
          }, {
              'value': 0x64,
              'stop': 'rgba(255,0,0,0.8)'
          }],
          'field': 'value'
      };
      class MapToolService {
          constructor(cd) {
              this['map'] = cd;
          }
          ['getCurrent']() {
              return this['currentTool'];
          }
          ['setCurrent'](cd) {
              var cq, cJ, cC;
              null === (cq = this['currentTool']) || undefined === cq || cq['end'](),
              this['currentTool'] = cd,
              null === (cJ = this['currentTool']) || undefined === cJ || cJ['setMap'](this['map']),
              null === (cC = this['currentTool']) || undefined === cC || cC['begin']();
          }
      }
      class LegendService extends iT['c'] {
          constructor() {
              super(...arguments),
              this['stopRulesMap'] = {};
          }
          ['attach'](cd, cq, cJ) {
              cJ || (cJ = (0x0,
              iq['it'])(cd)) || v0['kg']['error']('' + cd + ''),
              cJ instanceof iR['NB'] || (cJ = new iR['NB'](cJ));
              const cC = {
                  'firer': this,
                  'msg': {
                      'key': cd,
                      'sr': cJ
                  }
              };
              this['stopRulesMap'][cd] ? this['stopRulesMap'][cd]['changed']['push'](cq) : (this['stopRulesMap'][cd] = {
                  'sr': cJ,
                  'changed': [cq]
              },
              this['fire'](LegendService['EventTypes']['attachFirst'], cC)),
              this['fire'](LegendService['EventTypes']['attach'], cC);
          }
          ['setOpacity'](cd, cq, cJ, cC=iR['DY']['outside'], cO=0x0) {
              const cG = this['stopRulesMap'][cd];
              cG || v0['kg']['warn']('key' + cd + ''),
              cG['sr']['setOpacityByIndex'](cq, cC, cO, cJ);
              for (const cg of cG['changed'])
                  cg();
              this['fire'](LegendService['EventTypes']['changeOpacity'], {
                  'firer': this,
                  'msg': {
                      'key': cd,
                      'sr': cG['sr']
                  }
              });
          }
          ['detach'](cd, cq) {
              const cJ = this['stopRulesMap'][cd];
              cJ || v0['kg']['warn']('key' + cd + '');
              const cC = ()=>{
                  this['fire'](LegendService['EventTypes']['detachLast'], {
                      'firer': this,
                      'msg': {
                          'key': cd,
                          'sr': cJ['sr']
                      }
                  }),
                  this['fire'](LegendService['EventTypes']['detach'], {
                      'firer': this,
                      'msg': {
                          'key': cd,
                          'sr': cJ['sr']
                      }
                  }),
                  delete cJ['changed'],
                  delete cJ['sr'],
                  delete this['stopRulesMap'][cd];
              }
              ;
              if (cq) {
                  const cO = cJ['changed']['indexOf'](cq);
                  cO >= 0x0 && cJ['changed']['splice'](cO, 0x1),
                  0x0 === cJ['changed']['length'] ? cC() : this['fire'](LegendService['EventTypes']['detach'], {
                      'firer': this,
                      'msg': {
                          'key': cd,
                          'sr': cJ['sr']
                      }
                  });
              } else
                  cC();
          }
      }
      LegendService['EventTypes'] = {
          'attach': 'attach',
          'attachFirst': 'attach:first',
          'detachLast': 'detach:last',
          'detach': 'detach',
          'changeOpacity': 'change:opacity'
      };
      var e1 = n(0x11d);
      class DODSUnpacker {
          constructor(cd, cq) {
              this['options'] = (0x0,
              Kz['Ov'])({}, cq, DODSUnpacker['DefaultOptions']),
              this['_buf'] = cd,
              this['_pos'] = 0x0;
          }
          ['unpack']() {
              const cd = performance['now']();
              for (var cq = this['_view'] = new DataView(this['_buf']), cJ = 0x0, cC = ''; cJ < cq['byteLength'] && -0x1 === (cC += String['fromCharCode'](cq['getUint8'](cJ)))['indexOf']('\x0aData:\x0a'); )
                  cJ += 0x1;
              cC = cC['substr'](0x0, cC['length'] - 0x7),
              this['_pos'] = cJ + 0x1;
              const cO = this['dapvar'] = new e1['cF'](cC)['parse']()
                , cG = this['getValue']();
              return v0['kg']['debug']('unpack\x20dods\x20costs\x20' + (performance['now']() - cd) + 'ms'),
              {
                  'dds': cO,
                  'dods': cG
              };
          }
          ['getValue']() {
              var cd = this['dapvar']['type']['toLowerCase']();
              let cq;
              return cq = 'structure' === cd || 'dataset' === cd ? this['_parse_structure']() : 'grid' === cd ? this['_parse_grid']() : 'sequence' === cd ? this['_parse_sequence']() : 'Z\x00\x00\x00' === this['_buf']['slice'](this['_pos'], this['_pos'] + 0x4) ? this['_parse_base_type_sequence']() : this['_parse_base_type'](cd),
              cq;
          }
          ['_parse_structure']() {
              var cd, cq = {}, cJ = this['dapvar'];
              for (var cC in cJ)
                  cJ[cC]['type'] && (this['dapvar'] = cJ[cC],
                  cd = this['getValue'](),
                  cq[cC] = cd);
              return this['dapvar'] = cJ,
              cq;
          }
          ['_parse_grid']() {
              var cd, cq = [], cJ = this['dapvar'];
              for (var cC in (this['dapvar'] = cJ['array'],
              cd = this['getValue'](),
              cq['push'](cd),
              cJ['maps']))
                  cJ['maps'][cC]['type'] && (this['dapvar'] = cJ['maps'][cC],
                  cd = this['getValue'](),
                  cq['push'](cd));
              return this['dapvar'] = cJ,
              cq;
          }
          ['_parse_sequence']() {
              for (var cd, cq = [], cJ = this['_unpack_uint32'](), cC = this['dapvar']; 0xa5000000 !== cJ; ) {
                  var cO = [];
                  for (var cG in cC)
                      cC[cG]['type'] && (this['dapvar'] = cC[cG],
                      cd = this['getValue'](),
                      cO['push'](cd));
                  cq['push'](cO),
                  cJ = this['_unpack_uint32']();
              }
              return this['dapvar'] = cC,
              cq;
          }
          ['_parse_base_type_sequence']() {
              for (var cd, cq = [], cJ = this['_unpack_uint32'](); 0xa5000000 !== cJ; )
                  cd = this['getValue'](),
                  cq['push'](cd),
                  cJ = this['_unpack_uint32']();
              return cq;
          }
          ['_parse_base_type'](cd) {
              var cq = []
                , cJ = 0x1;
              if (this['dapvar']['shape']['length'] && (cJ = this['_unpack_uint32'](),
              'url' !== cd && 'string' !== cd && this['_unpack_uint32']()),
              'byte' === cd)
                  cq = this['_unpack_bytes'](cJ);
              else {
                  if ('url' === cd || 'string' === cd)
                      cq = this['_unpack_string'](cJ);
                  else {
                      var cC;
                      switch (cq = [],
                      cd) {
                      case 'float64':
                          cC = '_unpack_float64',
                          cq = new Float64Array(cJ);
                          break;
                      case 'float32':
                          cC = '_unpack_float32',
                          cq = new Float32Array(cJ);
                          break;
                      case 'int':
                      case 'int32':
                          cC = '_unpack_int32',
                          cq = new Int32Array(cJ);
                          break;
                      case 'uint':
                      case 'uint32':
                          cC = '_unpack_uint32',
                          cq = new Uint32Array(cJ);
                          break;
                      case 'int16':
                          cC = '_unpack_int32',
                          cq = new Int16Array(cJ);
                          break;
                      case 'uint16':
                          cC = '_unpack_uint32',
                          cq = new Uint16Array(cJ);
                          break;
                      case 'int8':
                          cC = '_unpack_int32',
                          cq = new Int8Array(cJ);
                          break;
                      case 'uint8':
                          cC = '_unpack_uint32',
                          cq = new Uint8Array(cJ);
                      }
                      for (var cO = 0x0; cO < cJ; cO++)
                          cq[cO] = this[cC]();
                  }
              }
              return this['dapvar']['shape'] ? this['options']['reshape'] && (cq = this['reshape'](cq, this['dapvar']['shape'])) : cq = cq[0x0],
              cq;
          }
          ['_unpack_byte']() {
              var cd = this['_pos'];
              return this['_pos'] += 0x1,
              this['_view']['getUint8'](cd);
          }
          ['_unpack_uint32']() {
              var cd = this['_pos'];
              return this['_pos'] += 0x4,
              this['_view']['getUint32'](cd);
          }
          ['_unpack_int32']() {
              var cd = this['_pos'];
              return this['_pos'] += 0x4,
              this['_view']['getInt32'](cd);
          }
          ['_unpack_float32']() {
              var cd = this['_pos'];
              return this['_pos'] += 0x4,
              this['_view']['getFloat32'](cd);
          }
          ['_unpack_float64']() {
              var cd = this['_pos'];
              return this['_pos'] += 0x8,
              this['_view']['getFloat64'](cd);
          }
          ['_unpack_bytes'](cd) {
              for (var cq = (0x4 - cd % 0x4) % 0x4, cJ = [], cC = 0x0; cC < cd; cC++)
                  cJ['push'](this['_unpack_byte']());
              return this['_pos'] += cq,
              cJ;
          }
          ['_unpack_string'](cd) {
              for (var cq = [], cJ = 0x0; cJ < cd; cJ++) {
                  for (var cC = this['_unpack_uint32'](), cO = (0x4 - cC % 0x4) % 0x4, cG = '', cg = 0x0; cg < cC; cg++)
                      cG += String['fromCharCode'](this['_unpack_byte']());
                  cq['push'](cG),
                  this['_pos'] += cO;
              }
              return cq;
          }
          ['reshape'](cd, cq) {
              if (!cq['length'])
                  return cd[0x0];
              if (0x1 === cq['length'])
                  return cd['slice'](0x0, cq[0x0]);
              for (var cJ, cC, cO, cG = [], cg = 0x0; cg < cq[0x0]; cg++)
                  cO = (cC = cg * (cJ = cd['length'] / cq[0x0])) + cJ,
                  cG['push'](this['reshape'](cd['slice'](cC, cO), cq['slice'](0x1)));
              return cG;
          }
      }
      DODSUnpacker['DefaultOptions'] = {
          'reshape': false
      };
      var e3 = function(cd, cq, cJ, cC) {
          return new (cJ || (cJ = Promise))(function(cO, cG) {
              function cg(cM) {
                  try {
                      cP(cC['next'](cM));
                  } catch (cz) {
                      cG(cz);
                  }
              }
              function cN(cM) {
                  try {
                      cP(cC['throw'](cM));
                  } catch (cz) {
                      cG(cz);
                  }
              }
              function cP(cM) {
                  var cz;
                  cM['done'] ? cO(cM['value']) : (cz = cM['value'],
                  cz instanceof cJ ? cz : new cJ(function(cQ) {
                      cQ(cz);
                  }
                  ))['then'](cg, cN);
              }
              cP((cC = cC['apply'](cd, cq || []))['next']());
          }
          );
      };
      class DAPService extends iT['c'] {
          constructor(cd, cq=[], cJ=false) {
              super(),
              this['baseUrl'] = cd,
              this['varList'] = cq,
              this['_loading'] = false,
              cJ && this['loadDataInfo']();
          }
          ['getGridDataType'](cd) {
              switch (cd['toLowerCase']()) {
              case 'float64':
                  return {
                      'type': KP['U']['Float64'],
                      'len': 0x8
                  };
              case 'float32':
                  return {
                      'type': KP['U']['Float32'],
                      'len': 0x4
                  };
              case 'int':
              case 'int32':
                  return {
                      'type': KP['U']['Int32'],
                      'len': 0x4
                  };
              case 'uint':
              case 'uint32':
                  return {
                      'type': KP['U']['UInt32'],
                      'len': 0x4
                  };
              case 'int16':
                  return {
                      'type': KP['U']['Int16'],
                      'len': 0x2
                  };
              case 'uint16':
                  return {
                      'type': KP['U']['UInt16'],
                      'len': 0x2
                  };
              case 'int8':
              case 'byte':
                  return {
                      'type': KP['U']['Int8'],
                      'len': 0x1
                  };
              case 'uint8':
                  return {
                      'type': KP['U']['UInt8'],
                      'len': 0x1
                  };
              }
          }
          ['_parseGridOptions'](cd, cq) {
              var cJ, cC, cO;
              let cG = cd['shape'] || (null === (cJ = cd['array']) || undefined === cJ ? undefined : cJ['shape'])
                , cg = 0x3
                , cN = 0x2
                , cP = 0x1
                , cM = 0x0;
              if (0x4 === cG['length'])
                  ;
              else {
                  if (0x3 === cG['length'])
                      0x0 === (null === (cO = null === (cC = cd['array']) || undefined === cC ? undefined : cC['dimensions']) || undefined === cO ? undefined : cO['indexOf']('level')) ? (cg = 0x2,
                      cN = 0x1,
                      cP = 0x0,
                      cM = -0x1) : (cg = 0x2,
                      cN = 0x1,
                      cP = -0x1,
                      cM = 0x0);
                  else {
                      if (0x2 !== cG['length'])
                          return v0['kg']['debug']('unsupported\x20shape:' + cG),
                          void v0['kg']['debug'](cd);
                      cg = 0x1,
                      cN = 0x0,
                      cP = -0x1,
                      cM = -0x1;
                  }
              }
              const cz = cq[cg + 0x1]
                , cQ = cq[cN + 0x1]
                , cm = {
                  'xStart': cz[0x0],
                  'xDelta': cz['length'] > 0x1 ? cz[0x1] - cz[0x0] : 0x0,
                  'xSize': cG[cg],
                  'yStart': cQ[0x0],
                  'yDelta': cQ['length'] > 0x1 ? cQ[0x1] - cQ[0x0] : 0x0,
                  'ySize': cG[cN],
                  'zValues': cP < 0x0 ? [0x0] : cq[cP + 0x1],
                  'tCount': cM < 0x0 ? 0x1 : cG[cM],
                  'tValues': cM < 0x0 ? [0x0] : cq[cM + 0x1]
              };
              return (0x0,
              KM['T'])(cm),
              cm;
          }
          get['dataInfo']() {
              return this['_dataInfo'] || v0['kg']['warn']('dapServiceloadDataInfo'),
              this['_dataInfo'];
          }
          ['loadDataInfo'](cd=false, cq=true) {
              var cJ;
              if (this['_dataInfo'] && !cd)
                  return Promise['resolve'](this['_dataInfo']);
              if (this['_loading'])
                  return cq ? new Promise((cO,cG)=>{
                      this['once']('info:loaded', cg=>{
                          cO(cg['msg']);
                      }
                      );
                  }
                  ) : Promise['resolve'](undefined);
              let cC = '.dds';
              return (null === (cJ = this['varList']) || undefined === cJ ? undefined : cJ['length']) && (cC += '?',
              this['varList']['forEach'](cO=>{
                  cC += cO + ',';
              }
              ),
              cC = cC['slice'](0x0, cC['length'] - 0x1)),
              fetch(this['baseUrl'] + cC)['then'](cO=>cO['text']()['then'](cG=>{
                  const cg = new e1['cF'](cG)['parse']();
                  return fetch(this['baseUrl'] + '.das')['then'](cN=>cN['text']()['then'](cP=>{
                      const cM = new e1['Bn'](cP,cg)['parse']();
                      return this['_dataInfo'] = cM,
                      this['fire']('info:loaded', {
                          'firer': this,
                          'msg': cM
                      }),
                      cM;
                  }
                  )['catch'](v0['kg']['debug']))['catch'](v0['kg']['debug']);
              }
              )['catch'](v0['kg']['debug']))['catch'](v0['kg']['debug']);
          }
          ['loadDataByRawFilter'](cd) {
              return fetch(this['baseUrl'] + ('.dods?' + encodeURI(cd)))['then'](cq=>cq['arrayBuffer']()['then'](cJ=>new DODSUnpacker(cJ)['unpack']())['catch'](v0['kg']['debug']))['catch'](v0['kg']['debug']);
          }
          ['loadDataByFullFilter'](cd) {
              return e3(this, undefined, undefined, function*() {
                  const cq = ()=>e3(this, undefined, undefined, function*() {
                      var cJ, cC, cO;
                      const cG = this['dataInfo'][cd['varName']];
                      let cg = cG['shape'] || (null === (cJ = cG['array']) || undefined === cJ ? undefined : cJ['shape'])
                        , cN = cd['zFilter']
                        , cP = cd['tFilter']
                        , cM = cd['yFilter']
                        , cz = cd['xFilter'];
                      if (0x4 === cg['length'])
                          cP = cP || '[0:1:' + (cg[0x0] - 0x1) + ']',
                          cN = cN || '[0:1:' + (cg[0x1] - 0x1) + ']';
                      else {
                          if (0x3 === cg['length'])
                              0x0 === (null === (cO = null === (cC = cG['array']) || undefined === cC ? undefined : cC['dimensions']) || undefined === cO ? undefined : cO['indexOf']('level')) ? (cg = [0x1, cg[0x0], cg[0x1], cg[0x2]],
                              cP = '',
                              cN = cN || '[0:1:' + (cg[0x1] - 0x1) + ']') : (cg = [cg[0x0], 0x1, cg[0x1], cg[0x2]],
                              cP = cP || '[0:1:' + (cg[0x0] - 0x1) + ']',
                              cN = '');
                          else {
                              if (0x2 !== cg['length'])
                                  return v0['kg']['debug']('unsupported\x20shape:' + cg),
                                  void v0['kg']['debug'](cG);
                              cP = '',
                              cN = '',
                              cg = [0x1, 0x1, cg[0x0], cg[0x1]];
                          }
                      }
                      cM = cM || '[0:1:' + (cg[0x2] - 0x1) + ']',
                      cz = cz || '[0:1:' + (cg[0x3] - 0x1) + ']';
                      const cQ = '' + cd['varName'] + cP + cN + cM + cz
                        , cm = yield this['loadDataByRawFilter'](cQ)
                        , cL = cm['dods'][cd['varName']];
                      return Object['assign'](Object['assign']({}, cm), {
                          'data': cL[0x0]
                      });
                  });
                  return this['_dataInfo'] ? cq() : this['loadDataInfo'](false, true)['then'](cJ=>cq())['catch'](v0['kg']['debug']);
              });
          }
          ['getFullGridOptions'](cd, cq=false) {
              return e3(this, undefined, undefined, function*() {
                  this['dataInfo'] || (yield this['loadDataInfo']());
                  const cJ = {
                      'varName': cd,
                      'xFilter': '[0:1:1]',
                      'yFilter': '[0:1:1]',
                      'tFilter': '[0]'
                  };
                  cq && delete cJ['tFilter'];
                  const cC = yield this['loadDataByFullFilter'](cJ)
                    , cO = this['dataInfo'][cd]
                    , cG = cC['dods'][cd];
                  return this['_parseGridOptions'](cO, cG);
              });
          }
          ['dapResultToProvider'](cd, cq) {
              var cJ;
              const cC = cd['dds'][cq]
                , cO = cd['dods'][cq]
                , cG = this['_parseGridOptions'](cC, cO)
                , cg = this['getGridDataType'](cC['array']['type']);
              let cN = null === (cJ = cC['attributes']) || undefined === cJ ? undefined : cJ['missing_value'];
              (!(0x0,
              Kz['ri'])(cN) || cN > 0xf423f) && (cN = 0xf423f);
              const cP = [];
              let cM = cO[0x0]['buffer'];
              if (!cM && cO[0x0]instanceof Array) {
                  let cL;
                  switch (v0['kg']['debug']('dapTypedArray'),
                  cg['type']) {
                  case KP['U']['UInt8']:
                      cL = new Uint8Array(cO[0x0]);
                      break;
                  case KP['U']['Int8']:
                      cL = new Int8Array(cO[0x0]);
                      break;
                  case KP['U']['UInt16']:
                      cL = new Uint16Array(cO[0x0]);
                      break;
                  case KP['U']['Int16']:
                      cL = new Int16Array(cO[0x0]);
                      break;
                  case KP['U']['UInt32']:
                      cL = new Uint32Array(cO[0x0]);
                      break;
                  case KP['U']['Int32']:
                      cL = new Int32Array(cO[0x0]);
                      break;
                  case KP['U']['Float32']:
                      cL = new Float32Array(cO[0x0]);
                      break;
                  case KP['U']['Float64']:
                      cL = new Float64Array(cO[0x0]);
                      break;
                  default:
                      throw new Error('not\x20supported\x20grid\x20data\x20type\x20' + cg);
                  }
                  cM = cL['buffer'];
              }
              let cz = 0x0
                , cQ = cG['ySize'] * cG['xSize'] * cg['len'];
              for (let cR = 0x0; cR < cG['tCount']; cR++) {
                  const H0 = [];
                  for (let H1 = 0x0; H1 < cG['zValues']['length']; H1++) {
                      const H2 = cz + cQ
                        , H3 = new KN['P'](cg['type'],cG['xSize'],cG['ySize'],cM['slice'](cz, H2),cN);
                      H0['push'](H3),
                      cz = H2;
                  }
                  cP['push'](H0);
              }
              const cm = new iu['o'](cP,{
                  'gridOptions': cG
              });
              return {
                  'dds': cd['dds'],
                  'dods': cd['dods'],
                  'gridOptions': cG,
                  'provider': cm
              };
          }
          ['loadData'](cd) {
              const cq = (cC,cO)=>{
                  if ((0x0,
                  Kz['ri'])(cC))
                      return (0x0,
                      Kz['ri'])(cO) ? '[' + cC + ':' + cO + ']' : '[' + cC + ']';
              }
                , cJ = ()=>{
                  var cC, cO, cG, cg, cN, cP, cM;
                  const cz = this['dataInfo'][cd['varName']];
                  let cQ = cz['shape'] || (null === (cC = cz['array']) || undefined === cC ? undefined : cC['shape'])
                    , cm = ''
                    , cL = '';
                  if (0x4 === cQ['length'])
                      cm = '[' + (null !== (cO = cd['zIdx']) && undefined !== cO ? cO : 0x0) + ']',
                      cL = '[' + (null !== (cG = cd['tIdx']) && undefined !== cG ? cG : 0x0) + ']';
                  else {
                      if (0x3 === cQ['length'])
                          0x0 === (null === (cN = null === (cg = cz['array']) || undefined === cg ? undefined : cg['dimensions']) || undefined === cN ? undefined : cN['indexOf']('level')) ? (cQ = [0x1, cQ[0x0], cQ[0x1], cQ[0x2]],
                          cm = '[' + (null !== (cP = cd['zIdx']) && undefined !== cP ? cP : 0x0) + ']') : (cQ = [cQ[0x0], 0x1, cQ[0x1], cQ[0x2]],
                          cL = '[' + (null !== (cM = cd['tIdx']) && undefined !== cM ? cM : 0x0) + ']');
                      else {
                          if (0x2 !== cQ['length'])
                              return v0['kg']['debug']('unsupported\x20shape:' + cQ),
                              void v0['kg']['debug'](cz);
                          cQ = [0x1, 0x1, cQ[0x0], cQ[0x1]];
                      }
                  }
                  const cR = cQ[0x2]
                    , H0 = cq(cd['yStartIdx'], cd['yEndIdx']) || '[0:' + (cR - 0x1) + ']'
                    , H1 = cQ[0x3]
                    , H2 = cq(cd['xStartIdx'], cd['xEndIdx']) || '[0:' + (H1 - 0x1) + ']'
                    , H3 = '' + cd['varName'] + cL + cm + H0 + H2;
                  return this['loadDataByRawFilter'](H3)['then'](H4=>this['dapResultToProvider'](H4, cd['varName']))['catch'](v0['kg']['debug']);
              }
              ;
              return this['_dataInfo'] ? cJ() : this['loadDataInfo'](false, true)['then'](cC=>cJ())['catch'](v0['kg']['debug']);
          }
      }
      var e5 = n(0x32b);
      const e6 = function(cd, cq, cJ) {
          undefined === cJ && (cJ = {});
          var cC = (0x0,
          e5['c9'])(cd)
            , cO = (0x0,
          e5['c9'])(cq)
            , cG = (0x0,
          bF['Ht'])(cO[0x1] - cC[0x1])
            , cg = (0x0,
          bF['Ht'])(cO[0x0] - cC[0x0])
            , cN = (0x0,
          bF['Ht'])(cC[0x1])
            , cP = (0x0,
          bF['Ht'])(cO[0x1])
            , cM = Math['pow'](Math['sin'](cG / 0x2), 0x2) + Math['pow'](Math['sin'](cg / 0x2), 0x2) * Math['cos'](cN) * Math['cos'](cP);
          return (0x0,
          bF['DL'])(0x2 * Math['atan2'](Math['sqrt'](cM), Math['sqrt'](0x1 - cM)), cJ['units']);
      };
      function e7(cd, cq, cJ) {
          if (undefined === cJ && (cJ = {}),
          true === cJ['final'])
              return function(cQ, cm) {
                  var cL = e7(cm, cQ);
                  return (cL + 0xb4) % 0x168;
              }(cd, cq);
          var cC = (0x0,
          e5['c9'])(cd)
            , cO = (0x0,
          e5['c9'])(cq)
            , cG = (0x0,
          bF['Ht'])(cC[0x0])
            , cg = (0x0,
          bF['Ht'])(cO[0x0])
            , cN = (0x0,
          bF['Ht'])(cC[0x1])
            , cP = (0x0,
          bF['Ht'])(cO[0x1])
            , cM = Math['sin'](cg - cG) * Math['cos'](cP)
            , cz = Math['cos'](cN) * Math['sin'](cP) - Math['sin'](cN) * Math['cos'](cP) * Math['cos'](cg - cG);
          return (0x0,
          bF['vi'])(Math['atan2'](cM, cz));
      }
      var e8 = n(0xcc);
      function e9(cd, cq, cJ) {
          undefined === cJ && (cJ = {});
          for (var cC = (0x0,
          e5['wA'])(cd)['coordinates'], cO = 0x0, cG = 0x0; cG < cC['length'] && !(cq >= cO && cG === cC['length'] - 0x1); cG++) {
              if (cO >= cq) {
                  var cg = cq - cO;
                  if (cg) {
                      var cN = e7(cC[cG], cC[cG - 0x1]) - 0xb4;
                      return (0x0,
                      e8['Z'])(cC[cG], cg, cN, cJ);
                  }
                  return (0x0,
                  bF['xm'])(cC[cG]);
              }
              cO += e6(cC[cG], cC[cG + 0x1], cJ);
          }
          return (0x0,
          bF['xm'])(cC[cC['length'] - 0x1]);
      }
      class FrameDrawService {
          constructor(cd) {
              'h' === (null == cd ? undefined : cd['defaultMode']) ? this['_defaultDrawOptions'] = FrameDrawService['HDefaultOptions'] : this['_defaultDrawOptions'] = FrameDrawService['VDefaultOptions'];
          }
          ['setDrawOptions'](cd, cq=true) {
              if (cd)
                  return this['_drawOptions'] && cq ? this['_drawOptions'] = (0x0,
                  Kz['uw'])({}, cd, this['_drawOptions']) : this['_drawOptions'] = (0x0,
                  Kz['uw'])({}, cd, this['_defaultDrawOptions']),
                  this;
              this['_drawOptions'] = (0x0,
              Kz['f8'])(this['_defaultDrawOptions']);
          }
          ['update'](cd) {
              var cq;
              const {content: cJ, x: cC, y: cO, mainTitle: cG, subTitle: cg, vTitle: cN, hTitle: cP, vSubTitle: cM, hSubTitle: cz} = cd
                , cQ = null !== (cq = this['_drawOptions']) && undefined !== cq ? cq : this['_defaultDrawOptions']
                , cm = cQ['content']['ltOffset']
                , cL = cQ['content']['rbOffset']
                , cR = [cJ['width'], cJ['height']]
                , H0 = [cR[0x0] + cm[0x0] + cL[0x0], cR[0x1] + cm[0x1] + cL[0x1]]
                , H1 = document['createElement']('canvas');
              H1['width'] = H0[0x0],
              H1['height'] = H0[0x1];
              const H2 = H1['getContext']('2d');
              H2['save'](),
              H2['fillStyle'] = cQ['background'],
              H2['fillRect'](0x0, 0x0, H0[0x0], H0[0x1]),
              H2['restore'](),
              H2['drawImage'](cJ, 0x0, 0x0, cR[0x0], cR[0x1], cm[0x0], cm[0x1], cR[0x0], cR[0x1]),
              this['_drawBorder'](H2, cQ['border'], cm, cR);
              let H3 = [cm[0x0] + cR[0x0] / 0x2, Math['floor'](cm[0x1] / 2.5)];
              const H4 = cQ['title'];
              'start' === H4['position'] ? H3 = [...cm] : 'end' === H4['position'] && (H3 = [cm[0x0] + cR[0x0], cm[0x1] + cR[0x1]]),
              this['_drawText'](H2, H4['main'], H3, cG, 0x0),
              this['_drawText'](H2, H4['sub'], H3, cg, 0x1);
              const H5 = [];
              cC['forEach'](HH=>{
                  H5['push'](cm[0x0] + HH['percent'] * cR[0x0]);
              }
              );
              const H6 = [];
              cO['forEach'](HH=>{
                  H6['push'](cm[0x1] + cR[0x1] * (0x1 - HH['percent']));
              }
              );
              const H7 = cQ['gridLines']
                , H8 = cQ['axis']['tick'];
              let H9 = cm[0x1] + cR[0x1];
              H5['forEach']((HH,Hx)=>{
                  let Hp;
                  Math['abs'](HH - cm[0x0]) > 0x2 && Math['abs'](HH - (cm[0x0] + cR[0x0])) > 0x2 && this['_drawLine'](H2, H7['major'], [HH, H9], [HH, cm[0x1]]),
                  Hp = 'out' === H8['position'] ? [HH, H9 + H8['length']] : 'cross' === H8['position'] ? [HH, H9 + H8['length'] / 0x2] : [HH, H9];
                  const HF = [HH, Hp[0x1] - H8['length']];
                  this['_drawLine'](H2, H8['line'], Hp, HF);
                  const Hy = [HH, Hp[0x1] + 0x3];
                  this['_drawText'](H2, cQ['axis']['label']['bottom']['text'], Hy, cC[Hx]['label'], Hx),
                  this['_drawText'](H2, cQ['axis']['label']['bottom']['text2'], Hy, cC[Hx]['label2'], Hx);
              }
              ),
              H6['forEach']((HH,Hx)=>{
                  Math['abs'](HH - cm[0x1]) > 0x2 && Math['abs'](HH - (cm[0x1] + cR[0x1])) > 0x2 && this['_drawLine'](H2, H7['major'], [cm[0x0], HH], [cm[0x0] + cR[0x0], HH]);
                  let Hp = [];
                  Hp = 'out' === H8['position'] ? [cm[0x0] - H8['length'], HH] : 'cross' === H8['position'] ? [cm[0x0] - H8['length'] / 0x2, HH] : [cm[0x0], HH];
                  const HF = [Hp[0x0] + H8['length'], HH];
                  this['_drawLine'](H2, H8['line'], Hp, HF);
                  const Hy = [Hp[0x0] - 0x3, HH];
                  this['_drawText'](H2, cQ['axis']['label']['left']['text'], Hy, cO[Hx]['label'], Hx),
                  this['_drawText'](H2, cQ['axis']['label']['left']['text2'], Hy, cO[Hx]['label2'], Hx);
              }
              );
              const Hv = [cm[0x0] + cR[0x0] / 0x2, H9]
                , HA = cQ['axis']['label']['bottom']['title'];
              'start' === HA['position'] ? Hv[0x0] = cm[0x0] : 'end' === HA['position'] && (Hv[0x0] = cm[0x0] + cR[0x0]),
              this['_drawText'](H2, HA['main'], Hv, cP, 0x0),
              this['_drawText'](H2, HA['sub'], Hv, cz, 0x1);
              const Hk = [cm[0x0], cm[0x1] + cR[0x1] / 0x2]
                , Hl = cQ['axis']['label']['left']['title'];
              'start' === Hl['position'] ? Hk[0x1] = cm[0x1] : 'end' === Hl['position'] && (Hk[0x1] = H9),
              this['_drawText'](H2, Hl['main'], Hk, cN, 0x0),
              this['_drawText'](H2, Hl['sub'], Hk, cM, 0x1);
              const HK = []
                , Hb = [];
              if (cQ['axis']['tick']['minorCount'] > 0x0) {
                  const HH = (Hx,Hp)=>{
                      for (let HF = 0x0; HF < Hx['length'] - 0x1; HF++) {
                          const Hy = Hx[HF]
                            , Hw = (Hx[HF + 0x1] - Hy) / (cQ['axis']['tick']['minorCount'] + 0x1);
                          for (let Hh = 0x1; Hh <= cQ['axis']['tick']['minorCount']; Hh++)
                              Hp['push'](Hy + Hw * Hh);
                      }
                  }
                  ;
                  HH(H5, HK),
                  HH(H6, Hb),
                  HK['forEach'](Hx=>{
                      let Hp;
                      this['_drawLine'](H2, H7['minor'], [Hx, cm[0x1] + cR[0x1]], [Hx, cm[0x1]]),
                      Hp = 'out' === H8['position'] ? [Hx, cm[0x1] + cR[0x1] + H8['length'] / 0x2] : 'cross' === H8['position'] ? [Hx, cm[0x1] + cR[0x1] + H8['length'] / 0x2 / 0x2] : [Hx, cm[0x1] + cR[0x1]];
                      const HF = [Hx, Hp[0x1] - H8['length'] / 0x2];
                      this['_drawLine'](H2, H8['line'], Hp, HF);
                  }
                  ),
                  Hb['forEach'](Hx=>{
                      this['_drawLine'](H2, H7['minor'], [cm[0x0], Hx], [cm[0x0] + cR[0x0], Hx]);
                      let Hp = [];
                      Hp = 'out' === H8['position'] ? [cm[0x0] - H8['length'] / 0x2, Hx] : 'cross' === H8['position'] ? [cm[0x0] - H8['length'] / 0x2 / 0x2, Hx] : [cm[0x0], Hx];
                      const HF = [Hp[0x0] + H8['length'] / 0x2, Hx];
                      this['_drawLine'](H2, H8['line'], Hp, HF);
                  }
                  );
              }
              let Hc = [];
              return Hc = 'h' === cQ['legend']['mode'] ? [cm[0x0] + (cR[0x0] - cQ['legend']['width']) / 0x2 + cQ['legend']['offset'][0x0], cm[0x1] + cR[0x1] + cQ['legend']['offset'][0x1]] : [cm[0x0] + cR[0x0] + cQ['legend']['offset'][0x0], cm[0x1] + (cR[0x1] - cQ['legend']['height']) / 0x2 + cQ['legend']['offset'][0x1]],
              this['_drawLegend'](H2, cQ['legend'], Hc),
              H1;
          }
          ['_drawLegend'](cd, cq, cJ) {
              var cC;
              if (!cq['visible'])
                  return;
              let cO = cq['color'];
              if ('string' == typeof cO && (cO = (0x0,
              iq['it'])(cq['color'])),
              cO['width']) {
                  const cN = cq['color'];
                  return void cd['drawImage'](cN, 0x0, 0x0, cN['width'], cN['height'], cJ[0x0], cJ[0x1], cq['width'], cq['height']);
              }
              if (!cO['stops'])
                  return void v0['kg']['error']('', false);
              cO instanceof iR['NB'] || (cO = new iR['NB'](cO));
              let cG = [...cO['stops']];
              (null === (cC = cG[cG['length'] - 0x1]['stop']) || undefined === cC ? undefined : cC['alpha']()) < 0.01 && cG['pop']();
              const cg = Math['max'](0x0, cq['skip']) + 0x1;
              cG['length'] > cq['height'] ? v0['kg']['warn']('') : 'h' === cq['mode'] ? this['_drawHLegend'](cd, cq, cJ, cG, cg) : this['_drawVLegend'](cd, cq, cJ, cG, cg);
          }
          ['_drawVLegend'](cd, cq, cJ, cC, cO) {
              const cG = 0x1 * cq['height'] / cC['length'];
              cd['save']();
              let cg = cq['reverse'] ? cJ[0x1] + cq['height'] - cG : cJ[0x1];
              for (let cP = 0x0; cP < cC['length']; cP++) {
                  const cM = cC[cP]['stop'];
                  if (!(cM instanceof id['t']))
                      return v0['kg']['error']('', false),
                      void cd['restore']();
                  cd['fillStyle'] = cM['rgbaString'](),
                  cd['fillRect'](cJ[0x0], cg, cq['width'], cG),
                  cq['reverse'] ? cg -= cG : cg += cG;
              }
              cd['restore'](),
              this['_drawBorder'](cd, cq['border'], cJ, [cq['width'], cq['height']]);
              const cN = [cJ[0x0] + cq['width'], cJ[0x1] + cq['height']];
              for (let cz = 0x0; cz < cC['length'] - 0x1; cz += cO) {
                  cg = cq['reverse'] ? cJ[0x1] + cq['height'] - (cz + 0x1) * cG : cJ[0x1] + (cz + 0x1) * cG;
                  const cQ = [cN[0x0], cg]
                    , cm = [cN[0x0] + cq['tick']['length'], cg];
                  this['_drawLine'](cd, cq['tick']['style'], cQ, cm),
                  this['_drawText'](cd, cq['label'], cm, cC[cz]['value']['toString'](), cz);
              }
          }
          ['_drawHLegend'](cd, cq, cJ, cC, cO) {
              const cG = 0x1 * cq['width'] / cC['length'];
              cd['save']();
              let cg = cq['reverse'] ? cJ[0x0] + cq['width'] - cG : cJ[0x0];
              for (let cP = 0x0; cP < cC['length']; cP++) {
                  const cM = cC[cP]['stop'];
                  if (!(cM instanceof id['t']))
                      return v0['kg']['error']('', false),
                      void cd['restore']();
                  cd['fillStyle'] = cM['rgbaString'](),
                  cd['fillRect'](cg, cJ[0x1], cG, cq['height']),
                  cq['reverse'] ? cg -= cG : cg += cG;
              }
              cd['restore'](),
              this['_drawBorder'](cd, cq['border'], cJ, [cq['width'], cq['height']]);
              const cN = [cJ[0x0] + cq['width'], cJ[0x1] + cq['height']];
              for (let cz = 0x0; cz < cC['length'] - 0x1; cz += cO) {
                  cg = cq['reverse'] ? cJ[0x0] + cq['width'] - (cz + 0x1) * cG : cJ[0x0] + (cz + 0x1) * cG;
                  const cQ = [cg, cN[0x1]]
                    , cm = [cg, cN[0x1] + cq['tick']['length']];
                  this['_drawLine'](cd, cq['tick']['style'], cQ, cm),
                  this['_drawText'](cd, cq['label'], cm, cC[cz]['value']['toString'](), cz);
              }
          }
          ['_drawText'](cd, cq, cJ, cC, cO) {
              if (!(0x0,
              Kz['ri'])(cq) || !(null == cC ? undefined : cC['length']) || !cq['visible'])
                  return false;
              if (cd['save'](),
              cd['font'] = cq['font'],
              cd['fillStyle'] = cq['color'],
              cd['textAlign'] = cq['textAlign'],
              cd['textBaseline'] = cq['textBase'],
              cq['formater'] && (cC = cq['formater'](cO, cC)),
              cq['offset'] && (cJ = [cJ[0x0] + cq['offset'][0x0], cJ[0x1] + cq['offset'][0x1]]),
              'number' == typeof cq['angle']) {
                  const cG = cq['angle'] * Math['PI'] / 0xb4;
                  cd['translate'](cJ[0x0], cJ[0x1]),
                  cd['rotate'](cG),
                  cd['translate'](-cJ[0x0], -cJ[0x1]);
              }
              return cd['fillText'](cC, cJ[0x0], cJ[0x1]),
              cd['restore'](),
              true;
          }
          ['_drawBorder'](cd, cq, cJ, cC) {
              cq['visible'] && (cd['save'](),
              cd['strokeStyle'] = cq['color'],
              cd['lineWidth'] = cq['width'],
              cq['dashArray'] && cd['setLineDash'](cq['dashArray']),
              cq['width'] > 0x1 ? cd['strokeRect'](Math['floor'](cJ[0x0]), Math['floor'](cJ[0x1]), cC[0x0], cC[0x1]) : cd['strokeRect'](Math['floor'](cJ[0x0]) + 0.5, Math['floor'](cJ[0x1]) + 0.5, cC[0x0], cC[0x1]),
              cd['restore']());
          }
          ['_drawLine'](cd, cq, cJ, cC) {
              cq['visible'] && (cd['save'](),
              cd['strokeStyle'] = cq['color'],
              cd['lineWidth'] = cq['width'],
              cq['dashArray'] && cd['setLineDash'](cq['dashArray']),
              cd['beginPath'](),
              cq['width'] > 0x1 ? (cd['moveTo'](Math['floor'](cJ[0x0]), Math['floor'](cJ[0x1])),
              cd['lineTo'](Math['floor'](cC[0x0]), Math['floor'](cC[0x1]))) : (cd['moveTo'](Math['floor'](cJ[0x0]) + 0.5, Math['floor'](cJ[0x1]) + 0.5),
              cd['lineTo'](Math['floor'](cC[0x0]) + 0.5, Math['floor'](cC[0x1]) + 0.5)),
              cd['stroke'](),
              cd['restore']());
          }
          static['getAxisArrayFromZProviderAndPath'](cd, cq, cJ, cC=0x6, cO=0x2) {
              cd['length'];
              const cG = cC;
              let cg = [];
              if (cd['length'] <= cG) {
                  for (let cQ = 0x0; cQ < cd['length']; cQ++)
                      cg['push']({
                          'label': cd[cQ]['y']['toFixed'](cO),
                          'label2': cd[cQ]['x']['toFixed'](cO),
                          'percent': 0x1 * cQ / (cd['length'] - 0x1)
                      });
              } else {
                  const cm = {
                      'type': 'Feature',
                      'geometry': {
                          'type': 'LineString',
                          'coordinates': cd['map'](cR=>[cR['x'], cR['y']])
                      },
                      'properties': {}
                  }
                    , cL = (undefined === (cN = {
                      'units': 'kilometers'
                  }) && (cN = {}),
                  bh(cm, function(cR, H0) {
                      var H1 = H0['geometry']['coordinates'];
                      return cR + e6(H1[0x0], H1[0x1], cN);
                  }, 0x0) / (cC - 0x1));
                  cg['push']({
                      'label': cd[0x0]['y']['toFixed'](cO),
                      'label2': cd[0x0]['x']['toFixed'](cO),
                      'percent': 0x0
                  });
                  for (let cR = 0x1; cR < cC - 0x1; cR++) {
                      const H0 = e9(cm, cR * cL, {
                          'units': 'kilometers'
                      });
                      cg['push']({
                          'label': H0['geometry']['coordinates'][0x1]['toFixed'](cO),
                          'label2': H0['geometry']['coordinates'][0x0]['toFixed'](cO),
                          'percent': 0x1 * cR / (cC - 0x1)
                      });
                  }
                  cg['push']({
                      'label': cd[cd['length'] - 0x1]['y']['toFixed'](cO),
                      'label2': cd[cd['length'] - 0x1]['x']['toFixed'](cO),
                      'percent': 0x1
                  });
              }
              var cN;
              const cP = cJ
                , cM = []
                , cz = cq[cq['length'] - 0x1] - cq[0x0];
              return cP['forEach'](H1=>{
                  H1 < cq[0x0] || H1 > cq[cq['length'] - 0x1] ? v0['kg']['warn']('ZzValues') : cM['push']({
                      'label': H1['toString'](),
                      'percent': (H1 - cq[0x0]) / cz
                  });
              }
              ),
              {
                  'xArr': cg,
                  'yArr': cM
              };
          }
      }
      FrameDrawService['VDefaultOptions'] = {
          'background': 'black',
          'content': {
              'ltOffset': [0x46, 0x4b],
              'rbOffset': [0x50, 0x32]
          },
          'border': {
              'visible': true,
              'width': 0x2,
              'color': 'white'
          },
          'gridLines': {
              'major': {
                  'visible': true,
                  'width': 0x1,
                  'color': 'gray',
                  'dashArray': [0x5, 0x2, 0x5, 0x2]
              },
              'minor': {
                  'visible': false,
                  'width': 0x1,
                  'color': 'gray',
                  'dashArray': [0x3, 0x3, 0x3, 0x3]
              }
          },
          'title': {
              'position': 'center',
              'main': {
                  'visible': true,
                  'font': '22px\x20Arial',
                  'color': 'white',
                  'textAlign': 'center',
                  'textBase': 'middle'
              },
              'sub': {
                  'visible': true,
                  'font': '16px\x20Arial',
                  'color': 'white',
                  'textAlign': 'center',
                  'textBase': 'middle',
                  'offset': [0x0, 0x19]
              }
          },
          'axis': {
              'tick': {
                  'position': 'out',
                  'length': 0x6,
                  'line': {
                      'color': 'white',
                      'visible': true,
                      'width': 0x1
                  }
              },
              'label': {
                  'bottom': {
                      'text': {
                          'visible': true,
                          'font': '14px\x20Arial',
                          'color': 'white',
                          'offset': [0x0, 0x5],
                          'textAlign': 'center',
                          'textBase': 'top'
                      },
                      'text2': {
                          'visible': true,
                          'font': '14px\x20Arial',
                          'color': 'white',
                          'offset': [0x0, 0x14],
                          'textAlign': 'center',
                          'textBase': 'top'
                      },
                      'title': {
                          'position': 'center',
                          'main': {
                              'visible': false,
                              'font': '14px\x20Arial',
                              'color': 'white',
                              'textAlign': 'center',
                              'textBase': 'middle',
                              'offset': [0x0, 0x37]
                          },
                          'sub': {
                              'visible': false,
                              'font': '12px\x20Arial',
                              'color': 'white',
                              'textAlign': 'center',
                              'textBase': 'middle',
                              'offset': [0x0, 0x4b]
                          }
                      }
                  },
                  'left': {
                      'text': {
                          'visible': true,
                          'font': '14px\x20Arial',
                          'color': 'white',
                          'offset': [-0x5, 0x0],
                          'textAlign': 'end',
                          'textBase': 'middle'
                      },
                      'text2': {
                          'visible': true,
                          'font': '14px\x20Arial',
                          'color': 'white',
                          'offset': [-0x5, 0x14],
                          'textAlign': 'center',
                          'textBase': 'middle'
                      },
                      'title': {
                          'position': 'center',
                          'main': {
                              'visible': true,
                              'font': '14px\x20Arial',
                              'color': 'white',
                              'textAlign': 'center',
                              'textBase': 'middle',
                              'offset': [-0x32, 0x0],
                              'angle': -0x5a
                          },
                          'sub': {
                              'visible': false,
                              'font': '12px\x20Arial',
                              'color': 'white',
                              'textAlign': 'center',
                              'textBase': 'middle',
                              'offset': [-0x46, 0x0],
                              'angle': -0x5a
                          }
                      }
                  }
              }
          },
          'legend': {
              'mode': 'v',
              'width': 0x14,
              'height': 0x12c,
              'skip': 0x0,
              'offset': [0x14, 0x0],
              'visible': true,
              'reverse': false,
              'border': {
                  'visible': true,
                  'width': 0x1,
                  'color': 'white'
              },
              'label': {
                  'visible': true,
                  'font': '16px\x20Arial',
                  'color': 'white',
                  'offset': [0x5, 0x0],
                  'textAlign': 'start',
                  'textBase': 'middle'
              },
              'tick': {
                  'style': {
                      'visible': true,
                      'width': 0x1,
                      'color': 'white'
                  },
                  'length': 0x3
              },
              'color': undefined
          }
      },
      FrameDrawService['HDefaultOptions'] = (0x0,
      Kz['uw'])({}, {
          'content': {
              'rbOffset': [0x32, 0x73]
          },
          'legend': {
              'mode': 'h',
              'width': 0x1c2,
              'height': 0x14,
              'offset': [0x0, 0x3c],
              'label': {
                  'textAlign': 'center',
                  'textBase': 'top',
                  'offset': [0x0, 0x5]
              }
          }
      }, FrameDrawService['VDefaultOptions']);
      class eA {
          constructor(cd) {
              this['finishPointCount'] = -0x1,
              this['freehand'] = false,
              this['setPoints'](cd);
          }
          ['setCoordinates'](cd) {
              this['coordinates'] = cd;
          }
          ['isPlot']() {
              return true;
          }
          get['generated']() {
              return undefined !== this['coordinates'];
          }
          ['setPoints'](cd) {
              this['points'] = cd || [],
              this['points']['length'] >= 0x1 ? this['generate']() : this['coordinates'] = undefined;
          }
          ['addPoint'](cd) {
              if (this['points']['length'] > 0x0) {
                  const cq = this['points'][this['points']['length'] - 0x1];
                  if (0x0 === Math['abs'](cq[0x0] - cd[0x0]) && 0x0 === Math['abs'](cq[0x1] - cd[0x1]))
                      return false;
              }
              return this['points']['push'](cd),
              this['generate'](),
              true;
          }
          ['getPoints'](cd=true) {
              return cd ? this['points']['slice'](0x0) : this['points'];
          }
          ['getPointCount']() {
              return this['points']['length'];
          }
          ['updatePoint'](cd, cq) {
              cq >= 0x0 && cq < this['points']['length'] && (this['points'][cq] = cd,
              this['generate']());
          }
          ['updateLastPoint'](cd) {
              this['updatePoint'](cd, this['points']['length'] - 0x1);
          }
          ['finishDrawing']() {}
      }
      class PlotPolygonBase extends eA {
          ['getGeoJSON']() {
              if (this['coordinates'])
                  return {
                      'type': 'Polygon',
                      'coordinates': this['coordinates']
                  };
          }
      }
      class PlotLineBase extends eA {
          ['getGeoJSON']() {
              if (this['coordinates'])
                  return {
                      'type': 'LineString',
                      'coordinates': this['coordinates']
                  };
          }
      }
      class PlotPointBase extends eA {
          ['getGeoJSON']() {
              if (this['coordinates'])
                  return {
                      'type': 'Point',
                      'coordinates': this['coordinates']
                  };
          }
      }
      const PlotConstants = {
          'TWO_PI': 0x2 * Math['PI'],
          'HALF_PI': Math['PI'] / 0x2,
          'FITTING_COUNT': 0x64,
          'ZERO_TOLERANCE': 0.0001
      }
        , eH = {
          'MARKER': '',
          'POLYLINE': '',
          'CURVE': '',
          'POLYGON': '',
          'CLOSED_CURVE': '',
          'RECTANGLE': '',
          'CIRCLE': '',
          'ELLIPSE': '',
          'ARC': '',
          'SECTOR': '',
          'FREEHAND_LINE': '',
          'FREEHAND_POLYGON': '',
          'LUNE': '',
          'DOUBLE_ARROW': '',
          'GATHERING_PLACE': '',
          'STRAIGHT_ARROW': '',
          'ASSAULT_DIRECTION': '',
          'ATTACK_ARROW': '',
          'TAILED_ATTACK_ARROW': '',
          'SQUAD_COMBAT': '',
          'TAILED_SQUAD_COMBAT': '',
          'FINE_ARROW': ''
      }
        , ex = function(cd, cq) {
          return Math['sqrt'](Math['pow'](cd[0x0] - cq[0x0], 0x2) + Math['pow'](cd[0x1] - cq[0x1], 0x2));
      }
        , ep = function(cd) {
          for (var cq = 0x0, cJ = 0x0; cJ < cd['length'] - 0x1; cJ++)
              cq += ex(cd[cJ], cd[cJ + 0x1]);
          return cq;
      }
        , eF = function(cd) {
          return Math['pow'](ep(cd), 0.99);
      }
        , ey = function(cd, cq) {
          return [(cd[0x0] + cq[0x0]) / 0x2, (cd[0x1] + cq[0x1]) / 0x2];
      }
        , ew = function(cd, cq, cJ) {
          var cC = [(cd[0x0] + cq[0x0]) / 0x2, (cd[0x1] + cq[0x1]) / 0x2]
            , cO = [cC[0x0] - cd[0x1] + cq[0x1], cC[0x1] + cd[0x0] - cq[0x0]]
            , cG = [(cd[0x0] + cJ[0x0]) / 0x2, (cd[0x1] + cJ[0x1]) / 0x2]
            , cg = [cG[0x0] - cd[0x1] + cJ[0x1], cG[0x1] + cd[0x0] - cJ[0x0]];
          return eh(cC, cO, cG, cg);
      }
        , eh = function(cd, cq, cJ, cC) {
          if (cd[0x1] == cq[0x1]) {
              var cO = (cC[0x0] - cJ[0x0]) / (cC[0x1] - cJ[0x1])
                , cG = cO * (cd[0x1] - cJ[0x1]) + cJ[0x0]
                , cg = cd[0x1];
              return [cG, cg];
          }
          if (cJ[0x1] == cC[0x1]) {
              var cN = (cq[0x0] - cd[0x0]) / (cq[0x1] - cd[0x1]);
              return [cG = cN * (cJ[0x1] - cd[0x1]) + cd[0x0], cg = cJ[0x1]];
          }
          return cN = (cq[0x0] - cd[0x0]) / (cq[0x1] - cd[0x1]),
          cO = (cC[0x0] - cJ[0x0]) / (cC[0x1] - cJ[0x1]),
          [cG = cN * (cg = (cN * cd[0x1] - cd[0x0] - cO * cJ[0x1] + cJ[0x0]) / (cN - cO)) - cN * cd[0x1] + cd[0x0], cg];
      }
        , eu = function(cd, cq) {
          var cJ, cC = Math['asin'](Math['abs'](cq[0x1] - cd[0x1]) / ex(cd, cq));
          return cq[0x1] >= cd[0x1] && cq[0x0] >= cd[0x0] ? cJ = cC + Math['PI'] : cq[0x1] >= cd[0x1] && cq[0x0] < cd[0x0] ? cJ = PlotConstants['TWO_PI'] - cC : cq[0x1] < cd[0x1] && cq[0x0] < cd[0x0] ? cJ = cC : cq[0x1] < cd[0x1] && cq[0x0] >= cd[0x0] && (cJ = Math['PI'] - cC),
          cJ;
      }
        , eY = function(cd, cq, cJ) {
          var cC = eu(cq, cd) - eu(cq, cJ);
          return cC < 0x0 ? cC + PlotConstants['TWO_PI'] : cC;
      }
        , eT = function(cd, cq, cJ) {
          return (cJ[0x1] - cd[0x1]) * (cq[0x0] - cd[0x0]) > (cq[0x1] - cd[0x1]) * (cJ[0x0] - cd[0x0]);
      }
        , eX = function(cd, cq, cJ, cC, cO) {
          var cG = 0x1 - (cd = Math['max'](Math['min'](cd, 0x1), 0x0))
            , cg = cd * cd
            , cN = cg * cd
            , cP = cG * cG
            , cM = cP * cG;
          return [cM * cq[0x0] + 0x3 * cP * cd * cJ[0x0] + 0x3 * cG * cg * cC[0x0] + cN * cO[0x0], cM * cq[0x1] + 0x3 * cP * cd * cJ[0x1] + 0x3 * cG * cg * cC[0x1] + cN * cO[0x1]];
      }
        , eE = function(cd, cq, cJ, cC, cO) {
          var cG = eu(cd, cq)
            , cg = cO ? cG + cJ : cG - cJ
            , cN = cC * Math['cos'](cg)
            , cP = cC * Math['sin'](cg);
          return [cq[0x0] + cN, cq[0x1] + cP];
      }
        , ef = function(cd, cq, cJ, cC) {
          var cO, cG, cg = [], cN = cC - cJ;
          cN = cN < 0x0 ? cN + PlotConstants['TWO_PI'] : cN;
          for (var cP = 0x0; cP <= PlotConstants['FITTING_COUNT']; cP++) {
              var cM = cJ + cN * cP / PlotConstants['FITTING_COUNT'];
              cO = cd[0x0] + cq * Math['cos'](cM),
              cG = cd[0x1] + cq * Math['sin'](cM),
              cg['push']([cO, cG]);
          }
          return cg;
      }
        , eW = function(cd, cq, cJ, cC) {
          var cO = eI(cq, cJ, cC)
            , cG = Math['sqrt'](cO[0x0] * cO[0x0] + cO[0x1] * cO[0x1])
            , cg = cO[0x0] / cG
            , cN = cO[0x1] / cG
            , cP = ex(cq, cJ)
            , cM = ex(cJ, cC);
          if (cG > PlotConstants['ZERO_TOLERANCE']) {
              if (eT(cq, cJ, cC)) {
                  var cz = cd * cP
                    , cQ = cJ[0x0] - cz * cN
                    , cm = cJ[0x1] + cz * cg
                    , cL = [cQ, cm];
                  cz = cd * cM;
                  var cR = [cQ = cJ[0x0] + cz * cN, cm = cJ[0x1] - cz * cg];
              } else
                  cz = cd * cP,
                  cL = [cQ = cJ[0x0] + cz * cN, cm = cJ[0x1] - cz * cg],
                  cz = cd * cM,
                  cR = [cQ = cJ[0x0] - cz * cN, cm = cJ[0x1] + cz * cg];
          } else
              cL = [cQ = cJ[0x0] + cd * (cq[0x0] - cJ[0x0]), cm = cJ[0x1] + cd * (cq[0x1] - cJ[0x1])],
              cR = [cQ = cJ[0x0] + cd * (cC[0x0] - cJ[0x0]), cm = cJ[0x1] + cd * (cC[0x1] - cJ[0x1])];
          return [cL, cR];
      }
        , eI = function(cd, cq, cJ) {
          var cC = cd[0x0] - cq[0x0]
            , cO = cd[0x1] - cq[0x1]
            , cG = Math['sqrt'](cC * cC + cO * cO);
          cC /= cG,
          cO /= cG;
          var cg = cJ[0x0] - cq[0x0]
            , cN = cJ[0x1] - cq[0x1]
            , cP = Math['sqrt'](cg * cg + cN * cN);
          return [cC + (cg /= cP), cO + (cN /= cP)];
      }
        , ej = function(cd, cq) {
          var cJ = cd[0x0]
            , cC = cd[0x1]
            , cO = cd[0x2]
            , cG = eW(0x0, cJ, cC, cO)[0x0]
            , cg = eI(cJ, cC, cO);
          if (Math['sqrt'](cg[0x0] * cg[0x0] + cg[0x1] * cg[0x1]) > PlotConstants['ZERO_TOLERANCE'])
              var cN = ey(cJ, cC)
                , cP = cJ[0x0] - cN[0x0]
                , cM = cJ[0x1] - cN[0x1]
                , cz = 0x2 / ex(cJ, cC)
                , cQ = -cz * cM
                , cm = cz * cP
                , cL = cQ * cQ - cm * cm
                , cR = 0x2 * cQ * cm
                , H0 = cm * cm - cQ * cQ
                , H1 = cG[0x0] - cN[0x0]
                , H2 = cG[0x1] - cN[0x1]
                , H3 = cN[0x0] + cL * H1 + cR * H2
                , H4 = cN[0x1] + cR * H1 + H0 * H2;
          else
              H3 = cJ[0x0] + cq * (cC[0x0] - cJ[0x0]),
              H4 = cJ[0x1] + cq * (cC[0x1] - cJ[0x1]);
          return [H3, H4];
      }
        , eD = function(cd) {
          if (cd['length'] <= 0x2)
              return cd;
          for (var cq = [], cJ = cd['length'] - 0x1, cC = 0x0; cC <= 0x1; cC += 0.01) {
              for (var cO = 0x0, cG = 0x0, cg = 0x0; cg <= cJ; cg++) {
                  var cN = eV(cJ, cg)
                    , cP = Math['pow'](cC, cg)
                    , cM = Math['pow'](0x1 - cC, cJ - cg);
                  cO += cN * cP * cM * cd[cg][0x0],
                  cG += cN * cP * cM * cd[cg][0x1];
              }
              cq['push']([cO, cG]);
          }
          return cq['push'](cd[cJ]),
          cq;
      }
        , eV = function(cd, cq) {
          return eZ(cd) / (eZ(cq) * eZ(cd - cq));
      }
        , eZ = function(cd) {
          if (cd <= 0x1)
              return 0x1;
          if (0x2 == cd)
              return 0x2;
          if (0x3 == cd)
              return 0x6;
          if (0x4 == cd)
              return 0x18;
          if (0x5 == cd)
              return 0x78;
          for (var cq = 0x1, cJ = 0x1; cJ <= cd; cJ++)
              cq *= cJ;
          return cq;
      }
        , eB = function(cd) {
          if (cd['length'] <= 0x2)
              return cd;
          var cq = []
            , cJ = cd['length'] - 0x2 - 0x1;
          cq['push'](cd[0x0]);
          for (var cC = 0x0; cC <= cJ; cC++)
              for (var cO = 0x0; cO <= 0x1; cO += 0.05) {
                  for (var cG = 0x0, cg = 0x0, cN = 0x0; cN <= 0x2; cN++) {
                      var cP = eS(cN, cO);
                      cG += cP * cd[cC + cN][0x0],
                      cg += cP * cd[cC + cN][0x1];
                  }
                  cq['push']([cG, cg]);
              }
          return cq['push'](cd[cd['length'] - 0x1]),
          cq;
      }
        , eS = function(cd, cq) {
          return 0x0 == cd ? Math['pow'](cq - 0x1, 0x2) / 0x2 : 0x1 == cd ? (-0x2 * Math['pow'](cq, 0x2) + 0x2 * cq + 0x1) / 0x2 : 0x2 == cd ? Math['pow'](cq, 0x2) / 0x2 : 0x0;
      };
      class eU extends PlotLineBase {
          constructor() {
              super(...arguments),
              this['type'] = eH['ARC'],
              this['finishPointCount'] = 0x3;
          }
          ['generate']() {
              if (!(this['getPointCount']() <= 0x2)) {
                  var cd = this['points'][0x0]
                    , cq = this['points'][0x1]
                    , cJ = this['points'][0x2]
                    , cC = ew(cd, cq, cJ)
                    , cO = ex(cd, cC)
                    , cG = eu(cd, cC)
                    , cg = eu(cq, cC);
                  if (eT(cd, cq, cJ))
                      var cN = cg
                        , cP = cG;
                  else
                      cN = cG,
                      cP = cg;
                  this['setCoordinates'](ef(cC, cO, cN, cP));
              }
          }
      }
      class ed extends PlotPolygonBase {
          constructor() {
              super(...arguments),
              this['type'] = eH['ELLIPSE'],
              this['finishPointCount'] = 0x2;
          }
          ['generate']() {
              if (!(this['getPointCount']() < 0x2)) {
                  var cd = this['points'][0x0]
                    , cq = this['points'][0x1]
                    , cJ = ey(cd, cq)
                    , cC = Math['abs']((cd[0x0] - cq[0x0]) / 0x2)
                    , cO = Math['abs']((cd[0x1] - cq[0x1]) / 0x2);
                  this['setCoordinates']([this['generatePoints'](cJ, cC, cO)]);
              }
          }
          ['generatePoints'](cd, cq, cJ) {
              for (var cC, cO, cG, cg = [], cN = 0x0; cN <= PlotConstants['FITTING_COUNT']; cN++)
                  cG = 0x2 * Math['PI'] * cN / PlotConstants['FITTING_COUNT'],
                  cC = cd[0x0] + cq * Math['cos'](cG),
                  cO = cd[0x1] + cJ * Math['sin'](cG),
                  cg['push']([cC, cO]);
              return cg;
          }
      }
      class eq extends PlotLineBase {
          constructor() {
              super(...arguments),
              this['type'] = eH['CURVE'],
              this['t'] = 0.3;
          }
          ['generate']() {
              this['getPointCount']() <= 0x2 || this['setCoordinates'](function(cd, cq) {
                  for (var cJ = [ej(cq, cd)], cC = 0x0; cC < cq['length'] - 0x2; cC++) {
                      var cO = cq[cC]
                        , cG = cq[cC + 0x1]
                        , cg = cq[cC + 0x2]
                        , cN = eW(cd, cO, cG, cg);
                      cJ = cJ['concat'](cN);
                  }
                  var cP = function(cQ, cm) {
                      var cL = cQ['length']
                        , cR = cQ[cL - 0x3]
                        , H0 = cQ[cL - 0x2]
                        , H1 = cQ[cL - 0x1]
                        , H2 = eW(0x0, cR, H0, H1)[0x1]
                        , H3 = eI(cR, H0, H1);
                      if (Math['sqrt'](H3[0x0] * H3[0x0] + H3[0x1] * H3[0x1]) > PlotConstants['ZERO_TOLERANCE'])
                          var H4 = ey(H0, H1)
                            , H5 = H1[0x0] - H4[0x0]
                            , H6 = H1[0x1] - H4[0x1]
                            , H7 = 0x2 / ex(H0, H1)
                            , H8 = -H7 * H6
                            , H9 = H7 * H5
                            , Hv = H8 * H8 - H9 * H9
                            , HA = 0x2 * H8 * H9
                            , Hk = H9 * H9 - H8 * H8
                            , Hl = H2[0x0] - H4[0x0]
                            , HK = H2[0x1] - H4[0x1]
                            , Hb = H4[0x0] + Hv * Hl + HA * HK
                            , Hc = H4[0x1] + HA * Hl + Hk * HK;
                      else
                          Hb = H1[0x0] + cm * (H0[0x0] - H1[0x0]),
                          Hc = H1[0x1] + cm * (H0[0x1] - H1[0x1]);
                      return [Hb, Hc];
                  }(cq, cd);
                  cJ['push'](cP);
                  var cM = [];
                  for (cC = 0x0; cC < cq['length'] - 0x1; cC++) {
                      cO = cq[cC],
                      cG = cq[cC + 0x1],
                      cM['push'](cO);
                      for (let cQ = 0x0; cQ < PlotConstants['FITTING_COUNT']; cQ++) {
                          var cz = eX(cQ / PlotConstants['FITTING_COUNT'], cO, cJ[0x2 * cC], cJ[0x2 * cC + 0x1], cG);
                          cM['push'](cz);
                      }
                      cM['push'](cG);
                  }
                  return cM;
              }(this['t'], this['points']));
          }
      }
      class eJ extends PlotPolygonBase {
          constructor() {
              super(...arguments),
              this['type'] = eH['CLOSED_CURVE'],
              this['t'] = 0.3;
          }
          ['generate']() {
              if (!((cd = this['getPointCount']()) <= 0x2)) {
                  var cd, cq = this['getPoints']();
                  cq['push'](cq[0x0], cq[0x1]);
                  for (var cJ = [], cC = 0x0; cC < cq['length'] - 0x2; cC++) {
                      var cO = eW(this['t'], cq[cC], cq[cC + 0x1], cq[cC + 0x2]);
                      cJ = cJ['concat'](cO);
                  }
                  cJ = [cJ[(cd = cJ['length']) - 0x1]]['concat'](cJ['slice'](0x0, cd - 0x1));
                  var cG = [];
                  for (cC = 0x0; cC < cq['length'] - 0x2; cC++) {
                      var cg = cq[cC]
                        , cN = cq[cC + 0x1];
                      cG['push'](cg);
                      for (var cP = 0x0; cP <= PlotConstants['FITTING_COUNT']; cP++) {
                          var cM = eX(cP / PlotConstants['FITTING_COUNT'], cg, cJ[0x2 * cC], cJ[0x2 * cC + 0x1], cN);
                          cG['push'](cM);
                      }
                      cG['push'](cN);
                  }
                  this['setCoordinates']([cG]);
              }
          }
      }
      class eC extends PlotPolygonBase {
          constructor() {
              super(...arguments),
              this['type'] = eH['LUNE'],
              this['finishPointCount'] = 0x3;
          }
          ['generate']() {
              if (!(this['getPointCount']() < 0x2)) {
                  var cd = this['getPoints']();
                  if (0x2 == this['getPointCount']()) {
                      var cq = ey(cd[0x0], cd[0x1])
                        , cJ = ex(cd[0x0], cq)
                        , cC = eE(cd[0x0], cq, PlotConstants['HALF_PI'], cJ, undefined);
                      cd['push'](cC);
                  }
                  var cO = cd[0x0]
                    , cG = cd[0x1]
                    , cg = cd[0x2]
                    , cN = ew(cO, cG, cg)
                    , cP = ex(cO, cN)
                    , cM = eu(cO, cN)
                    , cz = eu(cG, cN);
                  if (eT(cO, cG, cg))
                      var cQ = cz
                        , cm = cM;
                  else
                      cQ = cM,
                      cm = cz;
                  (cd = ef(cN, cP, cQ, cm))['push'](cd[0x0]),
                  this['setCoordinates']([cd]);
              }
          }
      }
      class eO extends PlotPolygonBase {
          constructor() {
              super(...arguments),
              this['type'] = eH['SECTOR'],
              this['finishPointCount'] = 0x3;
          }
          ['generate']() {
              if (!(this['getPointCount']() <= 0x2)) {
                  var cd = this['getPoints']()
                    , cq = cd[0x0]
                    , cJ = cd[0x1]
                    , cC = cd[0x2]
                    , cO = ex(cJ, cq)
                    , cG = eu(cJ, cq)
                    , cg = eu(cC, cq)
                    , cN = ef(cq, cO, cG, cg);
                  cN['push'](cq, cN[0x0]),
                  this['setCoordinates']([cN]);
              }
          }
      }
      class eG extends PlotPolygonBase {
          constructor() {
              super(...arguments),
              this['type'] = eH['GATHERING_PLACE'],
              this['t'] = 0.4,
              this['finishPointCount'] = 0x3;
          }
          ['generate']() {
              var cd = this['getPoints']();
              if (!(cd['length'] < 0x2)) {
                  if (0x2 == this['getPointCount']()) {
                      var cq = ey(cd[0x0], cd[0x1])
                        , cJ = ex(cd[0x0], cq) / 0.9
                        , cC = eE(cd[0x0], cq, PlotConstants['HALF_PI'], cJ, true);
                      cd = [cd[0x0], cC, cd[0x1]];
                  }
                  cq = ey(cd[0x0], cd[0x2]),
                  cd['push'](cq, cd[0x0], cd[0x1]);
                  for (var cO = [], cG = 0x0; cG < cd['length'] - 0x2; cG++) {
                      var cg = cd[cG]
                        , cN = cd[cG + 0x1]
                        , cP = cd[cG + 0x2]
                        , cM = eW(this['t'], cg, cN, cP);
                      cO = cO['concat'](cM);
                  }
                  var cz = cO['length'];
                  cO = [cO[cz - 0x1]]['concat'](cO['slice'](0x0, cz - 0x1));
                  var cQ = [];
                  for (cG = 0x0; cG < cd['length'] - 0x2; cG++) {
                      cg = cd[cG],
                      cN = cd[cG + 0x1],
                      cQ['push'](cg);
                      for (var cm = 0x0; cm <= PlotConstants['FITTING_COUNT']; cm++)
                          cC = eX(cm / PlotConstants['FITTING_COUNT'], cg, cO[0x2 * cG], cO[0x2 * cG + 0x1], cN),
                          cQ['push'](cC);
                      cQ['push'](cN);
                  }
                  this['setCoordinates']([cQ]);
              }
          }
      }
      class eg extends PlotPolygonBase {
          constructor() {
              super(...arguments),
              this['type'] = eH['FINE_ARROW'],
              this['tailWidthFactor'] = 0.15,
              this['neckWidthFactor'] = 0.2,
              this['headWidthFactor'] = 0.25,
              this['headAngle'] = Math['PI'] / 8.5,
              this['neckAngle'] = Math['PI'] / 0xd,
              this['finishPointCount'] = 0x2;
          }
          ['generate']() {
              if (!(this['getPointCount']() < 0x2)) {
                  var cd = this['getPoints']()
                    , cq = cd[0x0]
                    , cJ = cd[0x1]
                    , cC = eF(cd)
                    , cO = cC * this['tailWidthFactor']
                    , cG = cC * this['neckWidthFactor']
                    , cg = cC * this['headWidthFactor']
                    , cN = eE(cJ, cq, PlotConstants['HALF_PI'], cO, true)
                    , cP = eE(cJ, cq, PlotConstants['HALF_PI'], cO, false)
                    , cM = eE(cq, cJ, this['headAngle'], cg, false)
                    , cz = eE(cq, cJ, this['headAngle'], cg, true)
                    , cQ = [cN, eE(cq, cJ, this['neckAngle'], cG, false), cM, cJ, cz, eE(cq, cJ, this['neckAngle'], cG, true), cP];
                  this['setCoordinates']([cQ]);
              }
          }
      }
      class eN extends eg {
          constructor() {
              super(...arguments),
              this['type'] = eH['ASSAULT_DIRECTION'],
              this['tailWidthFactor'] = 0.2,
              this['neckWidthFactor'] = 0.25,
              this['headWidthFactor'] = 0.3,
              this['headAngle'] = Math['PI'] / 0x4,
              this['neckAngle'] = 0.17741 * Math['PI'];
          }
      }
      class eP extends PlotPolygonBase {
          constructor() {
              super(...arguments),
              this['type'] = eH['ATTACK_ARROW'],
              this['headHeightFactor'] = 0.18,
              this['headWidthFactor'] = 0.3,
              this['neckHeightFactor'] = 0.85,
              this['neckWidthFactor'] = 0.15,
              this['headTailFactor'] = 0.8;
          }
          ['generate']() {
              if (!(this['getPointCount']() <= 0x2)) {
                  var cd = this['getPoints']()
                    , cq = cd[0x0]
                    , cJ = cd[0x1];
                  eT(cd[0x0], cd[0x1], cd[0x2]) && (cq = cd[0x1],
                  cJ = cd[0x0]);
                  var cC = [ey(cq, cJ)]['concat'](cd['slice'](0x2))
                    , cO = this['getArrowHeadPoints'](cC, cq, cJ)
                    , cG = cO[0x0]
                    , cg = cO[0x4]
                    , cN = ex(cq, cJ) / eF(cC)
                    , cP = this['getArrowBodyPoints'](cC, cG, cg, cN)
                    , cM = cP['length']
                    , cz = [cq]['concat'](cP['slice'](0x0, cM / 0x2));
                  cz['push'](cG);
                  var cQ = [cJ]['concat'](cP['slice'](cM / 0x2, cM));
                  cQ['push'](cg),
                  cz = eB(cz),
                  cQ = eB(cQ),
                  this['setCoordinates']([cz['concat'](cO, cQ['reverse']())]);
              }
          }
          ['getArrowHeadPoints'](cd, cq, cJ) {
              var cC = eF(cd)
                , cO = cC * this['headHeightFactor']
                , cG = cd[cd['length'] - 0x1];
              cC = ex(cG, cd[cd['length'] - 0x2]);
              var cg = ex(cq, cJ);
              cO > cg * this['headTailFactor'] && (cO = cg * this['headTailFactor']);
              var cN = cO * this['headWidthFactor']
                , cP = cO * this['neckWidthFactor']
                , cM = (cO = cO > cC ? cC : cO) * this['neckHeightFactor']
                , cz = eE(cd[cd['length'] - 0x2], cG, 0x0, cO, true)
                , cQ = eE(cd[cd['length'] - 0x2], cG, 0x0, cM, true)
                , cm = eE(cG, cz, PlotConstants['HALF_PI'], cN, false)
                , cL = eE(cG, cz, PlotConstants['HALF_PI'], cN, true);
              return [eE(cG, cQ, PlotConstants['HALF_PI'], cP, false), cm, cG, cL, eE(cG, cQ, PlotConstants['HALF_PI'], cP, true)];
          }
          ['getArrowBodyPoints'](cd, cq, cJ, cC) {
              for (var cO = ep(cd), cG = eF(cd) * cC, cg = (cG - ex(cq, cJ)) / 0x2, cN = 0x0, cP = [], cM = [], cz = 0x1; cz < cd['length'] - 0x1; cz++) {
                  var cQ = eY(cd[cz - 0x1], cd[cz], cd[cz + 0x1]) / 0x2
                    , cm = (cG / 0x2 - (cN += ex(cd[cz - 0x1], cd[cz])) / cO * cg) / Math['sin'](cQ)
                    , cL = eE(cd[cz - 0x1], cd[cz], Math['PI'] - cQ, cm, true)
                    , cR = eE(cd[cz - 0x1], cd[cz], cQ, cm, false);
                  cP['push'](cL),
                  cM['push'](cR);
              }
              return cP['concat'](cM);
          }
      }
      class eM extends PlotPolygonBase {
          constructor() {
              super(...arguments),
              this['type'] = eH['CIRCLE'],
              this['finishPointCount'] = 0x2;
          }
          ['generate']() {
              if (!(this['getPointCount']() < 0x2)) {
                  var cd = this['points'][0x0]
                    , cq = ex(cd, this['points'][0x1]);
                  this['setCoordinates']([this['generatePoints'](cd, cq)]);
              }
          }
          ['generatePoints'](cd, cq) {
              for (var cJ, cC, cO, cG = [], cg = 0x0; cg <= PlotConstants['FITTING_COUNT']; cg++)
                  cO = 0x2 * Math['PI'] * cg / PlotConstants['FITTING_COUNT'],
                  cJ = cd[0x0] + cq * Math['cos'](cO),
                  cC = cd[0x1] + cq * Math['sin'](cO),
                  cG['push']([cJ, cC]);
              return cG;
          }
      }
      class ez extends PlotPolygonBase {
          constructor() {
              super(...arguments),
              this['type'] = eH['DOUBLE_ARROW'],
              this['headHeightFactor'] = 0.25,
              this['headWidthFactor'] = 0.3,
              this['neckHeightFactor'] = 0.85,
              this['neckWidthFactor'] = 0.15,
              this['connPoint'] = null,
              this['tempPoint4'] = null,
              this['finishPointCount'] = 0x4;
          }
          ['finishDrawing']() {
              0x3 == this['getPointCount']() && null != this['tempPoint4'] && this['points']['push'](this['tempPoint4']),
              null != this['connPoint'] && this['points']['push'](this['connPoint']);
          }
          ['generate']() {
              if (!((cG = this['getPointCount']()) <= 0x2)) {
                  var cd, cq, cJ = this['points'][0x0], cC = this['points'][0x1], cO = this['points'][0x2], cG = this['getPointCount']();
                  this['tempPoint4'] = 0x3 == cG ? this['getTempPoint4'](cJ, cC, cO) : this['points'][0x3],
                  this['connPoint'] = 0x3 == cG || 0x4 == cG ? ey(cJ, cC) : this['points'][0x4],
                  eT(cJ, cC, cO) ? (cd = this['getArrowPoints'](cJ, this['connPoint'], this['tempPoint4'], false),
                  cq = this['getArrowPoints'](this['connPoint'], cC, cO, true)) : (cd = this['getArrowPoints'](cC, this['connPoint'], cO, false),
                  cq = this['getArrowPoints'](this['connPoint'], cJ, this['tempPoint4'], true));
                  var cg = cd['length']
                    , cN = (cg - 0x5) / 0x2
                    , cP = cd['slice'](0x0, cN)
                    , cM = cd['slice'](cN, cN + 0x5)
                    , cz = cd['slice'](cN + 0x5, cg)
                    , cQ = cq['slice'](0x0, cN)
                    , cm = cq['slice'](cN, cN + 0x5)
                    , cL = cq['slice'](cN + 0x5, cg);
                  cQ = eD(cQ);
                  var cR = eD(cL['concat'](cP['slice'](0x1)));
                  cz = eD(cz);
                  var H0 = cQ['concat'](cm, cR, cM, cz);
                  this['setCoordinates']([H0]);
              }
          }
          ['getArrowPoints'](cd, cq, cJ, cC) {
              var cO = ey(cd, cq)
                , cG = ex(cO, cJ)
                , cg = eE(cJ, cO, 0x0, 0.3 * cG, true)
                , cN = eE(cJ, cO, 0x0, 0.5 * cG, true)
                , cP = [cO, cg = eE(cO, cg, PlotConstants['HALF_PI'], cG / 0x5, cC), cN = eE(cO, cN, PlotConstants['HALF_PI'], cG / 0x4, cC), cJ]
                , cM = this['getArrowHeadPoints'](cP, this['headHeightFactor'], this['headWidthFactor'])
                , cz = cM[0x0]
                , cQ = cM[0x4]
                , cm = ex(cd, cq) / eF(cP) / 0x2
                , cL = this['getArrowBodyPoints'](cP, cz, cQ, cm)
                , cR = cL['length']
                , H0 = cL['slice'](0x0, cR / 0x2)
                , H1 = cL['slice'](cR / 0x2, cR);
              return H0['push'](cz),
              H1['push'](cQ),
              (H0 = H0['reverse']())['push'](cq),
              (H1 = H1['reverse']())['push'](cd),
              H0['reverse']()['concat'](cM, H1);
          }
          ['getArrowHeadPoints'](cd, cq, cJ) {
              var cC = eF(cd) * this['headHeightFactor']
                , cO = cd[cd['length'] - 0x1]
                , cG = (ex(cq, cJ),
              cC * this['headWidthFactor'])
                , cg = cC * this['neckWidthFactor']
                , cN = cC * this['neckHeightFactor']
                , cP = eE(cd[cd['length'] - 0x2], cO, 0x0, cC, true)
                , cM = eE(cd[cd['length'] - 0x2], cO, 0x0, cN, true)
                , cz = eE(cO, cP, PlotConstants['HALF_PI'], cG, false)
                , cQ = eE(cO, cP, PlotConstants['HALF_PI'], cG, true);
              return [eE(cO, cM, PlotConstants['HALF_PI'], cg, false), cz, cO, cQ, eE(cO, cM, PlotConstants['HALF_PI'], cg, true)];
          }
          ['getArrowBodyPoints'](cd, cq, cJ, cC) {
              for (var cO = ep(cd), cG = eF(cd) * cC, cg = (cG - ex(cq, cJ)) / 0x2, cN = 0x0, cP = [], cM = [], cz = 0x1; cz < cd['length'] - 0x1; cz++) {
                  var cQ = eY(cd[cz - 0x1], cd[cz], cd[cz + 0x1]) / 0x2
                    , cm = (cG / 0x2 - (cN += ex(cd[cz - 0x1], cd[cz])) / cO * cg) / Math['sin'](cQ)
                    , cL = eE(cd[cz - 0x1], cd[cz], Math['PI'] - cQ, cm, true)
                    , cR = eE(cd[cz - 0x1], cd[cz], cQ, cm, false);
                  cP['push'](cL),
                  cM['push'](cR);
              }
              return cP['concat'](cM);
          }
          ['getTempPoint4'](cd, cq, cJ) {
              var cC, cO, cG, cg, cN = ey(cd, cq), cP = ex(cN, cJ), cM = eY(cd, cN, cJ);
              return cM < PlotConstants['HALF_PI'] ? (cO = cP * Math['sin'](cM),
              cG = cP * Math['cos'](cM),
              cg = eE(cd, cN, PlotConstants['HALF_PI'], cO, false),
              cC = eE(cN, cg, PlotConstants['HALF_PI'], cG, true)) : cM >= PlotConstants['HALF_PI'] && cM < Math['PI'] ? (cO = cP * Math['sin'](Math['PI'] - cM),
              cG = cP * Math['cos'](Math['PI'] - cM),
              cg = eE(cd, cN, PlotConstants['HALF_PI'], cO, false),
              cC = eE(cN, cg, PlotConstants['HALF_PI'], cG, false)) : cM >= Math['PI'] && cM < 1.5 * Math['PI'] ? (cO = cP * Math['sin'](cM - Math['PI']),
              cG = cP * Math['cos'](cM - Math['PI']),
              cg = eE(cd, cN, PlotConstants['HALF_PI'], cO, true),
              cC = eE(cN, cg, PlotConstants['HALF_PI'], cG, true)) : (cO = cP * Math['sin'](0x2 * Math['PI'] - cM),
              cG = cP * Math['cos'](0x2 * Math['PI'] - cM),
              cg = eE(cd, cN, PlotConstants['HALF_PI'], cO, true),
              cC = eE(cN, cg, PlotConstants['HALF_PI'], cG, false)),
              cC;
          }
      }
      class eQ extends eP {
          constructor() {
              super(...arguments),
              this['type'] = eH['TAILED_ATTACK_ARROW'],
              this['headHeightFactor'] = 0.18,
              this['headWidthFactor'] = 0.3,
              this['neckHeightFactor'] = 0.85,
              this['neckWidthFactor'] = 0.15,
              this['tailWidthFactor'] = 0.1,
              this['headTailFactor'] = 0.8,
              this['swallowTailFactor'] = 0x1,
              this['swallowTailPnt'] = null;
          }
          ['generate']() {
              if (!((cm = this['getPointCount']()) <= 0x2)) {
                  var cd = this['getPoints']()
                    , cq = cd[0x0]
                    , cJ = cd[0x1];
                  eT(cd[0x0], cd[0x1], cd[0x2]) && (cq = cd[0x1],
                  cJ = cd[0x0]);
                  var cC = [ey(cq, cJ)]['concat'](cd['slice'](0x2))
                    , cO = this['getArrowHeadPoints'](cC, cq, cJ)
                    , cG = cO[0x0]
                    , cg = cO[0x4]
                    , cN = ex(cq, cJ)
                    , cP = eF(cC)
                    , cM = cP * this['tailWidthFactor'] * this['swallowTailFactor'];
                  this['swallowTailPnt'] = eE(cC[0x1], cC[0x0], 0x0, cM, true);
                  var cz = cN / cP
                    , cQ = this['getArrowBodyPoints'](cC, cG, cg, cz)
                    , cm = cQ['length']
                    , cL = [cq]['concat'](cQ['slice'](0x0, cm / 0x2));
                  cL['push'](cG);
                  var cR = [cJ]['concat'](cQ['slice'](cm / 0x2, cm));
                  cR['push'](cg),
                  cL = eB(cL),
                  cR = eB(cR),
                  this['setCoordinates']([cL['concat'](cO, cR['reverse'](), [this['swallowTailPnt'], cL[0x0]])]);
              }
          }
      }
      class em extends eP {
          constructor() {
              super(...arguments),
              this['type'] = eH['SQUAD_COMBAT'],
              this['headHeightFactor'] = 0.18,
              this['headWidthFactor'] = 0.3,
              this['neckHeightFactor'] = 0.85,
              this['neckWidthFactor'] = 0.15,
              this['tailWidthFactor'] = 0.1;
          }
          ['generate']() {
              if (!((cg = this['getPointCount']()) < 0x2)) {
                  var cd = this['getPoints']()
                    , cq = this['getTailPoints'](cd)
                    , cJ = this['getArrowHeadPoints'](cd, cq[0x0], cq[0x1])
                    , cC = cJ[0x0]
                    , cO = cJ[0x4]
                    , cG = this['getArrowBodyPoints'](cd, cC, cO, this['tailWidthFactor'])
                    , cg = cG['length']
                    , cN = [cq[0x0]]['concat'](cG['slice'](0x0, cg / 0x2));
                  cN['push'](cC);
                  var cP = [cq[0x1]]['concat'](cG['slice'](cg / 0x2, cg));
                  cP['push'](cO),
                  cN = eB(cN),
                  cP = eB(cP),
                  this['setCoordinates']([cN['concat'](cJ, cP['reverse']())]);
              }
          }
          ['getTailPoints'](cd) {
              var cq = eF(cd) * this['tailWidthFactor'];
              return [eE(cd[0x1], cd[0x0], PlotConstants['HALF_PI'], cq, false), eE(cd[0x1], cd[0x0], PlotConstants['HALF_PI'], cq, true)];
          }
      }
      class eL extends eP {
          constructor() {
              super(...arguments),
              this['type'] = eH['TAILED_SQUAD_COMBAT'],
              this['headHeightFactor'] = 0.18,
              this['headWidthFactor'] = 0.3,
              this['neckHeightFactor'] = 0.85,
              this['neckWidthFactor'] = 0.15,
              this['tailWidthFactor'] = 0.1,
              this['swallowTailFactor'] = 0x1,
              this['swallowTailPnt'] = null;
          }
          ['generate']() {
              if (!((cg = this['getPointCount']()) < 0x2)) {
                  var cd = this['getPoints']()
                    , cq = this['getTailPoints'](cd)
                    , cJ = this['getArrowHeadPoints'](cd, cq[0x0], cq[0x2])
                    , cC = cJ[0x0]
                    , cO = cJ[0x4]
                    , cG = this['getArrowBodyPoints'](cd, cC, cO, this['tailWidthFactor'])
                    , cg = cG['length']
                    , cN = [cq[0x0]]['concat'](cG['slice'](0x0, cg / 0x2));
                  cN['push'](cC);
                  var cP = [cq[0x2]]['concat'](cG['slice'](cg / 0x2, cg));
                  cP['push'](cO),
                  cN = eB(cN),
                  cP = eB(cP),
                  this['setCoordinates']([cN['concat'](cJ, cP['reverse'](), [cq[0x1], cN[0x0]])]);
              }
          }
          ['getTailPoints'](cd) {
              var cq = eF(cd) * this['tailWidthFactor']
                , cJ = eE(cd[0x1], cd[0x0], PlotConstants['HALF_PI'], cq, false)
                , cC = eE(cd[0x1], cd[0x0], PlotConstants['HALF_PI'], cq, true)
                , cO = cq * this['swallowTailFactor'];
              return [cJ, eE(cd[0x1], cd[0x0], 0x0, cO, true), cC];
          }
      }
      class eR extends PlotLineBase {
          constructor() {
              super(...arguments),
              this['type'] = eH['FREEHAND_LINE'],
              this['freehand'] = true;
          }
          ['generate']() {
              this['getPointCount']() < 0x2 || this['setCoordinates'](this['points']);
          }
      }
      class c0 extends PlotPolygonBase {
          constructor() {
              super(...arguments),
              this['type'] = eH['FREEHAND_POLYGON'],
              this['freehand'] = true;
          }
          ['generate']() {
              this['getPointCount']() <= 0x2 || this['setCoordinates']([this['points']]);
          }
      }
      class c1 extends PlotPolygonBase {
          constructor() {
              super(...arguments),
              this['type'] = eH['POLYGON'];
          }
          ['generate']() {
              this['getPointCount']() <= 0x2 || this['setCoordinates']([this['points']]);
          }
      }
      class c2 extends PlotPointBase {
          constructor() {
              super(...arguments),
              this['type'] = eH['MARKER'],
              this['finishPointCount'] = 0x1;
          }
          ['generate']() {
              var cd = this['points'][0x0];
              this['setCoordinates'](cd);
          }
      }
      class c3 extends PlotLineBase {
          constructor(cd, cq) {
              super(cd),
              this['type'] = eH['POLYLINE'],
              (null == cq ? undefined : cq['finishPointCount']) > 0x1 && (this['finishPointCount'] = cq['finishPointCount']);
          }
          ['generate']() {
              this['getPointCount']() < 0x2 || this['setCoordinates'](this['points']);
          }
      }
      class c4 extends PlotLineBase {
          constructor() {
              super(...arguments),
              this['type'] = eH['STRAIGHT_ARROW'],
              this['finishPointCount'] = 0x2,
              this['maxArrowLength'] = 0x2dc6c0,
              this['arrowLengthScale'] = 0x5;
          }
          ['generate']() {
              if (!(this['getPointCount']() < 0x2)) {
                  var cd = this['getPoints']()
                    , cq = cd[0x0]
                    , cJ = cd[0x1]
                    , cC = ex(cq, cJ) / this['arrowLengthScale'];
                  cC = cC > this['maxArrowLength'] ? this['maxArrowLength'] : cC;
                  var cO = eE(cq, cJ, Math['PI'] / 0x6, cC, false)
                    , cG = eE(cq, cJ, Math['PI'] / 0x6, cC, true);
                  this['setCoordinates']([cq, cJ, cO, cJ, cG]);
              }
          }
      }
      class c5 extends PlotPolygonBase {
          constructor() {
              super(...arguments),
              this['type'] = eH['RECTANGLE'],
              this['finishPointCount'] = 0x2;
          }
          ['generate']() {
              if (!(this['getPointCount']() < 0x2)) {
                  var cd = this['points'][0x0]
                    , cq = this['points'][0x1]
                    , cJ = Math['min'](cd[0x0], cq[0x0])
                    , cC = Math['max'](cd[0x0], cq[0x0])
                    , cO = Math['min'](cd[0x1], cq[0x1])
                    , cG = Math['max'](cd[0x1], cq[0x1])
                    , cg = [cJ, cG]
                    , cN = [cC, cG]
                    , cP = [cC, cO]
                    , cM = [cJ, cO];
                  this['setCoordinates']([[cg, cN, cP, cM]]);
              }
          }
      }
      const c6 = {};
      function c7(cd, cq) {
          c6[cd] = cq;
      }
      function createDrawPlot(cd, cq, cJ) {
          if (c6[cd] && 'function' == typeof c6[cd])
              return c6[cd](cq);
          switch (cd) {
          case eH['ARC']:
              return new eU(cq);
          case eH['ELLIPSE']:
              return new ed(cq);
          case eH['CURVE']:
              return new eq(cq);
          case eH['CLOSED_CURVE']:
              return new eJ(cq);
          case eH['LUNE']:
              return new eC(cq);
          case eH['SECTOR']:
              return new eO(cq);
          case eH['GATHERING_PLACE']:
              return new eG(cq);
          case eH['STRAIGHT_ARROW']:
              return new c4(cq);
          case eH['ASSAULT_DIRECTION']:
              return new eN(cq);
          case eH['ATTACK_ARROW']:
              return new eP(cq);
          case eH['FINE_ARROW']:
              return new eg(cq);
          case eH['CIRCLE']:
              return new eM(cq);
          case eH['DOUBLE_ARROW']:
              return new ez(cq);
          case eH['TAILED_ATTACK_ARROW']:
              return new eQ(cq);
          case eH['SQUAD_COMBAT']:
              return new em(cq);
          case eH['TAILED_SQUAD_COMBAT']:
              return new eL(cq);
          case eH['FREEHAND_LINE']:
              return new eR(cq);
          case eH['FREEHAND_POLYGON']:
              return new c0(cq);
          case eH['POLYGON']:
              return new c1(cq);
          case eH['MARKER']:
              return new c2(cq);
          case eH['RECTANGLE']:
              return new c5(cq);
          case eH['POLYLINE']:
              return new c3(cq,cJ);
          }
          throw new Error('' + cd);
      }
      var c9;
      !function(cd) {
          cd[cd['left'] = 0x0] = 'left',
          cd[cd['middle'] = 0x1] = 'middle',
          cd[cd['right'] = 0x2] = 'right';
      }(c9 || (c9 = {}));
      class VectorMapTool extends iT['c'] {
          constructor(cd) {
              super(),
              this['dragging'] = false,
              this['movePointAdded'] = false,
              this['draggingMoved'] = false,
              this['onPointerDown'] = cq=>{
                  this['dragging'] = true,
                  this['draggingMoved'] = true,
                  this['pointDownTime'] = performance['now']();
              }
              ,
              this['onPointerMove'] = cq=>{
                  if (this['dragging'])
                      this['draggingMoved'] = true;
                  else {
                      if (this['shape']) {
                          if (this['shape']['freehand'])
                              return this['shape']['addPoint'](cq['coords']),
                              void this['updateShape']();
                          this['movePointAdded'] ? this['shape']['updateLastPoint'](cq['coords']) : this['shape']['addPoint'](cq['coords']) && (this['movePointAdded'] = true),
                          this['updateShape']();
                      }
                  }
              }
              ,
              this['onPointerUp'] = cq=>{
                  if (this['dragging'] = false,
                  cq['buttonType'] === c9['left']) {
                      const cJ = this['pointDownTime'] && performance['now']() - this['pointDownTime'] || 0x0;
                      if (this['draggingMoved'] && cJ > VectorMapTool['PointDownAsDragTime'])
                          return this['draggingMoved'] = false,
                          void (this['pointDownTime'] = undefined);
                      v0['kg']['debug']('pointer\x20down\x20time\x20' + cJ),
                      this['shape'] ? this['movePointAdded'] || this['shape']['addPoint'](cq['coords']) : (this['shape'] = createDrawPlot(this['options']['drawType'], [cq['coords']], this['options']['shapeOptions']),
                      this['options']['autoClear'] && this['clear']()),
                      this['updateShape'](),
                      this['fire'](VectorMapTool['EventTypes']['pointAdd'], {
                          'firer': this,
                          'msg': {
                              'point': cq['coords'],
                              'source': cq
                          }
                      }),
                      this['shape']['finishPointCount'] > 0x0 && this['shape']['getPointCount']() >= this['shape']['finishPointCount'] && this['finishDraw'](cq);
                  } else
                      this['shape'] && cq['buttonType'] === c9['right'] && (this['fire'](VectorMapTool['EventTypes']['pointAdd'], {
                          'firer': this,
                          'msg': {
                              'point': cq['coords'],
                              'source': cq
                          }
                      }),
                      this['finishDraw'](cq));
                  this['movePointAdded'] = false;
              }
              ,
              this['options'] = cd,
              this['listeners'] = {
                  'onPointerDown': this['onPointerDown'],
                  'onPointerMove': this['onPointerMove'],
                  'onPointerUp': this['onPointerUp']
              };
          }
          ['finishDraw'](cd) {
              var cq;
              this['shape'] && this['shape']['generated'] && this['fire'](VectorMapTool['EventTypes']['drawFinish'], {
                  'firer': this,
                  'msg': cd
              }),
              this['options']['continious'] ? (null === (cq = this['options']['tempLineRenderer']) || undefined === cq || cq['clear'](),
              this['tempLineShape'] = undefined,
              this['shape'] = undefined,
              this['drawId'] = (0x0,
              Kz['hQ'])()) : this['end'](),
              this['fire'](VectorMapTool['EventTypes']['afterFinish'], {
                  'firer': this,
                  'msg': cd
              });
          }
          ['updateShape']() {
              var cd, cq, cJ;
              if (this['shape']['generated'])
                  return this['tempLineShape'] && (null === (cd = this['options']['tempLineRenderer']) || undefined === cd || cd['clear'](),
                  this['tempLineShape'] = undefined),
                  void (null === (cq = this['options']['renderer']) || undefined === cq || cq['updateShape'](this['drawId'], this['shape'], this['properties']));
              this['tempLineShape'] || (this['tempLineShape'] = new c3()),
              this['tempLineShape']['setPoints'](this['shape']['getPoints'](false)),
              null === (cJ = this['options']['tempLineRenderer']) || undefined === cJ || cJ['updateShape'](this['drawId'] + '_temp', this['tempLineShape'], this['properties']);
          }
          ['addPoint'](cd) {
              this['shape'] ? this['shape']['addPoint'](cd) : (this['shape'] = createDrawPlot(this['options']['drawType'], [cd], this['options']['shapeOptions']),
              this['options']['autoClear'] && this['clear']());
          }
          ['begin'](cd) {
              this['options']['renderer'] && this['options']['tempLineRenderer'] ? (this['properties'] = cd,
              this['options']['lockMapWhenPlot'] && this['lockMap'](),
              this['drawId'] = (0x0,
              Kz['hQ'])(),
              this['setListeners']()) : v0['kg']['error']('vectorrenderertempLineRenderer');
          }
          ['end']() {
              var cd;
              this['unsetListeners'](),
              this['options']['lockMapWhenPlot'] && this['unlockMap'](),
              null === (cd = this['options']['tempLineRenderer']) || undefined === cd || cd['clear'](),
              this['drawId'] = undefined,
              this['shape'] = undefined;
          }
          ['setMap'](cd) {
              var cq, cJ;
              this['map'] = cd,
              null === (cq = this['options']['renderer']) || undefined === cq || cq['setMap'](cd),
              null === (cJ = this['options']['tempLineRenderer']) || undefined === cJ || cJ['setMap'](cd);
          }
          ['updateDrawType'](cd) {
              this['options']['drawType'] = cd,
              this['drawId'] && this['finishDraw'](undefined);
          }
          ['getGeoJSON']() {
              var cd;
              return null === (cd = this['options']['renderer']) || undefined === cd ? undefined : cd['getGeoJSON']();
          }
          ['pick'](cd) {
              var cq;
              return null === (cq = this['options']['renderer']) || undefined === cq ? undefined : cq['pick'](cd);
          }
          ['clear']() {
              var cd, cq;
              null === (cd = this['options']['renderer']) || undefined === cd || cd['clear'](),
              null === (cq = this['options']['tempLineRenderer']) || undefined === cq || cq['clear']();
          }
      }
      VectorMapTool['EventTypes'] = {
          'drawFinish': 'draw:finish',
          'pointAdd': 'point:add',
          'afterFinish': 'after:finish'
      },
      VectorMapTool['PointDownAsDragTime'] = 0xc8;
      class cA {
          constructor() {
              this['EarthRadius'] = 6371.1,
              this['rx'] = this['ry'] = 0x0,
              this['r_res'] = 0x1;
          }
          ['geo2polar'](cd, cq, cJ) {
              const cC = Math['sin'](cd) * Math['sin'](this['r_phy']) + Math['cos'](cd) * Math['cos'](this['r_phy']) * Math['cos'](cq);
              let cO = Math['sqrt'](0x1 - cC * cC);
              cO > 0x1 ? cO = 0x1 : cO < -0x1 && (cO = -0x1);
              const cG = Math['asin'](cO);
              let cg = Math['cos'](cd) * Math['sin'](cq) / cO;
              cg > 0x1 ? cg = 0x1 : cg < -0x1 && (cg = -0x1);
              let cN = Math['asin'](cg);
              cd < Math['asin'](cC * Math['sin'](this['r_phy'])) ? cN = Math['PI'] - cN : cq < 0x0 && (cN = 0x2 * Math['PI'] + cN),
              cJ['beta'] = cG,
              cJ['theta'] = cN;
          }
          ['polar2geo'](cd, cq, cJ) {
              const cC = Math['cos'](cd) * Math['sin'](this['r_phy']) + Math['sin'](cd) * Math['cos'](this['r_phy']) * Math['cos'](cq)
                , cO = Math['sqrt'](0x1 - cC * cC)
                , cG = Math['asin'](cC);
              let cg = Math['sin'](cq) * Math['sin'](cd) / cO;
              cg > 0x1 ? cg = 0x1 : cg < -0x1 && (cg = -0x1);
              const cN = Math['asin'](cg);
              cJ['phy'] = cG,
              cJ['delta_numda'] = cN;
          }
          ['arcS_of_gps'](cd, cq, cJ) {
              const cC = cq / this['EarthRadius']
                , cO = cd * Math['PI'] / 0xb4;
              let cG = {
                  'phy': undefined,
                  'delta_numda': undefined
              };
              this['polar2geo'](cC, cO, cG);
              const cg = 0xb4 * cG['phy'] / Math['PI']
                , cN = 0xb4 * (cG['delta_numda'] + this['r_numda']) / Math['PI'];
              cJ['lon'] = cN,
              cJ['lat'] = cg;
          }
          ['gps_to_Azimuth'](cd, cq, cJ) {
              const cC = cq * Math['PI'] / 0xb4
                , cO = cd * Math['PI'] / 0xb4 - this['r_numda'];
              let cG = {
                  'beta': undefined,
                  'theta': undefined
              };
              this['geo2polar'](cC, cO, cG);
              const cg = 0xb4 * cG['theta'] / Math['PI'];
              cJ['az'] = cg,
              cJ['beta'] = cG['beta'];
          }
          ['gps_to_arcS'](cd, cq, cJ) {
              const cC = {
                  'az': undefined,
                  'beta': undefined
              };
              if (this['gps_to_Azimuth'](cd, cq, cC),
              undefined === cJ['S'])
                  throw new Error('S\x20can\x27t\x20be\x20undefined');
              let cO = cJ['S'] * this['EarthRadius'];
              cJ['az'] = cC['az'],
              cJ['S'] = cO;
          }
          ['gps_to_arcS_Grid'](cd, cq, cJ) {
              const cC = cq * Math['PI'] / 0xb4
                , cO = cd * Math['PI'] / 0xb4 - this['r_numda']
                , cG = {
                  'beta': undefined,
                  'theta': undefined
              };
              this['geo2polar'](cC, cO, cG),
              cJ['sx'] = parseInt((cG['beta'] * this['EarthRadius'] * Math['sin'](cG['theta']) / this['r_res'] + this['rx'] + 0.5)['toString']()),
              cJ['sy'] = parseInt((this['ry'] - cG['beta'] * this['EarthRadius'] * Math['cos'](cG['theta']) / this['r_res'] + 0.5)['toString']());
          }
      }
      class ck extends cA {
          constructor(cd, cq, cJ, cC, cO, cG) {
              super(),
              this['r_numda'] = cd * Math['PI'] / 0xb4,
              this['r_phy'] = cq * Math['PI'] / 0xb4,
              this['r_h'] = 0.001 * cJ,
              this['r_res'] = 0.001 * cG,
              this['rx'] = cC,
              this['ry'] = cO,
              this['Km'] = 0x1;
          }
          ['tilt_of_gps'](cd, cq, cJ) {
              if (cq < this['r_res'])
                  return cJ['dh'] = this['r_h'],
                  void (cJ['dS'] = cq);
              const cC = this['Km'] * this['EarthRadius']
                , cO = cd * Math['PI'] / 0xb4
                , cG = this['Km'] * Math['atan'](cq * Math['cos'](cO) / (cC + this['r_h'] + cq * Math['sin'](cO)));
              cJ['dS'] = this['EarthRadius'] * cG,
              cJ['dh'] = Math['sqrt']((cC + this['r_h']) * (cC + this['r_h']) + cq * cq + 0x2 * (cC + this['r_h']) * cq * Math['sin'](cO)) - cC;
          }
          ['tilt_of_gps_lon_lat'](cd, cq, cJ, cC) {
              if (this['tilt_of_gps'](cd, cJ, cC),
              cJ < this['r_res'])
                  return cC['lon'] = 0xb4 * this['r_numda'] / Math['PI'],
                  void (cC['lat'] = 0xb4 * this['r_phy'] / Math['PI']);
              this['arcS_of_gps'](cq, cC['dS'], cC);
          }
          ['tilt_of_gps_by_grid'](cd, cq, cJ, cC) {
              const cO = Math['sqrt']((cq - this['rx']) * (cq - this['rx']) + (this['ry'] - cJ) * (this['ry'] - cJ)) * this['r_res'];
              let cG = Math['asin']((cq - this['rx']) * this['r_res'] / cO);
              cG = cq >= this['rx'] && cJ <= this['ry'] ? 0xb4 * cG / Math['PI'] : cq < this['rx'] && cJ <= this['ry'] ? 0x168 + 0xb4 * cG / Math['PI'] : 0xb4 - 0xb4 * cG / Math['PI'],
              this['tilt_of_gps_lon_lat'](cd, cG, cO, cC);
          }
          ['ES_of_H'](cd, cq, cJ) {
              if (cq <= this['r_res'])
                  cJ['dh'] = this['r_h'];
              else {
                  const cC = cd * Math['PI'] / 0xb4
                    , cO = this['EarthRadius'] * this['Km']
                    , cG = cq / cO;
                  cJ['dh'] = (cO + this['r_h']) * Math['cos'](cC) / Math['cos'](cC + cG) - cO;
              }
          }
          ['HS_of_E'](cd, cq, cJ) {
              const cC = this['EarthRadius'] * this['Km']
                , cO = cq / cC;
              let cG = Math['cos'](cO);
              cG > 0x1 && (cG = 0x1);
              const cg = Math['sin'](cO)
                , cN = (cG * (cC + cd) - (cC + this['r_h'])) / (cg * (cC + cd));
              cJ['ele'] = 0xb4 * Math['atan'](cN) / Math['PI'];
          }
          ['gps_to_tilt'](cd, cq, cJ, cC) {
              let cO = {
                  'beta': undefined,
                  'az': cC['Az']
              };
              this['gps_to_Azimuth'](cd, cq, cO),
              cO['beta'] = cO['beta'] / this['Km'];
              const cG = cJ * Math['PI'] / 0xb4;
              cC['L'] = (this['Km'] * this['EarthRadius'] + this['r_h']) * Math['sin'](cO['beta']) / Math['cos'](cG + cO['beta']);
              const cg = this['EarthRadius'] * this['Km'];
              cC['H'] = Math['sqrt']((cg + this['r_h']) * (cg + this['r_h']) + cC['L'] * cC['L'] + 0x2 * (cg + this['r_h']) * cC['L'] * Math['sin'](cG)) - cg,
              cC['Az'] = cO['az'];
          }
          ['gps_to_tilt_grid'](cd, cq, cJ, cC) {
              const cO = {
                  'Az': undefined,
                  'L': undefined,
                  'H': undefined
              };
              this['gps_to_tilt'](cd, cq, cJ, cO);
              const cG = Math['sin'](cO['Az'] * Math['PI'] / 0xb4)
                , cg = Math['cos'](cO['Az'] * Math['PI'] / 0xb4);
              cC['x'] = cO['L'] * cG / this['r_res'],
              cC['y'] = cO['L'] * cg / this['r_res'];
          }
          ['DEM_to_tilt'](cd, cq, cJ, cC) {
              const cO = {
                  'beta': undefined,
                  'az': cC['Az']
              };
              if (this['gps_to_Azimuth'](cd, cq, cO),
              cC['S'] = cO['beta'] * this['EarthRadius'],
              cJ <= this['r_h'])
                  return cC['e'] = 0x0,
                  void (cC['L'] = cC['S']);
              cO['beta'] = cO['beta'] / this['Km'];
              const cG = this['Km'] * this['EarthRadius'];
              let cg = Math['cos'](cO['beta']);
              cg > 0x1 && (cg = 0x1);
              const cN = Math['sin'](cO['beta']);
              cC['e'] = Math['atan'](((cG + cJ) * cg - (cG + this['r_h'])) / ((cG + cJ) * cN)),
              cC['L'] = (cG + cJ) * cN / Math['cos'](cC['e']),
              cC['e'] = 0xb4 * cC['e'] / Math['PI'],
              cC['Az'] = cO['az'];
          }
          ['RayPath_of_SH'](cd, cq, cJ) {
              cJ['S'] = cJ['S'] || [],
              cJ['H'] = cJ['H'] || [];
              const cC = {
                  'dh': undefined,
                  'dS': undefined
              };
              let cO = 0x0;
              for (let cG = 0x0; cG < cq; ++cG)
                  this['tilt_of_gps'](cd, cO, cC),
                  cJ['S'][cG] = cC['dS'] / this['r_res'] + 0.5,
                  cJ['H'][cG] = 0x3e8 * cC['dh'] + 0.5,
                  cO += this['r_res'];
          }
      }
      function cK(cd, cq, cJ, cC=0x1, cO=0x1, cG=0x1) {
          cC = Math['floor'](cC),
          cO = Math['floor'](cO),
          cG = Math['floor'](cG);
          const cg = []
            , cN = []
            , cP = []
            , cM = [];
          let cz = 0x0;
          function cQ(cm, cL, cR, H0, H1, H2, H3, H4, H5, H6, H7) {
              const H8 = H2 / H5
                , H9 = H3 / H6
                , Hv = H2 / 0x2
                , HA = H3 / 0x2
                , Hk = H4 / 0x2
                , Hl = H5 + 0x1
                , HK = H6 + 0x1;
              let Hb = 0x0;
              const Hc = {};
              for (let HH = 0x0; HH < HK; HH++) {
                  const Hx = HH * H9 - HA;
                  for (let Hp = 0x0; Hp < Hl; Hp++) {
                      const HF = Hp * H8 - Hv;
                      Hc[cm] = HF * H0,
                      Hc[cL] = Hx * H1,
                      Hc[cR] = Hk,
                      cN['push'](Hc['x'], Hc['y'], Hc['z']),
                      Hc[cm] = 0x0,
                      Hc[cL] = 0x0,
                      Hc[cR] = H4 > 0x0 ? 0x1 : -0x1,
                      cP['push'](Hc['x'], Hc['y'], Hc['z']),
                      cM['push'](Hp / H5),
                      cM['push'](0x1 - HH / H6),
                      Hb += 0x1;
                  }
              }
              for (let Hy = 0x0; Hy < H6; Hy++)
                  for (let Hw = 0x0; Hw < H5; Hw++) {
                      const Hh = cz + Hw + Hl * Hy
                        , Hu = cz + Hw + Hl * (Hy + 0x1)
                        , HY = cz + (Hw + 0x1) + Hl * (Hy + 0x1)
                        , HT = cz + (Hw + 0x1) + Hl * Hy;
                      cg['push'](Hh, Hu, HT),
                      cg['push'](Hu, HY, HT);
                  }
              cz += Hb;
          }
          return cQ('z', 'y', 'x', -0x1, -0x1, cJ, cq, cd, cG, cO),
          cQ('z', 'y', 'x', 0x1, -0x1, cJ, cq, -cd, cG, cO),
          cQ('x', 'z', 'y', 0x1, 0x1, cd, cJ, cq, cC, cG),
          cQ('x', 'z', 'y', 0x1, -0x1, cd, cJ, -cq, cC, cG),
          cQ('x', 'y', 'z', 0x1, -0x1, cd, cq, cJ, cC, cO),
          cQ('x', 'y', 'z', -0x1, -0x1, cd, cq, -cJ, cC, cO),
          {
              'indices': cg,
              'vertices': cN,
              'normals': cP,
              'uvs': cM
          };
      }
      function cb(cd, cq) {
          return cJ=>(cJ - cd['x']) / (cq['x'] - cd['x']) * (cq['y'] - cd['y']) + cd['y'];
      }
      function cc(cd, cq, cJ) {
          if (cd['length'] < 0x2)
              return;
          let cC = {}
            , cO = []
            , cG = 0x0;
          for (let cg = 0x0; cg < cd['length'] - 0x1; cg++) {
              let cN = cd[cg]
                , cP = cd[cg + 0x1];
              if (cN['x'] === cP['x']) {
                  let cM = Math['abs'](cJ)
                    , cz = cQ=>cQ <= cP['y'];
                  cP['y'] < cN['y'] && (cz = cQ=>cQ >= cP['y'],
                  cM = -cM);
                  for (let cQ = cN['y']; cz(cQ); cQ += cM)
                      cO[cG] = {
                          'x': cN['x'],
                          'y': cQ
                      },
                      cG++;
              } else {
                  if (cN['y'] === cP['y']) {
                      let cm = Math['abs'](cq)
                        , cL = cR=>cR <= cP['x'];
                      cP['x'] < cN['x'] && (cL = cR=>cR >= cP['x'],
                      cm = -cm);
                      for (let cR = cN['x']; cL(cR); cR += cm)
                          cO[cG] = {
                              'x': cR,
                              'y': cN['y']
                          },
                          cG++;
                  } else {
                      let H0 = cN['x']['toString']() + cN['y']['toString']() + cP['x']['toString']() + cP['y']['toString']()
                        , H1 = cC[H0];
                      H1 || (H1 = cb(cN, cP),
                      cC[H0] = H1);
                      let H2 = Math['abs'](cq)
                        , H3 = H4=>H4 <= cP['x'];
                      cP['x'] < cN['x'] && (H3 = H4=>H4 >= cP['x'],
                      H2 = -H2);
                      for (let H4 = cN['x']; H3(H4); H4 += H2) {
                          let H5 = H1(H4);
                          cO[cG] = {
                              'x': H4,
                              'y': H5
                          },
                          cG++;
                      }
                  }
              }
          }
          return cO['push'](cd[cd['length'] - 0x1]),
          {
              'posMap': cO
          };
      }
      function cH(cd, cq, cJ, cC, cO, cG) {
          cd['beginPath'](),
          cd['arc'](cq + cG, cJ + cG, cG, Math['PI'], 0x3 * Math['PI'] / 0x2),
          cd['lineTo'](cC - cG + cq, cJ),
          cd['arc'](cC - cG + cq, cG + cJ, cG, 0x3 * Math['PI'] / 0x2, 0x2 * Math['PI']),
          cd['lineTo'](cC + cq, cO + cJ - cG),
          cd['arc'](cC - cG + cq, cO - cG + cJ, cG, 0x0, 0x1 * Math['PI'] / 0x2),
          cd['lineTo'](cG + cq, cO + cJ),
          cd['arc'](cG + cq, cO - cG + cJ, cG, 0x1 * Math['PI'] / 0x2, Math['PI']),
          cd['closePath']();
      }
      function cx(cd, cq, cJ, cC=undefined, cO=false, cG=0x0, cg=0x200, cN=0x100, cP=0x0, cM=undefined) {
          var cz;
          if (!(null == cC ? undefined : cC['length'])) {
              cC = [];
              for (let H7 = 0x1f4; H7 < 0x2710; H7 += 0x1f4)
                  cC['push'](H7);
          }
          let cQ;
          cq[0x0]instanceof Array ? (cQ = [],
          cq['forEach'](H8=>cQ['push']({
              'x': H8[0x0],
              'y': H8[0x1]
          }))) : cQ = cq;
          let cm, cL = (0x0,
          iS['m_'])(cJ);
          cM ? cm = cM : (cm = document['createElement']('canvas'),
          cm['width'] = cg,
          cm['height'] = cN);
          let cR = cm['getContext']('2d');
          const H0 = cc(cQ, cd['gridOptions']['xDelta'], cd['gridOptions']['yDelta']);
          if (!(null === (cz = H0['posMap']) || undefined === cz ? undefined : cz['length']))
              return;
          const H1 = H8=>Math['floor'](H8 / cg * (H0['posMap']['length'] - 0x1));
          let H2 = (H8,H9,Hv,HA)=>{
              HA = null != HA ? HA : cd['gridOptions']['zValues'];
              const Hk = (0x1 - H8 / cN) * (cC[cC['length'] - 0x1] - cC[0x0]) + cC[0x0];
              let Hl = HA['length'] - 0x1
                , HK = HA['length'] - 0x1
                , Hb = 0x0;
              if (!(Hk < HA[0x0] || Hk > HA[HA['length'] - 0x1])) {
                  for (let Hc = 0x0; Hc < HA['length']; Hc++)
                      if (Hk <= parseFloat(HA[Hc])) {
                          HK = Math['max'](0x0, Hc - 0x1),
                          Hl = Hc,
                          Hb = HK === Hl ? 0x0 : (Hk - HA[HK]) / (HA[Hl] - HA[HK]);
                          break;
                      }
                  return {
                      'upper': Hl,
                      'lower': HK,
                      'weight': Hb
                  };
              }
          }
          ;
          if (cO) {
              const H8 = {}
                , H9 = new ck(cd['centerLon'](),cd['centerLat'](),null != cG ? cG : 0x0,cd['gridOptions']['xSize'],cd['gridOptions']['ySize'],0x1)
                , Hv = H2;
              H2 = (HA,Hk,Hl)=>{
                  const HK = Hk['toFixed'](0x3) + '_' + Hl['toFixed'](0x3)
                    , Hb = cd['gridOptions']['zValues']['map'](Hc=>{
                      const HH = HK + '_' + Hc['toFixed'](0x3);
                      if (H8[HH])
                          return H8[HH]['H'];
                      const Hx = {};
                      return H9['gps_to_tilt'](Hk, Hl, Hc, Hx),
                      Hx['H'] = 0x3e8 * Hx['H'],
                      H8[HH] = Hx,
                      Hx['H'];
                  }
                  );
                  return Hv(HA, Hk, Hl, Hb);
              }
              ;
          }
          let H3 = cR['getImageData'](0x0, 0x0, cg, cN)
            , H4 = -0x4
            , H5 = -0x1 / 0x0
            , H6 = 0x1 / 0x0;
          for (let HA = 0x0; HA < cN; HA++)
              for (let Hk = 0x0; Hk < cg; Hk++) {
                  let Hl = H1(Hk);
                  H4 += 0x4;
                  const HK = H0['posMap'][Hl]
                    , Hb = (0x0,
                  Kz['tr'])(cd['gridOptions']['xStart'], cd['gridOptions']['xDelta'], HK['x'])
                    , Hc = (0x0,
                  Kz['tr'])(cd['gridOptions']['yStart'], cd['gridOptions']['yDelta'], HK['y']);
                  if (Hb < 0x0 || Hc < 0x0 || Hb >= cd['gridOptions']['xSize'] || Hc >= cd['gridOptions']['ySize']) {
                      H3['data'][H4] = 0x0,
                      H3['data'][H4 + 0x1] = 0x0,
                      H3['data'][H4 + 0x2] = 0x0,
                      H3['data'][H4 + 0x3] = 0x0;
                      continue;
                  }
                  let HH = H2(HA, HK['x'], HK['y']);
                  if (!HH) {
                      H3['data'][H4] = 0x0,
                      H3['data'][H4 + 0x1] = 0x0,
                      H3['data'][H4 + 0x2] = 0x0,
                      H3['data'][H4 + 0x3] = 0x0;
                      continue;
                  }
                  Hk === Math['floor'](cg / 0x2) && Math['floor'](cN / 0x2);
                  const Hx = cd['getGrid'](cP, HH['lower'])
                    , Hp = cd['getGrid'](cP, HH['upper'])
                    , HF = Hx['getPos'](Hc, Hb);
                  let Hy = Hx['read1D'](HF)
                    , Hw = Hp['read1D'](HF);
                  const Hh = Hx['isUndef'](Hy)
                    , Hu = Hp['isUndef'](Hw);
                  let HY, HT = false;
                  Hh || Hu ? (HT = true,
                  HY = Hx['undef']) : HY = Hy * (0x1 - HH['weight']) + Hw * HH['weight'],
                  HT || (HY > H5 && (H5 = HY),
                  HY < H6 && (H6 = HY));
                  let HX = cL['getRule'](HY)['stop'];
                  if (!(HX instanceof id['t']))
                      return v0['kg']['warn'](''),
                      v0['kg']['warn'](HX),
                      {
                          'canvas': cm,
                          'path': H0['posMap'],
                          'maxVal': H5,
                          'minVal': H6
                      };
                  H3['data'][H4] = HX['red'](),
                  H3['data'][H4 + 0x1] = HX['green'](),
                  H3['data'][H4 + 0x2] = HX['blue'](),
                  H3['data'][H4 + 0x3] = Math['floor'](0xff * HX['alpha']());
              }
          return cR['putImageData'](H3, 0x0, 0x0),
          {
              'canvas': cm,
              'path': H0['posMap'],
              'maxVal': H5,
              'minVal': H6,
              'outputZValues': cC
          };
      }
      function cp(cd, cq, cJ, cC=0x200, cO=0x100, cG=-0x1, cg=0x0, cN=undefined) {
          var cP;
          let cM;
          cq[0x0]instanceof Array ? (cM = [],
          cq['forEach'](H5=>cM['push']({
              'x': H5[0x0],
              'y': H5[0x1]
          }))) : cM = cq;
          let cz, cQ = (0x0,
          iS['m_'])(cJ);
          cN ? cz = cN : (cz = document['createElement']('canvas'),
          cz['width'] = cC,
          cz['height'] = cO);
          let cm = cz['getContext']('2d');
          const cL = cc(cM, cd['gridOptions']['xDelta'], cd['gridOptions']['yDelta']);
          if (!(null === (cP = cL['posMap']) || undefined === cP ? undefined : cP['length']))
              return;
          const cR = H5=>Math['floor'](H5 / cC * (cL['posMap']['length'] - 0x1));
          let H0 = H5=>Math['floor']((0x1 - H5 / cO) * (cd['gridOptions']['zValues']['length'] - 0x1));
          cG > parseFloat(cd['gridOptions']['zValues'][0x0]) && (H0 = H5=>{
              const H6 = (0x1 - H5 / cO) * cG;
              for (let H7 = 0x0; H7 < cd['gridOptions']['zValues']['length']; H7++)
                  if (H6 < parseFloat(cd['gridOptions']['zValues'][H7]))
                      return H7;
              return cd['gridOptions']['zValues']['length'] - 0x1;
          }
          );
          let H1 = cm['getImageData'](0x0, 0x0, cC, cO)
            , H2 = -0x4
            , H3 = -0x1 / 0x0
            , H4 = 0x1 / 0x0;
          for (let H5 = 0x0; H5 < cO; H5++) {
              let H6 = H0(H5);
              for (let H7 = 0x0; H7 < cC; H7++) {
                  H2 += 0x4;
                  let H8 = cR(H7);
                  const H9 = cd['getGrid'](cg, H6)
                    , Hv = cL['posMap'][H8]
                    , HA = (0x0,
                  Kz['tr'])(cd['gridOptions']['xStart'], cd['gridOptions']['xDelta'], Hv['x'])
                    , Hk = (0x0,
                  Kz['tr'])(cd['gridOptions']['yStart'], cd['gridOptions']['yDelta'], Hv['y']);
                  if (HA < 0x0 || Hk < 0x0 || HA >= H9['xSize'] || Hk >= H9['ySize']) {
                      H1['data'][H2] = 0x0,
                      H1['data'][H2 + 0x1] = 0x0,
                      H1['data'][H2 + 0x2] = 0x0,
                      H1['data'][H2 + 0x3] = 0x0;
                      continue;
                  }
                  let Hl = H9['read2D'](Hk, HA);
                  H9['isUndef'](Hl) || (Hl > H3 && (H3 = Hl),
                  Hl < H4 && (H4 = Hl));
                  let HK = cQ['getRule'](Hl)['stop'];
                  if (!(HK instanceof id['t']))
                      return v0['kg']['warn'](''),
                      v0['kg']['warn'](HK),
                      {
                          'canvas': cz,
                          'path': cL['posMap'],
                          'maxVal': H3,
                          'minVal': H4
                      };
                  H1['data'][H2] = HK['red'](),
                  H1['data'][H2 + 0x1] = HK['green'](),
                  H1['data'][H2 + 0x2] = HK['blue'](),
                  H1['data'][H2 + 0x3] = Math['floor'](0xff * HK['alpha']());
              }
          }
          return cm['putImageData'](H1, 0x0, 0x0),
          {
              'canvas': cz,
              'path': cL['posMap'],
              'maxVal': H3,
              'minVal': H4
          };
      }
      var cF = n(0xfb);
      const cy = ['0', '1', '2', '3', '4', '5', '6', '7']
        , cw = ['1', '2', '3', '4']
        , ch = ['0', '1', '2', '3']
        , cu = {
          'tdt': 'c4f61f8b0b036ff262d8b480fa826711',
          'zkxt': '8a2174987fca73490355324d79908f10d36d7d114759abd832eb1fc5fb1d105d'
      }
        , cY = {
          'tdtSatellite': 'tdtSatellite',
          'tdtSatelliteAnnotation': 'tdtSatelliteAnnotation',
          'tdtNormal': 'tdtNormal',
          'tdtNormalAnnotation': 'tdtNormalAnnotation',
          'tdtBounds': 'tdtBounds',
          'tdtTerrain': 'tdtTerrain',
          'tdtTerrainAnnotation': 'tdtTerrainAnnotation',
          'gdSatellite': 'gdSatellite',
          'gdSatelliteAnnotation': 'gdSatelliteAnnotation',
          'gdNormal': 'gdNormal',
          'gdWarm': 'gdWarm',
          'geoQNormal': 'geoQNormal',
          'geoQPurplishBlue': 'geoQPurplishBlue',
          'geoQGray': 'geoQGray',
          'geoQWarm': 'geoQWarm',
          'geoQBoundary': 'geoQBoundary',
          'geoQWater': 'geoQWater',
          'tencentStreet': 'tencentStreet',
          'tencentDem': 'tencentDem',
          'tencentAnnotation': 'tencentAnnotation',
          'stamenTerrain': 'stamenTerrain',
          'stamenWaterColor': 'stamenWaterColor',
          'esriSate': 'esriSate',
          'esriTerrain': 'esriTarrain',
          'esriShaded': 'esriShaded',
          'mtb': 'mtb',
          'nasaNight': 'nasaNight',
          'windy': 'windy',
          'vectorTop': 'vectorTop',
          'zkxtNormal': 'zkxtNormal',
          'zkxtTerrain': 'zkxtTerrain',
          'zkxtSatellite': 'zkxtSatellite',
          'zkxtSatelliteAnnotation': 'zkxtSatelliteAnnotation',
          'zkxtTerrainAnnotation': 'zkxtTerrainAnnotation'
      }
        , cT = {};
      function cX(cd, cq) {
          cY[cd] = cd,
          cT[cd] = cq;
      }
      function cE(cd) {
          let cq = {
              'url': 'https://t{s}.tianditu.gov.cn/DataServer?T=img_w&X={x}&Y={y}&L={z}&tk=' + cu['tdt'],
              'subdomains': cy
          };
          switch (cd) {
          case cY['tdtSatellite']:
              break;
          case cY['tdtSatelliteAnnotation']:
              cq = {
                  'url': 'https://t{s}.tianditu.gov.cn/DataServer?T=cia_w&X={x}&Y={y}&L={z}&tk=' + cu['tdt'],
                  'subdomains': cy
              };
              break;
          case cY['tdtNormal']:
              cq = {
                  'url': 'https://t{s}.tianditu.gov.cn/DataServer?T=vec_w&X={x}&Y={y}&L={z}&tk=' + cu['tdt'],
                  'subdomains': cy
              };
              break;
          case cY['tdtNormalAnnotation']:
              cq = {
                  'url': 'https://t{s}.tianditu.gov.cn/DataServer?T=cva_w&X={x}&Y={y}&L={z}&tk=' + cu['tdt'],
                  'subdomains': cy
              };
              break;
          case cY['tdtTerrain']:
              cq = {
                  'url': 'https://t{s}.tianditu.gov.cn/DataServer?T=ter_w&X={x}&Y={y}&L={z}&tk=' + cu['tdt'],
                  'subdomains': cy
              };
              break;
          case cY['tdtTerrainAnnotation']:
              cq = {
                  'url': 'https://t{s}.tianditu.gov.cn/DataServer?T=cta_w&X={x}&Y={y}&L={z}&tk=' + cu['tdt'],
                  'subdomains': cy
              };
              break;
          case cY['tdtBounds']:
              cq = {
                  'url': 'https://t{s}.tianditu.gov.cn/ibo_w/wmts?service=wmts&request=GetTile&version=1.0.0&LAYER=ibo&tileMatrixSet=w&TileMatrix={z}&TileRow={y}&TileCol={x}&style=default&format=tiles&tk=' + cu['tdt'],
                  'subdomains': cy
              };
              break;
          case cY['gdSatellite']:
              cq = {
                  'url': 'https://webst0{s}.is.autonavi.com/appmaptile?style=6&x={x}&y={y}&z={z}',
                  'subdomains': cw
              };
              break;
          case cY['gdSatelliteAnnotation']:
              cq = {
                  'url': 'https://webst0{s}.is.autonavi.com/appmaptile?style=8&x={x}&y={y}&z={z}',
                  'subdomains': cw
              };
              break;
          case cY['gdNormal']:
              cq = {
                  'url': 'https://webrd0{s}.is.autonavi.com/appmaptile?lang=zh_cn&size=1&scale=1&style=8&x={x}&y={y}&z={z}',
                  'subdomains': cw
              };
              break;
          case cY['gdWarm']:
              cq = {
                  'url': 'https://webrd0{s}.is.autonavi.com/appmaptile?lang=zh_cn&size=1&scale=1&style=7&x={x}&y={y}&z={z}',
                  'subdomains': cw
              };
              break;
          case cY['geoQNormal']:
              cq = {
                  'url': 'https://mapnew.geoq.cn/ArcGIS/rest/services/ChinaOnlineCommunity/MapServer/tile/{z}/{y}/{x}'
              };
              break;
          case cY['geoQPurplishBlue']:
              cq = {
                  'url': 'https://mapnew.geoq.cn/ArcGIS/rest/services/ChinaOnlineStreetPurplishBlue/MapServer/tile/{z}/{y}/{x}'
              };
              break;
          case cY['geoQGray']:
              cq = {
                  'url': 'https://mapnew.geoq.cn/ArcGIS/rest/services/ChinaOnlineStreetGray/MapServer/tile/{z}/{y}/{x}'
              };
              break;
          case cY['geoQWarm']:
              cq = {
                  'url': 'https://mapnew.geoq.cn/ArcGIS/rest/services/ChinaOnlineStreetWarm/MapServer/tile/{z}/{y}/{x}'
              };
              break;
          case cY['geoQBoundary']:
              cq = {
                  'url': 'https://thematic.geoq.cn/arcgis/rest/services/ThematicMaps/administrative_division_boundaryandlabel/MapServer/tile/{z}/{y}/{x}'
              };
              break;
          case cY['geoQWater']:
              cq = {
                  'url': 'https://thematic.geoq.cn/arcgis/rest/services/ThematicMaps/WorldHydroMap/MapServer/tile/{z}/{y}/{x}'
              };
              break;
          case cY['tencentStreet']:
              cq = {
                  'url': 'https://rt{s}.map.gtimg.com/realtimerender?z={z}&x={x}&y={y}&type=vector&style=0',
                  'subdomains': ch,
                  'tms': true
              };
              break;
          case cY['tencentDem']:
              cq = {
                  'url': 'https://p{s}.map.gtimg.com/demTiles/{z}/{x}/{y}/{x}_{y}.jpg',
                  'subdomains': ch,
                  'tms': true
              };
              break;
          case cY['tencentAnnotation']:
              cq = {
                  'url': 'https://rt{s}.map.gtimg.com/tile?z={z}&x={x}&y={y}&styleid=2&version=837',
                  'subdomains': ch,
                  'tms': true
              };
              break;
          case cY['stamenTerrain']:
              cq = {
                  'url': 'https://stamen-tiles-{s}.a.ssl.fastly.net/terrain-background/{z}/{x}/{y}{r}.{ext}',
                  'subdomains': 'abcd',
                  'minZoom': 0x0,
                  'maxZoom': 0x12,
                  'ext': 'png'
              };
              break;
          case cY['stamenWaterColor']:
              cq = {
                  'url': 'https://stamen-tiles-{s}.a.ssl.fastly.net/terrain-background/{z}/{x}/{y}{r}.{ext}',
                  'subdomains': 'abcd',
                  'minZoom': 0x1,
                  'maxZoom': 0x10,
                  'ext': 'jpg'
              };
              break;
          case cY['esriSate']:
              cq = {
                  'url': 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'
              };
              break;
          case cY['esriShaded']:
              cq = {
                  'url': 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Shaded_Relief/MapServer/tile/{z}/{y}/{x}'
              };
              break;
          case cY['esriTerrain']:
              cq = {
                  'url': 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Terrain_Base/MapServer/tile/{z}/{y}/{x}'
              };
              break;
          case cY['mtb']:
              cq = {
                  'url': 'https://tile.mtbmap.cz/mtbmap_tiles/{z}/{x}/{y}.png'
              };
              break;
          case cY['nasaNight']:
              cq = {
                  'url': 'https://map1.vis.earthdata.nasa.gov/wmts-webmerc/VIIRS_CityLights_2012/default/{time}/{tilematrixset}{maxZoom}/{z}/{y}/{x}.{format}',
                  'bounds': [[-85.0511287776, -179.999999975], [85.0511287776, 179.999999975]],
                  'minZoom': 0x1,
                  'maxZoom': 0x8,
                  'format': 'jpg',
                  'time': '',
                  'tilematrixset': 'GoogleMapsCompatible_Level'
              };
              break;
          case cY['vectorTop']:
              cq = {
                  'url': 'https://qefiles.91weather.com/cdn-repo/mlog/cloud/terrain/tile/gaode/d461a96842e24b958142f84c3051e588/{z}/{x}_{y}.png'
              };
              break;
          case cY['zkxtNormal']:
              cq = {
                  'url': 'https://tiles{s}.geovisearth.com/base/v1/vec/{z}/{x}/{y}?format=webp&tmsIds=w&token=' + cu['zkxt'],
                  'subdomains': ['1', '2', '3']
              };
              break;
          case cY['zkxtSatellite']:
              cq = {
                  'url': 'https://tiles{s}.geovisearth.com/base/v1/img/{z}/{x}/{y}?format=webp&tmsIds=w&token=' + cu['zkxt'],
                  'subdomains': ['1', '2', '3']
              };
              break;
          case cY['zkxtSatelliteAnnotation']:
              cq = {
                  'url': 'https://tiles{s}.geovisearth.com/base/v1/cia/{z}/{x}/{y}?format=webp&tmsIds=w&token=' + cu['zkxt'],
                  'subdomains': ['1', '2', '3']
              };
              break;
          case cY['zkxtTerrain']:
              cq = {
                  'url': 'https://tiles{s}.geovisearth.com/base/v1/ter/{z}/{x}/{y}?format=webp&tmsIds=w&token=' + cu['zkxt'],
                  'subdomains': ['1', '2', '3']
              };
              break;
          case cY['zkxtTerrainAnnotation']:
              cq = {
                  'url': 'https://tiles{s}.geovisearth.com/base/v1/cat/{z}/{x}/{y}?format=webp&tmsIds=w&token=' + cu['zkxt'],
                  'subdomains': ['1', '2', '3']
              };
              break;
          case cY['windy']:
              cq = {
                  'url': 'https://tiles.windy.com/tiles/v10.0/darkmap/{z}/{x}/{y}.png'
              };
              break;
          default:
              cT[cd] && (cq = cT[cd]);
          }
          return cq;
      }
      const cf = {
          'code': '%8C%C6%DE%CC%CE%B0%A6%D3%E6%DC%u4E92%u9CE4%uA007%uDE86%uFF81%u7154%u788D%uE4E3%uC0A8%uCA6E%u7548%9C%9Cc%B2%DF%E9%EB%DB%D0%CF%DC%B4%u8CA1%u1BF2%u0962%uDC51%u62A0%9C%9C%u5566%uCA6E%uD8B0%uCACB%uF33A%u0C4B%uFD4F%uDCA9%uAF8F%u4EFB%uFF87%DC%D5%C7%CF%D5%C9%C3%D0'
      };
      function cW(cd) {
          cd = unescape(cd);
          for (var cq = String['fromCharCode'](cd['charCodeAt'](0x0) - cd['length']), cJ = 0x1; cJ < cd['length']; cJ++)
              cq += String['fromCharCode'](cd['charCodeAt'](cJ) - cq['charCodeAt'](cJ - 0x1));
          return cq;
      }
      var cI = function(cd, cq, cJ, cC) {
          return new (cJ || (cJ = Promise))(function(cO, cG) {
              function cg(cM) {
                  try {
                      cP(cC['next'](cM));
                  } catch (cz) {
                      cG(cz);
                  }
              }
              function cN(cM) {
                  try {
                      cP(cC['throw'](cM));
                  } catch (cz) {
                      cG(cz);
                  }
              }
              function cP(cM) {
                  var cz;
                  cM['done'] ? cO(cM['value']) : (cz = cM['value'],
                  cz instanceof cJ ? cz : new cJ(function(cQ) {
                      cQ(cz);
                  }
                  ))['then'](cg, cN);
              }
              cP((cC = cC['apply'](cd, cq || []))['next']());
          }
          );
      };
      let cj = false;
      function cV(cd, cq=true) {
          if(cj)return

          cj = true,
          iH(),
          ih(),
          (0x0,
          v0['qr'])(),
          false === cq && cB();
      }
      function cB() {}
  }
  )(),
  k;
}
)());
